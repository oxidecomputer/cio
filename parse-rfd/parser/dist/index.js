/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 853:
/***/ (function(module, __unused_webpack_exports, __nccwpck_require__) {

/* global Opal, Asciidoctor, ASCIIDOCTOR_JS_VERSION */
const Opal = (__nccwpck_require__(9560)/* .Opal */ .s)

// Node module
;(function (root, factory) {
  module.exports = factory
  // default export for ES6 module interop
  module.exports["default"] = factory
}(this, function (moduleConfig) {
/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/opal_ext/electron/io"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $send = Opal.send, $gvars = Opal.gvars, $writer = nil;
  if ($gvars.stdout == null) $gvars.stdout = nil;
  if ($gvars.stderr == null) $gvars.stderr = nil;

  Opal.add_stubs(['$write_proc=', '$-']);
  
  
  $writer = [function(s){console.log(s)}];
  $send($gvars.stdout, 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [function(s){console.error(s)}];
  $send($gvars.stderr, 'write_proc=', Opal.to_a($writer));
  return $writer[$rb_minus($writer["length"], 1)];;
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/opal_ext/node"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$==', '$require']);
  
  
  var isElectron = typeof navigator === 'object' && typeof navigator.userAgent === 'string' && typeof navigator.userAgent.indexOf('Electron') !== -1,
      platform,
      engine,
      framework,
      ioModule;

  if (typeof moduleConfig === 'object' && typeof moduleConfig.runtime === 'object') {
    var runtime = moduleConfig.runtime;
    platform = runtime.platform;
    engine = runtime.engine;
    framework = runtime.framework;
    ioModule = runtime.ioModule;
  }

  ioModule = ioModule || 'node';
  platform = platform || 'node';
  engine = engine || 'v8';
  if (isElectron) {
    framework = framework || 'electron';
  } else {
    framework = framework || '';
  }
;
  Opal.const_set($nesting[0], 'JAVASCRIPT_IO_MODULE', ioModule);
  Opal.const_set($nesting[0], 'JAVASCRIPT_PLATFORM', platform);
  Opal.const_set($nesting[0], 'JAVASCRIPT_ENGINE', engine);
  Opal.const_set($nesting[0], 'JAVASCRIPT_FRAMEWORK', framework);
  if ($$($nesting, 'JAVASCRIPT_FRAMEWORK')['$==']("electron")) {
    self.$require("asciidoctor/js/opal_ext/electron/io")};
  
// Load Opal modules
Opal.load("pathname");
Opal.load("nodejs");
;
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/asciidoctor_ext/node/abstract_node"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'AbstractNode');

      var $nesting = [self].concat($parent_nesting), $AbstractNode_generate_data_uri_from_uri$1;
      if (self.__xmlhttprequest__ == null) self.__xmlhttprequest__ = nil;

      
      self.__xmlhttprequest__ = __nccwpck_require__(4315);
      var __XMLHttpRequest__ = self.__xmlhttprequest__.XMLHttpRequest;
      return (Opal.def(self, '$generate_data_uri_from_uri', $AbstractNode_generate_data_uri_from_uri$1 = function $$generate_data_uri_from_uri(image_uri, cache_uri) {
        var self = this;

        
        
        if (cache_uri == null) {
          cache_uri = false;
        };
        
      var contentType = ''
      var b64encoded = ''
      var status = -1

      try {
        var xhr = new __XMLHttpRequest__();
        xhr.open('GET', image_uri, false);
        xhr.responseType = 'arraybuffer';
        xhr.addEventListener('load', function() {
          status = this.status
          if (status === 200) {
            var arrayBuffer = this.response;
            b64encoded = Buffer.from(arrayBuffer).toString('base64');
            contentType = this.getResponseHeader('content-type')
          }
        })
        xhr.send(null)
      }
      catch (e) {
        // something bad happened!
        status = 0
      }
      if (status === 404 || (status === 0 && !b64encoded)) {
        self.$logger().$warn('could not retrieve image data from URI: ' + image_uri)
        return image_uri
      }
      return 'data:' + contentType + ';base64,' + b64encoded
    ;
      }, $AbstractNode_generate_data_uri_from_uri$1.$$arity = -2), nil) && 'generate_data_uri_from_uri';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/asciidoctor_ext/node/open_uri"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  Opal.add_stubs(['$require', '$new', '$<<', '$rewind']);
  
  self.$require("stringio");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'OpenURI');

    var $nesting = [self].concat($parent_nesting), $OpenURI_open_uri$1;
    if (self.__xmlhttprequest__ == null) self.__xmlhttprequest__ = nil;

    
    self.__xmlhttprequest__ = __nccwpck_require__(4315);
    var __XMLHttpRequest__ = self.__xmlhttprequest__.XMLHttpRequest;
    Opal.defs($$($nesting, 'OpenURI'), '$open_uri', $OpenURI_open_uri$1 = function $$open_uri(uri, $a) {
      var $post_args, rest, $iter = $OpenURI_open_uri$1.$$p, $yield = $iter || nil, self = this, io = nil, data = nil;

      if ($iter) $OpenURI_open_uri$1.$$p = null;
      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      rest = $post_args;;
      io = $$$('::', 'StringIO').$new();
      data = "";
      
      var contentType = ''
      var status = -1

      try {
        var xhr = new __XMLHttpRequest__()
        xhr.open('GET', uri, false)
        xhr.responseType = 'text'
        xhr.addEventListener('load', function() {
          status = this.status
          if (status === 200) {
            data = this.responseText
            contentType = this.getResponseHeader('content-type')
          }
        })
        xhr.send(null)
      }
      catch (e) {
        // something bad happened!
        status = 0
      }
      if (status === 404 || (status === 0 && !data)) {
        throw $$($nesting, 'IOError').$new('No such file or directory: ' + uri)
      }
    ;
      io['$<<'](data);
      io.$rewind();
      if (($yield !== nil)) {
        return Opal.yield1($yield, io);
      } else {
        return io
      };
    }, $OpenURI_open_uri$1.$$arity = -2);
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/asciidoctor_ext/node/stylesheet"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$rstrip', '$read', '$join']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Stylesheets');

      var $nesting = [self].concat($parent_nesting), $Stylesheets_primary_stylesheet_data$1;

      self.$$prototype.primary_stylesheet_data = nil;
      return (Opal.def(self, '$primary_stylesheet_data', $Stylesheets_primary_stylesheet_data$1 = function $$primary_stylesheet_data() {
        var $a, self = this, __path__ = nil, stylesheets_dir = nil;

        
        __path__ = __nccwpck_require__(1017);
        if ($truthy(__path__.basename(__dirname) === 'node' && __path__.basename(__path__.dirname(__dirname)) === 'dist')) {
          stylesheets_dir = __nccwpck_require__.ab + "css"
        } else {
          stylesheets_dir = __path__.join(__dirname, 'css')
        };
        return (self.primary_stylesheet_data = ($truthy($a = self.primary_stylesheet_data) ? $a : $$$('::', 'IO').$read($$$('::', 'File').$join(stylesheets_dir, "asciidoctor.css")).$rstrip()));
      }, $Stylesheets_primary_stylesheet_data$1.$$arity = 0), nil) && 'primary_stylesheet_data'
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/asciidoctor_ext/node/template"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$[]', '$clear', '$===', '$caches', '$class', '$scan', '$node_name', '$raise', '$ctx', '$==', '$strip', '$rstrip', '$key?', '$merge', '$file', '$[]=', '$-', '$private', '$new', '$each', '$directory?', '$system_path', '$scan_dir', '$update', '$select', '$glob', '$file?', '$basename', '$<', '$size', '$split', '$start_with?', '$slice', '$length', '$to_sym', '$node_require']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'TemplateConverter');

      var $nesting = [self].concat($parent_nesting), $TemplateConverter_caches$1, $TemplateConverter_clear_caches$2, $TemplateConverter_initialize$3, $TemplateConverter_convert$4, $TemplateConverter_handles$ques$5, $TemplateConverter_templates$6, $TemplateConverter_register$7, $TemplateConverter_scan$8, $TemplateConverter_node_require$11, $TemplateConverter_scan_dir$12;

      self.$$prototype.templates = self.$$prototype.caches = self.$$prototype.backend = self.$$prototype.engine = self.$$prototype.template_dirs = nil;
      
      self.caches = $hash2(["scans", "templates"], {"scans": $hash2([], {}), "templates": $hash2([], {})});
      Opal.defs(self, '$caches', $TemplateConverter_caches$1 = function $$caches() {
        var self = this;
        if (self.caches == null) self.caches = nil;

        return self.caches
      }, $TemplateConverter_caches$1.$$arity = 0);
      Opal.defs(self, '$clear_caches', $TemplateConverter_clear_caches$2 = function $$clear_caches() {
        var self = this;
        if (self.caches == null) self.caches = nil;

        
        if ($truthy(self.caches['$[]']("scans"))) {
          self.caches['$[]']("scans").$clear()};
        if ($truthy(self.caches['$[]']("templates"))) {
          return self.caches['$[]']("templates").$clear()
        } else {
          return nil
        };
      }, $TemplateConverter_clear_caches$2.$$arity = 0);
      
      Opal.def(self, '$initialize', $TemplateConverter_initialize$3 = function $$initialize(backend, template_dirs, opts) {
        var $a, self = this, $case = nil;

        
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        self.backend = backend;
        self.templates = $hash2([], {});
        self.template_dirs = template_dirs;
        self.engine = opts['$[]']("template_engine");
        self.engine_options = ($truthy($a = opts['$[]']("template_engine_options")) ? $a : $hash2([], {}));
        $case = opts['$[]']("template_cache");
        if (true['$===']($case)) {self.caches = self.$class().$caches()}
        else if ($$$('::', 'Hash')['$===']($case)) {self.caches = opts['$[]']("template_cache")}
        else {self.caches = $hash2([], {})};
        return self.$scan();
      }, $TemplateConverter_initialize$3.$$arity = -3);
      
      Opal.def(self, '$convert', $TemplateConverter_convert$4 = function $$convert(node, template_name, opts) {
        var $a, self = this, template = nil, helpers_ctx = nil;

        
        
        if (template_name == null) {
          template_name = nil;
        };
        
        if (opts == null) {
          opts = nil;
        };
        if ($truthy((template = self.templates['$[]']((template_name = ($truthy($a = template_name) ? $a : node.$node_name())))))) {
        } else {
          self.$raise("" + "Could not find a custom template to handle transform: " + (template_name))
        };
        helpers_ctx = ($truthy($a = self.templates['$[]']("helpers.js")) ? self.templates['$[]']("helpers.js").$ctx() : $a);
        if (template_name['$==']("document")) {
          return (template.render({node: node, opts: fromHash(opts), helpers: helpers_ctx})).$strip()
        } else {
          return (template.render({node: node, opts: fromHash(opts), helpers: helpers_ctx})).$rstrip()
        };
      }, $TemplateConverter_convert$4.$$arity = -2);
      
      Opal.def(self, '$handles?', $TemplateConverter_handles$ques$5 = function(name) {
        var self = this;

        return self.templates['$key?'](name)
      }, $TemplateConverter_handles$ques$5.$$arity = 1);
      
      Opal.def(self, '$templates', $TemplateConverter_templates$6 = function $$templates() {
        var self = this;

        return self.templates.$merge()
      }, $TemplateConverter_templates$6.$$arity = 0);
      
      Opal.def(self, '$register', $TemplateConverter_register$7 = function $$register(name, template) {
        var $a, self = this, $writer = nil, template_cache = nil;

        
        $writer = [name, (function() {if ($truthy((template_cache = ($truthy($a = self.caches['$[]']("templates")) ? template.$file : $a)))) {
          
          $writer = [template.$file(), template];
          $send(template_cache, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        } else {
          return template
        }; return nil; })()];
        $send(self.templates, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];
      }, $TemplateConverter_register$7.$$arity = 2);
      self.$private();
      
      Opal.def(self, '$scan', $TemplateConverter_scan$8 = function $$scan() {
        var $$9, self = this, path_resolver = nil, backend = nil, engine = nil;

        
        path_resolver = $$($nesting, 'PathResolver').$new();
        backend = self.backend;
        engine = self.engine;
        return $send(self.template_dirs, 'each', [], ($$9 = function(template_dir){var self = $$9.$$s || this, $$10, file_pattern = nil, engine_dir = nil, backend_dir = nil, pattern = nil, scan_cache = nil, template_cache = nil, templates = nil, $writer = nil;
          if (self.caches == null) self.caches = nil;
          if (self.templates == null) self.templates = nil;

        
          
          if (template_dir == null) {
            template_dir = nil;
          };
          if ($truthy($$$('::', 'File')['$directory?']((template_dir = path_resolver.$system_path(template_dir))))) {
          } else {
            return nil;
          };
          if ($truthy(engine)) {
            
            file_pattern = "" + "*." + (engine);
            if ($truthy($$$('::', 'File')['$directory?']((engine_dir = "" + (template_dir) + "/" + (engine))))) {
              template_dir = engine_dir};
          } else {
            file_pattern = "*"
          };
          if ($truthy($$$('::', 'File')['$directory?']((backend_dir = "" + (template_dir) + "/" + (backend))))) {
            template_dir = backend_dir};
          pattern = "" + (template_dir) + "/" + (file_pattern);
          if ($truthy((scan_cache = self.caches['$[]']("scans")))) {
            
            template_cache = self.caches['$[]']("templates");
            if ($truthy((templates = scan_cache['$[]'](pattern)))) {
            } else {
              templates = (($writer = [pattern, self.$scan_dir(template_dir, pattern, template_cache)]), $send(scan_cache, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])
            };
            $send(templates, 'each', [], ($$10 = function(name, template){var self = $$10.$$s || this;
              if (self.templates == null) self.templates = nil;

            
              
              if (name == null) {
                name = nil;
              };
              
              if (template == null) {
                template = nil;
              };
              $writer = [name, (($writer = [template.$file(), template]), $send(template_cache, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])];
              $send(self.templates, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];}, $$10.$$s = self, $$10.$$arity = 2, $$10));
          } else {
            self.templates.$update(self.$scan_dir(template_dir, pattern, self.caches['$[]']("templates")))
          };
          return nil;}, $$9.$$s = self, $$9.$$arity = 1, $$9));
      }, $TemplateConverter_scan$8.$$arity = 0);
      
      Opal.def(self, '$node_require', $TemplateConverter_node_require$11 = function $$node_require(module_name) {
        var self = this;

        
      try {
        return require(module_name)
      }
      catch (e) {
        throw $$($nesting, 'IOError').$new("" + "Unable to require the module '" + (module_name) + "', please make sure that the module is installed.")
      }
    
      }, $TemplateConverter_node_require$11.$$arity = 1);
      return (Opal.def(self, '$scan_dir', $TemplateConverter_scan_dir$12 = function $$scan_dir(template_dir, pattern, template_cache) {
        var $a, $$13, $$14, self = this, result = nil, helpers = nil, $writer = nil;

        
        
        if (template_cache == null) {
          template_cache = nil;
        };
        $a = [$hash2([], {}), nil], (result = $a[0]), (helpers = $a[1]), $a;
              var enginesContext = {};
        $send($send($$$('::', 'Dir').$glob(pattern), 'select', [], ($$13 = function(match){var self = $$13.$$s || this;

        
          
          if (match == null) {
            match = nil;
          };
          return $$$('::', 'File')['$file?'](match);}, $$13.$$s = self, $$13.$$arity = 1, $$13)), 'each', [], ($$14 = function(file){var self = $$14.$$s || this, $b, basename = nil, path_segments = nil, name = nil, template = nil, extsym = nil, $case = nil, nunjucks = nil, handlebars = nil, ejs = nil, pug = nil, $writer = nil;

        
          
          if (file == null) {
            file = nil;
          };
          if ((basename = $$$('::', 'File').$basename(file))['$==']("helpers.js")) {
            
            helpers = file;
            return nil;;
          } else if ($truthy($rb_lt((path_segments = basename.$split(".")).$size(), 2))) {
            return nil;};
          if ((name = path_segments['$[]'](0))['$==']("block_ruler")) {
            name = "thematic_break"
          } else if ($truthy(name['$start_with?']("block_"))) {
            name = name.$slice(6, name.$length())};
          if ($truthy(($truthy($b = template_cache) ? (template = template_cache['$[]'](file)) : $b))) {
          } else {
            
            extsym = path_segments['$[]'](-1).$to_sym();
            $case = extsym;
            if ("nunjucks"['$===']($case) || "njk"['$===']($case)) {
            nunjucks = self.$node_require("nunjucks");
            
            var fs = __nccwpck_require__(7147)
            var env
            if (enginesContext.nunjucks && enginesContext.nunjucks.environment) {
              env = enginesContext.nunjucks.environment
            } else {
              var opts = self.engine_options['nunjucks'] || {}
              delete opts.web // unsupported option
              env = nunjucks.configure(template_dir, opts)
              enginesContext.nunjucks = { environment: env }
            }
            template = Object.assign(nunjucks.compile(fs.readFileSync(file, 'utf8'), env), { '$file': function() { return file } })
          ;}
            else if ("handlebars"['$===']($case) || "hbs"['$===']($case)) {
            handlebars = self.$node_require("handlebars");
            
            var fs = __nccwpck_require__(7147)
            var env
            var opts = self.engine_options['handlebars'] || {}
            if (enginesContext.handlebars && enginesContext.handlebars.environment) {
              env = enginesContext.handlebars.environment
            } else {
              env = handlebars.create()
              enginesContext.handlebars = { environment: env }
            }
            template = { render: env.compile(fs.readFileSync(file, 'utf8'), opts), '$file': function() { return file } }
          ;}
            else if ("ejs"['$===']($case)) {
            ejs = self.$node_require("ejs");
            
            var fs = __nccwpck_require__(7147)
            var opts = self.engine_options['ejs'] || {}
            opts.filename = file
            // unsupported options
            delete opts.async
            delete opts.client
            template = { render: ejs.compile(fs.readFileSync(file, 'utf8'), opts), '$file': function() { return file } }
          ;}
            else if ("pug"['$===']($case)) {
            pug = self.$node_require("pug");
            
            var opts = self.engine_options['pug'] || {}
            opts.filename = file
            template = { render: pug.compileFile(file, opts), '$file': function() { return file } }
          ;}
            else if ("js"['$===']($case)) {template = { render: require(file), '$file': function() { return file } }}
            else {
            var registry = Opal.Asciidoctor.TemplateEngine.registry
            var templateEngine = registry[extsym]
            if (templateEngine && typeof templateEngine.compile === 'function') {
              template = Object.assign(templateEngine.compile(file, name), { '$file': function() { return file } })
            } else {
              template = undefined
            }
          };
          };
          if ($truthy(template)) {
            
            $writer = [name, template];
            $send(result, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          } else {
            return nil
          };}, $$14.$$s = self, $$14.$$arity = 1, $$14));
        if ($truthy(($truthy($a = helpers) ? $a : $$$('::', 'File')['$file?']((helpers = "" + (template_dir) + "/helpers.js"))))) {
          
          
        var ctx = require(helpers)
        if (typeof ctx.configure === 'function') {
          ctx.configure(enginesContext)
        }
      ;
          
          $writer = ["helpers.js", { '$file': function() { return helpers }, $ctx: function() { return ctx } }];
          $send(result, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;};
        return result;
      }, $TemplateConverter_scan_dir$12.$$arity = -3), nil) && 'scan_dir';
    })($$($nesting, 'Converter'), $$$($$($nesting, 'Converter'), 'Base'), $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/asciidoctor_ext/node"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$require']);
  
  self.$require("asciidoctor/js/asciidoctor_ext/node/abstract_node");
  self.$require("asciidoctor/js/asciidoctor_ext/node/open_uri");
  self.$require("asciidoctor/js/asciidoctor_ext/node/stylesheet");
  return self.$require("asciidoctor/js/asciidoctor_ext/node/template");
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["set"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $module = Opal.module;

  Opal.add_stubs(['$include', '$new', '$nil?', '$===', '$raise', '$each', '$add', '$merge', '$class', '$respond_to?', '$subtract', '$dup', '$join', '$to_a', '$equal?', '$instance_of?', '$==', '$instance_variable_get', '$is_a?', '$size', '$all?', '$include?', '$[]=', '$-', '$enum_for', '$[]', '$<<', '$replace', '$delete', '$select', '$each_key', '$to_proc', '$empty?', '$eql?', '$instance_eval', '$clear', '$<', '$<=', '$keys']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Set');

    var $nesting = [self].concat($parent_nesting), $Set_$$$1, $Set_initialize$2, $Set_dup$4, $Set_$minus$5, $Set_inspect$6, $Set_$eq_eq$7, $Set_add$9, $Set_classify$10, $Set_collect$excl$13, $Set_delete$15, $Set_delete$ques$16, $Set_delete_if$17, $Set_add$ques$20, $Set_each$21, $Set_empty$ques$22, $Set_eql$ques$23, $Set_clear$25, $Set_include$ques$26, $Set_merge$27, $Set_replace$29, $Set_size$30, $Set_subtract$31, $Set_$$33, $Set_superset$ques$34, $Set_proper_superset$ques$36, $Set_subset$ques$38, $Set_proper_subset$ques$40, $Set_to_a$42;

    self.$$prototype.hash = nil;
    
    self.$include($$($nesting, 'Enumerable'));
    Opal.defs(self, '$[]', $Set_$$$1 = function($a) {
      var $post_args, ary, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      ary = $post_args;;
      return self.$new(ary);
    }, $Set_$$$1.$$arity = -1);
    
    Opal.def(self, '$initialize', $Set_initialize$2 = function $$initialize(enum$) {
      var $iter = $Set_initialize$2.$$p, block = $iter || nil, $$3, self = this;

      if ($iter) $Set_initialize$2.$$p = null;
      
      
      if ($iter) $Set_initialize$2.$$p = null;;
      
      if (enum$ == null) {
        enum$ = nil;
      };
      self.hash = $hash2([], {});
      if ($truthy(enum$['$nil?']())) {
        return nil};
      if ($truthy($$($nesting, 'Enumerable')['$==='](enum$))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "value must be enumerable")
      };
      if ($truthy(block)) {
        return $send(enum$, 'each', [], ($$3 = function(item){var self = $$3.$$s || this;

        
          
          if (item == null) {
            item = nil;
          };
          return self.$add(Opal.yield1(block, item));}, $$3.$$s = self, $$3.$$arity = 1, $$3))
      } else {
        return self.$merge(enum$)
      };
    }, $Set_initialize$2.$$arity = -1);
    
    Opal.def(self, '$dup', $Set_dup$4 = function $$dup() {
      var self = this, result = nil;

      
      result = self.$class().$new();
      return result.$merge(self);
    }, $Set_dup$4.$$arity = 0);
    
    Opal.def(self, '$-', $Set_$minus$5 = function(enum$) {
      var self = this;

      
      if ($truthy(enum$['$respond_to?']("each"))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "value must be enumerable")
      };
      return self.$dup().$subtract(enum$);
    }, $Set_$minus$5.$$arity = 1);
    Opal.alias(self, "difference", "-");
    
    Opal.def(self, '$inspect', $Set_inspect$6 = function $$inspect() {
      var self = this;

      return "" + "#<Set: {" + (self.$to_a().$join(",")) + "}>"
    }, $Set_inspect$6.$$arity = 0);
    
    Opal.def(self, '$==', $Set_$eq_eq$7 = function(other) {
      var $a, $$8, self = this;

      if ($truthy(self['$equal?'](other))) {
        return true
      } else if ($truthy(other['$instance_of?'](self.$class()))) {
        return self.hash['$=='](other.$instance_variable_get("@hash"))
      } else if ($truthy(($truthy($a = other['$is_a?']($$($nesting, 'Set'))) ? self.$size()['$=='](other.$size()) : $a))) {
        return $send(other, 'all?', [], ($$8 = function(o){var self = $$8.$$s || this;
          if (self.hash == null) self.hash = nil;

        
          
          if (o == null) {
            o = nil;
          };
          return self.hash['$include?'](o);}, $$8.$$s = self, $$8.$$arity = 1, $$8))
      } else {
        return false
      }
    }, $Set_$eq_eq$7.$$arity = 1);
    
    Opal.def(self, '$add', $Set_add$9 = function $$add(o) {
      var self = this, $writer = nil;

      
      
      $writer = [o, true];
      $send(self.hash, '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      return self;
    }, $Set_add$9.$$arity = 1);
    Opal.alias(self, "<<", "add");
    
    Opal.def(self, '$classify', $Set_classify$10 = function $$classify() {
      var $iter = $Set_classify$10.$$p, block = $iter || nil, $$11, $$12, self = this, result = nil;

      if ($iter) $Set_classify$10.$$p = null;
      
      
      if ($iter) $Set_classify$10.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("classify")
      };
      result = $send($$($nesting, 'Hash'), 'new', [], ($$11 = function(h, k){var self = $$11.$$s || this, $writer = nil;

      
        
        if (h == null) {
          h = nil;
        };
        
        if (k == null) {
          k = nil;
        };
        $writer = [k, self.$class().$new()];
        $send(h, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];}, $$11.$$s = self, $$11.$$arity = 2, $$11));
      $send(self, 'each', [], ($$12 = function(item){var self = $$12.$$s || this;

      
        
        if (item == null) {
          item = nil;
        };
        return result['$[]'](Opal.yield1(block, item)).$add(item);}, $$12.$$s = self, $$12.$$arity = 1, $$12));
      return result;
    }, $Set_classify$10.$$arity = 0);
    
    Opal.def(self, '$collect!', $Set_collect$excl$13 = function() {
      var $iter = $Set_collect$excl$13.$$p, block = $iter || nil, $$14, self = this, result = nil;

      if ($iter) $Set_collect$excl$13.$$p = null;
      
      
      if ($iter) $Set_collect$excl$13.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("collect!")
      };
      result = self.$class().$new();
      $send(self, 'each', [], ($$14 = function(item){var self = $$14.$$s || this;

      
        
        if (item == null) {
          item = nil;
        };
        return result['$<<'](Opal.yield1(block, item));}, $$14.$$s = self, $$14.$$arity = 1, $$14));
      return self.$replace(result);
    }, $Set_collect$excl$13.$$arity = 0);
    Opal.alias(self, "map!", "collect!");
    
    Opal.def(self, '$delete', $Set_delete$15 = function(o) {
      var self = this;

      
      self.hash.$delete(o);
      return self;
    }, $Set_delete$15.$$arity = 1);
    
    Opal.def(self, '$delete?', $Set_delete$ques$16 = function(o) {
      var self = this;

      if ($truthy(self['$include?'](o))) {
        
        self.$delete(o);
        return self;
      } else {
        return nil
      }
    }, $Set_delete$ques$16.$$arity = 1);
    
    Opal.def(self, '$delete_if', $Set_delete_if$17 = function $$delete_if() {
      var $$18, $$19, $iter = $Set_delete_if$17.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Set_delete_if$17.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return self.$enum_for("delete_if")
      };
      $send($send(self, 'select', [], ($$18 = function(o){var self = $$18.$$s || this;

      
        
        if (o == null) {
          o = nil;
        };
        return Opal.yield1($yield, o);;}, $$18.$$s = self, $$18.$$arity = 1, $$18)), 'each', [], ($$19 = function(o){var self = $$19.$$s || this;
        if (self.hash == null) self.hash = nil;

      
        
        if (o == null) {
          o = nil;
        };
        return self.hash.$delete(o);}, $$19.$$s = self, $$19.$$arity = 1, $$19));
      return self;
    }, $Set_delete_if$17.$$arity = 0);
    
    Opal.def(self, '$add?', $Set_add$ques$20 = function(o) {
      var self = this;

      if ($truthy(self['$include?'](o))) {
        return nil
      } else {
        return self.$add(o)
      }
    }, $Set_add$ques$20.$$arity = 1);
    
    Opal.def(self, '$each', $Set_each$21 = function $$each() {
      var $iter = $Set_each$21.$$p, block = $iter || nil, self = this;

      if ($iter) $Set_each$21.$$p = null;
      
      
      if ($iter) $Set_each$21.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each")
      };
      $send(self.hash, 'each_key', [], block.$to_proc());
      return self;
    }, $Set_each$21.$$arity = 0);
    
    Opal.def(self, '$empty?', $Set_empty$ques$22 = function() {
      var self = this;

      return self.hash['$empty?']()
    }, $Set_empty$ques$22.$$arity = 0);
    
    Opal.def(self, '$eql?', $Set_eql$ques$23 = function(other) {
      var $$24, self = this;

      return self.hash['$eql?']($send(other, 'instance_eval', [], ($$24 = function(){var self = $$24.$$s || this;
        if (self.hash == null) self.hash = nil;

      return self.hash}, $$24.$$s = self, $$24.$$arity = 0, $$24)))
    }, $Set_eql$ques$23.$$arity = 1);
    
    Opal.def(self, '$clear', $Set_clear$25 = function $$clear() {
      var self = this;

      
      self.hash.$clear();
      return self;
    }, $Set_clear$25.$$arity = 0);
    
    Opal.def(self, '$include?', $Set_include$ques$26 = function(o) {
      var self = this;

      return self.hash['$include?'](o)
    }, $Set_include$ques$26.$$arity = 1);
    Opal.alias(self, "member?", "include?");
    
    Opal.def(self, '$merge', $Set_merge$27 = function $$merge(enum$) {
      var $$28, self = this;

      
      $send(enum$, 'each', [], ($$28 = function(item){var self = $$28.$$s || this;

      
        
        if (item == null) {
          item = nil;
        };
        return self.$add(item);}, $$28.$$s = self, $$28.$$arity = 1, $$28));
      return self;
    }, $Set_merge$27.$$arity = 1);
    
    Opal.def(self, '$replace', $Set_replace$29 = function $$replace(enum$) {
      var self = this;

      
      self.$clear();
      self.$merge(enum$);
      return self;
    }, $Set_replace$29.$$arity = 1);
    
    Opal.def(self, '$size', $Set_size$30 = function $$size() {
      var self = this;

      return self.hash.$size()
    }, $Set_size$30.$$arity = 0);
    Opal.alias(self, "length", "size");
    
    Opal.def(self, '$subtract', $Set_subtract$31 = function $$subtract(enum$) {
      var $$32, self = this;

      
      $send(enum$, 'each', [], ($$32 = function(item){var self = $$32.$$s || this;

      
        
        if (item == null) {
          item = nil;
        };
        return self.$delete(item);}, $$32.$$s = self, $$32.$$arity = 1, $$32));
      return self;
    }, $Set_subtract$31.$$arity = 1);
    
    Opal.def(self, '$|', $Set_$$33 = function(enum$) {
      var self = this;

      
      if ($truthy(enum$['$respond_to?']("each"))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "value must be enumerable")
      };
      return self.$dup().$merge(enum$);
    }, $Set_$$33.$$arity = 1);
    
    Opal.def(self, '$superset?', $Set_superset$ques$34 = function(set) {
      var $a, $$35, self = this;

      
      ($truthy($a = set['$is_a?']($$($nesting, 'Set'))) ? $a : self.$raise($$($nesting, 'ArgumentError'), "value must be a set"));
      if ($truthy($rb_lt(self.$size(), set.$size()))) {
        return false};
      return $send(set, 'all?', [], ($$35 = function(o){var self = $$35.$$s || this;

      
        
        if (o == null) {
          o = nil;
        };
        return self['$include?'](o);}, $$35.$$s = self, $$35.$$arity = 1, $$35));
    }, $Set_superset$ques$34.$$arity = 1);
    Opal.alias(self, ">=", "superset?");
    
    Opal.def(self, '$proper_superset?', $Set_proper_superset$ques$36 = function(set) {
      var $a, $$37, self = this;

      
      ($truthy($a = set['$is_a?']($$($nesting, 'Set'))) ? $a : self.$raise($$($nesting, 'ArgumentError'), "value must be a set"));
      if ($truthy($rb_le(self.$size(), set.$size()))) {
        return false};
      return $send(set, 'all?', [], ($$37 = function(o){var self = $$37.$$s || this;

      
        
        if (o == null) {
          o = nil;
        };
        return self['$include?'](o);}, $$37.$$s = self, $$37.$$arity = 1, $$37));
    }, $Set_proper_superset$ques$36.$$arity = 1);
    Opal.alias(self, ">", "proper_superset?");
    
    Opal.def(self, '$subset?', $Set_subset$ques$38 = function(set) {
      var $a, $$39, self = this;

      
      ($truthy($a = set['$is_a?']($$($nesting, 'Set'))) ? $a : self.$raise($$($nesting, 'ArgumentError'), "value must be a set"));
      if ($truthy($rb_lt(set.$size(), self.$size()))) {
        return false};
      return $send(self, 'all?', [], ($$39 = function(o){var self = $$39.$$s || this;

      
        
        if (o == null) {
          o = nil;
        };
        return set['$include?'](o);}, $$39.$$s = self, $$39.$$arity = 1, $$39));
    }, $Set_subset$ques$38.$$arity = 1);
    Opal.alias(self, "<=", "subset?");
    
    Opal.def(self, '$proper_subset?', $Set_proper_subset$ques$40 = function(set) {
      var $a, $$41, self = this;

      
      ($truthy($a = set['$is_a?']($$($nesting, 'Set'))) ? $a : self.$raise($$($nesting, 'ArgumentError'), "value must be a set"));
      if ($truthy($rb_le(set.$size(), self.$size()))) {
        return false};
      return $send(self, 'all?', [], ($$41 = function(o){var self = $$41.$$s || this;

      
        
        if (o == null) {
          o = nil;
        };
        return set['$include?'](o);}, $$41.$$s = self, $$41.$$arity = 1, $$41));
    }, $Set_proper_subset$ques$40.$$arity = 1);
    Opal.alias(self, "<", "proper_subset?");
    Opal.alias(self, "+", "|");
    Opal.alias(self, "union", "|");
    return (Opal.def(self, '$to_a', $Set_to_a$42 = function $$to_a() {
      var self = this;

      return self.hash.$keys()
    }, $Set_to_a$42.$$arity = 0), nil) && 'to_a';
  })($nesting[0], null, $nesting);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Enumerable');

    var $nesting = [self].concat($parent_nesting), $Enumerable_to_set$43;

    
    Opal.def(self, '$to_set', $Enumerable_to_set$43 = function $$to_set($a, $b) {
      var $iter = $Enumerable_to_set$43.$$p, block = $iter || nil, $post_args, klass, args, self = this;

      if ($iter) $Enumerable_to_set$43.$$p = null;
      
      
      if ($iter) $Enumerable_to_set$43.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      if ($post_args.length > 0) {
        klass = $post_args[0];
        $post_args.splice(0, 1);
      }
      if (klass == null) {
        klass = $$($nesting, 'Set');
      };
      
      args = $post_args;;
      return $send(klass, 'new', [self].concat(Opal.to_a(args)), block.$to_proc());
    }, $Enumerable_to_set$43.$$arity = -1)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/opal_ext/kernel"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $send = Opal.send;

  Opal.add_stubs(['$new']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_open$1, $Kernel___dir__$2;

    
    
    Opal.def(self, '$open', $Kernel_open$1 = function $$open(path, $a) {
      var $post_args, rest, $iter = $Kernel_open$1.$$p, $yield = $iter || nil, self = this, file = nil;

      if ($iter) $Kernel_open$1.$$p = null;
      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      rest = $post_args;;
      file = $send($$($nesting, 'File'), 'new', [path].concat(Opal.to_a(rest)));
      if (($yield !== nil)) {
        return Opal.yield1($yield, file);
      } else {
        return file
      };
    }, $Kernel_open$1.$$arity = -2);
    
    Opal.def(self, '$__dir__', $Kernel___dir__$2 = function $$__dir__() {
      var self = this;

      return ""
    }, $Kernel___dir__$2.$$arity = 0);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/opal_ext/file"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$attr_reader', '$delete', '$gsub', '$read', '$size', '$to_enum', '$chomp', '$each_line', '$readlines', '$split']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), $File_initialize$1, $File_read$2, $File_each_line$3, $File_readlines$4;

    self.$$prototype.eof = self.$$prototype.path = nil;
    
    self.$attr_reader("eof");
    self.$attr_reader("lineno");
    self.$attr_reader("path");
    
    Opal.def(self, '$initialize', $File_initialize$1 = function $$initialize(path, flags) {
      var self = this, encoding_flag_regexp = nil;

      
      
      if (flags == null) {
        flags = "r";
      };
      self.path = path;
      self.contents = nil;
      self.eof = false;
      self.lineno = 0;
      flags = flags.$delete("b");
      encoding_flag_regexp = /:(.*)/;
      flags = flags.$gsub(encoding_flag_regexp, "");
      return (self.flags = flags);
    }, $File_initialize$1.$$arity = -2);
    
    Opal.def(self, '$read', $File_read$2 = function $$read() {
      var self = this, res = nil;

      if ($truthy(self.eof)) {
        return ""
      } else {
        
        res = $$($nesting, 'File').$read(self.path);
        self.eof = true;
        self.lineno = res.$size();
        return res;
      }
    }, $File_read$2.$$arity = 0);
    
    Opal.def(self, '$each_line', $File_each_line$3 = function $$each_line(separator) {
      var $iter = $File_each_line$3.$$p, block = $iter || nil, self = this, lines = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if ($iter) $File_each_line$3.$$p = null;
      
      
      if ($iter) $File_each_line$3.$$p = null;;
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      if ($truthy(self.eof)) {
        return (function() {if ((block !== nil)) {
          return self
        } else {
          return [].$to_enum()
        }; return nil; })()};
      if ((block !== nil)) {
        
        lines = $$($nesting, 'File').$read(self.path);
        
        self.eof = false;
        self.lineno = 0;
        var chomped  = lines.$chomp(),
            trailing = lines.length != chomped.length,
            splitted = chomped.split(separator);
        for (var i = 0, length = splitted.length; i < length; i++) {
          self.lineno += 1;
          if (i < length - 1 || trailing) {
            Opal.yield1(block, splitted[i] + separator);
          }
          else {
            Opal.yield1(block, splitted[i]);
          }
        }
        self.eof = true;
      ;
        return self;
      } else {
        return self.$read().$each_line()
      };
    }, $File_each_line$3.$$arity = -1);
    
    Opal.def(self, '$readlines', $File_readlines$4 = function $$readlines() {
      var self = this;

      return $$($nesting, 'File').$readlines(self.path)
    }, $File_readlines$4.$$arity = 0);
    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $readlines$5, $file$ques$6, $readable$ques$7, $read$8;

      
      
      Opal.def(self, '$readlines', $readlines$5 = function $$readlines(path, separator) {
        var self = this, content = nil;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        
        
        if (separator == null) {
          separator = $gvars["/"];
        };
        content = $$($nesting, 'File').$read(path);
        return content.$split(separator);
      }, $readlines$5.$$arity = -2);
      
      Opal.def(self, '$file?', $file$ques$6 = function(path) {
        var self = this;

        return true
      }, $file$ques$6.$$arity = 1);
      
      Opal.def(self, '$readable?', $readable$ques$7 = function(path) {
        var self = this;

        return true
      }, $readable$ques$7.$$arity = 1);
      return (Opal.def(self, '$read', $read$8 = function $$read(path) {
        var self = this;

        return ""
      }, $read$8.$$arity = 1), nil) && 'read';
    })(Opal.get_singleton_class(self), $nesting);
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IO');

    var $nesting = [self].concat($parent_nesting), $IO_read$9;

    return (Opal.defs(self, '$read', $IO_read$9 = function $$read(path) {
      var self = this;

      return $$($nesting, 'File').$read(path)
    }, $IO_read$9.$$arity = 1), nil) && 'read'
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/opal_ext/match_data"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs(['$[]=', '$-']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'MatchData');

    var $nesting = [self].concat($parent_nesting), $MatchData_$$$eq$1;

    self.$$prototype.matches = nil;
    return (Opal.def(self, '$[]=', $MatchData_$$$eq$1 = function(idx, val) {
      var self = this, $writer = nil;

      
      $writer = [idx, val];
      $send(self.matches, '[]=', Opal.to_a($writer));
      return $writer[$rb_minus($writer["length"], 1)];
    }, $MatchData_$$$eq$1.$$arity = 2), nil) && '[]='
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/opal_ext/string"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$method_defined?', '$<', '$length', '$bytes', '$to_s', '$byteslice', '$==', '$>=', '$-', '$_original_byteslice', '$_original_unpack']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_limit_bytesize$1, $String_byteslice$2, $String_unpack$3;

    
    if ($truthy(self['$method_defined?']("limit_bytesize"))) {
    } else {
      
      Opal.def(self, '$limit_bytesize', $String_limit_bytesize$1 = function $$limit_bytesize(size) {
        var self = this, result = nil;

        
        if ($truthy($rb_lt(size, self.$bytes().$length()))) {
        } else {
          return self.$to_s()
        };
        result = self.$byteslice(0, size);
        return result.$to_s();
      }, $String_limit_bytesize$1.$$arity = 1)
    };
    if ($truthy(self['$method_defined?']("limit"))) {
    } else {
      Opal.alias(self, "limit", "limit_bytesize")
    };
    Opal.alias(self, "_original_byteslice", "byteslice");
    
    Opal.def(self, '$byteslice', $String_byteslice$2 = function $$byteslice(index, length) {
      var $a, $b, self = this;

      
      
      if (length == null) {
        length = 1;
      };
      if ($truthy(($truthy($a = (($b = index['$=='](3)) ? $rb_ge(length, index) : index['$=='](3))) ? self.charCodeAt() === 65279 : $a))) {
        return (self.substr(1)).$byteslice(0, $rb_minus(length, 3))
      } else {
        return self.$_original_byteslice(index, length)
      };
    }, $String_byteslice$2.$$arity = -2);
    Opal.alias(self, "_original_unpack", "unpack");
    return (Opal.def(self, '$unpack', $String_unpack$3 = function $$unpack(format) {
      var self = this;

      if (format['$==']("C3")) {
        if ($truthy(self.charCodeAt() === 65279)) {
          return [239, 187, 191]
        } else {
          
          var bytes = []
          for (var i=0; i < 3; i++) {
            if (i < self.length) {
              bytes.push(self.charCodeAt(i))
            } else {
              bytes.push(nil)
            }
          }
          return bytes
        
        }
      } else {
        return self.$_original_unpack(format)
      }
    }, $String_unpack$3.$$arity = 1), nil) && 'unpack';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/opal_ext/uri"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  Opal.add_stubs(['$extend']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'URI');

    var $nesting = [self].concat($parent_nesting), $URI_parse$1, $URI_path$2;

    
    Opal.defs(self, '$parse', $URI_parse$1 = function $$parse(str) {
      var self = this;

      return str.$extend($$($nesting, 'URI'))
    }, $URI_parse$1.$$arity = 1);
    
    Opal.def(self, '$path', $URI_path$2 = function $$path() {
      var self = this;

      return self
    }, $URI_path$2.$$arity = 0);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/opal_ext/base64"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$delete']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Base64');

    var $nesting = [self].concat($parent_nesting), $Base64_decode64$1, $Base64_encode64$2, $Base64_strict_decode64$3, $Base64_strict_encode64$4, $Base64_urlsafe_decode64$5, $Base64_urlsafe_encode64$6;

    
    
    var encode, decode;
    encode = Opal.global.btoa || function (input) {
      var buffer;
      if (input instanceof Buffer) {
        buffer = input;
      } else {
        buffer = Buffer.from(input.toString(), 'binary');
      }
      return buffer.toString('base64');
    };
    decode = Opal.global.atob || function (input) {
      return Buffer.from(input, 'base64').toString('binary');
    };
  ;
    Opal.defs(self, '$decode64', $Base64_decode64$1 = function $$decode64(string) {
      var self = this;

      return decode(string.replace(/\r?\n/g, ''));
    }, $Base64_decode64$1.$$arity = 1);
    Opal.defs(self, '$encode64', $Base64_encode64$2 = function $$encode64(string) {
      var self = this;

      return encode(string).replace(/(.{60})/g, "$1\n").replace(/([^\n])$/g, "$1\n");
    }, $Base64_encode64$2.$$arity = 1);
    Opal.defs(self, '$strict_decode64', $Base64_strict_decode64$3 = function $$strict_decode64(string) {
      var self = this;

      return decode(string);
    }, $Base64_strict_decode64$3.$$arity = 1);
    Opal.defs(self, '$strict_encode64', $Base64_strict_encode64$4 = function $$strict_encode64(string) {
      var self = this;

      return encode(string);
    }, $Base64_strict_encode64$4.$$arity = 1);
    Opal.defs(self, '$urlsafe_decode64', $Base64_urlsafe_decode64$5 = function $$urlsafe_decode64(string) {
      var self = this;

      return decode(string.replace(/\-/g, '+').replace(/_/g, '/'));
    }, $Base64_urlsafe_decode64$5.$$arity = 1);
    Opal.defs(self, '$urlsafe_encode64', $Base64_urlsafe_encode64$6 = function $$urlsafe_encode64(string, $kwargs) {
      var padding, self = this, str = nil;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      padding = $kwargs.$$smap["padding"];
      if (padding == null) {
        padding = true
      };
      str = encode(string).replace(/\+/g, '-').replace(/\//g, '_');
      if ($truthy(padding)) {
      } else {
        str = str.$delete("=")
      };
      return str;
    }, $Base64_urlsafe_encode64$6.$$arity = -2);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/opal_ext/number"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$coerce_to!', '$>']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Number');

    var $nesting = [self].concat($parent_nesting), $Number_round$1;

    return (Opal.def(self, '$round', $Number_round$1 = function $$round(ndigits) {
      var self = this;

      
      ;
      ndigits = $$($nesting, 'Opal')['$coerce_to!'](ndigits, $$($nesting, 'Integer'), "to_int");
      if ($truthy($rb_gt(ndigits, 0))) {
        return Number(self.toFixed(ndigits));
      } else {
        return Math.round(self);
      };
    }, $Number_round$1.$$arity = -1), nil) && 'round'
  })($nesting[0], $$($nesting, 'Numeric'), $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/opal_ext"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$require']);
  
  self.$require("asciidoctor/js/opal_ext/kernel");
  self.$require("asciidoctor/js/opal_ext/file");
  self.$require("asciidoctor/js/opal_ext/match_data");
  self.$require("asciidoctor/js/opal_ext/string");
  self.$require("asciidoctor/js/opal_ext/uri");
  self.$require("asciidoctor/js/opal_ext/base64");
  self.$require("asciidoctor/js/opal_ext/number");
  
// suppress "not supported" warning messages from Opal
Opal.config.unsupported_features_severity = 'ignore'

// Load specific runtime
self.$require("asciidoctor/js/opal_ext/node");
;
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/rx"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $send = Opal.send, $gvars = Opal.gvars, $truthy = Opal.truthy;

  Opal.add_stubs(['$gsub', '$+', '$unpack_hex_range']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting), $Asciidoctor_unpack_hex_range$1;

    
    Opal.const_set($nesting[0], 'HEX_RANGE_RX', /([A-F0-9]{4})(?:-([A-F0-9]{4}))?/);
    Opal.defs(self, '$unpack_hex_range', $Asciidoctor_unpack_hex_range$1 = function $$unpack_hex_range(str) {
      var $$2, self = this;

      return $send(str, 'gsub', [$$($nesting, 'HEX_RANGE_RX')], ($$2 = function(){var self = $$2.$$s || this, $a, $b;

      return "" + "\\u" + ((($a = $gvars['~']) === nil ? nil : $a['$[]'](1))) + (($truthy($a = (($b = $gvars['~']) === nil ? nil : $b['$[]'](2))) ? "" + "-\\u" + ((($b = $gvars['~']) === nil ? nil : $b['$[]'](2))) : $a))}, $$2.$$s = self, $$2.$$arity = 0, $$2))
    }, $Asciidoctor_unpack_hex_range$1.$$arity = 1);
    Opal.const_set($nesting[0], 'P_L', $rb_plus("A-Za-z", self.$unpack_hex_range("00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D037F03860388-038A038C038E-03A103A3-03F503F7-0481048A-052F0531-055605590561-058705D0-05EA05F0-05F20620-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280840-085808A0-08B20904-0939093D09500958-09610971-09800985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10CF10CF20D05-0D0C0D0E-0D100D12-0D3A0D3D0D4E0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC-0EDF0F000F40-0F470F49-0F6C0F88-0F8C1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510C710CD10D0-10FA10FC-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA16F1-16F81700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191E1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1BBA-1BE51C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11CF51CF61D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209C21022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2CF22CF32D00-2D252D272D2D2D30-2D672D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31BA31F0-31FF3400-4DB54E00-9FCCA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A66EA67F-A69DA6A0-A6E5A717-A71FA722-A788A78B-A78EA790-A7ADA7B0A7B1A7F7-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFA9E0-A9E4A9E6-A9EFA9FA-A9FEAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA7E-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDAAE0-AAEAAAF2-AAF4AB01-AB06AB09-AB0EAB11-AB16AB20-AB26AB28-AB2EAB30-AB5AAB5C-AB5FAB64AB65ABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC")));
    Opal.const_set($nesting[0], 'P_Nl', self.$unpack_hex_range("16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF"));
    Opal.const_set($nesting[0], 'P_Nd', $rb_plus("0-9", self.$unpack_hex_range("0660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0DE6-0DEF0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19D91A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9A9F0-A9F9AA50-AA59ABF0-ABF9FF10-FF19")));
    Opal.const_set($nesting[0], 'P_Pc', self.$unpack_hex_range("005F203F20402054FE33FE34FE4D-FE4FFF3F"));
    Opal.const_set($nesting[0], 'CC_ALPHA', "" + ($$($nesting, 'P_L')) + ($$($nesting, 'P_Nl')));
    Opal.const_set($nesting[0], 'CG_ALPHA', "" + "[" + ($$($nesting, 'CC_ALPHA')) + "]");
    Opal.const_set($nesting[0], 'CC_ALNUM', "" + ($$($nesting, 'CC_ALPHA')) + ($$($nesting, 'P_Nd')));
    Opal.const_set($nesting[0], 'CG_ALNUM', "" + "[" + ($$($nesting, 'CC_ALNUM')) + "]");
    Opal.const_set($nesting[0], 'CC_WORD', "" + ($$($nesting, 'CC_ALNUM')) + ($$($nesting, 'P_Pc')));
    Opal.const_set($nesting[0], 'CG_WORD', "" + "[" + ($$($nesting, 'CC_WORD')) + "]");
    Opal.const_set($nesting[0], 'CG_BLANK', "[ \\t]");
    Opal.const_set($nesting[0], 'CC_EOL', "(?=\\n|$)");
    Opal.const_set($nesting[0], 'CG_GRAPH', "[^\\s\\x00-\\x1F\\x7F]");
    Opal.const_set($nesting[0], 'CC_ALL', "[\\s\\S]");
    Opal.const_set($nesting[0], 'CC_ANY', "[^\\n]");
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["strscan"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs(['$attr_reader', '$anchor', '$scan_until', '$length', '$size', '$rest', '$pos=', '$-', '$private']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StringScanner');

    var $nesting = [self].concat($parent_nesting), $StringScanner_initialize$1, $StringScanner_beginning_of_line$ques$2, $StringScanner_scan$3, $StringScanner_scan_until$4, $StringScanner_$$$5, $StringScanner_check$6, $StringScanner_check_until$7, $StringScanner_peek$8, $StringScanner_eos$ques$9, $StringScanner_exist$ques$10, $StringScanner_skip$11, $StringScanner_skip_until$12, $StringScanner_get_byte$13, $StringScanner_match$ques$14, $StringScanner_pos$eq$15, $StringScanner_matched_size$16, $StringScanner_post_match$17, $StringScanner_pre_match$18, $StringScanner_reset$19, $StringScanner_rest$20, $StringScanner_rest$ques$21, $StringScanner_rest_size$22, $StringScanner_terminate$23, $StringScanner_unscan$24, $StringScanner_anchor$25;

    self.$$prototype.pos = self.$$prototype.string = self.$$prototype.working = self.$$prototype.matched = self.$$prototype.prev_pos = self.$$prototype.match = nil;
    
    self.$attr_reader("pos");
    self.$attr_reader("matched");
    
    Opal.def(self, '$initialize', $StringScanner_initialize$1 = function $$initialize(string) {
      var self = this;

      
      self.string = string;
      self.pos = 0;
      self.matched = nil;
      self.working = string;
      return (self.match = []);
    }, $StringScanner_initialize$1.$$arity = 1);
    self.$attr_reader("string");
    
    Opal.def(self, '$beginning_of_line?', $StringScanner_beginning_of_line$ques$2 = function() {
      var self = this;

      return self.pos === 0 || self.string.charAt(self.pos - 1) === "\n"
    }, $StringScanner_beginning_of_line$ques$2.$$arity = 0);
    Opal.alias(self, "bol?", "beginning_of_line?");
    
    Opal.def(self, '$scan', $StringScanner_scan$3 = function $$scan(pattern) {
      var self = this;

      
      pattern = self.$anchor(pattern);
      
      var result = pattern.exec(self.working);

      if (result == null) {
        return self.matched = nil;
      }
      else if (typeof(result) === 'object') {
        self.prev_pos = self.pos;
        self.pos     += result[0].length;
        self.working  = self.working.substring(result[0].length);
        self.matched  = result[0];
        self.match    = result;

        return result[0];
      }
      else if (typeof(result) === 'string') {
        self.pos     += result.length;
        self.working  = self.working.substring(result.length);

        return result;
      }
      else {
        return nil;
      }
    ;
    }, $StringScanner_scan$3.$$arity = 1);
    
    Opal.def(self, '$scan_until', $StringScanner_scan_until$4 = function $$scan_until(pattern) {
      var self = this;

      
      pattern = self.$anchor(pattern);
      
      var pos     = self.pos,
          working = self.working,
          result;

      while (true) {
        result   = pattern.exec(working);
        pos     += 1;
        working  = working.substr(1);

        if (result == null) {
          if (working.length === 0) {
            return self.matched = nil;
          }

          continue;
        }

        self.matched  = self.string.substr(self.pos, pos - self.pos - 1 + result[0].length);
        self.prev_pos = pos - 1;
        self.pos      = pos;
        self.working  = working.substr(result[0].length);

        return self.matched;
      }
    ;
    }, $StringScanner_scan_until$4.$$arity = 1);
    
    Opal.def(self, '$[]', $StringScanner_$$$5 = function(idx) {
      var self = this;

      
      var match = self.match;

      if (idx < 0) {
        idx += match.length;
      }

      if (idx < 0 || idx >= match.length) {
        return nil;
      }

      if (match[idx] == null) {
        return nil;
      }

      return match[idx];
    
    }, $StringScanner_$$$5.$$arity = 1);
    
    Opal.def(self, '$check', $StringScanner_check$6 = function $$check(pattern) {
      var self = this;

      
      pattern = self.$anchor(pattern);
      
      var result = pattern.exec(self.working);

      if (result == null) {
        return self.matched = nil;
      }

      return self.matched = result[0];
    ;
    }, $StringScanner_check$6.$$arity = 1);
    
    Opal.def(self, '$check_until', $StringScanner_check_until$7 = function $$check_until(pattern) {
      var self = this;

      
      var prev_pos = self.prev_pos,
          pos      = self.pos;

      var result = self.$scan_until(pattern);

      if (result !== nil) {
        self.matched = result.substr(-1);
        self.working = self.string.substr(pos);
      }

      self.prev_pos = prev_pos;
      self.pos      = pos;

      return result;
    
    }, $StringScanner_check_until$7.$$arity = 1);
    
    Opal.def(self, '$peek', $StringScanner_peek$8 = function $$peek(length) {
      var self = this;

      return self.working.substring(0, length)
    }, $StringScanner_peek$8.$$arity = 1);
    
    Opal.def(self, '$eos?', $StringScanner_eos$ques$9 = function() {
      var self = this;

      return self.working.length === 0
    }, $StringScanner_eos$ques$9.$$arity = 0);
    
    Opal.def(self, '$exist?', $StringScanner_exist$ques$10 = function(pattern) {
      var self = this;

      
      var result = pattern.exec(self.working);

      if (result == null) {
        return nil;
      }
      else if (result.index == 0) {
        return 0;
      }
      else {
        return result.index + 1;
      }
    
    }, $StringScanner_exist$ques$10.$$arity = 1);
    
    Opal.def(self, '$skip', $StringScanner_skip$11 = function $$skip(pattern) {
      var self = this;

      
      pattern = self.$anchor(pattern);
      
      var result = pattern.exec(self.working);

      if (result == null) {
        return self.matched = nil;
      }
      else {
        var match_str = result[0];
        var match_len = match_str.length;

        self.matched   = match_str;
        self.prev_pos  = self.pos;
        self.pos      += match_len;
        self.working   = self.working.substring(match_len);

        return match_len;
      }
    ;
    }, $StringScanner_skip$11.$$arity = 1);
    
    Opal.def(self, '$skip_until', $StringScanner_skip_until$12 = function $$skip_until(pattern) {
      var self = this;

      
      var result = self.$scan_until(pattern);

      if (result === nil) {
        return nil;
      }
      else {
        self.matched = result.substr(-1);

        return result.length;
      }
    
    }, $StringScanner_skip_until$12.$$arity = 1);
    
    Opal.def(self, '$get_byte', $StringScanner_get_byte$13 = function $$get_byte() {
      var self = this;

      
      var result = nil;

      if (self.pos < self.string.length) {
        self.prev_pos  = self.pos;
        self.pos      += 1;
        result      = self.matched = self.working.substring(0, 1);
        self.working   = self.working.substring(1);
      }
      else {
        self.matched = nil;
      }

      return result;
    
    }, $StringScanner_get_byte$13.$$arity = 0);
    Opal.alias(self, "getch", "get_byte");
    
    Opal.def(self, '$match?', $StringScanner_match$ques$14 = function(pattern) {
      var self = this;

      
      pattern = self.$anchor(pattern);
      
      var result = pattern.exec(self.working);

      if (result == null) {
        return nil;
      }
      else {
        self.prev_pos = self.pos;

        return result[0].length;
      }
    ;
    }, $StringScanner_match$ques$14.$$arity = 1);
    
    Opal.def(self, '$pos=', $StringScanner_pos$eq$15 = function(pos) {
      var self = this;

      
      
      if (pos < 0) {
        pos += self.string.$length();
      }
    ;
      self.pos = pos;
      return (self.working = self.string.slice(pos));
    }, $StringScanner_pos$eq$15.$$arity = 1);
    
    Opal.def(self, '$matched_size', $StringScanner_matched_size$16 = function $$matched_size() {
      var self = this;

      
      if (self.matched === nil) {
        return nil;
      }

      return self.matched.length
    
    }, $StringScanner_matched_size$16.$$arity = 0);
    
    Opal.def(self, '$post_match', $StringScanner_post_match$17 = function $$post_match() {
      var self = this;

      
      if (self.matched === nil) {
        return nil;
      }

      return self.string.substr(self.pos);
    
    }, $StringScanner_post_match$17.$$arity = 0);
    
    Opal.def(self, '$pre_match', $StringScanner_pre_match$18 = function $$pre_match() {
      var self = this;

      
      if (self.matched === nil) {
        return nil;
      }

      return self.string.substr(0, self.prev_pos);
    
    }, $StringScanner_pre_match$18.$$arity = 0);
    
    Opal.def(self, '$reset', $StringScanner_reset$19 = function $$reset() {
      var self = this;

      
      self.working = self.string;
      self.matched = nil;
      return (self.pos = 0);
    }, $StringScanner_reset$19.$$arity = 0);
    
    Opal.def(self, '$rest', $StringScanner_rest$20 = function $$rest() {
      var self = this;

      return self.working
    }, $StringScanner_rest$20.$$arity = 0);
    
    Opal.def(self, '$rest?', $StringScanner_rest$ques$21 = function() {
      var self = this;

      return self.working.length !== 0
    }, $StringScanner_rest$ques$21.$$arity = 0);
    
    Opal.def(self, '$rest_size', $StringScanner_rest_size$22 = function $$rest_size() {
      var self = this;

      return self.$rest().$size()
    }, $StringScanner_rest_size$22.$$arity = 0);
    
    Opal.def(self, '$terminate', $StringScanner_terminate$23 = function $$terminate() {
      var self = this, $writer = nil;

      
      self.match = nil;
      
      $writer = [self.string.$length()];
      $send(self, 'pos=', Opal.to_a($writer));
      return $writer[$rb_minus($writer["length"], 1)];;
    }, $StringScanner_terminate$23.$$arity = 0);
    
    Opal.def(self, '$unscan', $StringScanner_unscan$24 = function $$unscan() {
      var self = this;

      
      self.pos = self.prev_pos;
      self.prev_pos = nil;
      self.match = nil;
      return self;
    }, $StringScanner_unscan$24.$$arity = 0);
    self.$private();
    return (Opal.def(self, '$anchor', $StringScanner_anchor$25 = function $$anchor(pattern) {
      var self = this;

      
      var flags = pattern.toString().match(/\/([^\/]+)$/);
      flags = flags ? flags[1] : undefined;
      return new RegExp('^(?:' + pattern.source + ')', flags);
    
    }, $StringScanner_anchor$25.$$arity = 1), nil) && 'anchor';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$require']);
  
  self.$require("asciidoctor/js/opal_ext");
  self.$require("asciidoctor/js/rx");
  return self.$require("strscan");
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/core_ext/nil_or_empty"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$method_defined?']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting);

    if ($truthy(self['$method_defined?']("nil_or_empty?"))) {
      return nil
    } else {
      return Opal.alias(self, "nil_or_empty?", "nil?")
    }
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting);

    if ($truthy(self['$method_defined?']("nil_or_empty?"))) {
      return nil
    } else {
      return Opal.alias(self, "nil_or_empty?", "empty?")
    }
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting);

    if ($truthy(self['$method_defined?']("nil_or_empty?"))) {
      return nil
    } else {
      return Opal.alias(self, "nil_or_empty?", "empty?")
    }
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting);

    if ($truthy(self['$method_defined?']("nil_or_empty?"))) {
      return nil
    } else {
      return Opal.alias(self, "nil_or_empty?", "empty?")
    }
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Numeric');

    var $nesting = [self].concat($parent_nesting);

    if ($truthy(self['$method_defined?']("nil_or_empty?"))) {
      return nil
    } else {
      return Opal.alias(self, "nil_or_empty?", "nil?")
    }
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/core_ext/hash/merge"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var $$1, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$==', '$arity', '$instance_method', '$send', '$new', '$<', '$length', '$dup', '$>', '$inject', '$merge', '$[]']);
  if ($$($nesting, 'Hash').$instance_method("merge").$arity()['$=='](1)) {
    return $$($nesting, 'Hash').$send("prepend", $send($$($nesting, 'Module'), 'new', [], ($$1 = function(){var self = $$1.$$s || this, $merge$2;

    return (Opal.def(self, '$merge', $merge$2 = function $$merge($a) {
        var $post_args, args, $$3, $iter = $merge$2.$$p, $yield = $iter || nil, self = this, len = nil;

        if ($iter) $merge$2.$$p = null;
        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        if ($truthy($rb_lt((len = args.$length()), 1))) {
          return self.$dup()
        } else {
          
          if ($truthy($rb_gt(len, 1))) {
            return $send(args, 'inject', [self], ($$3 = function(acc, arg){var self = $$3.$$s || this;

            
              
              if (acc == null) {
                acc = nil;
              };
              
              if (arg == null) {
                arg = nil;
              };
              return acc.$merge(arg);}, $$3.$$s = self, $$3.$$arity = 2, $$3))
          } else {
            
            return $send(self, Opal.find_super_dispatcher(self, 'merge', $merge$2, false), [args['$[]'](0)], null);
          };
        };
      }, $merge$2.$$arity = -1), nil) && 'merge'}, $$1.$$s = self, $$1.$$arity = 0, $$1)))
  } else {
    return nil
  }
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/core_ext/match_data/names"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $truthy = Opal.truthy, $klass = Opal.klass;

  Opal.add_stubs(['$method_defined?']);
  if ($truthy($$($nesting, 'MatchData')['$method_defined?']("names"))) {
    return nil
  } else {
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'MatchData');

      var $nesting = [self].concat($parent_nesting), $MatchData_names$1;

      return (Opal.def(self, '$names', $MatchData_names$1 = function $$names() {
        var self = this;

        return []
      }, $MatchData_names$1.$$arity = 0), nil) && 'names'
    })($nesting[0], null, $nesting)
  }
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/core_ext"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$==']);
  
  self.$require("asciidoctor/core_ext.rb"+ '/../' + "core_ext/nil_or_empty");
  self.$require("asciidoctor/core_ext.rb"+ '/../' + "core_ext/hash/merge");
  if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
    return self.$require("asciidoctor/core_ext.rb"+ '/../' + "core_ext/match_data/names")
  } else {
    return nil
  };
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/helpers"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $gvars = Opal.gvars, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$module_function', '$require', '$include?', '$include', '$==', '$===', '$path', '$message', '$raise', '$warn', '$logger', '$chomp', '$empty?', '$slice', '$unpack', '$[]', '$byteslice', '$bytesize', '$[]=', '$-', '$map', '$rstrip', '$encode', '$encoding', '$nil_or_empty?', '$!=', '$tap', '$each_line', '$<<', '$match?', '$gsub', '$rindex', '$index', '$basename', '$extname', '$!', '$length', '$directory?', '$dirname', '$mkdir_p', '$mkdir', '$private_constant', '$join', '$divmod', '$*', '$+', '$to_s', '$to_i', '$succ', '$class_for_name', '$const_get']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Helpers');

      var $nesting = [self].concat($parent_nesting), $Helpers_require_library$1, $Helpers_prepare_source_array$2, $Helpers_prepare_source_string$11, $Helpers_uriish$ques$16, $Helpers_encode_uri_component$17, $Helpers_encode_spaces_in_uri$18, $Helpers_rootname$19, $Helpers_basename$20, $Helpers_extname$ques$21, $Helpers_extname$22, $Helpers_extname$23, $Helpers_mkdir_p$24, $Helpers_int_to_roman$25, $Helpers_nextval$27, $Helpers_resolve_class$28, $Helpers_class_for_name$29;

      
      self.$module_function();
      
      Opal.def(self, '$require_library', $Helpers_require_library$1 = function $$require_library(name, gem_name, on_failure) {
        var self = this, $case = nil, details = nil;
        if ($gvars["!"] == null) $gvars["!"] = nil;

        
        
        if (gem_name == null) {
          gem_name = true;
        };
        
        if (on_failure == null) {
          on_failure = "abort";
        };
        try {
          return self.$require(name)
        } catch ($err) {
          if (Opal.rescue($err, [$$$('::', 'LoadError')])) {
            try {
              
              if ($truthy(self['$include?']($$($nesting, 'Logging')))) {
              } else {
                self.$include($$($nesting, 'Logging'))
              };
              if ($truthy(gem_name)) {
                
                if (gem_name['$=='](true)) {
                  gem_name = name};
                $case = on_failure;
                if ("abort"['$===']($case)) {
                details = (function() {if ($gvars["!"].$path()['$=='](gem_name)) {
                  return ""
                } else {
                  return "" + " (reason: " + ((function() {if ($truthy($gvars["!"].$path())) {
                    return "" + "cannot load '" + ($gvars["!"].$path()) + "'"
                  } else {
                    return $gvars["!"].$message()
                  }; return nil; })()) + ")"
                }; return nil; })();
                self.$raise($$$('::', 'LoadError'), "" + "asciidoctor: FAILED: required gem '" + (gem_name) + "' is not available" + (details) + ". Processing aborted.");}
                else if ("warn"['$===']($case)) {
                details = (function() {if ($gvars["!"].$path()['$=='](gem_name)) {
                  return ""
                } else {
                  return "" + " (reason: " + ((function() {if ($truthy($gvars["!"].$path())) {
                    return "" + "cannot load '" + ($gvars["!"].$path()) + "'"
                  } else {
                    return $gvars["!"].$message()
                  }; return nil; })()) + ")"
                }; return nil; })();
                self.$logger().$warn("" + "optional gem '" + (gem_name) + "' is not available" + (details) + ". Functionality disabled.");};
              } else {
                $case = on_failure;
                if ("abort"['$===']($case)) {self.$raise($$$('::', 'LoadError'), "" + "asciidoctor: FAILED: " + ($gvars["!"].$message().$chomp(".")) + ". Processing aborted.")}
                else if ("warn"['$===']($case)) {self.$logger().$warn("" + ($gvars["!"].$message().$chomp(".")) + ". Functionality disabled.")}
              };
              return nil;
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };
      }, $Helpers_require_library$1.$$arity = -2);
      
      Opal.def(self, '$prepare_source_array', $Helpers_prepare_source_array$2 = function $$prepare_source_array(data, trim_end) {
        var $$3, $$4, $$5, $$6, $$7, $$8, $$9, $$10, self = this, leading_2_bytes = nil, leading_bytes = nil, first = nil, $writer = nil;

        
        
        if (trim_end == null) {
          trim_end = true;
        };
        if ($truthy(data['$empty?']())) {
          return []};
        if ((leading_2_bytes = (leading_bytes = (first = data['$[]'](0)).$unpack("C3")).$slice(0, 2))['$==']($$($nesting, 'BOM_BYTES_UTF_16LE'))) {
          
          
          $writer = [0, first.$byteslice(2, first.$bytesize())];
          $send(data, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return (function() {if ($truthy(trim_end)) {
            return $send(data, 'map', [], ($$3 = function(line){var self = $$3.$$s || this;

            
              
              if (line == null) {
                line = nil;
              };
              return line.$encode($$($nesting, 'UTF_8'), $$$($$$('::', 'Encoding'), 'UTF_16LE')).$rstrip();}, $$3.$$s = self, $$3.$$arity = 1, $$3))
          } else {
            return $send(data, 'map', [], ($$4 = function(line){var self = $$4.$$s || this;

            
              
              if (line == null) {
                line = nil;
              };
              return line.$encode($$($nesting, 'UTF_8'), $$$($$$('::', 'Encoding'), 'UTF_16LE')).$chomp();}, $$4.$$s = self, $$4.$$arity = 1, $$4))
          }; return nil; })();
        } else if (leading_2_bytes['$==']($$($nesting, 'BOM_BYTES_UTF_16BE'))) {
          
          
          $writer = [0, first.$byteslice(2, first.$bytesize())];
          $send(data, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return (function() {if ($truthy(trim_end)) {
            return $send(data, 'map', [], ($$5 = function(line){var self = $$5.$$s || this;

            
              
              if (line == null) {
                line = nil;
              };
              return line.$encode($$($nesting, 'UTF_8'), $$$($$$('::', 'Encoding'), 'UTF_16BE')).$rstrip();}, $$5.$$s = self, $$5.$$arity = 1, $$5))
          } else {
            return $send(data, 'map', [], ($$6 = function(line){var self = $$6.$$s || this;

            
              
              if (line == null) {
                line = nil;
              };
              return line.$encode($$($nesting, 'UTF_8'), $$$($$$('::', 'Encoding'), 'UTF_16BE')).$chomp();}, $$6.$$s = self, $$6.$$arity = 1, $$6))
          }; return nil; })();
        } else if (leading_bytes['$==']($$($nesting, 'BOM_BYTES_UTF_8'))) {
          
          $writer = [0, first.$byteslice(3, first.$bytesize())];
          $send(data, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        if (first.$encoding()['$==']($$($nesting, 'UTF_8'))) {
          if ($truthy(trim_end)) {
            return $send(data, 'map', [], ($$7 = function(line){var self = $$7.$$s || this;

            
              
              if (line == null) {
                line = nil;
              };
              return line.$rstrip();}, $$7.$$s = self, $$7.$$arity = 1, $$7))
          } else {
            return $send(data, 'map', [], ($$8 = function(line){var self = $$8.$$s || this;

            
              
              if (line == null) {
                line = nil;
              };
              return line.$chomp();}, $$8.$$s = self, $$8.$$arity = 1, $$8))
          }
        } else if ($truthy(trim_end)) {
          return $send(data, 'map', [], ($$9 = function(line){var self = $$9.$$s || this;

          
            
            if (line == null) {
              line = nil;
            };
            return line.$encode($$($nesting, 'UTF_8')).$rstrip();}, $$9.$$s = self, $$9.$$arity = 1, $$9))
        } else {
          return $send(data, 'map', [], ($$10 = function(line){var self = $$10.$$s || this;

          
            
            if (line == null) {
              line = nil;
            };
            return line.$encode($$($nesting, 'UTF_8')).$chomp();}, $$10.$$s = self, $$10.$$arity = 1, $$10))
        };
      }, $Helpers_prepare_source_array$2.$$arity = -2);
      
      Opal.def(self, '$prepare_source_string', $Helpers_prepare_source_string$11 = function $$prepare_source_string(data, trim_end) {
        var $$12, $$14, self = this, leading_2_bytes = nil, leading_bytes = nil;

        
        
        if (trim_end == null) {
          trim_end = true;
        };
        if ($truthy(data['$nil_or_empty?']())) {
          return []};
        if ((leading_2_bytes = (leading_bytes = data.$unpack("C3")).$slice(0, 2))['$==']($$($nesting, 'BOM_BYTES_UTF_16LE'))) {
          data = data.$byteslice(2, data.$bytesize()).$encode($$($nesting, 'UTF_8'), $$$($$$('::', 'Encoding'), 'UTF_16LE'))
        } else if (leading_2_bytes['$==']($$($nesting, 'BOM_BYTES_UTF_16BE'))) {
          data = data.$byteslice(2, data.$bytesize()).$encode($$($nesting, 'UTF_8'), $$$($$$('::', 'Encoding'), 'UTF_16BE'))
        } else if (leading_bytes['$==']($$($nesting, 'BOM_BYTES_UTF_8'))) {
          
          data = data.$byteslice(3, data.$bytesize());
          if (data.$encoding()['$==']($$($nesting, 'UTF_8'))) {
          } else {
            data = data.$encode($$($nesting, 'UTF_8'))
          };
        } else if ($truthy(data.$encoding()['$!=']($$($nesting, 'UTF_8')))) {
          data = data.$encode($$($nesting, 'UTF_8'))};
        if ($truthy(trim_end)) {
          return $send([], 'tap', [], ($$12 = function(lines){var self = $$12.$$s || this, $$13;

          
            
            if (lines == null) {
              lines = nil;
            };
            return $send(data, 'each_line', [], ($$13 = function(line){var self = $$13.$$s || this;

            
              
              if (line == null) {
                line = nil;
              };
              return lines['$<<'](line.$rstrip());}, $$13.$$s = self, $$13.$$arity = 1, $$13));}, $$12.$$s = self, $$12.$$arity = 1, $$12))
        } else {
          return $send([], 'tap', [], ($$14 = function(lines){var self = $$14.$$s || this, $$15;

          
            
            if (lines == null) {
              lines = nil;
            };
            return $send(data, 'each_line', [], ($$15 = function(line){var self = $$15.$$s || this;

            
              
              if (line == null) {
                line = nil;
              };
              return lines['$<<'](line.$chomp());}, $$15.$$s = self, $$15.$$arity = 1, $$15));}, $$14.$$s = self, $$14.$$arity = 1, $$14))
        };
      }, $Helpers_prepare_source_string$11.$$arity = -2);
      
      Opal.def(self, '$uriish?', $Helpers_uriish$ques$16 = function(str) {
        var $a, self = this;

        return ($truthy($a = str['$include?'](":")) ? $$($nesting, 'UriSniffRx')['$match?'](str) : $a)
      }, $Helpers_uriish$ques$16.$$arity = 1);
      if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
        
        Opal.def(self, '$encode_uri_component', $Helpers_encode_uri_component$17 = function $$encode_uri_component(str) {
          var self = this;

          
        return encodeURIComponent(str).replace(/%20|[!'()*]/g, function (m) {
          return m === '%20' ? '+' : '%' + m.charCodeAt(0).toString(16)
        })
      
        }, $Helpers_encode_uri_component$17.$$arity = 1)
      } else {
        nil
      };
      
      Opal.def(self, '$encode_spaces_in_uri', $Helpers_encode_spaces_in_uri$18 = function $$encode_spaces_in_uri(str) {
        var self = this;

        if ($truthy(str['$include?'](" "))) {
          
          return str.$gsub(" ", "%20");
        } else {
          return str
        }
      }, $Helpers_encode_spaces_in_uri$18.$$arity = 1);
      
      Opal.def(self, '$rootname', $Helpers_rootname$19 = function $$rootname(filename) {
        var self = this, last_dot_idx = nil;

        if ($truthy((last_dot_idx = filename.$rindex(".")))) {
          if ($truthy(filename.$index("/", last_dot_idx))) {
            return filename
          } else {
            
            return filename.$slice(0, last_dot_idx);
          }
        } else {
          return filename
        }
      }, $Helpers_rootname$19.$$arity = 1);
      
      Opal.def(self, '$basename', $Helpers_basename$20 = function $$basename(filename, drop_ext) {
        var self = this;

        
        
        if (drop_ext == null) {
          drop_ext = nil;
        };
        if ($truthy(drop_ext)) {
          return $$$('::', 'File').$basename(filename, (function() {if (drop_ext['$=='](true)) {
            
            return self.$extname(filename);
          } else {
            return drop_ext
          }; return nil; })())
        } else {
          return $$$('::', 'File').$basename(filename)
        };
      }, $Helpers_basename$20.$$arity = -2);
      
      Opal.def(self, '$extname?', $Helpers_extname$ques$21 = function(path) {
        var $a, self = this, last_dot_idx = nil;

        return ($truthy($a = (last_dot_idx = path.$rindex("."))) ? path.$index("/", last_dot_idx)['$!']() : $a)
      }, $Helpers_extname$ques$21.$$arity = 1);
      if ($truthy($$$($$$('::', 'File'), 'ALT_SEPARATOR'))) {
        
        Opal.def(self, '$extname', $Helpers_extname$22 = function $$extname(path, fallback) {
          var $a, self = this, last_dot_idx = nil;

          
          
          if (fallback == null) {
            fallback = "";
          };
          if ($truthy((last_dot_idx = path.$rindex(".")))) {
            if ($truthy(($truthy($a = path.$index("/", last_dot_idx)) ? $a : path.$index($$$($$$('::', 'File'), 'ALT_SEPARATOR'), last_dot_idx)))) {
              return fallback
            } else {
              
              return path.$slice(last_dot_idx, path.$length());
            }
          } else {
            return fallback
          };
        }, $Helpers_extname$22.$$arity = -2)
      } else {
        
        Opal.def(self, '$extname', $Helpers_extname$23 = function $$extname(path, fallback) {
          var self = this, last_dot_idx = nil;

          
          
          if (fallback == null) {
            fallback = "";
          };
          if ($truthy((last_dot_idx = path.$rindex(".")))) {
            if ($truthy(path.$index("/", last_dot_idx))) {
              return fallback
            } else {
              
              return path.$slice(last_dot_idx, path.$length());
            }
          } else {
            return fallback
          };
        }, $Helpers_extname$23.$$arity = -2)
      };
      
      Opal.def(self, '$mkdir_p', $Helpers_mkdir_p$24 = function $$mkdir_p(dir) {
        var self = this, parent_dir = nil;

        if ($truthy($$$('::', 'File')['$directory?'](dir))) {
          return nil
        } else {
          
          if ((parent_dir = $$$('::', 'File').$dirname(dir))['$=='](".")) {
          } else {
            self.$mkdir_p(parent_dir)
          };
          
          try {
            return $$$('::', 'Dir').$mkdir(dir)
          } catch ($err) {
            if (Opal.rescue($err, [$$$('::', 'SystemCallError')])) {
              try {
                if ($truthy($$$('::', 'File')['$directory?'](dir))) {
                  return nil
                } else {
                  return self.$raise()
                }
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          };;
        }
      }, $Helpers_mkdir_p$24.$$arity = 1);
      Opal.const_set($nesting[0], 'ROMAN_NUMERALS', $hash2(["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"], {"M": 1000, "CM": 900, "D": 500, "CD": 400, "C": 100, "XC": 90, "L": 50, "XL": 40, "X": 10, "IX": 9, "V": 5, "IV": 4, "I": 1}));
      self.$private_constant("ROMAN_NUMERALS");
      
      Opal.def(self, '$int_to_roman', $Helpers_int_to_roman$25 = function $$int_to_roman(val) {
        var $$26, self = this;

        return $send($$($nesting, 'ROMAN_NUMERALS'), 'map', [], ($$26 = function(l, i){var self = $$26.$$s || this, $a, $b, repeat = nil;

        
          
          if (l == null) {
            l = nil;
          };
          
          if (i == null) {
            i = nil;
          };
          $b = val.$divmod(i), $a = Opal.to_ary($b), (repeat = ($a[0] == null ? nil : $a[0])), (val = ($a[1] == null ? nil : $a[1])), $b;
          return $rb_times(l, repeat);}, $$26.$$s = self, $$26.$$arity = 2, $$26)).$join()
      }, $Helpers_int_to_roman$25.$$arity = 1);
      
      Opal.def(self, '$nextval', $Helpers_nextval$27 = function $$nextval(current) {
        var self = this, intval = nil;

        if ($truthy($$$('::', 'Integer')['$==='](current))) {
          return $rb_plus(current, 1)
        } else if ((intval = current.$to_i()).$to_s()['$=='](current.$to_s())) {
          return $rb_plus(intval, 1)
        } else {
          return current.$succ()
        }
      }, $Helpers_nextval$27.$$arity = 1);
      
      Opal.def(self, '$resolve_class', $Helpers_resolve_class$28 = function $$resolve_class(object) {
        var self = this;

        if ($truthy($$$('::', 'Class')['$==='](object))) {
          return object
        } else {
          
          if ($truthy($$$('::', 'String')['$==='](object))) {
            
            return self.$class_for_name(object);
          } else {
            return nil
          };
        }
      }, $Helpers_resolve_class$28.$$arity = 1);
      
      Opal.def(self, '$class_for_name', $Helpers_class_for_name$29 = function $$class_for_name(qualified_name) {
        var self = this, resolved = nil;

        try {
          
          if ($truthy($$$('::', 'Class')['$===']((resolved = $$$('::', 'Object').$const_get(qualified_name, false))))) {
          } else {
            self.$raise()
          };
          return resolved;
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
            try {
              return self.$raise($$$('::', 'NameError'), "" + "Could not resolve class for name: " + (qualified_name))
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        }
      }, $Helpers_class_for_name$29.$$arity = 1);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["logger"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $module = Opal.module, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$include', '$to_h', '$map', '$constants', '$const_get', '$to_s', '$format', '$chr', '$strftime', '$message_as_string', '$===', '$+', '$message', '$class', '$join', '$backtrace', '$inspect', '$attr_reader', '$attr_accessor', '$new', '$key', '$upcase', '$raise', '$add', '$to_proc', '$<=', '$<', '$write', '$call', '$[]', '$now']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Logger');

    var $nesting = [self].concat($parent_nesting), $Logger$1, $Logger_initialize$4, $Logger_level$eq$5, $Logger_info$6, $Logger_debug$7, $Logger_warn$8, $Logger_error$9, $Logger_fatal$10, $Logger_unknown$11, $Logger_info$ques$12, $Logger_debug$ques$13, $Logger_warn$ques$14, $Logger_error$ques$15, $Logger_fatal$ques$16, $Logger_add$17;

    self.$$prototype.level = self.$$prototype.progname = self.$$prototype.pipe = self.$$prototype.formatter = nil;
    
    (function($base, $parent_nesting) {
      var self = $module($base, 'Severity');

      var $nesting = [self].concat($parent_nesting);

      
      Opal.const_set($nesting[0], 'DEBUG', 0);
      Opal.const_set($nesting[0], 'INFO', 1);
      Opal.const_set($nesting[0], 'WARN', 2);
      Opal.const_set($nesting[0], 'ERROR', 3);
      Opal.const_set($nesting[0], 'FATAL', 4);
      Opal.const_set($nesting[0], 'UNKNOWN', 5);
    })($nesting[0], $nesting);
    self.$include($$($nesting, 'Severity'));
    Opal.const_set($nesting[0], 'SEVERITY_LABELS', $send($$($nesting, 'Severity').$constants(), 'map', [], ($Logger$1 = function(s){var self = $Logger$1.$$s || this;

    
      
      if (s == null) {
        s = nil;
      };
      return [$$($nesting, 'Severity').$const_get(s), s.$to_s()];}, $Logger$1.$$s = self, $Logger$1.$$arity = 1, $Logger$1)).$to_h());
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Formatter');

      var $nesting = [self].concat($parent_nesting), $Formatter_call$2, $Formatter_message_as_string$3;

      
      Opal.const_set($nesting[0], 'MESSAGE_FORMAT', "%s, [%s] %5s -- %s: %s\n");
      Opal.const_set($nesting[0], 'DATE_TIME_FORMAT', "%Y-%m-%dT%H:%M:%S.%6N");
      
      Opal.def(self, '$call', $Formatter_call$2 = function $$call(severity, time, progname, msg) {
        var self = this;

        return self.$format($$($nesting, 'MESSAGE_FORMAT'), severity.$chr(), time.$strftime($$($nesting, 'DATE_TIME_FORMAT')), severity, progname, self.$message_as_string(msg))
      }, $Formatter_call$2.$$arity = 4);
      return (Opal.def(self, '$message_as_string', $Formatter_message_as_string$3 = function $$message_as_string(msg) {
        var $a, self = this, $case = nil;

        return (function() {$case = msg;
        if ($$$('::', 'String')['$===']($case)) {return msg}
        else if ($$$('::', 'Exception')['$===']($case)) {return $rb_plus("" + (msg.$message()) + " (" + (msg.$class()) + ")\n", ($truthy($a = msg.$backtrace()) ? $a : []).$join("\n"))}
        else {return msg.$inspect()}})()
      }, $Formatter_message_as_string$3.$$arity = 1), nil) && 'message_as_string';
    })($nesting[0], null, $nesting);
    self.$attr_reader("level");
    self.$attr_accessor("progname");
    self.$attr_accessor("formatter");
    
    Opal.def(self, '$initialize', $Logger_initialize$4 = function $$initialize(pipe) {
      var self = this;

      
      self.pipe = pipe;
      self.level = $$($nesting, 'DEBUG');
      return (self.formatter = $$($nesting, 'Formatter').$new());
    }, $Logger_initialize$4.$$arity = 1);
    
    Opal.def(self, '$level=', $Logger_level$eq$5 = function(severity) {
      var self = this, level = nil;

      if ($truthy($$$('::', 'Integer')['$==='](severity))) {
        return (self.level = severity)
      } else if ($truthy((level = $$($nesting, 'SEVERITY_LABELS').$key(severity.$to_s().$upcase())))) {
        return (self.level = level)
      } else {
        return self.$raise($$($nesting, 'ArgumentError'), "" + "invalid log level: " + (severity))
      }
    }, $Logger_level$eq$5.$$arity = 1);
    
    Opal.def(self, '$info', $Logger_info$6 = function $$info(progname) {
      var $iter = $Logger_info$6.$$p, block = $iter || nil, self = this;

      if ($iter) $Logger_info$6.$$p = null;
      
      
      if ($iter) $Logger_info$6.$$p = null;;
      
      if (progname == null) {
        progname = nil;
      };
      return $send(self, 'add', [$$($nesting, 'INFO'), nil, progname], block.$to_proc());
    }, $Logger_info$6.$$arity = -1);
    
    Opal.def(self, '$debug', $Logger_debug$7 = function $$debug(progname) {
      var $iter = $Logger_debug$7.$$p, block = $iter || nil, self = this;

      if ($iter) $Logger_debug$7.$$p = null;
      
      
      if ($iter) $Logger_debug$7.$$p = null;;
      
      if (progname == null) {
        progname = nil;
      };
      return $send(self, 'add', [$$($nesting, 'DEBUG'), nil, progname], block.$to_proc());
    }, $Logger_debug$7.$$arity = -1);
    
    Opal.def(self, '$warn', $Logger_warn$8 = function $$warn(progname) {
      var $iter = $Logger_warn$8.$$p, block = $iter || nil, self = this;

      if ($iter) $Logger_warn$8.$$p = null;
      
      
      if ($iter) $Logger_warn$8.$$p = null;;
      
      if (progname == null) {
        progname = nil;
      };
      return $send(self, 'add', [$$($nesting, 'WARN'), nil, progname], block.$to_proc());
    }, $Logger_warn$8.$$arity = -1);
    
    Opal.def(self, '$error', $Logger_error$9 = function $$error(progname) {
      var $iter = $Logger_error$9.$$p, block = $iter || nil, self = this;

      if ($iter) $Logger_error$9.$$p = null;
      
      
      if ($iter) $Logger_error$9.$$p = null;;
      
      if (progname == null) {
        progname = nil;
      };
      return $send(self, 'add', [$$($nesting, 'ERROR'), nil, progname], block.$to_proc());
    }, $Logger_error$9.$$arity = -1);
    
    Opal.def(self, '$fatal', $Logger_fatal$10 = function $$fatal(progname) {
      var $iter = $Logger_fatal$10.$$p, block = $iter || nil, self = this;

      if ($iter) $Logger_fatal$10.$$p = null;
      
      
      if ($iter) $Logger_fatal$10.$$p = null;;
      
      if (progname == null) {
        progname = nil;
      };
      return $send(self, 'add', [$$($nesting, 'FATAL'), nil, progname], block.$to_proc());
    }, $Logger_fatal$10.$$arity = -1);
    
    Opal.def(self, '$unknown', $Logger_unknown$11 = function $$unknown(progname) {
      var $iter = $Logger_unknown$11.$$p, block = $iter || nil, self = this;

      if ($iter) $Logger_unknown$11.$$p = null;
      
      
      if ($iter) $Logger_unknown$11.$$p = null;;
      
      if (progname == null) {
        progname = nil;
      };
      return $send(self, 'add', [$$($nesting, 'UNKNOWN'), nil, progname], block.$to_proc());
    }, $Logger_unknown$11.$$arity = -1);
    
    Opal.def(self, '$info?', $Logger_info$ques$12 = function() {
      var self = this;

      return $rb_le(self.level, $$($nesting, 'INFO'))
    }, $Logger_info$ques$12.$$arity = 0);
    
    Opal.def(self, '$debug?', $Logger_debug$ques$13 = function() {
      var self = this;

      return $rb_le(self.level, $$($nesting, 'DEBUG'))
    }, $Logger_debug$ques$13.$$arity = 0);
    
    Opal.def(self, '$warn?', $Logger_warn$ques$14 = function() {
      var self = this;

      return $rb_le(self.level, $$($nesting, 'WARN'))
    }, $Logger_warn$ques$14.$$arity = 0);
    
    Opal.def(self, '$error?', $Logger_error$ques$15 = function() {
      var self = this;

      return $rb_le(self.level, $$($nesting, 'ERROR'))
    }, $Logger_error$ques$15.$$arity = 0);
    
    Opal.def(self, '$fatal?', $Logger_fatal$ques$16 = function() {
      var self = this;

      return $rb_le(self.level, $$($nesting, 'FATAL'))
    }, $Logger_fatal$ques$16.$$arity = 0);
    return (Opal.def(self, '$add', $Logger_add$17 = function $$add(severity, message, progname) {
      var $iter = $Logger_add$17.$$p, block = $iter || nil, $a, self = this;

      if ($iter) $Logger_add$17.$$p = null;
      
      
      if ($iter) $Logger_add$17.$$p = null;;
      
      if (message == null) {
        message = nil;
      };
      
      if (progname == null) {
        progname = nil;
      };
      if ($truthy($rb_lt((severity = ($truthy($a = severity) ? $a : $$($nesting, 'UNKNOWN'))), self.level))) {
        return true};
      progname = ($truthy($a = progname) ? $a : self.progname);
      if ($truthy(message)) {
      } else if ((block !== nil)) {
        message = Opal.yieldX(block, [])
      } else {
        
        message = progname;
        progname = self.progname;
      };
      self.pipe.$write(self.formatter.$call(($truthy($a = $$($nesting, 'SEVERITY_LABELS')['$[]'](severity)) ? $a : "ANY"), $$$('::', 'Time').$now(), progname, message));
      return true;
    }, $Logger_add$17.$$arity = -2), nil) && 'add';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/logging"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2, $gvars = Opal.gvars;

  Opal.add_stubs(['$require', '$attr_reader', '$progname=', '$-', '$new', '$formatter=', '$level=', '$>', '$[]', '$===', '$inspect', '$to_h', '$map', '$constants', '$const_get', '$<<', '$clear', '$empty?', '$max', '$attr_accessor', '$memoize_logger', '$private', '$extend', '$private_class_method', '$logger', '$merge']);
  
  self.$require("logger");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Logger');

      var $nesting = [self].concat($parent_nesting), $Logger_initialize$1, $Logger_add$2;

      self.$$prototype.max_severity = nil;
      
      self.$attr_reader("max_severity");
      
      Opal.def(self, '$initialize', $Logger_initialize$1 = function $$initialize($a) {
        var $post_args, args, $iter = $Logger_initialize$1.$$p, $yield = $iter || nil, self = this, $writer = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $Logger_initialize$1.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        $send(self, Opal.find_super_dispatcher(self, 'initialize', $Logger_initialize$1, false), $zuper, $iter);
        
        $writer = ["asciidoctor"];
        $send(self, 'progname=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = [$$($nesting, 'BasicFormatter').$new()];
        $send(self, 'formatter=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = [$$($nesting, 'WARN')];
        $send(self, 'level=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];;
      }, $Logger_initialize$1.$$arity = -1);
      
      Opal.def(self, '$add', $Logger_add$2 = function $$add(severity, message, progname) {
        var $a, $iter = $Logger_add$2.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $Logger_add$2.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        
        if (message == null) {
          message = nil;
        };
        
        if (progname == null) {
          progname = nil;
        };
        if ($truthy($rb_gt((severity = ($truthy($a = severity) ? $a : $$($nesting, 'UNKNOWN'))), (self.max_severity = ($truthy($a = self.max_severity) ? $a : severity))))) {
          self.max_severity = severity};
        return $send(self, Opal.find_super_dispatcher(self, 'add', $Logger_add$2, false), $zuper, $iter);
      }, $Logger_add$2.$$arity = -2);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'BasicFormatter');

        var $nesting = [self].concat($parent_nesting), $BasicFormatter_call$3;

        
        Opal.const_set($nesting[0], 'SEVERITY_LABEL_SUBSTITUTES', $hash2(["WARN", "FATAL"], {"WARN": "WARNING", "FATAL": "FAILED"}));
        return (Opal.def(self, '$call', $BasicFormatter_call$3 = function $$call(severity, _, progname, msg) {
          var $a, self = this;

          return "" + (progname) + ": " + (($truthy($a = $$($nesting, 'SEVERITY_LABEL_SUBSTITUTES')['$[]'](severity)) ? $a : severity)) + ": " + ((function() {if ($truthy($$$('::', 'String')['$==='](msg))) {
            return msg
          } else {
            return msg.$inspect()
          }; return nil; })()) + ($$($nesting, 'LF'))
        }, $BasicFormatter_call$3.$$arity = 4), nil) && 'call';
      })($nesting[0], $$($nesting, 'Formatter'), $nesting);
      return (function($base, $parent_nesting) {
        var self = $module($base, 'AutoFormattingMessage');

        var $nesting = [self].concat($parent_nesting), $AutoFormattingMessage_inspect$4;

        
        Opal.def(self, '$inspect', $AutoFormattingMessage_inspect$4 = function $$inspect() {
          var self = this, sloc = nil;

          if ($truthy((sloc = self['$[]']("source_location")))) {
            return "" + (sloc) + ": " + (self['$[]']("text"))
          } else {
            return self['$[]']("text")
          }
        }, $AutoFormattingMessage_inspect$4.$$arity = 0)
      })($nesting[0], $nesting);
    })($nesting[0], $$$('::', 'Logger'), $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'MemoryLogger');

      var $nesting = [self].concat($parent_nesting), $MemoryLogger$5, $MemoryLogger_initialize$6, $MemoryLogger_add$7, $MemoryLogger_clear$8, $MemoryLogger_empty$ques$9, $MemoryLogger_max_severity$10;

      self.$$prototype.messages = nil;
      
      Opal.const_set($nesting[0], 'SEVERITY_SYMBOL_BY_VALUE', $send($$($nesting, 'Severity').$constants(false), 'map', [], ($MemoryLogger$5 = function(c){var self = $MemoryLogger$5.$$s || this;

      
        
        if (c == null) {
          c = nil;
        };
        return [$$($nesting, 'Severity').$const_get(c), c];}, $MemoryLogger$5.$$s = self, $MemoryLogger$5.$$arity = 1, $MemoryLogger$5)).$to_h());
      self.$attr_reader("messages");
      
      Opal.def(self, '$initialize', $MemoryLogger_initialize$6 = function $$initialize() {
        var self = this, $writer = nil;

        
        
        $writer = [$$($nesting, 'WARN')];
        $send(self, 'level=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        return (self.messages = []);
      }, $MemoryLogger_initialize$6.$$arity = 0);
      
      Opal.def(self, '$add', $MemoryLogger_add$7 = function $$add(severity, message, progname) {
        var $a, $iter = $MemoryLogger_add$7.$$p, $yield = $iter || nil, self = this;

        if ($iter) $MemoryLogger_add$7.$$p = null;
        
        
        if (message == null) {
          message = nil;
        };
        
        if (progname == null) {
          progname = nil;
        };
        message = ($truthy($a = message) ? $a : (function() {if (($yield !== nil)) {
          return Opal.yieldX($yield, []);
        } else {
          return progname
        }; return nil; })());
        self.messages['$<<']($hash2(["severity", "message"], {"severity": $$($nesting, 'SEVERITY_SYMBOL_BY_VALUE')['$[]'](($truthy($a = severity) ? $a : $$($nesting, 'UNKNOWN'))), "message": message}));
        return true;
      }, $MemoryLogger_add$7.$$arity = -2);
      
      Opal.def(self, '$clear', $MemoryLogger_clear$8 = function $$clear() {
        var self = this;

        return self.messages.$clear()
      }, $MemoryLogger_clear$8.$$arity = 0);
      
      Opal.def(self, '$empty?', $MemoryLogger_empty$ques$9 = function() {
        var self = this;

        return self.messages['$empty?']()
      }, $MemoryLogger_empty$ques$9.$$arity = 0);
      return (Opal.def(self, '$max_severity', $MemoryLogger_max_severity$10 = function $$max_severity() {
        var $$11, self = this;

        if ($truthy(self['$empty?']())) {
          return nil
        } else {
          return $send(self.messages, 'map', [], ($$11 = function(m){var self = $$11.$$s || this;

          
            
            if (m == null) {
              m = nil;
            };
            return $$($nesting, 'Severity').$const_get(m['$[]']("severity"));}, $$11.$$s = self, $$11.$$arity = 1, $$11)).$max()
        }
      }, $MemoryLogger_max_severity$10.$$arity = 0), nil) && 'max_severity';
    })($nesting[0], $$$('::', 'Logger'), $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'NullLogger');

      var $nesting = [self].concat($parent_nesting), $NullLogger_initialize$12, $NullLogger_add$13;

      self.$$prototype.max_severity = nil;
      
      self.$attr_reader("max_severity");
      
      Opal.def(self, '$initialize', $NullLogger_initialize$12 = function $$initialize() {
        var self = this, $writer = nil;

        
        $writer = [$$($nesting, 'WARN')];
        $send(self, 'level=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];
      }, $NullLogger_initialize$12.$$arity = 0);
      return (Opal.def(self, '$add', $NullLogger_add$13 = function $$add(severity, message, progname) {
        var $a, self = this;

        
        
        if (message == null) {
          message = nil;
        };
        
        if (progname == null) {
          progname = nil;
        };
        if ($truthy($rb_gt((severity = ($truthy($a = severity) ? $a : $$($nesting, 'UNKNOWN'))), (self.max_severity = ($truthy($a = self.max_severity) ? $a : severity))))) {
          self.max_severity = severity};
        return true;
      }, $NullLogger_add$13.$$arity = -2), nil) && 'add';
    })($nesting[0], $$$('::', 'Logger'), $nesting);
    (function($base, $parent_nesting) {
      var self = $module($base, 'LoggerManager');

      var $nesting = [self].concat($parent_nesting);

      
      self.logger_class = $$($nesting, 'Logger');
      (function(self, $parent_nesting) {
        var $nesting = [self].concat($parent_nesting), $logger$14, $logger$eq$15, $memoize_logger$16;

        
        self.$attr_accessor("logger_class");
        
        Opal.def(self, '$logger', $logger$14 = function $$logger(pipe) {
          var $a, self = this;
          if (self.logger == null) self.logger = nil;
          if (self.logger_class == null) self.logger_class = nil;
          if ($gvars.stderr == null) $gvars.stderr = nil;

          
          
          if (pipe == null) {
            pipe = $gvars.stderr;
          };
          self.$memoize_logger();
          return (self.logger = ($truthy($a = self.logger) ? $a : self.logger_class.$new(pipe)));
        }, $logger$14.$$arity = -1);
        
        Opal.def(self, '$logger=', $logger$eq$15 = function(new_logger) {
          var $a, self = this;
          if (self.logger_class == null) self.logger_class = nil;
          if ($gvars.stderr == null) $gvars.stderr = nil;

          return (self.logger = ($truthy($a = new_logger) ? $a : self.logger_class.$new($gvars.stderr)))
        }, $logger$eq$15.$$arity = 1);
        self.$private();
        return (Opal.def(self, '$memoize_logger', $memoize_logger$16 = function $$memoize_logger() {
          var self = this;

          return (function(self, $parent_nesting) {
            var $nesting = [self].concat($parent_nesting);

            
            Opal.alias(self, "logger", "logger");
            return self.$attr_reader("logger");
          })(Opal.get_singleton_class(self), $nesting)
        }, $memoize_logger$16.$$arity = 0), nil) && 'memoize_logger';
      })(Opal.get_singleton_class(self), $nesting);
    })($nesting[0], $nesting);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Logging');

      var $nesting = [self].concat($parent_nesting), $Logging_included$17, $Logging_logger$18, $Logging_message_with_context$19;

      
      Opal.defs(self, '$included', $Logging_included$17 = function $$included(into) {
        var self = this;

        return into.$extend($$($nesting, 'Logging'))
      }, $Logging_included$17.$$arity = 1);
      self.$private_class_method("included");
      
      Opal.def(self, '$logger', $Logging_logger$18 = function $$logger() {
        var self = this;

        return $$($nesting, 'LoggerManager').$logger()
      }, $Logging_logger$18.$$arity = 0);
      
      Opal.def(self, '$message_with_context', $Logging_message_with_context$19 = function $$message_with_context(text, context) {
        var self = this;

        
        
        if (context == null) {
          context = $hash2([], {});
        };
        return $hash2(["text"], {"text": text}).$merge(context).$extend($$$($$($nesting, 'Logger'), 'AutoFormattingMessage'));
      }, $Logging_message_with_context$19.$$arity = -2);
    })($nesting[0], $nesting);
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/rx"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy, $hash = Opal.hash;

  Opal.add_stubs(['$==', '$join', '$to_a', '$new', '$empty?', '$escape', '$[]=', '$-']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting), $Asciidoctor$1, $Asciidoctor$2;

    
    (function($base, $parent_nesting) {
      var self = $module($base, 'Rx');

      var $nesting = [self].concat($parent_nesting);

      nil
    })($nesting[0], $nesting);
    Opal.const_set($nesting[0], 'AuthorInfoLineRx', new RegExp("" + "^(" + ($$($nesting, 'CG_WORD')) + "[" + ($$($nesting, 'CC_WORD')) + "\\-'.]*)(?: +(" + ($$($nesting, 'CG_WORD')) + "[" + ($$($nesting, 'CC_WORD')) + "\\-'.]*))?(?: +(" + ($$($nesting, 'CG_WORD')) + "[" + ($$($nesting, 'CC_WORD')) + "\\-'.]*))?(?: +<([^>]+)>)?$"));
    Opal.const_set($nesting[0], 'AuthorDelimiterRx', /;(?: |$)/);
    Opal.const_set($nesting[0], 'RevisionInfoLineRx', new RegExp("" + "^(?:[^\\d{]*(" + ($$($nesting, 'CC_ANY')) + "*?),)? *(?!:)(" + ($$($nesting, 'CC_ANY')) + "*?)(?: *(?!^),?: *(" + ($$($nesting, 'CC_ANY')) + "*))?$"));
    Opal.const_set($nesting[0], 'ManpageTitleVolnumRx', new RegExp("" + "^(" + ($$($nesting, 'CC_ANY')) + "+?) *\\( *(" + ($$($nesting, 'CC_ANY')) + "+?) *\\)$"));
    Opal.const_set($nesting[0], 'ManpageNamePurposeRx', new RegExp("" + "^(" + ($$($nesting, 'CC_ANY')) + "+?) +- +(" + ($$($nesting, 'CC_ANY')) + "+)$"));
    Opal.const_set($nesting[0], 'ConditionalDirectiveRx', new RegExp("" + "^(\\\\)?(ifdef|ifndef|ifeval|endif)::(\\S*?(?:([,+])\\S*?)?)\\[(" + ($$($nesting, 'CC_ANY')) + "+)?\\]$"));
    Opal.const_set($nesting[0], 'EvalExpressionRx', new RegExp("" + "^(" + ($$($nesting, 'CC_ANY')) + "+?) *([=!><]=|[><]) *(" + ($$($nesting, 'CC_ANY')) + "+)$"));
    Opal.const_set($nesting[0], 'IncludeDirectiveRx', new RegExp("" + "^(\\\\)?include::([^\\[][^\\[]*)\\[(" + ($$($nesting, 'CC_ANY')) + "+)?\\]$"));
    Opal.const_set($nesting[0], 'TagDirectiveRx', /\b(?:tag|(e)nd)::(\S+?)\[\](?=$|[ \r])/m);
    Opal.const_set($nesting[0], 'AttributeEntryRx', new RegExp("" + "^:(!?" + ($$($nesting, 'CG_WORD')) + "[^:]*):(?:[ \\t]+(" + ($$($nesting, 'CC_ANY')) + "*))?$"));
    Opal.const_set($nesting[0], 'InvalidAttributeNameCharsRx', new RegExp("" + "[^" + ($$($nesting, 'CC_WORD')) + "-]"));
    if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
      Opal.const_set($nesting[0], 'AttributeEntryPassMacroRx', new RegExp("" + "^pass:([a-z]+(?:,[a-z-]+)*)?\\[(" + ($$($nesting, 'CC_ALL')) + "*)\\]$"))
    } else {
      nil
    };
    Opal.const_set($nesting[0], 'AttributeReferenceRx', new RegExp("" + "(\\\\)?\\{(" + ($$($nesting, 'CG_WORD')) + "[" + ($$($nesting, 'CC_WORD')) + "-]*|(set|counter2?):" + ($$($nesting, 'CC_ANY')) + "+?)(\\\\)?\\}"));
    Opal.const_set($nesting[0], 'BlockAnchorRx', new RegExp("" + "^\\[\\[(?:|([" + ($$($nesting, 'CC_ALPHA')) + "_:][" + ($$($nesting, 'CC_WORD')) + "\\-:.]*)(?:, *(" + ($$($nesting, 'CC_ANY')) + "+))?)\\]\\]$"));
    Opal.const_set($nesting[0], 'BlockAttributeListRx', new RegExp("" + "^\\[(|[" + ($$($nesting, 'CC_WORD')) + ".#%{,\"']" + ($$($nesting, 'CC_ANY')) + "*)\\]$"));
    Opal.const_set($nesting[0], 'BlockAttributeLineRx', new RegExp("" + "^\\[(?:|[" + ($$($nesting, 'CC_WORD')) + ".#%{,\"']" + ($$($nesting, 'CC_ANY')) + "*|\\[(?:|[" + ($$($nesting, 'CC_ALPHA')) + "_:][" + ($$($nesting, 'CC_WORD')) + "\\-:.]*(?:, *" + ($$($nesting, 'CC_ANY')) + "+)?)\\])\\]$"));
    Opal.const_set($nesting[0], 'BlockTitleRx', new RegExp("" + "^\\.(\\.?[^ \\t.]" + ($$($nesting, 'CC_ANY')) + "*)$"));
    Opal.const_set($nesting[0], 'AdmonitionParagraphRx', new RegExp("" + "^(" + ($$($nesting, 'ADMONITION_STYLES').$to_a().$join("|")) + "):[ \\t]+"));
    Opal.const_set($nesting[0], 'LiteralParagraphRx', new RegExp("" + "^([ \\t]+" + ($$($nesting, 'CC_ANY')) + "*)$"));
    Opal.const_set($nesting[0], 'AtxSectionTitleRx', new RegExp("" + "^(=={0,5})[ \\t]+(" + ($$($nesting, 'CC_ANY')) + "+?)(?:[ \\t]+\\1)?$"));
    Opal.const_set($nesting[0], 'ExtAtxSectionTitleRx', new RegExp("" + "^(=={0,5}|#\\\#{0,5})[ \\t]+(" + ($$($nesting, 'CC_ANY')) + "+?)(?:[ \\t]+\\1)?$"));
    Opal.const_set($nesting[0], 'SetextSectionTitleRx', new RegExp("" + "^((?!\\.)" + ($$($nesting, 'CC_ANY')) + "*?" + ($$($nesting, 'CG_ALNUM')) + ($$($nesting, 'CC_ANY')) + "*)$"));
    Opal.const_set($nesting[0], 'InlineSectionAnchorRx', new RegExp("" + " (\\\\)?\\[\\[([" + ($$($nesting, 'CC_ALPHA')) + "_:][" + ($$($nesting, 'CC_WORD')) + "\\-:.]*)(?:, *(" + ($$($nesting, 'CC_ANY')) + "+))?\\]\\]$"));
    Opal.const_set($nesting[0], 'InvalidSectionIdCharsRx', new RegExp("" + "<[^>]+>|&(?:[a-z][a-z]+\\d{0,2}|#\\d\\d\\d{0,4}|#x[\\da-f][\\da-f][\\da-f]{0,3});|[^ " + ($$($nesting, 'CC_WORD')) + "\\-.]+?"));
    Opal.const_set($nesting[0], 'SectionLevelStyleRx', /^sect\d$/);
    Opal.const_set($nesting[0], 'AnyListRx', new RegExp("" + "^(?:[ \\t]*(?:-|\\*\\**|\\.\\.*|\\u2022|\\d+\\.|[a-zA-Z]\\.|[IVXivx]+\\))[ \\t]|(?!//[^/])[ \\t]*[^ \\t]" + ($$($nesting, 'CC_ANY')) + "*?(?::::{0,2}|;;)(?:$|[ \\t])|<(?:\\d+|\\.)>[ \\t])"));
    Opal.const_set($nesting[0], 'UnorderedListRx', new RegExp("" + "^[ \\t]*(-|\\*\\**|\\u2022)[ \\t]+(" + ($$($nesting, 'CC_ANY')) + "*)$"));
    Opal.const_set($nesting[0], 'OrderedListRx', new RegExp("" + "^[ \\t]*(\\.\\.*|\\d+\\.|[a-zA-Z]\\.|[IVXivx]+\\))[ \\t]+(" + ($$($nesting, 'CC_ANY')) + "*)$"));
    Opal.const_set($nesting[0], 'OrderedListMarkerRxMap', $hash2(["arabic", "loweralpha", "lowerroman", "upperalpha", "upperroman"], {"arabic": /\d+\./, "loweralpha": /[a-z]\./, "lowerroman": /[ivx]+\)/, "upperalpha": /[A-Z]\./, "upperroman": /[IVX]+\)/}));
    Opal.const_set($nesting[0], 'DescriptionListRx', new RegExp("" + "^(?!//[^/])[ \\t]*([^ \\t]" + ($$($nesting, 'CC_ANY')) + "*?)(:::{0,2}|;;)(?:$|[ \\t]+(" + ($$($nesting, 'CC_ANY')) + "*)$)"));
    Opal.const_set($nesting[0], 'DescriptionListSiblingRx', $hash2(["::", ":::", "::::", ";;"], {"::": new RegExp("" + "^(?!//[^/])[ \\t]*([^ \\t]" + ($$($nesting, 'CC_ANY')) + "*?[^:]|[^ \\t:])(::)(?:$|[ \\t]+(" + ($$($nesting, 'CC_ANY')) + "*)$)"), ":::": new RegExp("" + "^(?!//[^/])[ \\t]*([^ \\t]" + ($$($nesting, 'CC_ANY')) + "*?[^:]|[^ \\t:])(:::)(?:$|[ \\t]+(" + ($$($nesting, 'CC_ANY')) + "*)$)"), "::::": new RegExp("" + "^(?!//[^/])[ \\t]*([^ \\t]" + ($$($nesting, 'CC_ANY')) + "*?[^:]|[^ \\t:])(::::)(?:$|[ \\t]+(" + ($$($nesting, 'CC_ANY')) + "*)$)"), ";;": new RegExp("" + "^(?!//[^/])[ \\t]*([^ \\t]" + ($$($nesting, 'CC_ANY')) + "*?)(;;)(?:$|[ \\t]+(" + ($$($nesting, 'CC_ANY')) + "*)$)")}));
    Opal.const_set($nesting[0], 'CalloutListRx', new RegExp("" + "^<(\\d+|\\.)>[ \\t]+(" + ($$($nesting, 'CC_ANY')) + "*)$"));
    Opal.const_set($nesting[0], 'CalloutExtractRx', /((?:\/\/|#|--|;;) ?)?(\\)?<!?(|--)(\d+|\.)\3>(?=(?: ?\\?<!?\3(?:\d+|\.)\3>)*$)/);
    Opal.const_set($nesting[0], 'CalloutExtractRxt', "(\\\\)?<()(\\d+|\\.)>(?=(?: ?\\\\?<(?:\\d+|\\.)>)*$)");
    Opal.const_set($nesting[0], 'CalloutExtractRxMap', $send($$$('::', 'Hash'), 'new', [], ($Asciidoctor$1 = function(h, k){var self = $Asciidoctor$1.$$s || this, $writer = nil;

    
      
      if (h == null) {
        h = nil;
      };
      
      if (k == null) {
        k = nil;
      };
      $writer = [k, new RegExp("" + "(" + ((function() {if ($truthy(k['$empty?']())) {
        return ""
      } else {
        return "" + ($$$('::', 'Regexp').$escape(k)) + " ?"
      }; return nil; })()) + ")?" + ($$($nesting, 'CalloutExtractRxt')))];
      $send(h, '[]=', Opal.to_a($writer));
      return $writer[$rb_minus($writer["length"], 1)];}, $Asciidoctor$1.$$s = self, $Asciidoctor$1.$$arity = 2, $Asciidoctor$1)));
    Opal.const_set($nesting[0], 'CalloutScanRx', new RegExp("" + "\\\\?<!?(|--)(\\d+|\\.)\\1>(?=(?: ?\\\\?<!?\\1(?:\\d+|\\.)\\1>)*" + ($$($nesting, 'CC_EOL')) + ")"));
    Opal.const_set($nesting[0], 'CalloutSourceRx', new RegExp("" + "((?://|#|--|;;) ?)?(\\\\)?&lt;!?(|--)(\\d+|\\.)\\3&gt;(?=(?: ?\\\\?&lt;!?\\3(?:\\d+|\\.)\\3&gt;)*" + ($$($nesting, 'CC_EOL')) + ")"));
    Opal.const_set($nesting[0], 'CalloutSourceRxt', "" + "(\\\\)?&lt;()(\\d+|\\.)&gt;(?=(?: ?\\\\?&lt;(?:\\d+|\\.)&gt;)*" + ($$($nesting, 'CC_EOL')) + ")");
    Opal.const_set($nesting[0], 'CalloutSourceRxMap', $send($$$('::', 'Hash'), 'new', [], ($Asciidoctor$2 = function(h, k){var self = $Asciidoctor$2.$$s || this, $writer = nil;

    
      
      if (h == null) {
        h = nil;
      };
      
      if (k == null) {
        k = nil;
      };
      $writer = [k, new RegExp("" + "(" + ((function() {if ($truthy(k['$empty?']())) {
        return ""
      } else {
        return "" + ($$$('::', 'Regexp').$escape(k)) + " ?"
      }; return nil; })()) + ")?" + ($$($nesting, 'CalloutSourceRxt')))];
      $send(h, '[]=', Opal.to_a($writer));
      return $writer[$rb_minus($writer["length"], 1)];}, $Asciidoctor$2.$$s = self, $Asciidoctor$2.$$arity = 2, $Asciidoctor$2)));
    Opal.const_set($nesting[0], 'ListRxMap', $hash2(["ulist", "olist", "dlist", "colist"], {"ulist": $$($nesting, 'UnorderedListRx'), "olist": $$($nesting, 'OrderedListRx'), "dlist": $$($nesting, 'DescriptionListRx'), "colist": $$($nesting, 'CalloutListRx')}));
    Opal.const_set($nesting[0], 'ColumnSpecRx', /^(?:(\d+)\*)?([<^>](?:\.[<^>]?)?|(?:[<^>]?\.)?[<^>])?(\d+%?|~)?([a-z])?$/);
    Opal.const_set($nesting[0], 'CellSpecStartRx', /^[ \t]*(?:(\d+(?:\.\d*)?|(?:\d*\.)?\d+)([*+]))?([<^>](?:\.[<^>]?)?|(?:[<^>]?\.)?[<^>])?([a-z])?$/);
    Opal.const_set($nesting[0], 'CellSpecEndRx', /[ \t]+(?:(\d+(?:\.\d*)?|(?:\d*\.)?\d+)([*+]))?([<^>](?:\.[<^>]?)?|(?:[<^>]?\.)?[<^>])?([a-z])?$/);
    Opal.const_set($nesting[0], 'CustomBlockMacroRx', new RegExp("" + "^(" + ($$($nesting, 'CG_WORD')) + "[" + ($$($nesting, 'CC_WORD')) + "-]*)::(|\\S|\\S" + ($$($nesting, 'CC_ANY')) + "*?\\S)\\[(" + ($$($nesting, 'CC_ANY')) + "+)?\\]$"));
    Opal.const_set($nesting[0], 'BlockMediaMacroRx', new RegExp("" + "^(image|video|audio)::(\\S|\\S" + ($$($nesting, 'CC_ANY')) + "*?\\S)\\[(" + ($$($nesting, 'CC_ANY')) + "+)?\\]$"));
    Opal.const_set($nesting[0], 'BlockTocMacroRx', new RegExp("" + "^toc::\\[(" + ($$($nesting, 'CC_ANY')) + "+)?\\]$"));
    Opal.const_set($nesting[0], 'InlineAnchorRx', new RegExp("" + "(\\\\)?(?:\\[\\[([" + ($$($nesting, 'CC_ALPHA')) + "_:][" + ($$($nesting, 'CC_WORD')) + "\\-:.]*)(?:, *(" + ($$($nesting, 'CC_ANY')) + "+?))?\\]\\]|anchor:([" + ($$($nesting, 'CC_ALPHA')) + "_:][" + ($$($nesting, 'CC_WORD')) + "\\-:.]*)\\[(?:\\]|(" + ($$($nesting, 'CC_ANY')) + "*?[^\\\\])\\]))"));
    Opal.const_set($nesting[0], 'InlineAnchorScanRx', new RegExp("" + "(?:^|[^\\\\\\[])\\[\\[([" + ($$($nesting, 'CC_ALPHA')) + "_:][" + ($$($nesting, 'CC_WORD')) + "\\-:.]*)(?:, *(" + ($$($nesting, 'CC_ANY')) + "+?))?\\]\\]|(?:^|[^\\\\])anchor:([" + ($$($nesting, 'CC_ALPHA')) + "_:][" + ($$($nesting, 'CC_WORD')) + "\\-:.]*)\\[(?:\\]|(" + ($$($nesting, 'CC_ANY')) + "*?[^\\\\])\\])"));
    Opal.const_set($nesting[0], 'LeadingInlineAnchorRx', new RegExp("" + "^\\[\\[([" + ($$($nesting, 'CC_ALPHA')) + "_:][" + ($$($nesting, 'CC_WORD')) + "\\-:.]*)(?:, *(" + ($$($nesting, 'CC_ANY')) + "+?))?\\]\\]"));
    Opal.const_set($nesting[0], 'InlineBiblioAnchorRx', new RegExp("" + "^\\[\\[\\[([" + ($$($nesting, 'CC_ALPHA')) + "_:][" + ($$($nesting, 'CC_WORD')) + "\\-:.]*)(?:, *(" + ($$($nesting, 'CC_ANY')) + "+?))?\\]\\]\\]"));
    Opal.const_set($nesting[0], 'InlineEmailRx', new RegExp("" + "([\\\\>:/])?" + ($$($nesting, 'CG_WORD')) + "(?:&amp;|[" + ($$($nesting, 'CC_WORD')) + "\\-.%+])*@" + ($$($nesting, 'CG_ALNUM')) + "[" + ($$($nesting, 'CC_ALNUM')) + "_\\-.]*\\.[a-zA-Z]{2,5}\\b"));
    Opal.const_set($nesting[0], 'InlineFootnoteMacroRx', new RegExp("" + "\\\\?footnote(?:(ref):|:([" + ($$($nesting, 'CC_WORD')) + "-]+)?)\\[(?:|(" + ($$($nesting, 'CC_ALL')) + "*?[^\\\\]))\\](?!</a>)", 'm'));
    Opal.const_set($nesting[0], 'InlineImageMacroRx', new RegExp("" + "\\\\?i(?:mage|con):([^:\\s\\[](?:[^\\n\\[]*[^\\s\\[])?)\\[(|" + ($$($nesting, 'CC_ALL')) + "*?[^\\\\])\\]", 'm'));
    Opal.const_set($nesting[0], 'InlineIndextermMacroRx', new RegExp("" + "\\\\?(?:(indexterm2?):\\[(" + ($$($nesting, 'CC_ALL')) + "*?[^\\\\])\\]|\\(\\((" + ($$($nesting, 'CC_ALL')) + "+?)\\)\\)(?!\\)))", 'm'));
    Opal.const_set($nesting[0], 'InlineKbdBtnMacroRx', new RegExp("" + "(\\\\)?(kbd|btn):\\[(" + ($$($nesting, 'CC_ALL')) + "*?[^\\\\])\\]", 'm'));
    Opal.const_set($nesting[0], 'InlineLinkRx', new RegExp("" + "(^|link:|" + ($$($nesting, 'CG_BLANK')) + "|&lt;|[>\\(\\)\\[\\];\"'])(\\\\?(?:https?|file|ftp|irc)://[^\\s\\[\\]<]*([^\\s.,\\[\\]<]))(?:\\[(|" + ($$($nesting, 'CC_ALL')) + "*?[^\\\\])\\])?", 'm'));
    Opal.const_set($nesting[0], 'InlineLinkMacroRx', new RegExp("" + "\\\\?(?:link|(mailto)):(|[^:\\s\\[][^\\s\\[]*)\\[(|" + ($$($nesting, 'CC_ALL')) + "*?[^\\\\])\\]", 'm'));
    Opal.const_set($nesting[0], 'MacroNameRx', new RegExp("" + "^" + ($$($nesting, 'CG_WORD')) + "[" + ($$($nesting, 'CC_WORD')) + "-]*$"));
    Opal.const_set($nesting[0], 'InlineStemMacroRx', new RegExp("" + "\\\\?(stem|(?:latex|ascii)math):([a-z]+(?:,[a-z-]+)*)?\\[(" + ($$($nesting, 'CC_ALL')) + "*?[^\\\\])\\]", 'm'));
    Opal.const_set($nesting[0], 'InlineMenuMacroRx', new RegExp("" + "\\\\?menu:(" + ($$($nesting, 'CG_WORD')) + "|[" + ($$($nesting, 'CC_WORD')) + "&][^\\n\\[]*[^\\s\\[])\\[ *(?:|(" + ($$($nesting, 'CC_ALL')) + "*?[^\\\\]))\\]", 'm'));
    Opal.const_set($nesting[0], 'InlineMenuRx', new RegExp("" + "\\\\?\"([" + ($$($nesting, 'CC_WORD')) + "&][^\"]*?[ \\n]+&gt;[ \\n]+[^\"]*)\""));
    Opal.const_set($nesting[0], 'InlinePassRx', $hash(false, ["+", "`", new RegExp("" + "(^|[^" + ($$($nesting, 'CC_WORD')) + ";:])(?:\\[([^\\]]+)\\])?(\\\\?(\\+|`)(\\S|\\S" + ($$($nesting, 'CC_ALL')) + "*?\\S)\\4)(?!" + ($$($nesting, 'CG_WORD')) + ")", 'm')], true, ["`", nil, new RegExp("" + "(^|[^`" + ($$($nesting, 'CC_WORD')) + "])(?:\\[([^\\]]+)\\])?(\\\\?(`)([^`\\s]|[^`\\s]" + ($$($nesting, 'CC_ALL')) + "*?\\S)\\4)(?![`" + ($$($nesting, 'CC_WORD')) + "])", 'm')]));
    Opal.const_set($nesting[0], 'SinglePlusInlinePassRx', new RegExp("" + "^(\\\\)?\\+(\\S|\\S" + ($$($nesting, 'CC_ALL')) + "*?\\S)\\+$", 'm'));
    Opal.const_set($nesting[0], 'InlinePassMacroRx', new RegExp("" + "(?:(?:(\\\\?)\\[([^\\]]+)\\])?(\\\\{0,2})(\\+\\+\\+?|\\$\\$)(" + ($$($nesting, 'CC_ALL')) + "*?)\\4|(\\\\?)pass:([a-z]+(?:,[a-z-]+)*)?\\[(|" + ($$($nesting, 'CC_ALL')) + "*?[^\\\\])\\])", 'm'));
    Opal.const_set($nesting[0], 'InlineXrefMacroRx', new RegExp("" + "\\\\?(?:&lt;&lt;([" + ($$($nesting, 'CC_WORD')) + "#/.:{]" + ($$($nesting, 'CC_ALL')) + "*?)&gt;&gt;|xref:([" + ($$($nesting, 'CC_WORD')) + "#/.:{]" + ($$($nesting, 'CC_ALL')) + "*?)\\[(?:\\]|(" + ($$($nesting, 'CC_ALL')) + "*?[^\\\\])\\]))", 'm'));
    if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
      Opal.const_set($nesting[0], 'HardLineBreakRx', new RegExp("" + "^(" + ($$($nesting, 'CC_ANY')) + "*) \\+$", 'm'))
    } else {
      nil
    };
    Opal.const_set($nesting[0], 'MarkdownThematicBreakRx', /^ {0,3}([-*_])( *)\1\2\1$/);
    Opal.const_set($nesting[0], 'ExtLayoutBreakRx', /^(?:'{3,}|<{3,}|([-*_])( *)\1\2\1)$/);
    Opal.const_set($nesting[0], 'BlankLineRx', /\n{2,}/);
    Opal.const_set($nesting[0], 'EscapedSpaceRx', /\\([ \t\n])/);
    Opal.const_set($nesting[0], 'ReplaceableTextRx', /[&']|--|\.\.\.|\([CRT]M?\)/);
    Opal.const_set($nesting[0], 'SpaceDelimiterRx', /([^\\])[ \t\n]+/);
    Opal.const_set($nesting[0], 'SubModifierSniffRx', /[+-]/);
    Opal.const_set($nesting[0], 'TrailingDigitsRx', /\d+$/);
    Opal.const_set($nesting[0], 'UriSniffRx', new RegExp("" + "^" + ($$($nesting, 'CG_ALPHA')) + "[" + ($$($nesting, 'CC_ALNUM')) + ".+-]+:/{0,2}"));
    Opal.const_set($nesting[0], 'XmlSanitizeRx', /<[^>]+>/);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/substitutors"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2, $hash = Opal.hash, $truthy = Opal.truthy, $send = Opal.send, $gvars = Opal.gvars;

  Opal.add_stubs(['$freeze', '$+', '$keys', '$empty?', '$!', '$===', '$[]', '$join', '$include?', '$extract_passthroughs', '$each', '$sub_specialchars', '$sub_quotes', '$sub_attributes', '$sub_replacements', '$sub_macros', '$highlight_source', '$sub_callouts', '$sub_post_replacements', '$warn', '$logger', '$restore_passthroughs', '$clear', '$split', '$apply_subs', '$==', '$gsub', '$match?', '$compat_mode', '$convert_quoted_text', '$attributes', '$shift', '$store_attribute', '$!=', '$attribute_undefined', '$counter', '$key?', '$downcase', '$attribute_missing', '$info', '$squeeze', '$delete', '$reject', '$start_with?', '$do_replacement', '$extensions', '$inline_macros?', '$inline_macros', '$regexp', '$instance', '$slice', '$length', '$names', '$config', '$merge', '$[]=', '$-', '$normalize_text', '$parse_attributes', '$process_method', '$expand_subs', '$text', '$text=', '$convert', '$class', '$strip', '$>', '$index', '$min', '$compact', '$end_with?', '$map', '$chop', '$new', '$pop', '$rstrip', '$register', '$tr', '$basename', '$parse', '$lstrip', '$split_simple_csv', '$partition', '$extract_attributes_from_text', '$sub', '$encode_uri_component', '$style', '$extname?', '$rindex', '$info?', '$catalog', '$fetch', '$outfilesuffix', '$natural_xrefs', '$resolve_id', '$find', '$footnotes', '$id', '$<', '$size', '$<<', '$attr?', '$attr', '$to_s', '$read_next_id', '$callouts', '$syntax_highlighter', '$highlight?', '$sub_source', '$extract_callouts', '$name', '$to_sym', '$to_i', '$resolve_lines_to_highlight', '$highlight', '$nil_or_empty?', '$restore_callouts', '$count', '$to_a', '$|', '$sort', '$*', '$parse_quoted_text_attributes', '$resolve_pass_subs', '$extract_inner_passthrough', '$basebackend?', '$error', '$chr', '$drop', '$&', '$resolve_subs', '$resolve_block_subs', '$parse_into', '$private', '$=~', '$shorthand_property_syntax', '$each_char']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Substitutors');

      var $nesting = [self].concat($parent_nesting), $Substitutors_apply_subs$1, $Substitutors_apply_normal_subs$3, $Substitutors_apply_header_subs$4, $Substitutors_apply_reftext_subs$5, $Substitutors_sub_specialchars$6, $Substitutors_sub_quotes$7, $Substitutors_sub_attributes$10, $Substitutors_sub_replacements$16, $Substitutors_sub_macros$19, $Substitutors_sub_post_replacements$42, $Substitutors_sub_source$45, $Substitutors_sub_callouts$46, $Substitutors_highlight_source$48, $Substitutors_resolve_lines_to_highlight$49, $Substitutors_extract_passthroughs$52, $Substitutors_restore_passthroughs$56, $Substitutors_resolve_subs$58, $Substitutors_resolve_block_subs$60, $Substitutors_resolve_pass_subs$61, $Substitutors_expand_subs$62, $Substitutors_commit_subs$64, $Substitutors_parse_attributes$65, $Substitutors_extract_attributes_from_text$66, $Substitutors_extract_callouts$67, $Substitutors_restore_callouts$70, $Substitutors_extract_inner_passthrough$73, $Substitutors_convert_quoted_text$74, $Substitutors_do_replacement$75, $Substitutors_parse_quoted_text_attributes$76, $Substitutors_normalize_text$77, $Substitutors_split_simple_csv$78;

      
      Opal.const_set($nesting[0], 'SpecialCharsRx', /[<&>]/);
      Opal.const_set($nesting[0], 'SpecialCharsTr', $hash2([">", "<", "&"], {">": "&gt;", "<": "&lt;", "&": "&amp;"}));
      Opal.const_set($nesting[0], 'QuotedTextSniffRx', $hash(false, /[*_`#^~]/, true, /[*'_+#^~]/));
      Opal.const_set($nesting[0], 'BASIC_SUBS', ["specialcharacters"]).$freeze();
      Opal.const_set($nesting[0], 'HEADER_SUBS', ["specialcharacters", "attributes"]).$freeze();
      Opal.const_set($nesting[0], 'NO_SUBS', []).$freeze();
      Opal.const_set($nesting[0], 'NORMAL_SUBS', ["specialcharacters", "quotes", "attributes", "replacements", "macros", "post_replacements"]).$freeze();
      Opal.const_set($nesting[0], 'REFTEXT_SUBS', ["specialcharacters", "quotes", "replacements"]).$freeze();
      Opal.const_set($nesting[0], 'VERBATIM_SUBS', ["specialcharacters", "callouts"]).$freeze();
      Opal.const_set($nesting[0], 'SUB_GROUPS', $hash2(["none", "normal", "verbatim", "specialchars"], {"none": $$($nesting, 'NO_SUBS'), "normal": $$($nesting, 'NORMAL_SUBS'), "verbatim": $$($nesting, 'VERBATIM_SUBS'), "specialchars": $$($nesting, 'BASIC_SUBS')}));
      Opal.const_set($nesting[0], 'SUB_HINTS', $hash2(["a", "m", "n", "p", "q", "r", "c", "v"], {"a": "attributes", "m": "macros", "n": "normal", "p": "post_replacements", "q": "quotes", "r": "replacements", "c": "specialcharacters", "v": "verbatim"}));
      Opal.const_set($nesting[0], 'SUB_OPTIONS', $hash2(["block", "inline"], {"block": $rb_plus($rb_plus($$($nesting, 'SUB_GROUPS').$keys(), $$($nesting, 'NORMAL_SUBS')), ["callouts"]), "inline": $rb_plus($$($nesting, 'SUB_GROUPS').$keys(), $$($nesting, 'NORMAL_SUBS'))}));
      Opal.const_set($nesting[0], 'CAN', "\u0018");
      Opal.const_set($nesting[0], 'DEL', "\u007F");
      Opal.const_set($nesting[0], 'PASS_START', "\u0096");
      Opal.const_set($nesting[0], 'PASS_END', "\u0097");
      Opal.const_set($nesting[0], 'PassSlotRx', new RegExp("" + ($$($nesting, 'PASS_START')) + "(\\d+)" + ($$($nesting, 'PASS_END'))));
      Opal.const_set($nesting[0], 'HighlightedPassSlotRx', new RegExp("" + "<span\\b[^>]*>" + ($$($nesting, 'PASS_START')) + "</span>[^\\d]*(\\d+)[^\\d]*<span\\b[^>]*>" + ($$($nesting, 'PASS_END')) + "</span>"));
      Opal.const_set($nesting[0], 'RS', "\\");
      Opal.const_set($nesting[0], 'R_SB', "]");
      Opal.const_set($nesting[0], 'ESC_R_SB', "\\]");
      Opal.const_set($nesting[0], 'PLUS', "+");
      
      Opal.def(self, '$apply_subs', $Substitutors_apply_subs$1 = function $$apply_subs(text, subs) {
        var $a, $$2, self = this, is_multiline = nil, passthrus = nil, clear_passthrus = nil;
        if (self.passthroughs == null) self.passthroughs = nil;
        if (self.passthroughs_locked == null) self.passthroughs_locked = nil;

        
        
        if (subs == null) {
          subs = $$($nesting, 'NORMAL_SUBS');
        };
        if ($truthy(($truthy($a = text['$empty?']()) ? $a : subs['$!']()))) {
          return text};
        if ($truthy((is_multiline = $$$('::', 'Array')['$==='](text)))) {
          text = (function() {if ($truthy(text['$[]'](1))) {
            
            return text.$join($$($nesting, 'LF'));
          } else {
            return text['$[]'](0)
          }; return nil; })()};
        if ($truthy(subs['$include?']("macros"))) {
          
          text = self.$extract_passthroughs(text);
          if ($truthy(self.passthroughs['$empty?']())) {
          } else {
            
            passthrus = self.passthroughs;
            self.passthroughs_locked = ($truthy($a = self.passthroughs_locked) ? $a : (clear_passthrus = true));
          };};
        $send(subs, 'each', [], ($$2 = function(type){var self = $$2.$$s || this, $case = nil;

        
          
          if (type == null) {
            type = nil;
          };
          return (function() {$case = type;
          if ("specialcharacters"['$===']($case)) {return (text = self.$sub_specialchars(text))}
          else if ("quotes"['$===']($case)) {return (text = self.$sub_quotes(text))}
          else if ("attributes"['$===']($case)) {if ($truthy(text['$include?']($$($nesting, 'ATTR_REF_HEAD')))) {
            return (text = self.$sub_attributes(text))
          } else {
            return nil
          }}
          else if ("replacements"['$===']($case)) {return (text = self.$sub_replacements(text))}
          else if ("macros"['$===']($case)) {return (text = self.$sub_macros(text))}
          else if ("highlight"['$===']($case)) {return (text = self.$highlight_source(text, subs['$include?']("callouts")))}
          else if ("callouts"['$===']($case)) {if ($truthy(subs['$include?']("highlight"))) {
            return nil
          } else {
            return (text = self.$sub_callouts(text))
          }}
          else if ("post_replacements"['$===']($case)) {return (text = self.$sub_post_replacements(text))}
          else {return self.$logger().$warn("" + "unknown substitution type " + (type))}})();}, $$2.$$s = self, $$2.$$arity = 1, $$2));
        if ($truthy(passthrus)) {
          
          text = self.$restore_passthroughs(text);
          if ($truthy(clear_passthrus)) {
            
            passthrus.$clear();
            self.passthroughs_locked = nil;};};
        if ($truthy(is_multiline)) {
          
          return text.$split($$($nesting, 'LF'), -1);
        } else {
          return text
        };
      }, $Substitutors_apply_subs$1.$$arity = -2);
      
      Opal.def(self, '$apply_normal_subs', $Substitutors_apply_normal_subs$3 = function $$apply_normal_subs(text) {
        var self = this;

        return self.$apply_subs(text, $$($nesting, 'NORMAL_SUBS'))
      }, $Substitutors_apply_normal_subs$3.$$arity = 1);
      
      Opal.def(self, '$apply_header_subs', $Substitutors_apply_header_subs$4 = function $$apply_header_subs(text) {
        var self = this;

        return self.$apply_subs(text, $$($nesting, 'HEADER_SUBS'))
      }, $Substitutors_apply_header_subs$4.$$arity = 1);
      Opal.alias(self, "apply_title_subs", "apply_subs");
      
      Opal.def(self, '$apply_reftext_subs', $Substitutors_apply_reftext_subs$5 = function $$apply_reftext_subs(text) {
        var self = this;

        return self.$apply_subs(text, $$($nesting, 'REFTEXT_SUBS'))
      }, $Substitutors_apply_reftext_subs$5.$$arity = 1);
      if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
        
        Opal.def(self, '$sub_specialchars', $Substitutors_sub_specialchars$6 = function $$sub_specialchars(text) {
          var $a, $b, self = this;

          if ($truthy(($truthy($a = ($truthy($b = text['$include?'](">")) ? $b : text['$include?']("&"))) ? $a : text['$include?']("<")))) {
            
            return text.$gsub($$($nesting, 'SpecialCharsRx'), $$($nesting, 'SpecialCharsTr'));
          } else {
            return text
          }
        }, $Substitutors_sub_specialchars$6.$$arity = 1)
      } else {
        nil
      };
      Opal.alias(self, "sub_specialcharacters", "sub_specialchars");
      
      Opal.def(self, '$sub_quotes', $Substitutors_sub_quotes$7 = function $$sub_quotes(text) {
        var $$8, self = this, compat = nil;
        if (self.document == null) self.document = nil;

        
        if ($truthy($$($nesting, 'QuotedTextSniffRx')['$[]']((compat = self.document.$compat_mode()))['$match?'](text))) {
          $send($$($nesting, 'QUOTE_SUBS')['$[]'](compat), 'each', [], ($$8 = function(type, scope, pattern){var self = $$8.$$s || this, $$9;

          
            
            if (type == null) {
              type = nil;
            };
            
            if (scope == null) {
              scope = nil;
            };
            
            if (pattern == null) {
              pattern = nil;
            };
            return (text = $send(text, 'gsub', [pattern], ($$9 = function(){var self = $$9.$$s || this;
              if ($gvars["~"] == null) $gvars["~"] = nil;

            return self.$convert_quoted_text($gvars["~"], type, scope)}, $$9.$$s = self, $$9.$$arity = 0, $$9)));}, $$8.$$s = self, $$8.$$arity = 3, $$8))};
        return text;
      }, $Substitutors_sub_quotes$7.$$arity = 1);
      
      Opal.def(self, '$sub_attributes', $Substitutors_sub_attributes$10 = function $$sub_attributes(text, opts) {
        var $$11, $$13, $$14, $$15, self = this, doc_attrs = nil, drop = nil, drop_line = nil, drop_line_severity = nil, drop_empty_line = nil, attribute_undefined = nil, attribute_missing = nil, lines = nil;
        if (self.document == null) self.document = nil;

        
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        doc_attrs = self.document.$attributes();
        drop = (drop_line = (drop_line_severity = (drop_empty_line = (attribute_undefined = (attribute_missing = nil)))));
        text = $send(text, 'gsub', [$$($nesting, 'AttributeReferenceRx')], ($$11 = function(){var self = $$11.$$s || this, $a, $b, $c, $$12, $case = nil, args = nil, _ = nil, value = nil, key = nil;
          if (self.document == null) self.document = nil;

        if ($truthy(($truthy($a = (($b = $gvars['~']) === nil ? nil : $b['$[]'](1))['$==']($$($nesting, 'RS'))) ? $a : (($b = $gvars['~']) === nil ? nil : $b['$[]'](4))['$==']($$($nesting, 'RS'))))) {
            return "" + "{" + ((($a = $gvars['~']) === nil ? nil : $a['$[]'](2))) + "}"
          } else if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](3)))) {
            return (function() {$case = (args = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)).$split(":", 3)).$shift();
            if ("set"['$===']($case)) {
            $b = $$($nesting, 'Parser').$store_attribute(args['$[]'](0), ($truthy($c = args['$[]'](1)) ? $c : ""), self.document), $a = Opal.to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1])), $b;
            if ($truthy(($truthy($a = value) ? $a : (attribute_undefined = ($truthy($b = attribute_undefined) ? $b : ($truthy($c = doc_attrs['$[]']("attribute-undefined")) ? $c : $$($nesting, 'Compliance').$attribute_undefined())))['$!=']("drop-line")))) {
              return (drop = (drop_empty_line = $$($nesting, 'DEL')))
            } else {
              return (drop = (drop_line = $$($nesting, 'CAN')))
            };}
            else if ("counter2"['$===']($case)) {
            $send(self.document, 'counter', Opal.to_a(args));
            return (drop = (drop_empty_line = $$($nesting, 'DEL')));}
            else {return $send(self.document, 'counter', Opal.to_a(args))}})()
          } else if ($truthy(doc_attrs['$key?']((key = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)).$downcase())))) {
            return doc_attrs['$[]'](key)
          } else if ($truthy((value = $$($nesting, 'INTRINSIC_ATTRIBUTES')['$[]'](key)))) {
            return value
          } else {
            return (function() {$case = (attribute_missing = ($truthy($a = attribute_missing) ? $a : ($truthy($b = ($truthy($c = opts['$[]']("attribute_missing")) ? $c : doc_attrs['$[]']("attribute-missing"))) ? $b : $$($nesting, 'Compliance').$attribute_missing())));
            if ("drop"['$===']($case)) {return (drop = (drop_empty_line = $$($nesting, 'DEL')))}
            else if ("drop-line"['$===']($case)) {
            if ((drop_line_severity = ($truthy($a = drop_line_severity) ? $a : ($truthy($b = opts['$[]']("drop_line_severity")) ? $b : "info")))['$==']("info")) {
              $send(self.$logger(), 'info', [], ($$12 = function(){var self = $$12.$$s || this;

              return "" + "dropping line containing reference to missing attribute: " + (key)}, $$12.$$s = self, $$12.$$arity = 0, $$12))};
            return (drop = (drop_line = $$($nesting, 'CAN')));}
            else if ("warn"['$===']($case)) {
            self.$logger().$warn("" + "skipping reference to missing attribute: " + (key));
            return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0));}
            else {return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0))}})()
          }}, $$11.$$s = self, $$11.$$arity = 0, $$11));
        if ($truthy(drop)) {
          if ($truthy(drop_empty_line)) {
            
            lines = text.$squeeze($$($nesting, 'DEL')).$split($$($nesting, 'LF'), -1);
            if ($truthy(drop_line)) {
              return $send(lines, 'reject', [], ($$13 = function(line){var self = $$13.$$s || this, $a, $b, $c;

              
                
                if (line == null) {
                  line = nil;
                };
                return ($truthy($a = ($truthy($b = ($truthy($c = line['$==']($$($nesting, 'DEL'))) ? $c : line['$==']($$($nesting, 'CAN')))) ? $b : line['$start_with?']($$($nesting, 'CAN')))) ? $a : line['$include?']($$($nesting, 'CAN')));}, $$13.$$s = self, $$13.$$arity = 1, $$13)).$join($$($nesting, 'LF')).$delete($$($nesting, 'DEL'))
            } else {
              return $send(lines, 'reject', [], ($$14 = function(line){var self = $$14.$$s || this;

              
                
                if (line == null) {
                  line = nil;
                };
                return line['$==']($$($nesting, 'DEL'));}, $$14.$$s = self, $$14.$$arity = 1, $$14)).$join($$($nesting, 'LF')).$delete($$($nesting, 'DEL'))
            };
          } else if ($truthy(text['$include?']($$($nesting, 'LF')))) {
            return $send(text.$split($$($nesting, 'LF'), -1), 'reject', [], ($$15 = function(line){var self = $$15.$$s || this, $a, $b;

            
              
              if (line == null) {
                line = nil;
              };
              return ($truthy($a = ($truthy($b = line['$==']($$($nesting, 'CAN'))) ? $b : line['$start_with?']($$($nesting, 'CAN')))) ? $a : line['$include?']($$($nesting, 'CAN')));}, $$15.$$s = self, $$15.$$arity = 1, $$15)).$join($$($nesting, 'LF'))
          } else {
            return ""
          }
        } else {
          return text
        };
      }, $Substitutors_sub_attributes$10.$$arity = -2);
      
      Opal.def(self, '$sub_replacements', $Substitutors_sub_replacements$16 = function $$sub_replacements(text) {
        var $$17, self = this;

        
        if ($truthy($$($nesting, 'ReplaceableTextRx')['$match?'](text))) {
          $send($$($nesting, 'REPLACEMENTS'), 'each', [], ($$17 = function(pattern, replacement, restore){var self = $$17.$$s || this, $$18;

          
            
            if (pattern == null) {
              pattern = nil;
            };
            
            if (replacement == null) {
              replacement = nil;
            };
            
            if (restore == null) {
              restore = nil;
            };
            return (text = $send(text, 'gsub', [pattern], ($$18 = function(){var self = $$18.$$s || this;
              if ($gvars["~"] == null) $gvars["~"] = nil;

            return self.$do_replacement($gvars["~"], replacement, restore)}, $$18.$$s = self, $$18.$$arity = 0, $$18)));}, $$17.$$s = self, $$17.$$arity = 3, $$17))};
        return text;
      }, $Substitutors_sub_replacements$16.$$arity = 1);
      
      Opal.def(self, '$sub_macros', $Substitutors_sub_macros$19 = function $$sub_macros(text) {
        var $a, $$20, $b, $$23, $$26, $$28, $$30, $$31, $$34, $$35, $$36, $$37, $$38, $$39, $$40, self = this, found_square_bracket = nil, found_colon = nil, found_macroish = nil, found_macroish_short = nil, doc_attrs = nil, doc = nil, extensions = nil;
        if (self.document == null) self.document = nil;
        if (self.context == null) self.context = nil;
        if (self.parent == null) self.parent = nil;

        
        found_square_bracket = text['$include?']("[");
        found_colon = text['$include?'](":");
        found_macroish = ($truthy($a = found_square_bracket) ? found_colon : $a);
        found_macroish_short = ($truthy($a = found_macroish) ? text['$include?'](":[") : $a);
        doc_attrs = (doc = self.document).$attributes();
        if ($truthy(($truthy($a = (extensions = doc.$extensions())) ? extensions['$inline_macros?']() : $a))) {
          $send(extensions.$inline_macros(), 'each', [], ($$20 = function(extension){var self = $$20.$$s || this, $$21;

          
            
            if (extension == null) {
              extension = nil;
            };
            return (text = $send(text, 'gsub', [extension.$instance().$regexp()], ($$21 = function(){var self = $$21.$$s || this, $b, $c, $$22, match = nil, target = nil, content = nil, attributes = nil, default_attrs = nil, ext_config = nil, $writer = nil, replacement = nil, inline_subs = nil;
              if ($gvars["~"] == null) $gvars["~"] = nil;

            
              if ($truthy((match = (($b = $gvars['~']) === nil ? nil : $b['$[]'](0)))['$start_with?']($$($nesting, 'RS')))) {
                return (($b = $gvars['~']) === nil ? nil : $b['$[]'](0)).$slice(1, (($b = $gvars['~']) === nil ? nil : $b['$[]'](0)).$length());};
              if ($truthy($gvars["~"].$names()['$empty?']())) {
                $b = [(($c = $gvars['~']) === nil ? nil : $c['$[]'](1)), (($c = $gvars['~']) === nil ? nil : $c['$[]'](2))], (target = $b[0]), (content = $b[1]), $b
              } else {
                $b = [(function() { try {
                  return $gvars["~"]['$[]']("target")
                } catch ($err) {
                  if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
                    try {
                      return nil
                    } finally { Opal.pop_exception() }
                  } else { throw $err; }
                }})(), (function() { try {
                  return $gvars["~"]['$[]']("content")
                } catch ($err) {
                  if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
                    try {
                      return nil
                    } finally { Opal.pop_exception() }
                  } else { throw $err; }
                }})()], (target = $b[0]), (content = $b[1]), $b
              };
              attributes = (function() {if ($truthy((default_attrs = (ext_config = extension.$config())['$[]']("default_attrs")))) {
                return default_attrs.$merge()
              } else {
                return $hash2([], {})
              }; return nil; })();
              if ($truthy(content)) {
                
                if ($truthy(content['$empty?']())) {
                  if (ext_config['$[]']("content_model")['$==']("attributes")) {
                  } else {
                    
                    $writer = ["text", content];
                    $send(attributes, '[]=', Opal.to_a($writer));
                    $writer[$rb_minus($writer["length"], 1)];
                  }
                } else {
                  
                  content = self.$normalize_text(content, true, true);
                  if (ext_config['$[]']("content_model")['$==']("attributes")) {
                    self.$parse_attributes(content, ($truthy($b = ($truthy($c = ext_config['$[]']("positional_attrs")) ? $c : ext_config['$[]']("pos_attrs"))) ? $b : []), $hash2(["into"], {"into": attributes}))
                  } else {
                    
                    $writer = ["text", content];
                    $send(attributes, '[]=', Opal.to_a($writer));
                    $writer[$rb_minus($writer["length"], 1)];
                  };
                };
                target = ($truthy($b = target) ? $b : (function() {if (ext_config['$[]']("format")['$==']("short")) {
                  return content
                } else {
                  return target
                }; return nil; })());};
              if ($truthy($$($nesting, 'Inline')['$===']((replacement = extension.$process_method()['$[]'](self, target, attributes))))) {
                
                if ($truthy(($truthy($b = (inline_subs = replacement.$attributes().$delete("subs"))) ? (inline_subs = self.$expand_subs(inline_subs, "custom inline macro")) : $b))) {
                  
                  $writer = [self.$apply_subs(replacement.$text(), inline_subs)];
                  $send(replacement, 'text=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];};
                return replacement.$convert();
              } else if ($truthy(replacement)) {
                
                $send(self.$logger(), 'info', [], ($$22 = function(){var self = $$22.$$s || this;

                return "" + "expected substitution value for custom inline macro to be of type Inline; got " + (replacement.$class()) + ": " + (match)}, $$22.$$s = self, $$22.$$arity = 0, $$22));
                return replacement;
              } else {
                return ""
              };}, $$21.$$s = self, $$21.$$arity = 0, $$21)));}, $$20.$$s = self, $$20.$$arity = 1, $$20))};
        if ($truthy(doc_attrs['$key?']("experimental"))) {
          
          if ($truthy(($truthy($a = found_macroish_short) ? ($truthy($b = text['$include?']("kbd:")) ? $b : text['$include?']("btn:")) : $a))) {
            text = $send(text, 'gsub', [$$($nesting, 'InlineKbdBtnMacroRx')], ($$23 = function(){var self = $$23.$$s || this, $c, $$24, $$25, keys = nil, delim_idx = nil, delim = nil, $writer = nil;

            if ($truthy((($c = $gvars['~']) === nil ? nil : $c['$[]'](1)))) {
                return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$slice(1, (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$length())
              } else if ((($c = $gvars['~']) === nil ? nil : $c['$[]'](2))['$==']("kbd")) {
                
                if ($truthy((keys = (($c = $gvars['~']) === nil ? nil : $c['$[]'](3)).$strip())['$include?']($$($nesting, 'R_SB')))) {
                  keys = keys.$gsub($$($nesting, 'ESC_R_SB'), $$($nesting, 'R_SB'))};
                if ($truthy(($truthy($c = $rb_gt(keys.$length(), 1)) ? (delim_idx = (function() {if ($truthy((delim_idx = keys.$index(",", 1)))) {
                  return [delim_idx, keys.$index("+", 1)].$compact().$min()
                } else {
                  
                  return keys.$index("+", 1);
                }; return nil; })()) : $c))) {
                  
                  delim = keys.$slice(delim_idx, 1);
                  if ($truthy(keys['$end_with?'](delim))) {
                    
                    keys = $send(keys.$chop().$split(delim, -1), 'map', [], ($$24 = function(key){var self = $$24.$$s || this;

                    
                      
                      if (key == null) {
                        key = nil;
                      };
                      return key.$strip();}, $$24.$$s = self, $$24.$$arity = 1, $$24));
                    
                    $writer = [-1, $rb_plus(keys['$[]'](-1), delim)];
                    $send(keys, '[]=', Opal.to_a($writer));
                    $writer[$rb_minus($writer["length"], 1)];;
                  } else {
                    keys = $send(keys.$split(delim), 'map', [], ($$25 = function(key){var self = $$25.$$s || this;

                    
                      
                      if (key == null) {
                        key = nil;
                      };
                      return key.$strip();}, $$25.$$s = self, $$25.$$arity = 1, $$25))
                  };
                } else {
                  keys = [keys]
                };
                return $$($nesting, 'Inline').$new(self, "kbd", nil, $hash2(["attributes"], {"attributes": $hash2(["keys"], {"keys": keys})})).$convert();
              } else {
                return $$($nesting, 'Inline').$new(self, "button", self.$normalize_text((($c = $gvars['~']) === nil ? nil : $c['$[]'](3)), true, true)).$convert()
              }}, $$23.$$s = self, $$23.$$arity = 0, $$23))};
          if ($truthy(($truthy($a = found_macroish) ? text['$include?']("menu:") : $a))) {
            text = $send(text, 'gsub', [$$($nesting, 'InlineMenuMacroRx')], ($$26 = function(){var self = $$26.$$s || this, $c, $$27, menu = nil, items = nil, delim = nil, submenus = nil, menuitem = nil;

            
              if ($truthy((($c = $gvars['~']) === nil ? nil : $c['$[]'](0))['$start_with?']($$($nesting, 'RS')))) {
                return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$slice(1, (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$length());};
              menu = (($c = $gvars['~']) === nil ? nil : $c['$[]'](1));
              if ($truthy((items = (($c = $gvars['~']) === nil ? nil : $c['$[]'](2))))) {
                
                if ($truthy(items['$include?']($$($nesting, 'R_SB')))) {
                  items = items.$gsub($$($nesting, 'ESC_R_SB'), $$($nesting, 'R_SB'))};
                if ($truthy((delim = (function() {if ($truthy(items['$include?']("&gt;"))) {
                  return "&gt;"
                } else {
                  
                  if ($truthy(items['$include?'](","))) {
                    return ","
                  } else {
                    return nil
                  };
                }; return nil; })()))) {
                  
                  submenus = $send(items.$split(delim), 'map', [], ($$27 = function(it){var self = $$27.$$s || this;

                  
                    
                    if (it == null) {
                      it = nil;
                    };
                    return it.$strip();}, $$27.$$s = self, $$27.$$arity = 1, $$27));
                  menuitem = submenus.$pop();
                } else {
                  $c = [[], items.$rstrip()], (submenus = $c[0]), (menuitem = $c[1]), $c
                };
              } else {
                $c = [[], nil], (submenus = $c[0]), (menuitem = $c[1]), $c
              };
              return $$($nesting, 'Inline').$new(self, "menu", nil, $hash2(["attributes"], {"attributes": $hash2(["menu", "submenus", "menuitem"], {"menu": menu, "submenus": submenus, "menuitem": menuitem})})).$convert();}, $$26.$$s = self, $$26.$$arity = 0, $$26))};
          if ($truthy(($truthy($a = text['$include?']("\"")) ? text['$include?']("&gt;") : $a))) {
            text = $send(text, 'gsub', [$$($nesting, 'InlineMenuRx')], ($$28 = function(){var self = $$28.$$s || this, $c, $d, $e, $$29, menu = nil, submenus = nil, menuitem = nil;

            
              if ($truthy((($c = $gvars['~']) === nil ? nil : $c['$[]'](0))['$start_with?']($$($nesting, 'RS')))) {
                return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$slice(1, (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$length());};
              $d = $send((($e = $gvars['~']) === nil ? nil : $e['$[]'](1)).$split("&gt;"), 'map', [], ($$29 = function(it){var self = $$29.$$s || this;

              
                
                if (it == null) {
                  it = nil;
                };
                return it.$strip();}, $$29.$$s = self, $$29.$$arity = 1, $$29)), $c = Opal.to_ary($d), (menu = ($c[0] == null ? nil : $c[0])), (submenus = $slice.call($c, 1)), $d;
              menuitem = submenus.$pop();
              return $$($nesting, 'Inline').$new(self, "menu", nil, $hash2(["attributes"], {"attributes": $hash2(["menu", "submenus", "menuitem"], {"menu": menu, "submenus": submenus, "menuitem": menuitem})})).$convert();}, $$28.$$s = self, $$28.$$arity = 0, $$28))};};
        if ($truthy(($truthy($a = found_macroish) ? ($truthy($b = text['$include?']("image:")) ? $b : text['$include?']("icon:")) : $a))) {
          text = $send(text, 'gsub', [$$($nesting, 'InlineImageMacroRx')], ($$30 = function(){var self = $$30.$$s || this, $c, type = nil, posattrs = nil, target = nil, attrs = nil, $writer = nil;

          
            if ($truthy((($c = $gvars['~']) === nil ? nil : $c['$[]'](0))['$start_with?']($$($nesting, 'RS')))) {
              return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$slice(1, (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$length());
            } else if ($truthy((($c = $gvars['~']) === nil ? nil : $c['$[]'](0))['$start_with?']("icon:"))) {
              $c = ["icon", ["size"]], (type = $c[0]), (posattrs = $c[1]), $c
            } else {
              $c = ["image", ["alt", "width", "height"]], (type = $c[0]), (posattrs = $c[1]), $c
            };
            target = (($c = $gvars['~']) === nil ? nil : $c['$[]'](1));
            attrs = self.$parse_attributes((($c = $gvars['~']) === nil ? nil : $c['$[]'](2)), posattrs, $hash2(["unescape_input"], {"unescape_input": true}));
            if (type['$==']("icon")) {
            } else {
              
              doc.$register("images", target);
              
              $writer = ["imagesdir", doc_attrs['$[]']("imagesdir")];
              $send(attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
            };
            ($truthy($c = attrs['$[]']("alt")) ? $c : (($writer = ["alt", (($writer = ["default-alt", $$($nesting, 'Helpers').$basename(target, true).$tr("_-", " ")]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
            return $$($nesting, 'Inline').$new(self, "image", nil, $hash2(["type", "target", "attributes"], {"type": type, "target": target, "attributes": attrs})).$convert();}, $$30.$$s = self, $$30.$$arity = 0, $$30))};
        if ($truthy(($truthy($a = ($truthy($b = text['$include?']("((")) ? text['$include?']("))") : $b)) ? $a : ($truthy($b = found_macroish_short) ? text['$include?']("dexterm") : $b)))) {
          text = $send(text, 'gsub', [$$($nesting, 'InlineIndextermMacroRx')], ($$31 = function(){var self = $$31.$$s || this, $c, $$32, $d, $$33, $case = nil, attrlist = nil, primary = nil, attrs = nil, $writer = nil, see_also = nil, term = nil, encl_text = nil, visible = nil, before = nil, after = nil, _ = nil, see = nil, subbed_term = nil, terms = nil;

          return (function() {$case = (($c = $gvars['~']) === nil ? nil : $c['$[]'](1));
            if ("indexterm"['$===']($case)) {
            if ($truthy((($c = $gvars['~']) === nil ? nil : $c['$[]'](0))['$start_with?']($$($nesting, 'RS')))) {
              return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$slice(1, (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$length());};
            if ($truthy((attrlist = self.$normalize_text((($c = $gvars['~']) === nil ? nil : $c['$[]'](2)), true, true))['$include?']("="))) {
              if ($truthy((primary = (attrs = $$($nesting, 'AttributeList').$new(attrlist, self).$parse())['$[]'](1)))) {
                
                
                $writer = ["terms", [primary]];
                $send(attrs, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
                if ($truthy((see_also = attrs['$[]']("see-also")))) {
                  
                  $writer = ["see-also", (function() {if ($truthy(see_also['$include?'](","))) {
                    return $send(see_also.$split(","), 'map', [], ($$32 = function(it){var self = $$32.$$s || this;

                    
                      
                      if (it == null) {
                        it = nil;
                      };
                      return it.$lstrip();}, $$32.$$s = self, $$32.$$arity = 1, $$32))
                  } else {
                    return [see_also]
                  }; return nil; })()];
                  $send(attrs, '[]=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];};
              } else {
                attrs = $hash2(["terms"], {"terms": attrlist})
              }
            } else {
              attrs = $hash2(["terms"], {"terms": self.$split_simple_csv(attrlist)})
            };
            return $$($nesting, 'Inline').$new(self, "indexterm", nil, $hash2(["attributes"], {"attributes": attrs})).$convert();}
            else if ("indexterm2"['$===']($case)) {
            if ($truthy((($c = $gvars['~']) === nil ? nil : $c['$[]'](0))['$start_with?']($$($nesting, 'RS')))) {
              return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$slice(1, (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$length());};
            if ($truthy((term = self.$normalize_text((($c = $gvars['~']) === nil ? nil : $c['$[]'](2)), true, true))['$include?']("="))) {
              
              term = ($truthy($c = ($truthy($d = (attrs = $$($nesting, 'AttributeList').$new(term, self).$parse())['$[]'](1)) ? $d : (attrs = nil))) ? $c : term);
              if ($truthy(($truthy($c = attrs) ? (see_also = attrs['$[]']("see-also")) : $c))) {
                
                $writer = ["see-also", (function() {if ($truthy(see_also['$include?'](","))) {
                  return $send(see_also.$split(","), 'map', [], ($$33 = function(it){var self = $$33.$$s || this;

                  
                    
                    if (it == null) {
                      it = nil;
                    };
                    return it.$lstrip();}, $$33.$$s = self, $$33.$$arity = 1, $$33))
                } else {
                  return [see_also]
                }; return nil; })()];
                $send(attrs, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];};};
            return $$($nesting, 'Inline').$new(self, "indexterm", term, $hash2(["attributes", "type"], {"attributes": attrs, "type": "visible"})).$convert();}
            else {
            encl_text = (($c = $gvars['~']) === nil ? nil : $c['$[]'](3));
            if ($truthy((($c = $gvars['~']) === nil ? nil : $c['$[]'](0))['$start_with?']($$($nesting, 'RS')))) {
              if ($truthy(($truthy($c = encl_text['$start_with?']("(")) ? encl_text['$end_with?'](")") : $c))) {
                
                encl_text = encl_text.$slice(1, $rb_minus(encl_text.$length(), 2));
                $c = [true, "(", ")"], (visible = $c[0]), (before = $c[1]), (after = $c[2]), $c;
              } else {
                return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$slice(1, (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$length());
              }
            } else {
              
              visible = true;
              if ($truthy(encl_text['$start_with?']("("))) {
                if ($truthy(encl_text['$end_with?'](")"))) {
                  $c = [encl_text.$slice(1, $rb_minus(encl_text.$length(), 2)), false], (encl_text = $c[0]), (visible = $c[1]), $c
                } else {
                  $c = [encl_text.$slice(1, encl_text.$length()), "(", ""], (encl_text = $c[0]), (before = $c[1]), (after = $c[2]), $c
                }
              } else if ($truthy(encl_text['$end_with?'](")"))) {
                $c = [encl_text.$chop(), "", ")"], (encl_text = $c[0]), (before = $c[1]), (after = $c[2]), $c};
            };
            if ($truthy(visible)) {
              
              if ($truthy((term = self.$normalize_text(encl_text, true))['$include?'](";&"))) {
                if ($truthy(term['$include?'](" &gt;&gt; "))) {
                  
                  $d = term.$partition(" &gt;&gt; "), $c = Opal.to_ary($d), (term = ($c[0] == null ? nil : $c[0])), (_ = ($c[1] == null ? nil : $c[1])), (see = ($c[2] == null ? nil : $c[2])), $d;
                  attrs = $hash2(["see"], {"see": see});
                } else if ($truthy(term['$include?'](" &amp;&gt; "))) {
                  
                  $d = term.$split(" &amp;&gt; "), $c = Opal.to_ary($d), (term = ($c[0] == null ? nil : $c[0])), (see_also = $slice.call($c, 1)), $d;
                  attrs = $hash2(["see-also"], {"see-also": see_also});}};
              subbed_term = $$($nesting, 'Inline').$new(self, "indexterm", term, $hash2(["attributes", "type"], {"attributes": attrs, "type": "visible"})).$convert();
            } else {
              
              attrs = $hash2([], {});
              if ($truthy((terms = self.$normalize_text(encl_text, true))['$include?'](";&"))) {
                if ($truthy(terms['$include?'](" &gt;&gt; "))) {
                  
                  $d = terms.$partition(" &gt;&gt; "), $c = Opal.to_ary($d), (terms = ($c[0] == null ? nil : $c[0])), (_ = ($c[1] == null ? nil : $c[1])), (see = ($c[2] == null ? nil : $c[2])), $d;
                  
                  $writer = ["see", see];
                  $send(attrs, '[]=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];;
                } else if ($truthy(terms['$include?'](" &amp;&gt; "))) {
                  
                  $d = terms.$split(" &amp;&gt; "), $c = Opal.to_ary($d), (terms = ($c[0] == null ? nil : $c[0])), (see_also = $slice.call($c, 1)), $d;
                  
                  $writer = ["see-also", see_also];
                  $send(attrs, '[]=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];;}};
              
              $writer = ["terms", self.$split_simple_csv(terms)];
              $send(attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              subbed_term = $$($nesting, 'Inline').$new(self, "indexterm", nil, $hash2(["attributes"], {"attributes": attrs})).$convert();
            };
            if ($truthy(before)) {
              return "" + (before) + (subbed_term) + (after)
            } else {
              return subbed_term
            };}})()}, $$31.$$s = self, $$31.$$arity = 0, $$31))};
        if ($truthy(($truthy($a = found_colon) ? text['$include?']("://") : $a))) {
          text = $send(text, 'gsub', [$$($nesting, 'InlineLinkRx')], ($$34 = function(){var self = $$34.$$s || this, $c, $d, target = nil, prefix = nil, suffix = nil, link_text = nil, $case = nil, attrs = nil, link_opts = nil, new_link_text = nil, $writer = nil, bare = nil;

          
            if ($truthy((target = (($c = $gvars['~']) === nil ? nil : $c['$[]'](2)))['$start_with?']($$($nesting, 'RS')))) {
              return "" + ((($c = $gvars['~']) === nil ? nil : $c['$[]'](1))) + (target.$slice(1, target.$length())) + ((($c = $gvars['~']) === nil ? nil : $c['$[]'](4)));};
            $c = [(($d = $gvars['~']) === nil ? nil : $d['$[]'](1)), ""], (prefix = $c[0]), (suffix = $c[1]), $c;
            if ($truthy((($c = $gvars['~']) === nil ? nil : $c['$[]'](4)))) {
              
              if (prefix['$==']("link:")) {
                prefix = ""};
              if ($truthy((link_text = (($c = $gvars['~']) === nil ? nil : $c['$[]'](4)))['$empty?']())) {
                link_text = nil};
            } else {
              
              $case = prefix;
              if ("link:"['$===']($case) || "\""['$===']($case) || "'"['$===']($case)) {return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0));};
              $case = (($c = $gvars['~']) === nil ? nil : $c['$[]'](3));
              if (")"['$===']($case) || "?"['$===']($case) || "!"['$===']($case)) {
              target = target.$chop();
              if ($truthy((($c = (suffix = (($d = $gvars['~']) === nil ? nil : $d['$[]'](3)))['$=='](")")) ? target['$end_with?'](".", "?", "!") : (suffix = (($d = $gvars['~']) === nil ? nil : $d['$[]'](3)))['$=='](")")))) {
                
                suffix = $rb_plus(target['$[]'](-1), suffix);
                target = target.$chop();};
              if ($truthy(target['$end_with?']("://"))) {
                return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0));};}
              else if (";"['$===']($case)) {
              if ($truthy(($truthy($c = prefix['$start_with?']("&lt;")) ? target['$end_with?']("&gt;") : $c))) {
                
                prefix = prefix.$slice(4, prefix.$length());
                target = target.$slice(0, $rb_minus(target.$length(), 4));
              } else if ($truthy((target = target.$chop())['$end_with?'](")"))) {
                
                target = target.$chop();
                suffix = ");";
              } else {
                suffix = ";"
              };
              if ($truthy(target['$end_with?']("://"))) {
                return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0));};}
              else if (":"['$===']($case)) {
              if ($truthy((target = target.$chop())['$end_with?'](")"))) {
                
                target = target.$chop();
                suffix = "):";
              } else {
                suffix = ":"
              };
              if ($truthy(target['$end_with?']("://"))) {
                return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0));};};
            };
            $c = [nil, $hash2(["type"], {"type": "link"})], (attrs = $c[0]), (link_opts = $c[1]), $c;
            if ($truthy(link_text)) {
              
              if ($truthy(link_text['$include?']($$($nesting, 'R_SB')))) {
                new_link_text = (link_text = link_text.$gsub($$($nesting, 'ESC_R_SB'), $$($nesting, 'R_SB')))};
              if ($truthy(($truthy($c = doc.$compat_mode()['$!']()) ? link_text['$include?']("=") : $c))) {
                
                $d = self.$extract_attributes_from_text(link_text, ""), $c = Opal.to_ary($d), (link_text = ($c[0] == null ? nil : $c[0])), (attrs = ($c[1] == null ? nil : $c[1])), $d;
                new_link_text = link_text;
                
                $writer = ["id", attrs['$[]']("id")];
                $send(link_opts, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;};
              if ($truthy(link_text['$end_with?']("^"))) {
                
                new_link_text = (link_text = link_text.$chop());
                if ($truthy(attrs)) {
                  ($truthy($c = attrs['$[]']("window")) ? $c : (($writer = ["window", "_blank"]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))
                } else {
                  attrs = $hash2(["window"], {"window": "_blank"})
                };};
              if ($truthy(($truthy($c = new_link_text) ? new_link_text['$empty?']() : $c))) {
                
                link_text = (function() {if ($truthy(doc_attrs['$key?']("hide-uri-scheme"))) {
                  
                  return target.$sub($$($nesting, 'UriSniffRx'), "");
                } else {
                  return target
                }; return nil; })();
                bare = true;};
            } else {
              
              link_text = (function() {if ($truthy(doc_attrs['$key?']("hide-uri-scheme"))) {
                
                return target.$sub($$($nesting, 'UriSniffRx'), "");
              } else {
                return target
              }; return nil; })();
              bare = true;
            };
            if ($truthy(bare)) {
              if ($truthy(attrs)) {
                
                $writer = ["role", (function() {if ($truthy(attrs['$key?']("role"))) {
                  return "" + "bare " + (attrs['$[]']("role"))
                } else {
                  return "bare"
                }; return nil; })()];
                $send(attrs, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
              } else {
                attrs = $hash2(["role"], {"role": "bare"})
              }};
            doc.$register("links", (($writer = ["target", target]), $send(link_opts, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
            if ($truthy(attrs)) {
              
              $writer = ["attributes", attrs];
              $send(link_opts, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            return "" + (prefix) + ($$($nesting, 'Inline').$new(self, "anchor", link_text, link_opts).$convert()) + (suffix);}, $$34.$$s = self, $$34.$$arity = 0, $$34))};
        if ($truthy(($truthy($a = found_macroish) ? ($truthy($b = text['$include?']("link:")) ? $b : text['$include?']("ilto:")) : $a))) {
          text = $send(text, 'gsub', [$$($nesting, 'InlineLinkMacroRx')], ($$35 = function(){var self = $$35.$$s || this, $c, $d, mailto = nil, target = nil, mailto_text = nil, attrs = nil, link_opts = nil, link_text = nil, $writer = nil;

          
            if ($truthy((($c = $gvars['~']) === nil ? nil : $c['$[]'](0))['$start_with?']($$($nesting, 'RS')))) {
              return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$slice(1, (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$length());
            } else if ($truthy((mailto = (($c = $gvars['~']) === nil ? nil : $c['$[]'](1))))) {
              target = $rb_plus("mailto:", (mailto_text = (($c = $gvars['~']) === nil ? nil : $c['$[]'](2))))
            } else {
              target = (($c = $gvars['~']) === nil ? nil : $c['$[]'](2))
            };
            $c = [nil, $hash2(["type"], {"type": "link"})], (attrs = $c[0]), (link_opts = $c[1]), $c;
            if ($truthy((link_text = (($c = $gvars['~']) === nil ? nil : $c['$[]'](3)))['$empty?']())) {
            } else {
              
              if ($truthy(link_text['$include?']($$($nesting, 'R_SB')))) {
                link_text = link_text.$gsub($$($nesting, 'ESC_R_SB'), $$($nesting, 'R_SB'))};
              if ($truthy(mailto)) {
                if ($truthy(($truthy($c = doc.$compat_mode()['$!']()) ? link_text['$include?'](",") : $c))) {
                  
                  $d = self.$extract_attributes_from_text(link_text, ""), $c = Opal.to_ary($d), (link_text = ($c[0] == null ? nil : $c[0])), (attrs = ($c[1] == null ? nil : $c[1])), $d;
                  
                  $writer = ["id", attrs['$[]']("id")];
                  $send(link_opts, '[]=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];;
                  if ($truthy(attrs['$key?'](2))) {
                    if ($truthy(attrs['$key?'](3))) {
                      target = "" + (target) + "?subject=" + ($$($nesting, 'Helpers').$encode_uri_component(attrs['$[]'](2))) + "&amp;body=" + ($$($nesting, 'Helpers').$encode_uri_component(attrs['$[]'](3)))
                    } else {
                      target = "" + (target) + "?subject=" + ($$($nesting, 'Helpers').$encode_uri_component(attrs['$[]'](2)))
                    }};}
              } else if ($truthy(($truthy($c = doc.$compat_mode()['$!']()) ? link_text['$include?']("=") : $c))) {
                
                $d = self.$extract_attributes_from_text(link_text, ""), $c = Opal.to_ary($d), (link_text = ($c[0] == null ? nil : $c[0])), (attrs = ($c[1] == null ? nil : $c[1])), $d;
                
                $writer = ["id", attrs['$[]']("id")];
                $send(link_opts, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;};
              if ($truthy(link_text['$end_with?']("^"))) {
                
                link_text = link_text.$chop();
                if ($truthy(attrs)) {
                  ($truthy($c = attrs['$[]']("window")) ? $c : (($writer = ["window", "_blank"]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))
                } else {
                  attrs = $hash2(["window"], {"window": "_blank"})
                };};
            };
            if ($truthy(link_text['$empty?']())) {
              if ($truthy(mailto)) {
                link_text = mailto_text
              } else {
                
                if ($truthy(doc_attrs['$key?']("hide-uri-scheme"))) {
                  if ($truthy((link_text = target.$sub($$($nesting, 'UriSniffRx'), ""))['$empty?']())) {
                    link_text = target}
                } else {
                  link_text = target
                };
                if ($truthy(attrs)) {
                  
                  $writer = ["role", (function() {if ($truthy(attrs['$key?']("role"))) {
                    return "" + "bare " + (attrs['$[]']("role"))
                  } else {
                    return "bare"
                  }; return nil; })()];
                  $send(attrs, '[]=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];
                } else {
                  attrs = $hash2(["role"], {"role": "bare"})
                };
              }};
            doc.$register("links", (($writer = ["target", target]), $send(link_opts, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
            if ($truthy(attrs)) {
              
              $writer = ["attributes", attrs];
              $send(link_opts, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            return $$($nesting, 'Inline').$new(self, "anchor", link_text, link_opts).$convert();}, $$35.$$s = self, $$35.$$arity = 0, $$35))};
        if ($truthy(text['$include?']("@"))) {
          text = $send(text, 'gsub', [$$($nesting, 'InlineEmailRx')], ($$36 = function(){var self = $$36.$$s || this, $c, target = nil, address = nil;

          
            if ($truthy((($c = $gvars['~']) === nil ? nil : $c['$[]'](1)))) {
              return (function() {if ((($c = $gvars['~']) === nil ? nil : $c['$[]'](1))['$==']($$($nesting, 'RS'))) {
                
                return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$slice(1, (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$length());
              } else {
                return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0))
              }; return nil; })();};
            target = $rb_plus("mailto:", (address = (($c = $gvars['~']) === nil ? nil : $c['$[]'](0))));
            doc.$register("links", target);
            return $$($nesting, 'Inline').$new(self, "anchor", address, $hash2(["type", "target"], {"type": "link", "target": target})).$convert();}, $$36.$$s = self, $$36.$$arity = 0, $$36))};
        if ($truthy(($truthy($a = ($truthy($b = found_square_bracket) ? self.context['$==']("list_item") : $b)) ? self.parent.$style()['$==']("bibliography") : $a))) {
          text = $send(text, 'sub', [$$($nesting, 'InlineBiblioAnchorRx')], ($$37 = function(){var self = $$37.$$s || this, $c;

          return $$($nesting, 'Inline').$new(self, "anchor", (($c = $gvars['~']) === nil ? nil : $c['$[]'](2)), $hash2(["type", "id"], {"type": "bibref", "id": (($c = $gvars['~']) === nil ? nil : $c['$[]'](1))})).$convert()}, $$37.$$s = self, $$37.$$arity = 0, $$37))};
        if ($truthy(($truthy($a = ($truthy($b = found_square_bracket) ? text['$include?']("[[") : $b)) ? $a : ($truthy($b = found_macroish) ? text['$include?']("or:") : $b)))) {
          text = $send(text, 'gsub', [$$($nesting, 'InlineAnchorRx')], ($$38 = function(){var self = $$38.$$s || this, $c, $d, id = nil, reftext = nil;

          
            if ($truthy((($c = $gvars['~']) === nil ? nil : $c['$[]'](1)))) {
              return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$slice(1, (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$length());};
            if ($truthy((id = (($c = $gvars['~']) === nil ? nil : $c['$[]'](2))))) {
              reftext = (($c = $gvars['~']) === nil ? nil : $c['$[]'](3))
            } else {
              
              id = (($c = $gvars['~']) === nil ? nil : $c['$[]'](4));
              if ($truthy(($truthy($c = (reftext = (($d = $gvars['~']) === nil ? nil : $d['$[]'](5)))) ? reftext['$include?']($$($nesting, 'R_SB')) : $c))) {
                reftext = reftext.$gsub($$($nesting, 'ESC_R_SB'), $$($nesting, 'R_SB'))};
            };
            return $$($nesting, 'Inline').$new(self, "anchor", reftext, $hash2(["type", "id"], {"type": "ref", "id": id})).$convert();}, $$38.$$s = self, $$38.$$arity = 0, $$38))};
        if ($truthy(($truthy($a = ($truthy($b = text['$include?']("&")) ? text['$include?'](";&l") : $b)) ? $a : ($truthy($b = found_macroish) ? text['$include?']("xref:") : $b)))) {
          text = $send(text, 'gsub', [$$($nesting, 'InlineXrefMacroRx')], ($$39 = function(){var self = $$39.$$s || this, $c, $d, attrs = nil, refid = nil, _ = nil, link_text = nil, macro = nil, fragment = nil, hash_idx = nil, fragment_len = nil, path = nil, src2src = nil, target = nil, $writer = nil;

          
            if ($truthy((($c = $gvars['~']) === nil ? nil : $c['$[]'](0))['$start_with?']($$($nesting, 'RS')))) {
              return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$slice(1, (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$length());};
            attrs = $hash2([], {});
            if ($truthy((refid = (($c = $gvars['~']) === nil ? nil : $c['$[]'](1))))) {
              if ($truthy(refid['$include?'](","))) {
                
                $d = refid.$partition(","), $c = Opal.to_ary($d), (refid = ($c[0] == null ? nil : $c[0])), (_ = ($c[1] == null ? nil : $c[1])), (link_text = ($c[2] == null ? nil : $c[2])), $d;
                if ($truthy((link_text = link_text.$lstrip())['$empty?']())) {
                  link_text = nil};}
            } else {
              
              macro = true;
              refid = (($c = $gvars['~']) === nil ? nil : $c['$[]'](2));
              if ($truthy((link_text = (($c = $gvars['~']) === nil ? nil : $c['$[]'](3))))) {
                
                if ($truthy(link_text['$include?']($$($nesting, 'R_SB')))) {
                  link_text = link_text.$gsub($$($nesting, 'ESC_R_SB'), $$($nesting, 'R_SB'))};
                if ($truthy(($truthy($c = doc.$compat_mode()['$!']()) ? link_text['$include?']("=") : $c))) {
                  $d = self.$extract_attributes_from_text(link_text), $c = Opal.to_ary($d), (link_text = ($c[0] == null ? nil : $c[0])), (attrs = ($c[1] == null ? nil : $c[1])), $d};};
            };
            if ($truthy(doc.$compat_mode())) {
              fragment = refid
            } else if ($truthy((hash_idx = refid.$index("#")))) {
              if ($truthy($rb_gt(hash_idx, 0))) {
                
                if ($truthy($rb_gt((fragment_len = $rb_minus($rb_minus(refid.$length(), 1), hash_idx)), 0))) {
                  $c = [refid.$slice(0, hash_idx), refid.$slice($rb_plus(hash_idx, 1), fragment_len)], (path = $c[0]), (fragment = $c[1]), $c
                } else {
                  path = refid.$chop()
                };
                if ($truthy(macro)) {
                  if ($truthy(path['$end_with?'](".adoc"))) {
                    src2src = (path = path.$slice(0, $rb_minus(path.$length(), 5)))
                  } else if ($truthy($$($nesting, 'Helpers')['$extname?'](path)['$!']())) {
                    src2src = path}
                } else if ($truthy($send(path, 'end_with?', Opal.to_a($$($nesting, 'ASCIIDOC_EXTENSIONS').$keys())))) {
                  src2src = (path = path.$slice(0, path.$rindex(".")))
                } else {
                  src2src = path
                };
              } else {
                $c = [refid, refid.$slice(1, refid.$length())], (target = $c[0]), (fragment = $c[1]), $c
              }
            } else if ($truthy(macro)) {
              if ($truthy(refid['$end_with?'](".adoc"))) {
                src2src = (path = refid.$slice(0, $rb_minus(refid.$length(), 5)))
              } else if ($truthy($$($nesting, 'Helpers')['$extname?'](refid))) {
                path = refid
              } else {
                fragment = refid
              }
            } else {
              fragment = refid
            };
            if ($truthy(target)) {
              
              refid = fragment;
              if ($truthy(($truthy($c = self.$logger()['$info?']()) ? doc.$catalog()['$[]']("refs")['$[]'](refid)['$!']() : $c))) {
                self.$logger().$info("" + "possible invalid reference: " + (refid))};
            } else if ($truthy(path)) {
              if ($truthy(($truthy($c = src2src) ? ($truthy($d = doc.$attributes()['$[]']("docname")['$=='](path)) ? $d : doc.$catalog()['$[]']("includes")['$[]'](path)) : $c))) {
                if ($truthy(fragment)) {
                  
                  $c = [fragment, nil, "" + "#" + (fragment)], (refid = $c[0]), (path = $c[1]), (target = $c[2]), $c;
                  if ($truthy(($truthy($c = self.$logger()['$info?']()) ? doc.$catalog()['$[]']("refs")['$[]'](refid)['$!']() : $c))) {
                    self.$logger().$info("" + "possible invalid reference: " + (refid))};
                } else {
                  $c = [nil, nil, "#"], (refid = $c[0]), (path = $c[1]), (target = $c[2]), $c
                }
              } else {
                
                $c = [path, "" + (($truthy($d = doc.$attributes()['$[]']("relfileprefix")) ? $d : "")) + (path) + ((function() {if ($truthy(src2src)) {
                  
                  return doc.$attributes().$fetch("relfilesuffix", doc.$outfilesuffix());
                } else {
                  return ""
                }; return nil; })())], (refid = $c[0]), (path = $c[1]), $c;
                if ($truthy(fragment)) {
                  $c = ["" + (refid) + "#" + (fragment), "" + (path) + "#" + (fragment)], (refid = $c[0]), (target = $c[1]), $c
                } else {
                  target = path
                };
              }
            } else if ($truthy(($truthy($c = doc.$compat_mode()) ? $c : $$($nesting, 'Compliance').$natural_xrefs()['$!']()))) {
              
              $c = [fragment, "" + "#" + (fragment)], (refid = $c[0]), (target = $c[1]), $c;
              if ($truthy(($truthy($c = self.$logger()['$info?']()) ? doc.$catalog()['$[]']("refs")['$[]'](refid)['$!']() : $c))) {
                self.$logger().$info("" + "possible invalid reference: " + (refid))};
            } else if ($truthy(doc.$catalog()['$[]']("refs")['$[]'](fragment))) {
              $c = [fragment, "" + "#" + (fragment)], (refid = $c[0]), (target = $c[1]), $c
            } else if ($truthy(($truthy($c = ($truthy($d = fragment['$include?'](" ")) ? $d : fragment.$downcase()['$!='](fragment))) ? (refid = doc.$resolve_id(fragment)) : $c))) {
              $c = [refid, "" + "#" + (refid)], (fragment = $c[0]), (target = $c[1]), $c
            } else {
              
              $c = [fragment, "" + "#" + (fragment)], (refid = $c[0]), (target = $c[1]), $c;
              if ($truthy(self.$logger()['$info?']())) {
                self.$logger().$info("" + "possible invalid reference: " + (refid))};
            };
            
            $writer = ["path", path];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = ["fragment", fragment];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = ["refid", refid];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            return $$($nesting, 'Inline').$new(self, "anchor", link_text, $hash2(["type", "target", "attributes"], {"type": "xref", "target": target, "attributes": attrs})).$convert();}, $$39.$$s = self, $$39.$$arity = 0, $$39))};
        if ($truthy(($truthy($a = found_macroish) ? text['$include?']("tnote") : $a))) {
          text = $send(text, 'gsub', [$$($nesting, 'InlineFootnoteMacroRx')], ($$40 = function(){var self = $$40.$$s || this, $c, $d, $e, $$41, id = nil, content = nil, footnote = nil, index = nil, type = nil, target = nil;

          
            if ($truthy((($c = $gvars['~']) === nil ? nil : $c['$[]'](0))['$start_with?']($$($nesting, 'RS')))) {
              return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$slice(1, (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$length());};
            if ($truthy((($c = $gvars['~']) === nil ? nil : $c['$[]'](1)))) {
              if ($truthy((($c = $gvars['~']) === nil ? nil : $c['$[]'](3)))) {
                
                $d = (($e = $gvars['~']) === nil ? nil : $e['$[]'](3)).$split(",", 2), $c = Opal.to_ary($d), (id = ($c[0] == null ? nil : $c[0])), (content = ($c[1] == null ? nil : $c[1])), $d;
                if ($truthy(doc.$compat_mode())) {
                } else {
                  self.$logger().$warn("" + "found deprecated footnoteref macro: " + ((($c = $gvars['~']) === nil ? nil : $c['$[]'](0))) + "; use footnote macro with target instead")
                };
              } else {
                return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0));
              }
            } else {
              
              id = (($c = $gvars['~']) === nil ? nil : $c['$[]'](2));
              content = (($c = $gvars['~']) === nil ? nil : $c['$[]'](3));
            };
            if ($truthy(id)) {
              if ($truthy((footnote = $send(doc.$footnotes(), 'find', [], ($$41 = function(candidate){var self = $$41.$$s || this;

              
                
                if (candidate == null) {
                  candidate = nil;
                };
                return candidate.$id()['$=='](id);}, $$41.$$s = self, $$41.$$arity = 1, $$41))))) {
                
                $c = [footnote.$index(), footnote.$text()], (index = $c[0]), (content = $c[1]), $c;
                $c = ["xref", id, nil], (type = $c[0]), (target = $c[1]), (id = $c[2]), $c;
              } else if ($truthy(content)) {
                
                content = self.$restore_passthroughs(self.$normalize_text(content, true, true));
                index = doc.$counter("footnote-number");
                doc.$register("footnotes", $$$($$($nesting, 'Document'), 'Footnote').$new(index, id, content));
                $c = ["ref", nil], (type = $c[0]), (target = $c[1]), $c;
              } else {
                
                self.$logger().$warn("" + "invalid footnote reference: " + (id));
                $c = ["xref", id, id, nil], (type = $c[0]), (target = $c[1]), (content = $c[2]), (id = $c[3]), $c;
              }
            } else if ($truthy(content)) {
              
              content = self.$restore_passthroughs(self.$normalize_text(content, true, true));
              index = doc.$counter("footnote-number");
              doc.$register("footnotes", $$$($$($nesting, 'Document'), 'Footnote').$new(index, id, content));
              type = (target = nil);
            } else {
              return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0));
            };
            return $$($nesting, 'Inline').$new(self, "footnote", content, $hash2(["attributes", "id", "target", "type"], {"attributes": $hash2(["index"], {"index": index}), "id": id, "target": target, "type": type})).$convert();}, $$40.$$s = self, $$40.$$arity = 0, $$40))};
        return text;
      }, $Substitutors_sub_macros$19.$$arity = 1);
      
      Opal.def(self, '$sub_post_replacements', $Substitutors_sub_post_replacements$42 = function $$sub_post_replacements(text) {
        var $a, $$43, $$44, self = this, lines = nil, last = nil;
        if (self.attributes == null) self.attributes = nil;
        if (self.document == null) self.document = nil;

        if ($truthy(($truthy($a = self.attributes['$[]']("hardbreaks-option")) ? $a : self.document.$attributes()['$[]']("hardbreaks-option")))) {
          
          lines = text.$split($$($nesting, 'LF'), -1);
          if ($truthy($rb_lt(lines.$size(), 2))) {
            return text};
          last = lines.$pop();
          return $send(lines, 'map', [], ($$43 = function(line){var self = $$43.$$s || this;

          
            
            if (line == null) {
              line = nil;
            };
            return $$($nesting, 'Inline').$new(self, "break", (function() {if ($truthy(line['$end_with?']($$($nesting, 'HARD_LINE_BREAK')))) {
              
              return line.$slice(0, $rb_minus(line.$length(), 2));
            } else {
              return line
            }; return nil; })(), $hash2(["type"], {"type": "line"})).$convert();}, $$43.$$s = self, $$43.$$arity = 1, $$43))['$<<'](last).$join($$($nesting, 'LF'));
        } else if ($truthy(($truthy($a = text['$include?']($$($nesting, 'PLUS'))) ? text['$include?']($$($nesting, 'HARD_LINE_BREAK')) : $a))) {
          return $send(text, 'gsub', [$$($nesting, 'HardLineBreakRx')], ($$44 = function(){var self = $$44.$$s || this, $b;

          return $$($nesting, 'Inline').$new(self, "break", (($b = $gvars['~']) === nil ? nil : $b['$[]'](1)), $hash2(["type"], {"type": "line"})).$convert()}, $$44.$$s = self, $$44.$$arity = 0, $$44))
        } else {
          return text
        }
      }, $Substitutors_sub_post_replacements$42.$$arity = 1);
      
      Opal.def(self, '$sub_source', $Substitutors_sub_source$45 = function $$sub_source(source, process_callouts) {
        var self = this;

        if ($truthy(process_callouts)) {
          return self.$sub_callouts(self.$sub_specialchars(source))
        } else {
          
          return self.$sub_specialchars(source);
        }
      }, $Substitutors_sub_source$45.$$arity = 2);
      
      Opal.def(self, '$sub_callouts', $Substitutors_sub_callouts$46 = function $$sub_callouts(text) {
        var $$47, self = this, callout_rx = nil, autonum = nil;

        
        callout_rx = (function() {if ($truthy(self['$attr?']("line-comment"))) {
          return $$($nesting, 'CalloutSourceRxMap')['$[]'](self.$attr("line-comment"))
        } else {
          return $$($nesting, 'CalloutSourceRx')
        }; return nil; })();
        autonum = 0;
        return $send(text, 'gsub', [callout_rx], ($$47 = function(){var self = $$47.$$s || this, $a, $b;
          if (self.document == null) self.document = nil;

        if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](2)))) {
            return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$sub($$($nesting, 'RS'), "")
          } else {
            return $$($nesting, 'Inline').$new(self, "callout", (function() {if ((($a = $gvars['~']) === nil ? nil : $a['$[]'](4))['$=='](".")) {
              return (autonum = $rb_plus(autonum, 1)).$to_s()
            } else {
              return (($a = $gvars['~']) === nil ? nil : $a['$[]'](4))
            }; return nil; })(), $hash2(["id", "attributes"], {"id": self.document.$callouts().$read_next_id(), "attributes": $hash2(["guard"], {"guard": ($truthy($a = (($b = $gvars['~']) === nil ? nil : $b['$[]'](1))) ? $a : (function() {if ((($b = $gvars['~']) === nil ? nil : $b['$[]'](3))['$==']("--")) {
              return ["<!--", "-->"]
            } else {
              return nil
            }; return nil; })())})})).$convert()
          }}, $$47.$$s = self, $$47.$$arity = 0, $$47));
      }, $Substitutors_sub_callouts$46.$$arity = 1);
      
      Opal.def(self, '$highlight_source', $Substitutors_highlight_source$48 = function $$highlight_source(source, process_callouts) {
        var $a, $b, $c, self = this, syntax_hl = nil, callout_marks = nil, doc_attrs = nil, syntax_hl_name = nil, linenums_mode = nil, start_line_number = nil, highlight_lines = nil, highlighted = nil, source_offset = nil;
        if (self.document == null) self.document = nil;
        if (self.passthroughs == null) self.passthroughs = nil;

        
        if ($truthy(($truthy($a = (syntax_hl = self.document.$syntax_highlighter())) ? syntax_hl['$highlight?']() : $a))) {
        } else {
          return self.$sub_source(source, process_callouts)
        };
        if ($truthy(process_callouts)) {
          $b = self.$extract_callouts(source), $a = Opal.to_ary($b), (source = ($a[0] == null ? nil : $a[0])), (callout_marks = ($a[1] == null ? nil : $a[1])), $b};
        doc_attrs = self.document.$attributes();
        syntax_hl_name = syntax_hl.$name();
        if ($truthy(($truthy($a = (linenums_mode = (function() {if ($truthy(self['$attr?']("linenums"))) {
          return ($truthy($b = doc_attrs['$[]']("" + (syntax_hl_name) + "-linenums-mode")) ? $b : "table").$to_sym()
        } else {
          return nil
        }; return nil; })())) ? $rb_lt((start_line_number = self.$attr("start", 1).$to_i()), 1) : $a))) {
          start_line_number = 1};
        if ($truthy(self['$attr?']("highlight"))) {
          highlight_lines = self.$resolve_lines_to_highlight(source, self.$attr("highlight"), start_line_number)};
        $b = syntax_hl.$highlight(self, source, self.$attr("language"), $hash2(["callouts", "css_mode", "highlight_lines", "number_lines", "start_line_number", "style"], {"callouts": callout_marks, "css_mode": ($truthy($c = doc_attrs['$[]']("" + (syntax_hl_name) + "-css")) ? $c : "class").$to_sym(), "highlight_lines": highlight_lines, "number_lines": linenums_mode, "start_line_number": start_line_number, "style": doc_attrs['$[]']("" + (syntax_hl_name) + "-style")})), $a = Opal.to_ary($b), (highlighted = ($a[0] == null ? nil : $a[0])), (source_offset = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy(self.passthroughs['$empty?']())) {
        } else {
          highlighted = highlighted.$gsub($$($nesting, 'HighlightedPassSlotRx'), "" + ($$($nesting, 'PASS_START')) + "\\1" + ($$($nesting, 'PASS_END')))
        };
        if ($truthy(callout_marks['$nil_or_empty?']())) {
          return highlighted
        } else {
          
          return self.$restore_callouts(highlighted, callout_marks, source_offset);
        };
      }, $Substitutors_highlight_source$48.$$arity = 2);
      
      Opal.def(self, '$resolve_lines_to_highlight', $Substitutors_resolve_lines_to_highlight$49 = function $$resolve_lines_to_highlight(source, spec, start) {
        var $$50, $$51, self = this, lines = nil, shift = nil;

        
        
        if (start == null) {
          start = nil;
        };
        lines = [];
        if ($truthy(spec['$include?'](" "))) {
          spec = spec.$delete(" ")};
        $send((function() {if ($truthy(spec['$include?'](","))) {
          
          return spec.$split(",");
        } else {
          
          return spec.$split(";");
        }; return nil; })(), 'map', [], ($$50 = function(entry){var self = $$50.$$s || this, $a, $b, negate = nil, delim = nil, from = nil, _ = nil, to = nil, line = nil;

        
          
          if (entry == null) {
            entry = nil;
          };
          if ($truthy(entry['$start_with?']("!"))) {
            
            entry = entry.$slice(1, entry.$length());
            negate = true;};
          if ($truthy((delim = (function() {if ($truthy(entry['$include?'](".."))) {
            return ".."
          } else {
            
            if ($truthy(entry['$include?']("-"))) {
              return "-"
            } else {
              return nil
            };
          }; return nil; })()))) {
            
            $b = entry.$partition(delim), $a = Opal.to_ary($b), (from = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), (to = ($a[2] == null ? nil : $a[2])), $b;
            if ($truthy(($truthy($a = to['$empty?']()) ? $a : $rb_lt((to = to.$to_i()), 0)))) {
              to = $rb_plus(source.$count($$($nesting, 'LF')), 1)};
            if ($truthy(negate)) {
              return (lines = $rb_minus(lines, Opal.Range.$new(from.$to_i(), to, false).$to_a()))
            } else {
              return (lines = lines['$|'](Opal.Range.$new(from.$to_i(), to, false).$to_a()))
            };
          } else if ($truthy(negate)) {
            return lines.$delete(entry.$to_i())
          } else if ($truthy(lines['$include?']((line = entry.$to_i()))['$!']())) {
            return lines['$<<'](line)
          } else {
            return nil
          };}, $$50.$$s = self, $$50.$$arity = 1, $$50));
        if ((shift = (function() {if ($truthy(start)) {
          return $rb_minus(start, 1)
        } else {
          return 0
        }; return nil; })())['$=='](0)) {
        } else {
          lines = $send(lines, 'map', [], ($$51 = function(it){var self = $$51.$$s || this;

          
            
            if (it == null) {
              it = nil;
            };
            return $rb_minus(it, shift);}, $$51.$$s = self, $$51.$$arity = 1, $$51))
        };
        return lines.$sort();
      }, $Substitutors_resolve_lines_to_highlight$49.$$arity = -3);
      
      Opal.def(self, '$extract_passthroughs', $Substitutors_extract_passthroughs$52 = function $$extract_passthroughs(text) {
        var $a, $b, $$53, $$54, $$55, self = this, compat_mode = nil, passthrus = nil, pass_inline_char1 = nil, pass_inline_char2 = nil, pass_inline_rx = nil;
        if (self.document == null) self.document = nil;
        if (self.passthroughs == null) self.passthroughs = nil;

        
        compat_mode = self.document.$compat_mode();
        passthrus = self.passthroughs;
        if ($truthy(($truthy($a = ($truthy($b = text['$include?']("++")) ? $b : text['$include?']("$$"))) ? $a : text['$include?']("ss:")))) {
          text = $send(text, 'gsub', [$$($nesting, 'InlinePassMacroRx')], ($$53 = function(){var self = $$53.$$s || this, $c, boundary = nil, attrlist = nil, escape_count = nil, preceding = nil, old_behavior = nil, attributes = nil, subs = nil, $writer = nil, passthru_key = nil;

          
            if ($truthy((boundary = (($c = $gvars['~']) === nil ? nil : $c['$[]'](4))))) {
              
              if ($truthy(($truthy($c = compat_mode) ? boundary['$==']("++") : $c))) {
                return "" + ((function() {if ($truthy((($c = $gvars['~']) === nil ? nil : $c['$[]'](2)))) {
                  return "" + ((($c = $gvars['~']) === nil ? nil : $c['$[]'](1))) + "[" + ((($c = $gvars['~']) === nil ? nil : $c['$[]'](2))) + "]" + ((($c = $gvars['~']) === nil ? nil : $c['$[]'](3)))
                } else {
                  return "" + ((($c = $gvars['~']) === nil ? nil : $c['$[]'](1))) + ((($c = $gvars['~']) === nil ? nil : $c['$[]'](3)))
                }; return nil; })()) + "++" + (self.$extract_passthroughs((($c = $gvars['~']) === nil ? nil : $c['$[]'](5)))) + "++";};
              if ($truthy((attrlist = (($c = $gvars['~']) === nil ? nil : $c['$[]'](2))))) {
                if ($truthy($rb_gt((escape_count = (($c = $gvars['~']) === nil ? nil : $c['$[]'](3)).$length()), 0))) {
                  return "" + ((($c = $gvars['~']) === nil ? nil : $c['$[]'](1))) + "[" + (attrlist) + "]" + ($rb_times($$($nesting, 'RS'), $rb_minus(escape_count, 1))) + (boundary) + ((($c = $gvars['~']) === nil ? nil : $c['$[]'](5))) + (boundary);
                } else if ((($c = $gvars['~']) === nil ? nil : $c['$[]'](1))['$==']($$($nesting, 'RS'))) {
                  preceding = "" + "[" + (attrlist) + "]"
                } else {
                  
                  if ($truthy((($c = boundary['$==']("++")) ? attrlist['$end_with?']("x-") : boundary['$==']("++")))) {
                    
                    old_behavior = true;
                    attrlist = attrlist.$slice(0, $rb_minus(attrlist.$length(), 2));};
                  attributes = self.$parse_quoted_text_attributes(attrlist);
                }
              } else if ($truthy($rb_gt((escape_count = (($c = $gvars['~']) === nil ? nil : $c['$[]'](3)).$length()), 0))) {
                return "" + ($rb_times($$($nesting, 'RS'), $rb_minus(escape_count, 1))) + (boundary) + ((($c = $gvars['~']) === nil ? nil : $c['$[]'](5))) + (boundary);};
              subs = (function() {if (boundary['$==']("+++")) {
                return []
              } else {
                return $$($nesting, 'BASIC_SUBS')
              }; return nil; })();
              if ($truthy(attributes)) {
                if ($truthy(old_behavior)) {
                  
                  $writer = [(passthru_key = passthrus.$size()), $hash2(["text", "subs", "type", "attributes"], {"text": (($c = $gvars['~']) === nil ? nil : $c['$[]'](5)), "subs": $$($nesting, 'NORMAL_SUBS'), "type": "monospaced", "attributes": attributes})];
                  $send(passthrus, '[]=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];
                } else {
                  
                  $writer = [(passthru_key = passthrus.$size()), $hash2(["text", "subs", "type", "attributes"], {"text": (($c = $gvars['~']) === nil ? nil : $c['$[]'](5)), "subs": subs, "type": "unquoted", "attributes": attributes})];
                  $send(passthrus, '[]=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];
                }
              } else {
                
                $writer = [(passthru_key = passthrus.$size()), $hash2(["text", "subs"], {"text": (($c = $gvars['~']) === nil ? nil : $c['$[]'](5)), "subs": subs})];
                $send(passthrus, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
              };
            } else {
              
              if ((($c = $gvars['~']) === nil ? nil : $c['$[]'](6))['$==']($$($nesting, 'RS'))) {
                return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$slice(1, (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$length());};
              if ($truthy((subs = (($c = $gvars['~']) === nil ? nil : $c['$[]'](7))))) {
                
                $writer = [(passthru_key = passthrus.$size()), $hash2(["text", "subs"], {"text": self.$normalize_text((($c = $gvars['~']) === nil ? nil : $c['$[]'](8)), nil, true), "subs": self.$resolve_pass_subs(subs)})];
                $send(passthrus, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
              } else {
                
                $writer = [(passthru_key = passthrus.$size()), $hash2(["text"], {"text": self.$normalize_text((($c = $gvars['~']) === nil ? nil : $c['$[]'](8)), nil, true)})];
                $send(passthrus, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
              };
            };
            return "" + (($truthy($c = preceding) ? $c : "")) + ($$($nesting, 'PASS_START')) + (passthru_key) + ($$($nesting, 'PASS_END'));}, $$53.$$s = self, $$53.$$arity = 0, $$53))};
        $b = $$($nesting, 'InlinePassRx')['$[]'](compat_mode), $a = Opal.to_ary($b), (pass_inline_char1 = ($a[0] == null ? nil : $a[0])), (pass_inline_char2 = ($a[1] == null ? nil : $a[1])), (pass_inline_rx = ($a[2] == null ? nil : $a[2])), $b;
        if ($truthy(($truthy($a = text['$include?'](pass_inline_char1)) ? $a : ($truthy($b = pass_inline_char2) ? text['$include?'](pass_inline_char2) : $b)))) {
          text = $send(text, 'gsub', [pass_inline_rx], ($$54 = function(){var self = $$54.$$s || this, $c, preceding = nil, attrlist = nil, quoted_text = nil, escape_mark = nil, format_mark = nil, content = nil, old_behavior = nil, attributes = nil, $writer = nil, passthru_key = nil, subs = nil;

          
            preceding = (($c = $gvars['~']) === nil ? nil : $c['$[]'](1));
            attrlist = (($c = $gvars['~']) === nil ? nil : $c['$[]'](2));
            if ($truthy((quoted_text = (($c = $gvars['~']) === nil ? nil : $c['$[]'](3)))['$start_with?']($$($nesting, 'RS')))) {
              escape_mark = $$($nesting, 'RS')};
            format_mark = (($c = $gvars['~']) === nil ? nil : $c['$[]'](4));
            content = (($c = $gvars['~']) === nil ? nil : $c['$[]'](5));
            if ($truthy(compat_mode)) {
              old_behavior = true
            } else if ($truthy((old_behavior = ($truthy($c = attrlist) ? attrlist['$end_with?']("x-") : $c)))) {
              attrlist = attrlist.$slice(0, $rb_minus(attrlist.$length(), 2))};
            if ($truthy(attrlist)) {
              if ($truthy((($c = format_mark['$==']("`")) ? old_behavior['$!']() : format_mark['$==']("`")))) {
                return self.$extract_inner_passthrough(content, "" + (preceding) + "[" + (attrlist) + "]" + (escape_mark));
              } else if ($truthy(escape_mark)) {
                return "" + (preceding) + "[" + (attrlist) + "]" + (quoted_text.$slice(1, quoted_text.$length()));
              } else if (preceding['$==']($$($nesting, 'RS'))) {
                preceding = "" + "[" + (attrlist) + "]"
              } else {
                attributes = self.$parse_quoted_text_attributes(attrlist)
              }
            } else if ($truthy((($c = format_mark['$==']("`")) ? old_behavior['$!']() : format_mark['$==']("`")))) {
              return self.$extract_inner_passthrough(content, "" + (preceding) + (escape_mark));
            } else if ($truthy(escape_mark)) {
              return "" + (preceding) + (quoted_text.$slice(1, quoted_text.$length()));};
            if ($truthy(compat_mode)) {
              
              $writer = [(passthru_key = passthrus.$size()), $hash2(["text", "subs", "attributes", "type"], {"text": content, "subs": $$($nesting, 'BASIC_SUBS'), "attributes": attributes, "type": "monospaced"})];
              $send(passthrus, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            } else if ($truthy(attributes)) {
              if ($truthy(old_behavior)) {
                
                subs = (function() {if (format_mark['$==']("`")) {
                  return $$($nesting, 'BASIC_SUBS')
                } else {
                  return $$($nesting, 'NORMAL_SUBS')
                }; return nil; })();
                
                $writer = [(passthru_key = passthrus.$size()), $hash2(["text", "subs", "attributes", "type"], {"text": content, "subs": subs, "attributes": attributes, "type": "monospaced"})];
                $send(passthrus, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
              } else {
                
                $writer = [(passthru_key = passthrus.$size()), $hash2(["text", "subs", "attributes", "type"], {"text": content, "subs": $$($nesting, 'BASIC_SUBS'), "attributes": attributes, "type": "unquoted"})];
                $send(passthrus, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
              }
            } else {
              
              $writer = [(passthru_key = passthrus.$size()), $hash2(["text", "subs"], {"text": content, "subs": $$($nesting, 'BASIC_SUBS')})];
              $send(passthrus, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            };
            return "" + (preceding) + ($$($nesting, 'PASS_START')) + (passthru_key) + ($$($nesting, 'PASS_END'));}, $$54.$$s = self, $$54.$$arity = 0, $$54))};
        if ($truthy(($truthy($a = text['$include?'](":")) ? ($truthy($b = text['$include?']("stem:")) ? $b : text['$include?']("math:")) : $a))) {
          text = $send(text, 'gsub', [$$($nesting, 'InlineStemMacroRx')], ($$55 = function(){var self = $$55.$$s || this, $c, $d, type = nil, subs = nil, content = nil, $writer = nil, passthru_key = nil;
            if (self.document == null) self.document = nil;

          
            if ($truthy((($c = $gvars['~']) === nil ? nil : $c['$[]'](0))['$start_with?']($$($nesting, 'RS')))) {
              return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$slice(1, (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$length());};
            if ((type = (($c = $gvars['~']) === nil ? nil : $c['$[]'](1)).$to_sym())['$==']("stem")) {
              type = $$($nesting, 'STEM_TYPE_ALIASES')['$[]'](self.document.$attributes()['$[]']("stem")).$to_sym()};
            subs = (($c = $gvars['~']) === nil ? nil : $c['$[]'](2));
            content = self.$normalize_text((($c = $gvars['~']) === nil ? nil : $c['$[]'](3)), nil, true);
            if ($truthy(($truthy($c = (($d = type['$==']("latexmath")) ? content['$start_with?']("$") : type['$==']("latexmath"))) ? content['$end_with?']("$") : $c))) {
              content = content.$slice(1, $rb_minus(content.$length(), 2))};
            subs = (function() {if ($truthy(subs)) {
              
              return self.$resolve_pass_subs(subs);
            } else {
              
              if ($truthy(self.document['$basebackend?']("html"))) {
                return $$($nesting, 'BASIC_SUBS')
              } else {
                return nil
              };
            }; return nil; })();
            
            $writer = [(passthru_key = passthrus.$size()), $hash2(["text", "subs", "type"], {"text": content, "subs": subs, "type": type})];
            $send(passthrus, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            return "" + ($$($nesting, 'PASS_START')) + (passthru_key) + ($$($nesting, 'PASS_END'));}, $$55.$$s = self, $$55.$$arity = 0, $$55))};
        return text;
      }, $Substitutors_extract_passthroughs$52.$$arity = 1);
      
      Opal.def(self, '$restore_passthroughs', $Substitutors_restore_passthroughs$56 = function $$restore_passthroughs(text) {
        var $$57, self = this, passthrus = nil;
        if (self.passthroughs == null) self.passthroughs = nil;

        
        passthrus = self.passthroughs;
        return $send(text, 'gsub', [$$($nesting, 'PassSlotRx')], ($$57 = function(){var self = $$57.$$s || this, $a, pass = nil, subbed_text = nil, type = nil, attributes = nil, id = nil;

        if ($truthy((pass = passthrus['$[]']((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)).$to_i())))) {
            
            subbed_text = self.$apply_subs(pass['$[]']("text"), pass['$[]']("subs"));
            if ($truthy((type = pass['$[]']("type")))) {
              
              if ($truthy((attributes = pass['$[]']("attributes")))) {
                id = attributes['$[]']("id")};
              subbed_text = $$($nesting, 'Inline').$new(self, "quoted", subbed_text, $hash2(["type", "id", "attributes"], {"type": type, "id": id, "attributes": attributes})).$convert();};
            if ($truthy(subbed_text['$include?']($$($nesting, 'PASS_START')))) {
              return self.$restore_passthroughs(subbed_text)
            } else {
              return subbed_text
            };
          } else {
            
            self.$logger().$error("" + "unresolved passthrough detected: " + (text));
            return "??pass??";
          }}, $$57.$$s = self, $$57.$$arity = 0, $$57));
      }, $Substitutors_restore_passthroughs$56.$$arity = 1);
      
      Opal.def(self, '$resolve_subs', $Substitutors_resolve_subs$58 = function $$resolve_subs(subs, type, defaults, subject) {
        var $$59, self = this, candidates = nil, modifiers_present = nil, resolved = nil, invalid = nil;

        
        
        if (type == null) {
          type = "block";
        };
        
        if (defaults == null) {
          defaults = nil;
        };
        
        if (subject == null) {
          subject = nil;
        };
        if ($truthy(subs['$nil_or_empty?']())) {
          return nil};
        candidates = nil;
        if ($truthy(subs['$include?'](" "))) {
          subs = subs.$delete(" ")};
        modifiers_present = $$($nesting, 'SubModifierSniffRx')['$match?'](subs);
        $send(subs.$split(","), 'each', [], ($$59 = function(key){var self = $$59.$$s || this, $a, $b, modifier_operation = nil, first = nil, resolved_keys = nil, resolved_key = nil, candidate = nil, $case = nil;

        
          
          if (key == null) {
            key = nil;
          };
          modifier_operation = nil;
          if ($truthy(modifiers_present)) {
            if ((first = key.$chr())['$==']("+")) {
              
              modifier_operation = "append";
              key = key.$slice(1, key.$length());
            } else if (first['$==']("-")) {
              
              modifier_operation = "remove";
              key = key.$slice(1, key.$length());
            } else if ($truthy(key['$end_with?']("+"))) {
              
              modifier_operation = "prepend";
              key = key.$chop();}};
          key = key.$to_sym();
          if ($truthy((($a = type['$==']("inline")) ? ($truthy($b = key['$==']("verbatim")) ? $b : key['$==']("v")) : type['$==']("inline")))) {
            resolved_keys = $$($nesting, 'BASIC_SUBS')
          } else if ($truthy($$($nesting, 'SUB_GROUPS')['$key?'](key))) {
            resolved_keys = $$($nesting, 'SUB_GROUPS')['$[]'](key)
          } else if ($truthy(($truthy($a = (($b = type['$==']("inline")) ? key.$length()['$=='](1) : type['$==']("inline"))) ? $$($nesting, 'SUB_HINTS')['$key?'](key) : $a))) {
            
            resolved_key = $$($nesting, 'SUB_HINTS')['$[]'](key);
            if ($truthy((candidate = $$($nesting, 'SUB_GROUPS')['$[]'](resolved_key)))) {
              resolved_keys = candidate
            } else {
              resolved_keys = [resolved_key]
            };
          } else {
            resolved_keys = [key]
          };
          if ($truthy(modifier_operation)) {
            
            candidates = ($truthy($a = candidates) ? $a : (function() {if ($truthy(defaults)) {
              
              return defaults.$drop(0);
            } else {
              return []
            }; return nil; })());
            return (function() {$case = modifier_operation;
            if ("append"['$===']($case)) {return (candidates = $rb_plus(candidates, resolved_keys))}
            else if ("prepend"['$===']($case)) {return (candidates = $rb_plus(resolved_keys, candidates))}
            else if ("remove"['$===']($case)) {return (candidates = $rb_minus(candidates, resolved_keys))}
            else { return nil }})();
          } else {
            
            candidates = ($truthy($a = candidates) ? $a : []);
            return (candidates = $rb_plus(candidates, resolved_keys));
          };}, $$59.$$s = self, $$59.$$arity = 1, $$59));
        if ($truthy(candidates)) {
        } else {
          return nil
        };
        resolved = candidates['$&']($$($nesting, 'SUB_OPTIONS')['$[]'](type));
        if ($truthy($rb_minus(candidates, resolved)['$empty?']())) {
        } else {
          
          invalid = $rb_minus(candidates, resolved);
          self.$logger().$warn("" + "invalid substitution type" + ((function() {if ($truthy($rb_gt(invalid.$size(), 1))) {
            return "s"
          } else {
            return ""
          }; return nil; })()) + ((function() {if ($truthy(subject)) {
            return " for "
          } else {
            return ""
          }; return nil; })()) + (subject) + ": " + (invalid.$join(", ")));
        };
        return resolved;
      }, $Substitutors_resolve_subs$58.$$arity = -2);
      
      Opal.def(self, '$resolve_block_subs', $Substitutors_resolve_block_subs$60 = function $$resolve_block_subs(subs, defaults, subject) {
        var self = this;

        return self.$resolve_subs(subs, "block", defaults, subject)
      }, $Substitutors_resolve_block_subs$60.$$arity = 3);
      
      Opal.def(self, '$resolve_pass_subs', $Substitutors_resolve_pass_subs$61 = function $$resolve_pass_subs(subs) {
        var self = this;

        return self.$resolve_subs(subs, "inline", nil, "passthrough macro")
      }, $Substitutors_resolve_pass_subs$61.$$arity = 1);
      
      Opal.def(self, '$expand_subs', $Substitutors_expand_subs$62 = function $$expand_subs(subs, subject) {
        var $a, $$63, self = this, $case = nil, expanded_subs = nil;

        
        
        if (subject == null) {
          subject = nil;
        };
        return (function() {$case = subs;
        if ($$$('::', 'Symbol')['$===']($case)) {if (subs['$==']("none")) {
          return nil
        } else {
          return ($truthy($a = $$($nesting, 'SUB_GROUPS')['$[]'](subs)) ? $a : [subs])
        }}
        else if ($$$('::', 'Array')['$===']($case)) {
        expanded_subs = [];
        $send(subs, 'each', [], ($$63 = function(key){var self = $$63.$$s || this, sub_group = nil;

        
          
          if (key == null) {
            key = nil;
          };
          if (key['$==']("none")) {
            return nil
          } else if ($truthy((sub_group = $$($nesting, 'SUB_GROUPS')['$[]'](key)))) {
            return (expanded_subs = $rb_plus(expanded_subs, sub_group))
          } else {
            return expanded_subs['$<<'](key)
          };}, $$63.$$s = self, $$63.$$arity = 1, $$63));
        if ($truthy(expanded_subs['$empty?']())) {
          return nil
        } else {
          return expanded_subs
        };}
        else {return self.$resolve_subs(subs, "inline", nil, subject)}})();
      }, $Substitutors_expand_subs$62.$$arity = -2);
      
      Opal.def(self, '$commit_subs', $Substitutors_commit_subs$64 = function $$commit_subs() {
        var $a, $b, $c, $d, self = this, default_subs = nil, $case = nil, custom_subs = nil, syntax_hl = nil, idx = nil, $writer = nil;
        if (self.default_subs == null) self.default_subs = nil;
        if (self.content_model == null) self.content_model = nil;
        if (self.context == null) self.context = nil;
        if (self.subs == null) self.subs = nil;
        if (self.attributes == null) self.attributes = nil;
        if (self.style == null) self.style = nil;
        if (self.document == null) self.document = nil;

        
        if ($truthy((default_subs = self.default_subs))) {
        } else {
          $case = self.content_model;
          if ("simple"['$===']($case)) {default_subs = $$($nesting, 'NORMAL_SUBS')}
          else if ("verbatim"['$===']($case)) {default_subs = (function() {if (self.context['$==']("verse")) {
            return $$($nesting, 'NORMAL_SUBS')
          } else {
            return $$($nesting, 'VERBATIM_SUBS')
          }; return nil; })()}
          else if ("raw"['$===']($case)) {default_subs = (function() {if (self.context['$==']("stem")) {
            return $$($nesting, 'BASIC_SUBS')
          } else {
            return $$($nesting, 'NO_SUBS')
          }; return nil; })()}
          else {return self.subs}
        };
        if ($truthy((custom_subs = self.attributes['$[]']("subs")))) {
          self.subs = ($truthy($a = self.$resolve_block_subs(custom_subs, default_subs, self.context)) ? $a : [])
        } else {
          self.subs = default_subs.$drop(0)
        };
        if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = (($d = self.context['$==']("listing")) ? self.style['$==']("source") : self.context['$==']("listing"))) ? (syntax_hl = self.document.$syntax_highlighter()) : $c)) ? syntax_hl['$highlight?']() : $b)) ? (idx = self.subs.$index("specialcharacters")) : $a))) {
          
          $writer = [idx, "highlight"];
          $send(self.subs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        return nil;
      }, $Substitutors_commit_subs$64.$$arity = 0);
      
      Opal.def(self, '$parse_attributes', $Substitutors_parse_attributes$65 = function $$parse_attributes(attrlist, posattrs, opts) {
        var $a, self = this, block = nil, into = nil;
        if (self.document == null) self.document = nil;

        
        
        if (posattrs == null) {
          posattrs = [];
        };
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        if ($truthy((function() {if ($truthy(attrlist)) {
          return attrlist['$empty?']()
        } else {
          return true
        }; return nil; })())) {
          return $hash2([], {})};
        if ($truthy(opts['$[]']("unescape_input"))) {
          attrlist = self.$normalize_text(attrlist, true, true)};
        if ($truthy(($truthy($a = opts['$[]']("sub_input")) ? attrlist['$include?']($$($nesting, 'ATTR_REF_HEAD')) : $a))) {
          attrlist = self.document.$sub_attributes(attrlist)};
        if ($truthy(opts['$[]']("sub_result"))) {
          block = self};
        if ($truthy((into = opts['$[]']("into")))) {
          return $$($nesting, 'AttributeList').$new(attrlist, block).$parse_into(into, posattrs)
        } else {
          return $$($nesting, 'AttributeList').$new(attrlist, block).$parse(posattrs)
        };
      }, $Substitutors_parse_attributes$65.$$arity = -2);
      self.$private();
      
      Opal.def(self, '$extract_attributes_from_text', $Substitutors_extract_attributes_from_text$66 = function $$extract_attributes_from_text(text, default_text) {
        var self = this, attrlist = nil, resolved_text = nil, attrs = nil;

        
        
        if (default_text == null) {
          default_text = nil;
        };
        attrlist = (function() {if ($truthy(text['$include?']($$($nesting, 'LF')))) {
          
          return text.$tr($$($nesting, 'LF'), " ");
        } else {
          return text
        }; return nil; })();
        if ($truthy((resolved_text = (attrs = $$($nesting, 'AttributeList').$new(attrlist, self).$parse())['$[]'](1)))) {
          if (resolved_text['$=='](attrlist)) {
            return [text, attrs.$clear()]
          } else {
            return [resolved_text, attrs]
          }
        } else {
          return [default_text, attrs]
        };
      }, $Substitutors_extract_attributes_from_text$66.$$arity = -2);
      
      Opal.def(self, '$extract_callouts', $Substitutors_extract_callouts$67 = function $$extract_callouts(source) {
        var $$68, self = this, callout_marks = nil, autonum = nil, lineno = nil, last_lineno = nil, callout_rx = nil;

        
        callout_marks = $hash2([], {});
        autonum = (lineno = 0);
        last_lineno = nil;
        callout_rx = (function() {if ($truthy(self['$attr?']("line-comment"))) {
          return $$($nesting, 'CalloutExtractRxMap')['$[]'](self.$attr("line-comment"))
        } else {
          return $$($nesting, 'CalloutExtractRx')
        }; return nil; })();
        source = $send(source.$split($$($nesting, 'LF'), -1), 'map', [], ($$68 = function(line){var self = $$68.$$s || this, $$69;

        
          
          if (line == null) {
            line = nil;
          };
          lineno = $rb_plus(lineno, 1);
          return $send(line, 'gsub', [callout_rx], ($$69 = function(){var self = $$69.$$s || this, $a, $b, $writer = nil;

          if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](2)))) {
              return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$sub($$($nesting, 'RS'), "")
            } else {
              
              ($truthy($a = callout_marks['$[]'](lineno)) ? $a : (($writer = [lineno, []]), $send(callout_marks, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))['$<<']([($truthy($a = (($b = $gvars['~']) === nil ? nil : $b['$[]'](1))) ? $a : (function() {if ((($b = $gvars['~']) === nil ? nil : $b['$[]'](3))['$==']("--")) {
                return ["<!--", "-->"]
              } else {
                return nil
              }; return nil; })()), (function() {if ((($a = $gvars['~']) === nil ? nil : $a['$[]'](4))['$=='](".")) {
                return (autonum = $rb_plus(autonum, 1)).$to_s()
              } else {
                return (($a = $gvars['~']) === nil ? nil : $a['$[]'](4))
              }; return nil; })()]);
              last_lineno = lineno;
              return "";
            }}, $$69.$$s = self, $$69.$$arity = 0, $$69));}, $$68.$$s = self, $$68.$$arity = 1, $$68)).$join($$($nesting, 'LF'));
        if ($truthy(last_lineno)) {
          if (last_lineno['$=='](lineno)) {
            source = "" + (source) + ($$($nesting, 'LF'))}
        } else {
          callout_marks = nil
        };
        return [source, callout_marks];
      }, $Substitutors_extract_callouts$67.$$arity = 1);
      
      Opal.def(self, '$restore_callouts', $Substitutors_restore_callouts$70 = function $$restore_callouts(source, callout_marks, source_offset) {
        var $$71, self = this, preamble = nil, lineno = nil;

        
        
        if (source_offset == null) {
          source_offset = nil;
        };
        if ($truthy(source_offset)) {
          
          preamble = source.$slice(0, source_offset);
          source = source.$slice(source_offset, source.$length());
        } else {
          preamble = ""
        };
        lineno = 0;
        return $rb_plus(preamble, $send(source.$split($$($nesting, 'LF'), -1), 'map', [], ($$71 = function(line){var self = $$71.$$s || this, $a, $b, $$72, conums = nil, guard = nil, numeral = nil;
          if (self.document == null) self.document = nil;

        
          
          if (line == null) {
            line = nil;
          };
          if ($truthy((conums = callout_marks.$delete((lineno = $rb_plus(lineno, 1)))))) {
            if (conums.$size()['$=='](1)) {
              
              $b = conums['$[]'](0), $a = Opal.to_ary($b), (guard = ($a[0] == null ? nil : $a[0])), (numeral = ($a[1] == null ? nil : $a[1])), $b;
              return "" + (line) + ($$($nesting, 'Inline').$new(self, "callout", numeral, $hash2(["id", "attributes"], {"id": self.document.$callouts().$read_next_id(), "attributes": $hash2(["guard"], {"guard": guard})})).$convert());
            } else {
              return "" + (line) + ($send(conums, 'map', [], ($$72 = function(guard_it, numeral_it){var self = $$72.$$s || this;
                if (self.document == null) self.document = nil;

              
                
                if (guard_it == null) {
                  guard_it = nil;
                };
                
                if (numeral_it == null) {
                  numeral_it = nil;
                };
                return $$($nesting, 'Inline').$new(self, "callout", numeral_it, $hash2(["id", "attributes"], {"id": self.document.$callouts().$read_next_id(), "attributes": $hash2(["guard"], {"guard": guard_it})})).$convert();}, $$72.$$s = self, $$72.$$arity = 2, $$72)).$join(" "))
            }
          } else {
            return line
          };}, $$71.$$s = self, $$71.$$arity = 1, $$71)).$join($$($nesting, 'LF')));
      }, $Substitutors_restore_callouts$70.$$arity = -3);
      
      Opal.def(self, '$extract_inner_passthrough', $Substitutors_extract_inner_passthrough$73 = function $$extract_inner_passthrough(text, pre) {
        var $a, $b, self = this, $writer = nil, passthru_key = nil;
        if (self.passthroughs == null) self.passthroughs = nil;

        if ($truthy(($truthy($a = ($truthy($b = text['$end_with?']("+")) ? text['$start_with?']("+", "\\+") : $b)) ? $$($nesting, 'SinglePlusInlinePassRx')['$=~'](text) : $a))) {
          if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)))) {
            return "" + (pre) + "`+" + ((($a = $gvars['~']) === nil ? nil : $a['$[]'](2))) + "+`"
          } else {
            
            
            $writer = [(passthru_key = self.passthroughs.$size()), $hash2(["text", "subs"], {"text": (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), "subs": $$($nesting, 'BASIC_SUBS')})];
            $send(self.passthroughs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            return "" + (pre) + "`" + ($$($nesting, 'PASS_START')) + (passthru_key) + ($$($nesting, 'PASS_END')) + "`";
          }
        } else {
          return "" + (pre) + "`" + (text) + "`"
        }
      }, $Substitutors_extract_inner_passthrough$73.$$arity = 2);
      
      Opal.def(self, '$convert_quoted_text', $Substitutors_convert_quoted_text$74 = function $$convert_quoted_text(match, type, scope) {
        var $a, self = this, attrs = nil, unescaped_attrs = nil, attrlist = nil, id = nil, attributes = nil;

        
        if ($truthy(match['$[]'](0)['$start_with?']($$($nesting, 'RS')))) {
          if ($truthy((($a = scope['$==']("constrained")) ? (attrs = match['$[]'](2)) : scope['$==']("constrained")))) {
            unescaped_attrs = "" + "[" + (attrs) + "]"
          } else {
            return match['$[]'](0).$slice(1, match['$[]'](0).$length())
          }};
        if (scope['$==']("constrained")) {
          if ($truthy(unescaped_attrs)) {
            return "" + (unescaped_attrs) + ($$($nesting, 'Inline').$new(self, "quoted", match['$[]'](3), $hash2(["type"], {"type": type})).$convert())
          } else {
            
            if ($truthy((attrlist = match['$[]'](2)))) {
              
              id = (attributes = self.$parse_quoted_text_attributes(attrlist))['$[]']("id");
              if (type['$==']("mark")) {
                type = "unquoted"};};
            return "" + (match['$[]'](1)) + ($$($nesting, 'Inline').$new(self, "quoted", match['$[]'](3), $hash2(["type", "id", "attributes"], {"type": type, "id": id, "attributes": attributes})).$convert());
          }
        } else {
          
          if ($truthy((attrlist = match['$[]'](1)))) {
            
            id = (attributes = self.$parse_quoted_text_attributes(attrlist))['$[]']("id");
            if (type['$==']("mark")) {
              type = "unquoted"};};
          return $$($nesting, 'Inline').$new(self, "quoted", match['$[]'](2), $hash2(["type", "id", "attributes"], {"type": type, "id": id, "attributes": attributes})).$convert();
        };
      }, $Substitutors_convert_quoted_text$74.$$arity = 3);
      
      Opal.def(self, '$do_replacement', $Substitutors_do_replacement$75 = function $$do_replacement(m, replacement, restore) {
        var self = this, captured = nil, $case = nil;

        if ($truthy((captured = m['$[]'](0))['$include?']($$($nesting, 'RS')))) {
          return captured.$sub($$($nesting, 'RS'), "")
        } else {
          return (function() {$case = restore;
          if ("none"['$===']($case)) {return replacement}
          else if ("bounding"['$===']($case)) {return $rb_plus($rb_plus(m['$[]'](1), replacement), m['$[]'](2))}
          else {return $rb_plus(m['$[]'](1), replacement)}})()
        }
      }, $Substitutors_do_replacement$75.$$arity = 3);
      if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
      } else {
        nil
      };
      
      Opal.def(self, '$parse_quoted_text_attributes', $Substitutors_parse_quoted_text_attributes$76 = function $$parse_quoted_text_attributes(str) {
        var $a, $b, self = this, before = nil, _ = nil, after = nil, attrs = nil, $writer = nil, id = nil, roles = nil;

        
        if ($truthy(str['$include?']($$($nesting, 'ATTR_REF_HEAD')))) {
          str = self.$sub_attributes(str)};
        if ($truthy(str['$include?'](","))) {
          str = str.$slice(0, str.$index(","))};
        if ($truthy((str = str.$strip())['$empty?']())) {
          return $hash2([], {})
        } else if ($truthy(($truthy($a = str['$start_with?'](".", "#")) ? $$($nesting, 'Compliance').$shorthand_property_syntax() : $a))) {
          
          $b = str.$partition("#"), $a = Opal.to_ary($b), (before = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), (after = ($a[2] == null ? nil : $a[2])), $b;
          attrs = $hash2([], {});
          if ($truthy(after['$empty?']())) {
            if ($truthy($rb_gt(before.$length(), 1))) {
              
              $writer = ["role", before.$tr(".", " ").$lstrip()];
              $send(attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];}
          } else {
            
            $b = after.$partition("."), $a = Opal.to_ary($b), (id = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), (roles = ($a[2] == null ? nil : $a[2])), $b;
            if ($truthy(id['$empty?']())) {
            } else {
              
              $writer = ["id", id];
              $send(attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            };
            if ($truthy(roles['$empty?']())) {
              if ($truthy($rb_gt(before.$length(), 1))) {
                
                $writer = ["role", before.$tr(".", " ").$lstrip()];
                $send(attrs, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];}
            } else if ($truthy($rb_gt(before.$length(), 1))) {
              
              $writer = ["role", $rb_plus($rb_plus(before, "."), roles).$tr(".", " ").$lstrip()];
              $send(attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            } else {
              
              $writer = ["role", roles.$tr(".", " ")];
              $send(attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            };
          };
          return attrs;
        } else {
          return $hash2(["role"], {"role": str})
        };
      }, $Substitutors_parse_quoted_text_attributes$76.$$arity = 1);
      
      Opal.def(self, '$normalize_text', $Substitutors_normalize_text$77 = function $$normalize_text(text, normalize_whitespace, unescape_closing_square_brackets) {
        var $a, self = this;

        
        
        if (normalize_whitespace == null) {
          normalize_whitespace = nil;
        };
        
        if (unescape_closing_square_brackets == null) {
          unescape_closing_square_brackets = nil;
        };
        if ($truthy(text['$empty?']())) {
        } else {
          
          if ($truthy(normalize_whitespace)) {
            text = text.$strip().$tr($$($nesting, 'LF'), " ")};
          if ($truthy(($truthy($a = unescape_closing_square_brackets) ? text['$include?']($$($nesting, 'R_SB')) : $a))) {
            text = text.$gsub($$($nesting, 'ESC_R_SB'), $$($nesting, 'R_SB'))};
        };
        return text;
      }, $Substitutors_normalize_text$77.$$arity = -2);
      
      Opal.def(self, '$split_simple_csv', $Substitutors_split_simple_csv$78 = function $$split_simple_csv(str) {
        var $$79, $$80, self = this, values = nil, accum = nil, quote_open = nil;

        if ($truthy(str['$empty?']())) {
          return []
        } else if ($truthy(str['$include?']("\""))) {
          
          values = [];
          accum = "";
          quote_open = nil;
          $send(str, 'each_char', [], ($$79 = function(c){var self = $$79.$$s || this, $case = nil;

          
            
            if (c == null) {
              c = nil;
            };
            return (function() {$case = c;
            if (","['$===']($case)) {if ($truthy(quote_open)) {
              return (accum = $rb_plus(accum, c))
            } else {
              
              values['$<<'](accum.$strip());
              return (accum = "");
            }}
            else if ("\""['$===']($case)) {return (quote_open = quote_open['$!']())}
            else {return (accum = $rb_plus(accum, c))}})();}, $$79.$$s = self, $$79.$$arity = 1, $$79));
          return values['$<<'](accum.$strip());
        } else {
          return $send(str.$split(","), 'map', [], ($$80 = function(it){var self = $$80.$$s || this;

          
            
            if (it == null) {
              it = nil;
            };
            return it.$strip();}, $$80.$$s = self, $$80.$$arity = 1, $$80))
        }
      }, $Substitutors_split_simple_csv$78.$$arity = 1);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/version"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    Opal.const_set($nesting[0], 'VERSION', "2.0.17")
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/abstract_node"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$include', '$attr_reader', '$attr_accessor', '$==', '$document', '$to_s', '$[]', '$merge', '$raise', '$converter', '$attributes', '$key?', '$[]=', '$-', '$delete', '$tap', '$new', '$each_key', '$end_with?', '$<<', '$slice', '$length', '$update', '$split', '$include?', '$===', '$join', '$empty?', '$apply_reftext_subs', '$attr?', '$attr', '$extname?', '$image_uri', '$<', '$safe', '$uriish?', '$encode_spaces_in_uri', '$normalize_web_path', '$generate_data_uri_from_uri', '$generate_data_uri', '$extname', '$normalize_system_path', '$readable?', '$strict_encode64', '$binread', '$warn', '$logger', '$require_library', '$!', '$open_uri', '$content_type', '$read', '$base_dir', '$root?', '$path_resolver', '$system_path', '$web_path', '$!=', '$prepare_source_string', '$fetch', '$read_asset']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'AbstractNode');

      var $nesting = [self].concat($parent_nesting), $AbstractNode_initialize$1, $AbstractNode_block$ques$2, $AbstractNode_inline$ques$3, $AbstractNode_converter$4, $AbstractNode_parent$eq$5, $AbstractNode_attr$6, $AbstractNode_attr$ques$7, $AbstractNode_set_attr$8, $AbstractNode_remove_attr$9, $AbstractNode_option$ques$10, $AbstractNode_set_option$11, $AbstractNode_enabled_options$12, $AbstractNode_update_attributes$15, $AbstractNode_role$16, $AbstractNode_roles$17, $AbstractNode_role$ques$18, $AbstractNode_has_role$ques$19, $AbstractNode_role$eq$20, $AbstractNode_add_role$21, $AbstractNode_remove_role$22, $AbstractNode_reftext$23, $AbstractNode_reftext$ques$24, $AbstractNode_icon_uri$25, $AbstractNode_image_uri$26, $AbstractNode_media_uri$27, $AbstractNode_generate_data_uri$28, $AbstractNode_generate_data_uri_from_uri$29, $AbstractNode_normalize_asset_path$31, $AbstractNode_normalize_system_path$32, $AbstractNode_normalize_web_path$33, $AbstractNode_read_asset$34, $AbstractNode_read_contents$35, $AbstractNode_is_uri$ques$38;

      self.$$prototype.document = self.$$prototype.attributes = self.$$prototype.parent = nil;
      
      self.$include($$($nesting, 'Logging'));
      self.$include($$($nesting, 'Substitutors'));
      self.$attr_reader("attributes");
      self.$attr_reader("context");
      self.$attr_reader("document");
      self.$attr_accessor("id");
      self.$attr_reader("node_name");
      self.$attr_reader("parent");
      
      Opal.def(self, '$initialize', $AbstractNode_initialize$1 = function $$initialize(parent, context, opts) {
        var self = this, attrs = nil;

        
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        if (context['$==']("document")) {
          self.document = self
        } else if ($truthy(parent)) {
          self.document = (self.parent = parent).$document()};
        self.node_name = (self.context = context).$to_s();
        self.attributes = (function() {if ($truthy((attrs = opts['$[]']("attributes")))) {
          return attrs.$merge()
        } else {
          return $hash2([], {})
        }; return nil; })();
        return (self.passthroughs = []);
      }, $AbstractNode_initialize$1.$$arity = -3);
      
      Opal.def(self, '$block?', $AbstractNode_block$ques$2 = function() {
        var self = this;

        return self.$raise($$$('::', 'NotImplementedError'))
      }, $AbstractNode_block$ques$2.$$arity = 0);
      
      Opal.def(self, '$inline?', $AbstractNode_inline$ques$3 = function() {
        var self = this;

        return self.$raise($$$('::', 'NotImplementedError'))
      }, $AbstractNode_inline$ques$3.$$arity = 0);
      
      Opal.def(self, '$converter', $AbstractNode_converter$4 = function $$converter() {
        var self = this;

        return self.document.$converter()
      }, $AbstractNode_converter$4.$$arity = 0);
      
      Opal.def(self, '$parent=', $AbstractNode_parent$eq$5 = function(parent) {
        var $a, self = this;

        return $a = [parent, parent.$document()], (self.parent = $a[0]), (self.document = $a[1]), $a
      }, $AbstractNode_parent$eq$5.$$arity = 1);
      
      Opal.def(self, '$attr', $AbstractNode_attr$6 = function $$attr(name, default_value, fallback_name) {
        var $a, $b, $c, $d, self = this;

        
        
        if (default_value == null) {
          default_value = nil;
        };
        
        if (fallback_name == null) {
          fallback_name = nil;
        };
        return ($truthy($a = self.attributes['$[]'](name.$to_s())) ? $a : ($truthy($b = ($truthy($c = ($truthy($d = fallback_name) ? self.parent : $d)) ? self.document.$attributes()['$[]']((function() {if (fallback_name['$=='](true)) {
          return name
        } else {
          return fallback_name
        }; return nil; })().$to_s()) : $c)) ? $b : default_value));
      }, $AbstractNode_attr$6.$$arity = -2);
      
      Opal.def(self, '$attr?', $AbstractNode_attr$ques$7 = function(name, expected_value, fallback_name) {
        var $a, $b, self = this;

        
        
        if (expected_value == null) {
          expected_value = nil;
        };
        
        if (fallback_name == null) {
          fallback_name = nil;
        };
        if ($truthy(expected_value)) {
          return expected_value['$=='](($truthy($a = self.attributes['$[]'](name.$to_s())) ? $a : (function() {if ($truthy(($truthy($b = fallback_name) ? self.parent : $b))) {
            return self.document.$attributes()['$[]']((function() {if (fallback_name['$=='](true)) {
              return name
            } else {
              return fallback_name
            }; return nil; })().$to_s())
          } else {
            return nil
          }; return nil; })()))
        } else {
          return ($truthy($a = self.attributes['$key?'](name.$to_s())) ? $a : (function() {if ($truthy(($truthy($b = fallback_name) ? self.parent : $b))) {
            
            return self.document.$attributes()['$key?']((function() {if (fallback_name['$=='](true)) {
              return name
            } else {
              return fallback_name
            }; return nil; })().$to_s());
          } else {
            return false
          }; return nil; })())
        };
      }, $AbstractNode_attr$ques$7.$$arity = -2);
      
      Opal.def(self, '$set_attr', $AbstractNode_set_attr$8 = function $$set_attr(name, value, overwrite) {
        var $a, self = this, $writer = nil;

        
        
        if (value == null) {
          value = "";
        };
        
        if (overwrite == null) {
          overwrite = true;
        };
        if ($truthy((($a = overwrite['$=='](false)) ? self.attributes['$key?'](name) : overwrite['$=='](false)))) {
          return false
        } else {
          
          
          $writer = [name, value];
          $send(self.attributes, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return true;
        };
      }, $AbstractNode_set_attr$8.$$arity = -2);
      
      Opal.def(self, '$remove_attr', $AbstractNode_remove_attr$9 = function $$remove_attr(name) {
        var self = this;

        return self.attributes.$delete(name)
      }, $AbstractNode_remove_attr$9.$$arity = 1);
      
      Opal.def(self, '$option?', $AbstractNode_option$ques$10 = function(name) {
        var self = this;

        if ($truthy(self.attributes['$[]']("" + (name) + "-option"))) {
          return true
        } else {
          return false
        }
      }, $AbstractNode_option$ques$10.$$arity = 1);
      
      Opal.def(self, '$set_option', $AbstractNode_set_option$11 = function $$set_option(name) {
        var self = this, $writer = nil;

        
        
        $writer = ["" + (name) + "-option", ""];
        $send(self.attributes, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        return nil;
      }, $AbstractNode_set_option$11.$$arity = 1);
      
      Opal.def(self, '$enabled_options', $AbstractNode_enabled_options$12 = function $$enabled_options() {
        var $$13, self = this;

        return $send($$$('::', 'Set').$new(), 'tap', [], ($$13 = function(accum){var self = $$13.$$s || this, $$14;
          if (self.attributes == null) self.attributes = nil;

        
          
          if (accum == null) {
            accum = nil;
          };
          return $send(self.attributes, 'each_key', [], ($$14 = function(k){var self = $$14.$$s || this;

          
            
            if (k == null) {
              k = nil;
            };
            if ($truthy(k.$to_s()['$end_with?']("-option"))) {
              return accum['$<<'](k.$slice(0, $rb_minus(k.$length(), 7)))
            } else {
              return nil
            };}, $$14.$$s = self, $$14.$$arity = 1, $$14));}, $$13.$$s = self, $$13.$$arity = 1, $$13))
      }, $AbstractNode_enabled_options$12.$$arity = 0);
      
      Opal.def(self, '$update_attributes', $AbstractNode_update_attributes$15 = function $$update_attributes(new_attributes) {
        var self = this;

        return self.attributes.$update(new_attributes)
      }, $AbstractNode_update_attributes$15.$$arity = 1);
      
      Opal.def(self, '$role', $AbstractNode_role$16 = function $$role() {
        var self = this;

        return self.attributes['$[]']("role")
      }, $AbstractNode_role$16.$$arity = 0);
      
      Opal.def(self, '$roles', $AbstractNode_roles$17 = function $$roles() {
        var self = this, val = nil;

        if ($truthy((val = self.attributes['$[]']("role")))) {
          return val.$split()
        } else {
          return []
        }
      }, $AbstractNode_roles$17.$$arity = 0);
      
      Opal.def(self, '$role?', $AbstractNode_role$ques$18 = function(expected_value) {
        var self = this;

        
        
        if (expected_value == null) {
          expected_value = nil;
        };
        if ($truthy(expected_value)) {
          return expected_value['$=='](self.attributes['$[]']("role"))
        } else {
          
          return self.attributes['$key?']("role");
        };
      }, $AbstractNode_role$ques$18.$$arity = -1);
      
      Opal.def(self, '$has_role?', $AbstractNode_has_role$ques$19 = function(name) {
        var self = this, val = nil;

        if ($truthy((val = self.attributes['$[]']("role")))) {
          
          return ((("" + " ") + (val)) + " ")['$include?']("" + " " + (name) + " ");
        } else {
          return false
        }
      }, $AbstractNode_has_role$ques$19.$$arity = 1);
      
      Opal.def(self, '$role=', $AbstractNode_role$eq$20 = function(names) {
        var self = this, $writer = nil;

        
        $writer = ["role", (function() {if ($truthy($$$('::', 'Array')['$==='](names))) {
          
          return names.$join(" ");
        } else {
          return names
        }; return nil; })()];
        $send(self.attributes, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];
      }, $AbstractNode_role$eq$20.$$arity = 1);
      
      Opal.def(self, '$add_role', $AbstractNode_add_role$21 = function $$add_role(name) {
        var self = this, val = nil, $writer = nil;

        if ($truthy((val = self.attributes['$[]']("role")))) {
          if ($truthy(((("" + " ") + (val)) + " ")['$include?']("" + " " + (name) + " "))) {
            return false
          } else {
            
            
            $writer = ["role", "" + (val) + " " + (name)];
            $send(self.attributes, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            return true;
          }
        } else {
          
          
          $writer = ["role", name];
          $send(self.attributes, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return true;
        }
      }, $AbstractNode_add_role$21.$$arity = 1);
      
      Opal.def(self, '$remove_role', $AbstractNode_remove_role$22 = function $$remove_role(name) {
        var $a, self = this, val = nil, $writer = nil;

        if ($truthy(($truthy($a = (val = self.attributes['$[]']("role"))) ? (val = val.$split()).$delete(name) : $a))) {
          
          if ($truthy(val['$empty?']())) {
            self.attributes.$delete("role")
          } else {
            
            $writer = ["role", val.$join(" ")];
            $send(self.attributes, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          };
          return true;
        } else {
          return false
        }
      }, $AbstractNode_remove_role$22.$$arity = 1);
      
      Opal.def(self, '$reftext', $AbstractNode_reftext$23 = function $$reftext() {
        var self = this, val = nil;

        if ($truthy((val = self.attributes['$[]']("reftext")))) {
          
          return self.$apply_reftext_subs(val);
        } else {
          return nil
        }
      }, $AbstractNode_reftext$23.$$arity = 0);
      
      Opal.def(self, '$reftext?', $AbstractNode_reftext$ques$24 = function() {
        var self = this;

        return self.attributes['$key?']("reftext")
      }, $AbstractNode_reftext$ques$24.$$arity = 0);
      
      Opal.def(self, '$icon_uri', $AbstractNode_icon_uri$25 = function $$icon_uri(name) {
        var self = this, icon = nil;

        
        if ($truthy(self['$attr?']("icon"))) {
          
          icon = self.$attr("icon");
          if ($truthy($$($nesting, 'Helpers')['$extname?'](icon))) {
          } else {
            icon = "" + (icon) + "." + (self.document.$attr("icontype", "png"))
          };
        } else {
          icon = "" + (name) + "." + (self.document.$attr("icontype", "png"))
        };
        return self.$image_uri(icon, "iconsdir");
      }, $AbstractNode_icon_uri$25.$$arity = 1);
      
      Opal.def(self, '$image_uri', $AbstractNode_image_uri$26 = function $$image_uri(target_image, asset_dir_key) {
        var $a, $b, $c, $d, self = this, doc = nil, images_base = nil;

        
        
        if (asset_dir_key == null) {
          asset_dir_key = "imagesdir";
        };
        if ($truthy(($truthy($a = $rb_lt((doc = self.document).$safe(), $$$($$($nesting, 'SafeMode'), 'SECURE'))) ? doc['$attr?']("data-uri") : $a))) {
          if ($truthy(($truthy($a = ($truthy($b = $$($nesting, 'Helpers')['$uriish?'](target_image)) ? (target_image = $$($nesting, 'Helpers').$encode_spaces_in_uri(target_image)) : $b)) ? $a : ($truthy($b = ($truthy($c = ($truthy($d = asset_dir_key) ? (images_base = doc.$attr(asset_dir_key)) : $d)) ? $$($nesting, 'Helpers')['$uriish?'](images_base) : $c)) ? (target_image = self.$normalize_web_path(target_image, images_base, false)) : $b)))) {
            if ($truthy(doc['$attr?']("allow-uri-read"))) {
              
              return self.$generate_data_uri_from_uri(target_image, doc['$attr?']("cache-uri"));
            } else {
              return target_image
            }
          } else {
            return self.$generate_data_uri(target_image, asset_dir_key)
          }
        } else {
          return self.$normalize_web_path(target_image, (function() {if ($truthy(asset_dir_key)) {
            
            return doc.$attr(asset_dir_key);
          } else {
            return nil
          }; return nil; })())
        };
      }, $AbstractNode_image_uri$26.$$arity = -2);
      
      Opal.def(self, '$media_uri', $AbstractNode_media_uri$27 = function $$media_uri(target, asset_dir_key) {
        var self = this;

        
        
        if (asset_dir_key == null) {
          asset_dir_key = "imagesdir";
        };
        return self.$normalize_web_path(target, (function() {if ($truthy(asset_dir_key)) {
          return self.document.$attr(asset_dir_key)
        } else {
          return nil
        }; return nil; })());
      }, $AbstractNode_media_uri$27.$$arity = -2);
      
      Opal.def(self, '$generate_data_uri', $AbstractNode_generate_data_uri$28 = function $$generate_data_uri(target_image, asset_dir_key) {
        var self = this, ext = nil, mimetype = nil, image_path = nil;

        
        
        if (asset_dir_key == null) {
          asset_dir_key = nil;
        };
        if ($truthy((ext = $$($nesting, 'Helpers').$extname(target_image, nil)))) {
          mimetype = (function() {if (ext['$=='](".svg")) {
            return "image/svg+xml"
          } else {
            return "" + "image/" + (ext.$slice(1, ext.$length()))
          }; return nil; })()
        } else {
          mimetype = "application/octet-stream"
        };
        if ($truthy(asset_dir_key)) {
          image_path = self.$normalize_system_path(target_image, self.document.$attr(asset_dir_key), nil, $hash2(["target_name"], {"target_name": "image"}))
        } else {
          image_path = self.$normalize_system_path(target_image)
        };
        if ($truthy($$$('::', 'File')['$readable?'](image_path))) {
          return "" + "data:" + (mimetype) + ";base64," + ($$$('::', 'Base64').$strict_encode64($$$('::', 'File').$binread(image_path)))
        } else {
          
          self.$logger().$warn("" + "image to embed not found or not readable: " + (image_path));
          return "" + "data:" + (mimetype) + ";base64,";
        };
      }, $AbstractNode_generate_data_uri$28.$$arity = -2);
      
      Opal.def(self, '$generate_data_uri_from_uri', $AbstractNode_generate_data_uri_from_uri$29 = function $$generate_data_uri_from_uri(image_uri, cache_uri) {
        var $a, $b, $$30, self = this, mimetype = nil, bindata = nil;

        
        
        if (cache_uri == null) {
          cache_uri = false;
        };
        if ($truthy(cache_uri)) {
          $$($nesting, 'Helpers').$require_library("open-uri/cached", "open-uri-cached")
        } else if ($truthy($$($nesting, 'RUBY_ENGINE_OPAL')['$!']())) {
          $$$('::', 'OpenURI')};
        
        try {
          
          $b = $send($$$('::', 'OpenURI'), 'open_uri', [image_uri, $$($nesting, 'URI_READ_MODE')], ($$30 = function(f){var self = $$30.$$s || this;

          
            
            if (f == null) {
              f = nil;
            };
            return [f.$content_type(), f.$read()];}, $$30.$$s = self, $$30.$$arity = 1, $$30)), $a = Opal.to_ary($b), (mimetype = ($a[0] == null ? nil : $a[0])), (bindata = ($a[1] == null ? nil : $a[1])), $b;
          return "" + "data:" + (mimetype) + ";base64," + ($$$('::', 'Base64').$strict_encode64(bindata));
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
            try {
              
              self.$logger().$warn("" + "could not retrieve image data from URI: " + (image_uri));
              return image_uri;
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };;
      }, $AbstractNode_generate_data_uri_from_uri$29.$$arity = -2);
      
      Opal.def(self, '$normalize_asset_path', $AbstractNode_normalize_asset_path$31 = function $$normalize_asset_path(asset_ref, asset_name, autocorrect) {
        var self = this;

        
        
        if (asset_name == null) {
          asset_name = "path";
        };
        
        if (autocorrect == null) {
          autocorrect = true;
        };
        return self.$normalize_system_path(asset_ref, self.document.$base_dir(), nil, $hash2(["target_name", "recover"], {"target_name": asset_name, "recover": autocorrect}));
      }, $AbstractNode_normalize_asset_path$31.$$arity = -2);
      
      Opal.def(self, '$normalize_system_path', $AbstractNode_normalize_system_path$32 = function $$normalize_system_path(target, start, jail, opts) {
        var $a, self = this, doc = nil;

        
        
        if (start == null) {
          start = nil;
        };
        
        if (jail == null) {
          jail = nil;
        };
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        if ($truthy($rb_lt((doc = self.document).$safe(), $$$($$($nesting, 'SafeMode'), 'SAFE')))) {
          if ($truthy(start)) {
            if ($truthy(doc.$path_resolver()['$root?'](start))) {
            } else {
              start = $$$('::', 'File').$join(doc.$base_dir(), start)
            }
          } else {
            start = doc.$base_dir()
          }
        } else {
          
          start = ($truthy($a = start) ? $a : doc.$base_dir());
          jail = ($truthy($a = jail) ? $a : doc.$base_dir());
        };
        return doc.$path_resolver().$system_path(target, start, jail, opts);
      }, $AbstractNode_normalize_system_path$32.$$arity = -2);
      
      Opal.def(self, '$normalize_web_path', $AbstractNode_normalize_web_path$33 = function $$normalize_web_path(target, start, preserve_uri_target) {
        var $a, self = this;

        
        
        if (start == null) {
          start = nil;
        };
        
        if (preserve_uri_target == null) {
          preserve_uri_target = true;
        };
        if ($truthy(($truthy($a = preserve_uri_target) ? $$($nesting, 'Helpers')['$uriish?'](target) : $a))) {
          return $$($nesting, 'Helpers').$encode_spaces_in_uri(target)
        } else {
          return self.document.$path_resolver().$web_path(target, start)
        };
      }, $AbstractNode_normalize_web_path$33.$$arity = -2);
      
      Opal.def(self, '$read_asset', $AbstractNode_read_asset$34 = function $$read_asset(path, opts) {
        var $a, self = this;

        
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        if ($truthy($$$('::', 'Hash')['$==='](opts))) {
        } else {
          opts = $hash2(["warn_on_failure"], {"warn_on_failure": opts['$!='](false)})
        };
        if ($truthy($$$('::', 'File')['$readable?'](path))) {
          if ($truthy(opts['$[]']("normalize"))) {
            
            return $$($nesting, 'Helpers').$prepare_source_string($$$('::', 'File').$read(path, $hash2(["mode"], {"mode": $$($nesting, 'FILE_READ_MODE')}))).$join($$($nesting, 'LF'));
          } else {
            
            return $$$('::', 'File').$read(path, $hash2(["mode"], {"mode": $$($nesting, 'FILE_READ_MODE')}));
          }
        } else if ($truthy(opts['$[]']("warn_on_failure"))) {
          
          self.$logger().$warn("" + (($truthy($a = self.$attr("docfile")) ? $a : "<stdin>")) + ": " + (($truthy($a = opts['$[]']("label")) ? $a : "file")) + " does not exist or cannot be read: " + (path));
          return nil;
        } else {
          return nil
        };
      }, $AbstractNode_read_asset$34.$$arity = -2);
      
      Opal.def(self, '$read_contents', $AbstractNode_read_contents$35 = function $$read_contents(target, opts) {
        var $a, $b, $c, $$36, $$37, self = this, doc = nil, start = nil, contents = nil;

        
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        doc = self.document;
        if ($truthy(($truthy($a = $$($nesting, 'Helpers')['$uriish?'](target)) ? $a : ($truthy($b = ($truthy($c = (start = opts['$[]']("start"))) ? $$($nesting, 'Helpers')['$uriish?'](start) : $c)) ? (target = doc.$path_resolver().$web_path(target, start)) : $b)))) {
          if ($truthy(doc['$attr?']("allow-uri-read"))) {
            
            if ($truthy(doc['$attr?']("cache-uri"))) {
              $$($nesting, 'Helpers').$require_library("open-uri/cached", "open-uri-cached")};
            
            try {
              if ($truthy(opts['$[]']("normalize"))) {
                contents = $$($nesting, 'Helpers').$prepare_source_string($send($$$('::', 'OpenURI'), 'open_uri', [target, $$($nesting, 'URI_READ_MODE')], ($$36 = function(f){var self = $$36.$$s || this;

                
                  
                  if (f == null) {
                    f = nil;
                  };
                  return f.$read();}, $$36.$$s = self, $$36.$$arity = 1, $$36))).$join($$($nesting, 'LF'))
              } else {
                contents = $send($$$('::', 'OpenURI'), 'open_uri', [target, $$($nesting, 'URI_READ_MODE')], ($$37 = function(f){var self = $$37.$$s || this;

                
                  
                  if (f == null) {
                    f = nil;
                  };
                  return f.$read();}, $$37.$$s = self, $$37.$$arity = 1, $$37))
              }
            } catch ($err) {
              if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
                try {
                  if ($truthy(opts.$fetch("warn_on_failure", true))) {
                    self.$logger().$warn("" + "could not retrieve contents of " + (($truthy($a = opts['$[]']("label")) ? $a : "asset")) + " at URI: " + (target))}
                } finally { Opal.pop_exception() }
              } else { throw $err; }
            };;
          } else if ($truthy(opts.$fetch("warn_on_failure", true))) {
            self.$logger().$warn("" + "cannot retrieve contents of " + (($truthy($a = opts['$[]']("label")) ? $a : "asset")) + " at URI: " + (target) + " (allow-uri-read attribute not enabled)")}
        } else {
          
          target = self.$normalize_system_path(target, opts['$[]']("start"), nil, $hash2(["target_name"], {"target_name": ($truthy($a = opts['$[]']("label")) ? $a : "asset")}));
          contents = self.$read_asset(target, $hash2(["normalize", "warn_on_failure", "label"], {"normalize": opts['$[]']("normalize"), "warn_on_failure": opts.$fetch("warn_on_failure", true), "label": opts['$[]']("label")}));
        };
        if ($truthy(($truthy($a = ($truthy($b = contents) ? opts['$[]']("warn_if_empty") : $b)) ? contents['$empty?']() : $a))) {
          self.$logger().$warn("" + "contents of " + (($truthy($a = opts['$[]']("label")) ? $a : "asset")) + " is empty: " + (target))};
        return contents;
      }, $AbstractNode_read_contents$35.$$arity = -2);
      return (Opal.def(self, '$is_uri?', $AbstractNode_is_uri$ques$38 = function(str) {
        var self = this;

        return $$($nesting, 'Helpers')['$uriish?'](str)
      }, $AbstractNode_is_uri$ques$38.$$arity = 1), nil) && 'is_uri?';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/abstract_block"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_reader', '$attr_writer', '$attr_accessor', '$==', '$===', '$level', '$file', '$lineno', '$playback_attributes', '$convert', '$converter', '$join', '$map', '$to_s', '$parent', '$parent=', '$-', '$<<', '$empty?', '$Integer', '$find_by_internal', '$to_proc', '$context', '$[]', '$items', '$+', '$find_index', '$include?', '$next_adjacent_block', '$blocks', '$select', '$sub_specialchars', '$match?', '$sub_replacements', '$title', '$apply_title_subs', '$delete', '$reftext', '$!', '$nil_or_empty?', '$sub_placeholder', '$sub_quotes', '$compat_mode', '$attributes', '$chomp', '$increment_and_store_counter', '$index=', '$numbered', '$sectname', '$counter', '$numeral=', '$numeral', '$caption=', '$int_to_roman', '$each', '$assign_numeral', '$reindex_sections', '$protected', '$has_role?', '$raise', '$header?', '$!=', '$flatten', '$head', '$rows', '$merge', '$body', '$foot', '$style', '$inner_document']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'AbstractBlock');

      var $nesting = [self].concat($parent_nesting), $AbstractBlock_initialize$1, $AbstractBlock_block$ques$2, $AbstractBlock_inline$ques$3, $AbstractBlock_file$4, $AbstractBlock_lineno$5, $AbstractBlock_convert$6, $AbstractBlock_content$7, $AbstractBlock_context$eq$9, $AbstractBlock_$lt$lt$10, $AbstractBlock_blocks$ques$11, $AbstractBlock_sections$ques$12, $AbstractBlock_number$13, $AbstractBlock_number$eq$14, $AbstractBlock_find_by$15, $AbstractBlock_next_adjacent_block$16, $AbstractBlock_sections$18, $AbstractBlock_alt$20, $AbstractBlock_caption$21, $AbstractBlock_captioned_title$22, $AbstractBlock_list_marker_keyword$23, $AbstractBlock_title$24, $AbstractBlock_title$ques$25, $AbstractBlock_title$eq$26, $AbstractBlock_sub$ques$27, $AbstractBlock_remove_sub$28, $AbstractBlock_xreftext$29, $AbstractBlock_assign_caption$30, $AbstractBlock_assign_numeral$31, $AbstractBlock_reindex_sections$32, $AbstractBlock_find_by_internal$34;

      self.$$prototype.source_location = self.$$prototype.document = self.$$prototype.attributes = self.$$prototype.blocks = self.$$prototype.numeral = self.$$prototype.context = self.$$prototype.parent = self.$$prototype.caption = self.$$prototype.style = self.$$prototype.converted_title = self.$$prototype.title = self.$$prototype.subs = self.$$prototype.next_section_index = self.$$prototype.next_section_ordinal = self.$$prototype.id = self.$$prototype.header = nil;
      
      self.$attr_reader("blocks");
      self.$attr_writer("caption");
      self.$attr_accessor("content_model");
      self.$attr_accessor("level");
      self.$attr_accessor("numeral");
      self.$attr_accessor("source_location");
      self.$attr_accessor("style");
      self.$attr_reader("subs");
      
      Opal.def(self, '$initialize', $AbstractBlock_initialize$1 = function $$initialize(parent, context, opts) {
        var $a, $iter = $AbstractBlock_initialize$1.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $AbstractBlock_initialize$1.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        $send(self, Opal.find_super_dispatcher(self, 'initialize', $AbstractBlock_initialize$1, false), $zuper, $iter);
        self.content_model = "compound";
        self.blocks = [];
        self.subs = [];
        self.id = (self.title = (self.caption = (self.numeral = (self.style = (self.default_subs = (self.source_location = nil))))));
        if ($truthy(($truthy($a = context['$==']("document")) ? $a : context['$==']("section")))) {
          
          self.level = (self.next_section_index = 0);
          return (self.next_section_ordinal = 1);
        } else if ($truthy($$($nesting, 'AbstractBlock')['$==='](parent))) {
          return (self.level = parent.$level())
        } else {
          return (self.level = nil)
        };
      }, $AbstractBlock_initialize$1.$$arity = -3);
      
      Opal.def(self, '$block?', $AbstractBlock_block$ques$2 = function() {
        var self = this;

        return true
      }, $AbstractBlock_block$ques$2.$$arity = 0);
      
      Opal.def(self, '$inline?', $AbstractBlock_inline$ques$3 = function() {
        var self = this;

        return false
      }, $AbstractBlock_inline$ques$3.$$arity = 0);
      
      Opal.def(self, '$file', $AbstractBlock_file$4 = function $$file() {
        var $a, self = this;

        return ($truthy($a = self.source_location) ? self.source_location.$file() : $a)
      }, $AbstractBlock_file$4.$$arity = 0);
      
      Opal.def(self, '$lineno', $AbstractBlock_lineno$5 = function $$lineno() {
        var $a, self = this;

        return ($truthy($a = self.source_location) ? self.source_location.$lineno() : $a)
      }, $AbstractBlock_lineno$5.$$arity = 0);
      
      Opal.def(self, '$convert', $AbstractBlock_convert$6 = function $$convert() {
        var self = this;

        
        self.document.$playback_attributes(self.attributes);
        return self.$converter().$convert(self);
      }, $AbstractBlock_convert$6.$$arity = 0);
      Opal.alias(self, "render", "convert");
      
      Opal.def(self, '$content', $AbstractBlock_content$7 = function $$content() {
        var $$8, self = this;

        return $send(self.blocks, 'map', [], ($$8 = function(b){var self = $$8.$$s || this;

        
          
          if (b == null) {
            b = nil;
          };
          return b.$convert();}, $$8.$$s = self, $$8.$$arity = 1, $$8)).$join($$($nesting, 'LF'))
      }, $AbstractBlock_content$7.$$arity = 0);
      
      Opal.def(self, '$context=', $AbstractBlock_context$eq$9 = function(context) {
        var self = this;

        return (self.node_name = (self.context = context).$to_s())
      }, $AbstractBlock_context$eq$9.$$arity = 1);
      
      Opal.def(self, '$<<', $AbstractBlock_$lt$lt$10 = function(block) {
        var self = this, $writer = nil;

        
        if (block.$parent()['$=='](self)) {
        } else {
          
          $writer = [self];
          $send(block, 'parent=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        };
        self.blocks['$<<'](block);
        return self;
      }, $AbstractBlock_$lt$lt$10.$$arity = 1);
      Opal.alias(self, "append", "<<");
      
      Opal.def(self, '$blocks?', $AbstractBlock_blocks$ques$11 = function() {
        var self = this;

        if ($truthy(self.blocks['$empty?']())) {
          return false
        } else {
          return true
        }
      }, $AbstractBlock_blocks$ques$11.$$arity = 0);
      
      Opal.def(self, '$sections?', $AbstractBlock_sections$ques$12 = function() {
        var self = this;

        return false
      }, $AbstractBlock_sections$ques$12.$$arity = 0);
      
      Opal.def(self, '$number', $AbstractBlock_number$13 = function $$number() {
        var self = this;

        try {
          
          return self.$Integer(self.numeral);
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
            try {
              return self.numeral
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        }
      }, $AbstractBlock_number$13.$$arity = 0);
      
      Opal.def(self, '$number=', $AbstractBlock_number$eq$14 = function(val) {
        var self = this;

        return (self.numeral = val.$to_s())
      }, $AbstractBlock_number$eq$14.$$arity = 1);
      
      Opal.def(self, '$find_by', $AbstractBlock_find_by$15 = function $$find_by(selector) {
        var $iter = $AbstractBlock_find_by$15.$$p, block = $iter || nil, self = this, result = nil;

        if ($iter) $AbstractBlock_find_by$15.$$p = null;
        
        
        if ($iter) $AbstractBlock_find_by$15.$$p = null;;
        
        if (selector == null) {
          selector = $hash2([], {});
        };
        try {
          return $send(self, 'find_by_internal', [selector, (result = [])], block.$to_proc())
        } catch ($err) {
          if (Opal.rescue($err, [$$$('::', 'StopIteration')])) {
            try {
              return result
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };
      }, $AbstractBlock_find_by$15.$$arity = -1);
      Opal.alias(self, "query", "find_by");
      
      Opal.def(self, '$next_adjacent_block', $AbstractBlock_next_adjacent_block$16 = function $$next_adjacent_block() {
        var $a, $$17, self = this, p = nil, sib = nil;

        if (self.context['$==']("document")) {
          return nil
        } else if ($truthy((($a = (p = self.parent).$context()['$==']("dlist")) ? self.context['$==']("list_item") : (p = self.parent).$context()['$==']("dlist")))) {
          if ($truthy((sib = p.$items()['$[]']($rb_plus($send(p.$items(), 'find_index', [], ($$17 = function(terms, desc){var self = $$17.$$s || this, $b;

          
            
            if (terms == null) {
              terms = nil;
            };
            
            if (desc == null) {
              desc = nil;
            };
            return ($truthy($b = terms['$include?'](self)) ? $b : desc['$=='](self));}, $$17.$$s = self, $$17.$$arity = 2, $$17)), 1))))) {
            return sib
          } else {
            return p.$next_adjacent_block()
          }
        } else if ($truthy((sib = p.$blocks()['$[]']($rb_plus(p.$blocks().$find_index(self), 1))))) {
          return sib
        } else {
          return p.$next_adjacent_block()
        }
      }, $AbstractBlock_next_adjacent_block$16.$$arity = 0);
      
      Opal.def(self, '$sections', $AbstractBlock_sections$18 = function $$sections() {
        var $$19, self = this;

        return $send(self.blocks, 'select', [], ($$19 = function(block){var self = $$19.$$s || this;

        
          
          if (block == null) {
            block = nil;
          };
          return block.$context()['$==']("section");}, $$19.$$s = self, $$19.$$arity = 1, $$19))
      }, $AbstractBlock_sections$18.$$arity = 0);
      
      Opal.def(self, '$alt', $AbstractBlock_alt$20 = function $$alt() {
        var self = this, text = nil;

        if ($truthy((text = self.attributes['$[]']("alt")))) {
          if (text['$=='](self.attributes['$[]']("default-alt"))) {
            return self.$sub_specialchars(text)
          } else {
            
            text = self.$sub_specialchars(text);
            if ($truthy($$($nesting, 'ReplaceableTextRx')['$match?'](text))) {
              
              return self.$sub_replacements(text);
            } else {
              return text
            };
          }
        } else {
          return ""
        }
      }, $AbstractBlock_alt$20.$$arity = 0);
      
      Opal.def(self, '$caption', $AbstractBlock_caption$21 = function $$caption() {
        var self = this;

        if (self.context['$==']("admonition")) {
          return self.attributes['$[]']("textlabel")
        } else {
          return self.caption
        }
      }, $AbstractBlock_caption$21.$$arity = 0);
      
      Opal.def(self, '$captioned_title', $AbstractBlock_captioned_title$22 = function $$captioned_title() {
        var self = this;

        return "" + (self.caption) + (self.$title())
      }, $AbstractBlock_captioned_title$22.$$arity = 0);
      
      Opal.def(self, '$list_marker_keyword', $AbstractBlock_list_marker_keyword$23 = function $$list_marker_keyword(list_type) {
        var $a, self = this;

        
        
        if (list_type == null) {
          list_type = nil;
        };
        return $$($nesting, 'ORDERED_LIST_KEYWORDS')['$[]'](($truthy($a = list_type) ? $a : self.style));
      }, $AbstractBlock_list_marker_keyword$23.$$arity = -1);
      
      Opal.def(self, '$title', $AbstractBlock_title$24 = function $$title() {
        var $a, $b, self = this;

        return (self.converted_title = ($truthy($a = self.converted_title) ? $a : ($truthy($b = self.title) ? self.$apply_title_subs(self.title) : $b)))
      }, $AbstractBlock_title$24.$$arity = 0);
      
      Opal.def(self, '$title?', $AbstractBlock_title$ques$25 = function() {
        var self = this;

        if ($truthy(self.title)) {
          return true
        } else {
          return false
        }
      }, $AbstractBlock_title$ques$25.$$arity = 0);
      
      Opal.def(self, '$title=', $AbstractBlock_title$eq$26 = function(val) {
        var self = this;

        
        self.converted_title = nil;
        return (self.title = val);
      }, $AbstractBlock_title$eq$26.$$arity = 1);
      
      Opal.def(self, '$sub?', $AbstractBlock_sub$ques$27 = function(name) {
        var self = this;

        return self.subs['$include?'](name)
      }, $AbstractBlock_sub$ques$27.$$arity = 1);
      
      Opal.def(self, '$remove_sub', $AbstractBlock_remove_sub$28 = function $$remove_sub(sub) {
        var self = this;

        
        self.subs.$delete(sub);
        return nil;
      }, $AbstractBlock_remove_sub$28.$$arity = 1);
      
      Opal.def(self, '$xreftext', $AbstractBlock_xreftext$29 = function $$xreftext(xrefstyle) {
        var $a, $b, self = this, val = nil, $case = nil, quoted_title = nil, caption_attr_name = nil, prefix = nil;

        
        
        if (xrefstyle == null) {
          xrefstyle = nil;
        };
        if ($truthy(($truthy($a = (val = self.$reftext())) ? val['$empty?']()['$!']() : $a))) {
          return val
        } else if ($truthy(($truthy($a = ($truthy($b = xrefstyle) ? self.title : $b)) ? self.caption['$nil_or_empty?']()['$!']() : $a))) {
          return (function() {$case = xrefstyle;
          if ("full"['$===']($case)) {
          quoted_title = self.$sub_placeholder(self.$sub_quotes((function() {if ($truthy(self.document.$compat_mode())) {
            return "``%s''"
          } else {
            return "\"`%s`\""
          }; return nil; })()), self.$title());
          if ($truthy(($truthy($a = ($truthy($b = self.numeral) ? (caption_attr_name = $$($nesting, 'CAPTION_ATTRIBUTE_NAMES')['$[]'](self.context)) : $b)) ? (prefix = self.document.$attributes()['$[]'](caption_attr_name)) : $a))) {
            return "" + (prefix) + " " + (self.numeral) + ", " + (quoted_title)
          } else {
            return "" + (self.caption.$chomp(". ")) + ", " + (quoted_title)
          };}
          else if ("short"['$===']($case)) {if ($truthy(($truthy($a = ($truthy($b = self.numeral) ? (caption_attr_name = $$($nesting, 'CAPTION_ATTRIBUTE_NAMES')['$[]'](self.context)) : $b)) ? (prefix = self.document.$attributes()['$[]'](caption_attr_name)) : $a))) {
            return "" + (prefix) + " " + (self.numeral)
          } else {
            return self.caption.$chomp(". ")
          }}
          else {return self.$title()}})()
        } else {
          return self.$title()
        };
      }, $AbstractBlock_xreftext$29.$$arity = -1);
      
      Opal.def(self, '$assign_caption', $AbstractBlock_assign_caption$30 = function $$assign_caption(value, caption_context) {
        var $a, $b, self = this, attr_name = nil, prefix = nil;

        
        
        if (caption_context == null) {
          caption_context = self.context;
        };
        if ($truthy(($truthy($a = ($truthy($b = self.caption) ? $b : self.title['$!']())) ? $a : (self.caption = ($truthy($b = value) ? $b : self.document.$attributes()['$[]']("caption")))))) {
          return nil
        } else if ($truthy(($truthy($a = (attr_name = $$($nesting, 'CAPTION_ATTRIBUTE_NAMES')['$[]'](caption_context))) ? (prefix = self.document.$attributes()['$[]'](attr_name)) : $a))) {
          
          self.caption = "" + (prefix) + " " + ((self.numeral = self.document.$increment_and_store_counter("" + (caption_context) + "-number", self))) + ". ";
          return nil;
        } else {
          return nil
        };
      }, $AbstractBlock_assign_caption$30.$$arity = -2);
      
      Opal.def(self, '$assign_numeral', $AbstractBlock_assign_numeral$31 = function $$assign_numeral(section) {
        var $a, self = this, $writer = nil, like = nil, sectname = nil, caption = nil;

        
        self.next_section_index = $rb_plus((($writer = [self.next_section_index]), $send(section, 'index=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]), 1);
        if ($truthy((like = section.$numbered()))) {
          if ((sectname = section.$sectname())['$==']("appendix")) {
            
            
            $writer = [self.document.$counter("appendix-number", "A")];
            $send(section, 'numeral=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [(function() {if ($truthy((caption = self.document.$attributes()['$[]']("appendix-caption")))) {
              return "" + (caption) + " " + (section.$numeral()) + ": "
            } else {
              return "" + (section.$numeral()) + ". "
            }; return nil; })()];
            $send(section, 'caption=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
          } else if ($truthy(($truthy($a = sectname['$==']("chapter")) ? $a : like['$==']("chapter")))) {
            
            $writer = [self.document.$counter("chapter-number", 1).$to_s()];
            $send(section, 'numeral=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          } else {
            
            
            $writer = [(function() {if (sectname['$==']("part")) {
              
              return $$($nesting, 'Helpers').$int_to_roman(self.next_section_ordinal);
            } else {
              return self.next_section_ordinal.$to_s()
            }; return nil; })()];
            $send(section, 'numeral=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            self.next_section_ordinal = $rb_plus(self.next_section_ordinal, 1);
          }};
        return nil;
      }, $AbstractBlock_assign_numeral$31.$$arity = 1);
      
      Opal.def(self, '$reindex_sections', $AbstractBlock_reindex_sections$32 = function $$reindex_sections() {
        var $$33, self = this;

        
        self.next_section_index = 0;
        self.next_section_ordinal = 1;
        return $send(self.blocks, 'each', [], ($$33 = function(block){var self = $$33.$$s || this;

        
          
          if (block == null) {
            block = nil;
          };
          if (block.$context()['$==']("section")) {
            
            self.$assign_numeral(block);
            return block.$reindex_sections();
          } else {
            return nil
          };}, $$33.$$s = self, $$33.$$arity = 1, $$33));
      }, $AbstractBlock_reindex_sections$32.$$arity = 0);
      self.$protected();
      return (Opal.def(self, '$find_by_internal', $AbstractBlock_find_by_internal$34 = function $$find_by_internal(selector, result) {
        var $iter = $AbstractBlock_find_by_internal$34.$$p, block = $iter || nil, $a, $b, $c, $d, $$35, $$36, $$37, $$39, $$41, $$43, self = this, any_context = nil, context_selector = nil, style_selector = nil, role_selector = nil, id_selector = nil, verdict = nil, $case = nil;

        if ($iter) $AbstractBlock_find_by_internal$34.$$p = null;
        
        
        if ($iter) $AbstractBlock_find_by_internal$34.$$p = null;;
        
        if (selector == null) {
          selector = $hash2([], {});
        };
        
        if (result == null) {
          result = [];
        };
        if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = ($truthy($d = (any_context = (function() {if ($truthy((context_selector = selector['$[]']("context")))) {
          return nil
        } else {
          return true
        }; return nil; })())) ? $d : context_selector['$=='](self.context))) ? ($truthy($d = (style_selector = selector['$[]']("style"))['$!']()) ? $d : style_selector['$=='](self.style)) : $c)) ? ($truthy($c = (role_selector = selector['$[]']("role"))['$!']()) ? $c : self['$has_role?'](role_selector)) : $b)) ? ($truthy($b = (id_selector = selector['$[]']("id"))['$!']()) ? $b : id_selector['$=='](self.id)) : $a))) {
          if ((block !== nil)) {
            if ($truthy((verdict = Opal.yield1(block, self)))) {
              $case = verdict;
              if ("prune"['$===']($case)) {
              result['$<<'](self);
              if ($truthy(id_selector)) {
                self.$raise($$$('::', 'StopIteration'))};
              return result;}
              else if ("reject"['$===']($case)) {
              if ($truthy(id_selector)) {
                self.$raise($$$('::', 'StopIteration'))};
              return result;}
              else if ("stop"['$===']($case)) {self.$raise($$$('::', 'StopIteration'))}
              else {
              result['$<<'](self);
              if ($truthy(id_selector)) {
                self.$raise($$$('::', 'StopIteration'))};}
            } else if ($truthy(id_selector)) {
              self.$raise($$$('::', 'StopIteration'))}
          } else {
            
            result['$<<'](self);
            if ($truthy(id_selector)) {
              self.$raise($$$('::', 'StopIteration'))};
          }};
        $case = self.context;
        if ("document"['$===']($case)) {if (context_selector['$==']("document")) {
        } else {
          
          if ($truthy(($truthy($a = self['$header?']()) ? ($truthy($b = any_context) ? $b : context_selector['$==']("section")) : $a))) {
            $send(self.header, 'find_by_internal', [selector, result], block.$to_proc())};
          $send(self.blocks, 'each', [], ($$35 = function(b){var self = $$35.$$s || this, $e;

          
            
            if (b == null) {
              b = nil;
            };
            if ($truthy((($e = context_selector['$==']("section")) ? b.$context()['$!=']("section") : context_selector['$==']("section")))) {
              return nil;};
            return $send(b, 'find_by_internal', [selector, result], block.$to_proc());}, $$35.$$s = self, $$35.$$arity = 1, $$35));
        }}
        else if ("dlist"['$===']($case)) {if ($truthy(($truthy($a = any_context) ? $a : context_selector['$!=']("section")))) {
          $send(self.blocks.$flatten(), 'each', [], ($$36 = function(b){var self = $$36.$$s || this;

          
            
            if (b == null) {
              b = nil;
            };
            if ($truthy(b)) {
              return $send(b, 'find_by_internal', [selector, result], block.$to_proc())
            } else {
              return nil
            };}, $$36.$$s = self, $$36.$$arity = 1, $$36))}}
        else if ("table"['$===']($case)) {if ($truthy(selector['$[]']("traverse_documents"))) {
          
          $send(self.$rows().$head(), 'each', [], ($$37 = function(r){var self = $$37.$$s || this, $$38;

          
            
            if (r == null) {
              r = nil;
            };
            return $send(r, 'each', [], ($$38 = function(c){var self = $$38.$$s || this;

            
              
              if (c == null) {
                c = nil;
              };
              return $send(c, 'find_by_internal', [selector, result], block.$to_proc());}, $$38.$$s = self, $$38.$$arity = 1, $$38));}, $$37.$$s = self, $$37.$$arity = 1, $$37));
          if (context_selector['$==']("inner_document")) {
            selector = selector.$merge($hash2(["context"], {"context": "document"}))};
          $send($rb_plus(self.$rows().$body(), self.$rows().$foot()), 'each', [], ($$39 = function(r){var self = $$39.$$s || this, $$40;

          
            
            if (r == null) {
              r = nil;
            };
            return $send(r, 'each', [], ($$40 = function(c){var self = $$40.$$s || this;

            
              
              if (c == null) {
                c = nil;
              };
              $send(c, 'find_by_internal', [selector, result], block.$to_proc());
              if (c.$style()['$==']("asciidoc")) {
                return $send(c.$inner_document(), 'find_by_internal', [selector, result], block.$to_proc())
              } else {
                return nil
              };}, $$40.$$s = self, $$40.$$arity = 1, $$40));}, $$39.$$s = self, $$39.$$arity = 1, $$39));
        } else {
          $send($rb_plus($rb_plus(self.$rows().$head(), self.$rows().$body()), self.$rows().$foot()), 'each', [], ($$41 = function(r){var self = $$41.$$s || this, $$42;

          
            
            if (r == null) {
              r = nil;
            };
            return $send(r, 'each', [], ($$42 = function(c){var self = $$42.$$s || this;

            
              
              if (c == null) {
                c = nil;
              };
              return $send(c, 'find_by_internal', [selector, result], block.$to_proc());}, $$42.$$s = self, $$42.$$arity = 1, $$42));}, $$41.$$s = self, $$41.$$arity = 1, $$41))
        }}
        else {$send(self.blocks, 'each', [], ($$43 = function(b){var self = $$43.$$s || this, $e;

        
          
          if (b == null) {
            b = nil;
          };
          if ($truthy((($e = context_selector['$==']("section")) ? b.$context()['$!=']("section") : context_selector['$==']("section")))) {
            return nil;};
          return $send(b, 'find_by_internal', [selector, result], block.$to_proc());}, $$43.$$s = self, $$43.$$arity = 1, $$43))};
        return result;
      }, $AbstractBlock_find_by_internal$34.$$arity = -1), nil) && 'find_by_internal';
    })($nesting[0], $$($nesting, 'AbstractNode'), $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/attribute_list"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash = Opal.hash, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$new', '$[]', '$update', '$parse', '$parse_attribute', '$eos?', '$skip_delimiter', '$+', '$rekey', '$each_with_index', '$[]=', '$-', '$private', '$skip_blank', '$peek', '$===', '$parse_attribute_value', '$get_byte', '$start_with?', '$scan_name', '$end_with?', '$rstrip', '$string', '$==', '$unscan', '$scan_to_delimiter', '$*', '$include?', '$delete', '$each', '$split', '$empty?', '$apply_subs', '$scan_to_quote', '$gsub', '$skip', '$scan']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'AttributeList');

      var $nesting = [self].concat($parent_nesting), $AttributeList_initialize$1, $AttributeList_parse_into$2, $AttributeList_parse$3, $AttributeList_rekey$4, $AttributeList_rekey$5, $AttributeList_parse_attribute$7, $AttributeList_parse_attribute_value$9, $AttributeList_skip_blank$10, $AttributeList_skip_delimiter$11, $AttributeList_scan_name$12, $AttributeList_scan_to_delimiter$13, $AttributeList_scan_to_quote$14;

      self.$$prototype.attributes = self.$$prototype.scanner = self.$$prototype.delimiter = self.$$prototype.block = self.$$prototype.delimiter_skip_pattern = self.$$prototype.delimiter_boundary_pattern = nil;
      
      Opal.const_set($nesting[0], 'APOS', "'");
      Opal.const_set($nesting[0], 'BACKSLASH', "\\");
      Opal.const_set($nesting[0], 'QUOT', "\"");
      Opal.const_set($nesting[0], 'BoundaryRx', $hash($$($nesting, 'QUOT'), /.*?[^\\](?=")/, $$($nesting, 'APOS'), /.*?[^\\](?=')/, ",", /.*?(?=[ \t]*(,|$))/));
      Opal.const_set($nesting[0], 'EscapedQuotes', $hash($$($nesting, 'QUOT'), "\\\"", $$($nesting, 'APOS'), "\\'"));
      Opal.const_set($nesting[0], 'NameRx', new RegExp("" + ($$($nesting, 'CG_WORD')) + "[" + ($$($nesting, 'CC_WORD')) + "\\-.]*"));
      Opal.const_set($nesting[0], 'BlankRx', /[ \t]+/);
      Opal.const_set($nesting[0], 'SkipRx', $hash2([","], {",": /[ \t]*(,|$)/}));
      
      Opal.def(self, '$initialize', $AttributeList_initialize$1 = function $$initialize(source, block, delimiter) {
        var self = this;

        
        
        if (block == null) {
          block = nil;
        };
        
        if (delimiter == null) {
          delimiter = ",";
        };
        self.scanner = $$$('::', 'StringScanner').$new(source);
        self.block = block;
        self.delimiter = delimiter;
        self.delimiter_skip_pattern = $$($nesting, 'SkipRx')['$[]'](delimiter);
        self.delimiter_boundary_pattern = $$($nesting, 'BoundaryRx')['$[]'](delimiter);
        return (self.attributes = nil);
      }, $AttributeList_initialize$1.$$arity = -2);
      
      Opal.def(self, '$parse_into', $AttributeList_parse_into$2 = function $$parse_into(attributes, positional_attrs) {
        var self = this;

        
        
        if (positional_attrs == null) {
          positional_attrs = [];
        };
        return attributes.$update(self.$parse(positional_attrs));
      }, $AttributeList_parse_into$2.$$arity = -2);
      
      Opal.def(self, '$parse', $AttributeList_parse$3 = function $$parse(positional_attrs) {
        var $a, self = this, index = nil;

        
        
        if (positional_attrs == null) {
          positional_attrs = [];
        };
        if ($truthy(self.attributes)) {
          return self.attributes};
        self.attributes = $hash2([], {});
        index = 0;
        while ($truthy(self.$parse_attribute(index, positional_attrs))) {
          
          if ($truthy(self.scanner['$eos?']())) {
            break;};
          self.$skip_delimiter();
          index = $rb_plus(index, 1);
        };
        return self.attributes;
      }, $AttributeList_parse$3.$$arity = -1);
      
      Opal.def(self, '$rekey', $AttributeList_rekey$4 = function $$rekey(positional_attrs) {
        var self = this;

        return $$($nesting, 'AttributeList').$rekey(self.attributes, positional_attrs)
      }, $AttributeList_rekey$4.$$arity = 1);
      Opal.defs(self, '$rekey', $AttributeList_rekey$5 = function $$rekey(attributes, positional_attrs) {
        var $$6, self = this;

        
        $send(positional_attrs, 'each_with_index', [], ($$6 = function(key, index){var self = $$6.$$s || this, $a, val = nil, $writer = nil;

        
          
          if (key == null) {
            key = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          if ($truthy(($truthy($a = key) ? (val = attributes['$[]']($rb_plus(index, 1))) : $a))) {
            
            $writer = [key, val];
            $send(attributes, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          } else {
            return nil
          };}, $$6.$$s = self, $$6.$$arity = 2, $$6));
        return attributes;
      }, $AttributeList_rekey$5.$$arity = 2);
      self.$private();
      
      Opal.def(self, '$parse_attribute', $AttributeList_parse_attribute$7 = function $$parse_attribute(index, positional_attrs) {
        var $a, $b, $$8, self = this, continue$ = nil, $case = nil, name = nil, single_quoted = nil, skipped = nil, c = nil, value = nil, $writer = nil, positional_attr_name = nil;

        
        continue$ = true;
        self.$skip_blank();
        $case = self.scanner.$peek(1);
        if ($$($nesting, 'QUOT')['$===']($case)) {name = self.$parse_attribute_value(self.scanner.$get_byte())}
        else if ($$($nesting, 'APOS')['$===']($case)) {
        name = self.$parse_attribute_value(self.scanner.$get_byte());
        if ($truthy(name['$start_with?']($$($nesting, 'APOS')))) {
        } else {
          single_quoted = true
        };}
        else {
        skipped = ($truthy($a = ($truthy($b = (name = self.$scan_name())) ? self.$skip_blank() : $b)) ? $a : 0);
        if ($truthy(self.scanner['$eos?']())) {
          
          if ($truthy(($truthy($a = name) ? $a : self.scanner.$string().$rstrip()['$end_with?'](self.delimiter)))) {
          } else {
            return nil
          };
          continue$ = nil;
        } else if ((c = self.scanner.$get_byte())['$=='](self.delimiter)) {
          self.scanner.$unscan()
        } else if ($truthy(name)) {
          if (c['$==']("=")) {
            
            self.$skip_blank();
            $case = (c = self.scanner.$get_byte());
            if ($$($nesting, 'QUOT')['$===']($case)) {value = self.$parse_attribute_value(c)}
            else if ($$($nesting, 'APOS')['$===']($case)) {
            value = self.$parse_attribute_value(c);
            if ($truthy(value['$start_with?']($$($nesting, 'APOS')))) {
            } else {
              single_quoted = true
            };}
            else if (self.delimiter['$===']($case)) {
            value = "";
            self.scanner.$unscan();}
            else if (nil['$===']($case)) {value = ""}
            else {
            value = "" + (c) + (self.$scan_to_delimiter());
            if (value['$==']("None")) {
              return true};};
          } else {
            name = "" + (name) + ($rb_times(" ", skipped)) + (c) + (self.$scan_to_delimiter())
          }
        } else {
          name = "" + (c) + (self.$scan_to_delimiter())
        };};
        if ($truthy(value)) {
          $case = name;
          if ("options"['$===']($case) || "opts"['$===']($case)) {if ($truthy(value['$include?'](","))) {
            
            if ($truthy(value['$include?'](" "))) {
              value = value.$delete(" ")};
            $send(value.$split(","), 'each', [], ($$8 = function(opt){var self = $$8.$$s || this, $writer = nil;
              if (self.attributes == null) self.attributes = nil;

            
              
              if (opt == null) {
                opt = nil;
              };
              if ($truthy(opt['$empty?']())) {
                return nil
              } else {
                
                $writer = ["" + (opt) + "-option", ""];
                $send(self.attributes, '[]=', Opal.to_a($writer));
                return $writer[$rb_minus($writer["length"], 1)];
              };}, $$8.$$s = self, $$8.$$arity = 1, $$8));
          } else if ($truthy(value['$empty?']())) {
          } else {
            
            $writer = ["" + (value) + "-option", ""];
            $send(self.attributes, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          }}
          else {if ($truthy(($truthy($a = single_quoted) ? self.block : $a))) {
            $case = name;
            if ("title"['$===']($case) || "reftext"['$===']($case)) {
            $writer = [name, value];
            $send(self.attributes, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];}
            else {
            $writer = [name, self.block.$apply_subs(value)];
            $send(self.attributes, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];}
          } else {
            
            $writer = [name, value];
            $send(self.attributes, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          }}
        } else {
          
          if ($truthy(($truthy($a = single_quoted) ? self.block : $a))) {
            name = self.block.$apply_subs(name)};
          if ($truthy(($truthy($a = (positional_attr_name = positional_attrs['$[]'](index))) ? name : $a))) {
            
            $writer = [positional_attr_name, name];
            $send(self.attributes, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          
          $writer = [$rb_plus(index, 1), name];
          $send(self.attributes, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
        };
        return continue$;
      }, $AttributeList_parse_attribute$7.$$arity = 2);
      
      Opal.def(self, '$parse_attribute_value', $AttributeList_parse_attribute_value$9 = function $$parse_attribute_value(quote) {
        var self = this, value = nil;

        if (self.scanner.$peek(1)['$=='](quote)) {
          
          self.scanner.$get_byte();
          return "";
        } else if ($truthy((value = self.$scan_to_quote(quote)))) {
          
          self.scanner.$get_byte();
          if ($truthy(value['$include?']($$($nesting, 'BACKSLASH')))) {
            
            return value.$gsub($$($nesting, 'EscapedQuotes')['$[]'](quote), quote);
          } else {
            return value
          };
        } else {
          return "" + (quote) + (self.$scan_to_delimiter())
        }
      }, $AttributeList_parse_attribute_value$9.$$arity = 1);
      
      Opal.def(self, '$skip_blank', $AttributeList_skip_blank$10 = function $$skip_blank() {
        var self = this;

        return self.scanner.$skip($$($nesting, 'BlankRx'))
      }, $AttributeList_skip_blank$10.$$arity = 0);
      
      Opal.def(self, '$skip_delimiter', $AttributeList_skip_delimiter$11 = function $$skip_delimiter() {
        var self = this;

        return self.scanner.$skip(self.delimiter_skip_pattern)
      }, $AttributeList_skip_delimiter$11.$$arity = 0);
      
      Opal.def(self, '$scan_name', $AttributeList_scan_name$12 = function $$scan_name() {
        var self = this;

        return self.scanner.$scan($$($nesting, 'NameRx'))
      }, $AttributeList_scan_name$12.$$arity = 0);
      
      Opal.def(self, '$scan_to_delimiter', $AttributeList_scan_to_delimiter$13 = function $$scan_to_delimiter() {
        var self = this;

        return self.scanner.$scan(self.delimiter_boundary_pattern)
      }, $AttributeList_scan_to_delimiter$13.$$arity = 0);
      return (Opal.def(self, '$scan_to_quote', $AttributeList_scan_to_quote$14 = function $$scan_to_quote(quote) {
        var self = this;

        return self.scanner.$scan($$($nesting, 'BoundaryRx')['$[]'](quote))
      }, $AttributeList_scan_to_quote$14.$$arity = 1), nil) && 'scan_to_quote';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/block"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$default=', '$-', '$attr_accessor', '$[]', '$key?', '$===', '$drop', '$delete', '$to_s', '$[]=', '$commit_subs', '$nil_or_empty?', '$prepare_source_string', '$apply_subs', '$join', '$<', '$size', '$empty?', '$rstrip', '$shift', '$pop', '$==', '$warn', '$logger', '$class', '$object_id', '$inspect']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Block');

      var $nesting = [self].concat($parent_nesting), $Block_initialize$1, $Block_content$2, $Block_source$3, $Block_to_s$4, $writer = nil;

      self.$$prototype.attributes = self.$$prototype.content_model = self.$$prototype.lines = self.$$prototype.subs = self.$$prototype.blocks = self.$$prototype.context = self.$$prototype.style = nil;
      
      
      $writer = ["simple"];
      $send(Opal.const_set($nesting[0], 'DEFAULT_CONTENT_MODEL', $hash2(["audio", "image", "listing", "literal", "stem", "open", "page_break", "pass", "thematic_break", "video"], {"audio": "empty", "image": "empty", "listing": "verbatim", "literal": "verbatim", "stem": "raw", "open": "compound", "page_break": "empty", "pass": "raw", "thematic_break": "empty", "video": "empty"})), 'default=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      Opal.alias(self, "blockname", "context");
      self.$attr_accessor("lines");
      
      Opal.def(self, '$initialize', $Block_initialize$1 = function $$initialize(parent, context, opts) {
        var $a, $iter = $Block_initialize$1.$$p, $yield = $iter || nil, self = this, subs = nil, $case = nil, $writer = nil, raw_source = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $Block_initialize$1.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        $send(self, Opal.find_super_dispatcher(self, 'initialize', $Block_initialize$1, false), $zuper, $iter);
        self.content_model = ($truthy($a = opts['$[]']("content_model")) ? $a : $$($nesting, 'DEFAULT_CONTENT_MODEL')['$[]'](context));
        if ($truthy(opts['$key?']("subs"))) {
          if ($truthy((subs = opts['$[]']("subs")))) {
            
            $case = subs;
            if ("default"['$===']($case)) {self.default_subs = opts['$[]']("default_subs")}
            else if ($$$('::', 'Array')['$===']($case)) {
            self.default_subs = subs.$drop(0);
            self.attributes.$delete("subs");}
            else {
            self.default_subs = nil;
            
            $writer = ["subs", subs.$to_s()];
            $send(self.attributes, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;};
            self.$commit_subs();
          } else {
            
            self.default_subs = [];
            self.attributes.$delete("subs");
          }
        } else {
          self.default_subs = nil
        };
        if ($truthy((raw_source = opts['$[]']("source"))['$nil_or_empty?']())) {
          return (self.lines = [])
        } else if ($truthy($$$('::', 'String')['$==='](raw_source))) {
          return (self.lines = $$($nesting, 'Helpers').$prepare_source_string(raw_source))
        } else {
          return (self.lines = raw_source.$drop(0))
        };
      }, $Block_initialize$1.$$arity = -3);
      
      Opal.def(self, '$content', $Block_content$2 = function $$content() {
        var $a, $b, $iter = $Block_content$2.$$p, $yield = $iter || nil, self = this, $case = nil, result = nil, first = nil, last = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $Block_content$2.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        return (function() {$case = self.content_model;
        if ("compound"['$===']($case)) {return $send(self, Opal.find_super_dispatcher(self, 'content', $Block_content$2, false), $zuper, $iter)}
        else if ("simple"['$===']($case)) {return self.$apply_subs(self.lines.$join($$($nesting, 'LF')), self.subs)}
        else if ("verbatim"['$===']($case) || "raw"['$===']($case)) {
        result = self.$apply_subs(self.lines, self.subs);
        if ($truthy($rb_lt(result.$size(), 2))) {
          return result['$[]'](0)
        } else {
          
          while ($truthy(($truthy($b = (first = result['$[]'](0))) ? first.$rstrip()['$empty?']() : $b))) {
            result.$shift()
          };
          while ($truthy(($truthy($b = (last = result['$[]'](-1))) ? last.$rstrip()['$empty?']() : $b))) {
            result.$pop()
          };
          return result.$join($$($nesting, 'LF'));
        };}
        else {
        if (self.content_model['$==']("empty")) {
        } else {
          self.$logger().$warn("" + "Unknown content model '" + (self.content_model) + "' for block: " + (self))
        };
        return nil;}})()
      }, $Block_content$2.$$arity = 0);
      
      Opal.def(self, '$source', $Block_source$3 = function $$source() {
        var self = this;

        return self.lines.$join($$($nesting, 'LF'))
      }, $Block_source$3.$$arity = 0);
      return (Opal.def(self, '$to_s', $Block_to_s$4 = function $$to_s() {
        var self = this, content_summary = nil;

        
        content_summary = (function() {if (self.content_model['$==']("compound")) {
          return "" + "blocks: " + (self.blocks.$size())
        } else {
          return "" + "lines: " + (self.lines.$size())
        }; return nil; })();
        return "" + "#<" + (self.$class()) + "@" + (self.$object_id()) + " {context: " + (self.context.$inspect()) + ", content_model: " + (self.content_model.$inspect()) + ", style: " + (self.style.$inspect()) + ", " + (content_summary) + "}>";
      }, $Block_to_s$4.$$arity = 0), nil) && 'to_s';
    })($nesting[0], $$($nesting, 'AbstractBlock'), $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/callouts"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$next_list', '$<<', '$current_list', '$to_i', '$generate_next_callout_id', '$+', '$<=', '$size', '$[]', '$-', '$chop', '$join', '$map', '$==', '$<', '$private', '$generate_callout_id']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Callouts');

      var $nesting = [self].concat($parent_nesting), $Callouts_initialize$1, $Callouts_register$2, $Callouts_read_next_id$3, $Callouts_callout_ids$4, $Callouts_current_list$6, $Callouts_next_list$7, $Callouts_rewind$8, $Callouts_generate_next_callout_id$9, $Callouts_generate_callout_id$10;

      self.$$prototype.co_index = self.$$prototype.lists = self.$$prototype.list_index = nil;
      
      
      Opal.def(self, '$initialize', $Callouts_initialize$1 = function $$initialize() {
        var self = this;

        
        self.lists = [];
        self.list_index = 0;
        return self.$next_list();
      }, $Callouts_initialize$1.$$arity = 0);
      
      Opal.def(self, '$register', $Callouts_register$2 = function $$register(li_ordinal) {
        var self = this, id = nil;

        
        self.$current_list()['$<<']($hash2(["ordinal", "id"], {"ordinal": li_ordinal.$to_i(), "id": (id = self.$generate_next_callout_id())}));
        self.co_index = $rb_plus(self.co_index, 1);
        return id;
      }, $Callouts_register$2.$$arity = 1);
      
      Opal.def(self, '$read_next_id', $Callouts_read_next_id$3 = function $$read_next_id() {
        var self = this, id = nil, list = nil;

        
        id = nil;
        list = self.$current_list();
        if ($truthy($rb_le(self.co_index, list.$size()))) {
          id = list['$[]']($rb_minus(self.co_index, 1))['$[]']("id")};
        self.co_index = $rb_plus(self.co_index, 1);
        return id;
      }, $Callouts_read_next_id$3.$$arity = 0);
      
      Opal.def(self, '$callout_ids', $Callouts_callout_ids$4 = function $$callout_ids(li_ordinal) {
        var $$5, self = this;

        return $send(self.$current_list(), 'map', [], ($$5 = function(it){var self = $$5.$$s || this;

        
          
          if (it == null) {
            it = nil;
          };
          if (it['$[]']("ordinal")['$=='](li_ordinal)) {
            return "" + (it['$[]']("id")) + " "
          } else {
            return ""
          };}, $$5.$$s = self, $$5.$$arity = 1, $$5)).$join().$chop()
      }, $Callouts_callout_ids$4.$$arity = 1);
      
      Opal.def(self, '$current_list', $Callouts_current_list$6 = function $$current_list() {
        var self = this;

        return self.lists['$[]']($rb_minus(self.list_index, 1))
      }, $Callouts_current_list$6.$$arity = 0);
      
      Opal.def(self, '$next_list', $Callouts_next_list$7 = function $$next_list() {
        var self = this;

        
        self.list_index = $rb_plus(self.list_index, 1);
        if ($truthy($rb_lt(self.lists.$size(), self.list_index))) {
          self.lists['$<<']([])};
        self.co_index = 1;
        return nil;
      }, $Callouts_next_list$7.$$arity = 0);
      
      Opal.def(self, '$rewind', $Callouts_rewind$8 = function $$rewind() {
        var self = this;

        
        self.list_index = 1;
        self.co_index = 1;
        return nil;
      }, $Callouts_rewind$8.$$arity = 0);
      self.$private();
      
      Opal.def(self, '$generate_next_callout_id', $Callouts_generate_next_callout_id$9 = function $$generate_next_callout_id() {
        var self = this;

        return self.$generate_callout_id(self.list_index, self.co_index)
      }, $Callouts_generate_next_callout_id$9.$$arity = 0);
      return (Opal.def(self, '$generate_callout_id', $Callouts_generate_callout_id$10 = function $$generate_callout_id(list_index, co_index) {
        var self = this;

        return "" + "CO" + (list_index) + "-" + (co_index)
      }, $Callouts_generate_callout_id$10.$$arity = 2), nil) && 'generate_callout_id';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/converter"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $klass = Opal.klass, $gvars = Opal.gvars;

  Opal.add_stubs(['$autoload', '$__dir__', '$==', '$attr_reader', '$raise', '$class', '$[]', '$sub', '$slice', '$length', '$[]=', '$backend_traits', '$-', '$derive_backend_traits', '$register', '$map', '$to_s', '$new', '$create', '$default', '$each', '$default=', '$registry', '$for', '$===', '$supports_templates?', '$merge', '$private', '$include', '$delete', '$clear', '$send', '$extend', '$private_class_method', '$node_name', '$+', '$receiver', '$name', '$warn', '$logger', '$respond_to?', '$content']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Converter');

      var $nesting = [self].concat($parent_nesting), $Converter_initialize$1, $Converter_convert$2, $Converter_handles$ques$3, $Converter_derive_backend_traits$4, $Converter_included$28;

      
      self.$autoload("CompositeConverter", "" + (self.$__dir__()) + "/converter/composite");
      if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
      } else {
        nil
      };
      self.$attr_reader("backend");
      
      Opal.def(self, '$initialize', $Converter_initialize$1 = function $$initialize(backend, opts) {
        var self = this;

        
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        return (self.backend = backend);
      }, $Converter_initialize$1.$$arity = -2);
      
      Opal.def(self, '$convert', $Converter_convert$2 = function $$convert(node, transform, opts) {
        var self = this;
        if (self.backend == null) self.backend = nil;

        
        
        if (transform == null) {
          transform = nil;
        };
        
        if (opts == null) {
          opts = nil;
        };
        return self.$raise($$$('::', 'NotImplementedError'), "" + (self.$class()) + " (backend: " + (self.backend) + ") must implement the #" + ("convert") + " method");
      }, $Converter_convert$2.$$arity = -2);
      
      Opal.def(self, '$handles?', $Converter_handles$ques$3 = function(transform) {
        var self = this;

        return true
      }, $Converter_handles$ques$3.$$arity = 1);
      Opal.defs(self, '$derive_backend_traits', $Converter_derive_backend_traits$4 = function $$derive_backend_traits(backend, basebackend) {
        var $a, self = this, outfilesuffix = nil, filetype = nil;

        
        
        if (basebackend == null) {
          basebackend = nil;
        };
        if ($truthy(backend)) {
        } else {
          return $hash2([], {})
        };
        if ($truthy((outfilesuffix = $$($nesting, 'DEFAULT_EXTENSIONS')['$[]']((basebackend = ($truthy($a = basebackend) ? $a : backend.$sub($$($nesting, 'TrailingDigitsRx'), ""))))))) {
          filetype = outfilesuffix.$slice(1, outfilesuffix.$length())
        } else {
          outfilesuffix = "" + "." + ((filetype = basebackend))
        };
        if (filetype['$==']("html")) {
          return $hash2(["basebackend", "filetype", "htmlsyntax", "outfilesuffix"], {"basebackend": basebackend, "filetype": filetype, "htmlsyntax": "html", "outfilesuffix": outfilesuffix})
        } else {
          return $hash2(["basebackend", "filetype", "outfilesuffix"], {"basebackend": basebackend, "filetype": filetype, "outfilesuffix": outfilesuffix})
        };
      }, $Converter_derive_backend_traits$4.$$arity = -2);
      (function($base, $parent_nesting) {
        var self = $module($base, 'BackendTraits');

        var $nesting = [self].concat($parent_nesting), $BackendTraits_basebackend$5, $BackendTraits_filetype$6, $BackendTraits_htmlsyntax$7, $BackendTraits_outfilesuffix$8, $BackendTraits_supports_templates$9, $BackendTraits_supports_templates$ques$10, $BackendTraits_init_backend_traits$11, $BackendTraits_backend_traits$12, $BackendTraits_derive_backend_traits$13;

        
        
        Opal.def(self, '$basebackend', $BackendTraits_basebackend$5 = function $$basebackend(value) {
          var self = this, $writer = nil;

          
          
          if (value == null) {
            value = nil;
          };
          if ($truthy(value)) {
            
            
            $writer = ["basebackend", value];
            $send(self.$backend_traits(value), '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];;
          } else {
            return self.$backend_traits()['$[]']("basebackend")
          };
        }, $BackendTraits_basebackend$5.$$arity = -1);
        
        Opal.def(self, '$filetype', $BackendTraits_filetype$6 = function $$filetype(value) {
          var self = this, $writer = nil;

          
          
          if (value == null) {
            value = nil;
          };
          if ($truthy(value)) {
            
            
            $writer = ["filetype", value];
            $send(self.$backend_traits(), '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];;
          } else {
            return self.$backend_traits()['$[]']("filetype")
          };
        }, $BackendTraits_filetype$6.$$arity = -1);
        
        Opal.def(self, '$htmlsyntax', $BackendTraits_htmlsyntax$7 = function $$htmlsyntax(value) {
          var self = this, $writer = nil;

          
          
          if (value == null) {
            value = nil;
          };
          if ($truthy(value)) {
            
            
            $writer = ["htmlsyntax", value];
            $send(self.$backend_traits(), '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];;
          } else {
            return self.$backend_traits()['$[]']("htmlsyntax")
          };
        }, $BackendTraits_htmlsyntax$7.$$arity = -1);
        
        Opal.def(self, '$outfilesuffix', $BackendTraits_outfilesuffix$8 = function $$outfilesuffix(value) {
          var self = this, $writer = nil;

          
          
          if (value == null) {
            value = nil;
          };
          if ($truthy(value)) {
            
            
            $writer = ["outfilesuffix", value];
            $send(self.$backend_traits(), '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];;
          } else {
            return self.$backend_traits()['$[]']("outfilesuffix")
          };
        }, $BackendTraits_outfilesuffix$8.$$arity = -1);
        
        Opal.def(self, '$supports_templates', $BackendTraits_supports_templates$9 = function $$supports_templates(value) {
          var self = this, $writer = nil;

          
          
          if (value == null) {
            value = true;
          };
          $writer = ["supports_templates", value];
          $send(self.$backend_traits(), '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        }, $BackendTraits_supports_templates$9.$$arity = -1);
        
        Opal.def(self, '$supports_templates?', $BackendTraits_supports_templates$ques$10 = function() {
          var self = this;

          return self.$backend_traits()['$[]']("supports_templates")
        }, $BackendTraits_supports_templates$ques$10.$$arity = 0);
        
        Opal.def(self, '$init_backend_traits', $BackendTraits_init_backend_traits$11 = function $$init_backend_traits(value) {
          var $a, self = this;

          
          
          if (value == null) {
            value = nil;
          };
          return (self.backend_traits = ($truthy($a = value) ? $a : $hash2([], {})));
        }, $BackendTraits_init_backend_traits$11.$$arity = -1);
        
        Opal.def(self, '$backend_traits', $BackendTraits_backend_traits$12 = function $$backend_traits(basebackend) {
          var $a, self = this;
          if (self.backend_traits == null) self.backend_traits = nil;
          if (self.backend == null) self.backend = nil;

          
          
          if (basebackend == null) {
            basebackend = nil;
          };
          return (self.backend_traits = ($truthy($a = self.backend_traits) ? $a : $$($nesting, 'Converter').$derive_backend_traits(self.backend, basebackend)));
        }, $BackendTraits_backend_traits$12.$$arity = -1);
        Opal.alias(self, "backend_info", "backend_traits");
        Opal.defs(self, '$derive_backend_traits', $BackendTraits_derive_backend_traits$13 = function $$derive_backend_traits(backend, basebackend) {
          var self = this;

          
          
          if (basebackend == null) {
            basebackend = nil;
          };
          return $$($nesting, 'Converter').$derive_backend_traits(backend, basebackend);
        }, $BackendTraits_derive_backend_traits$13.$$arity = -2);
      })($nesting[0], $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'Config');

        var $nesting = [self].concat($parent_nesting), $Config_register_for$14;

        
        Opal.def(self, '$register_for', $Config_register_for$14 = function $$register_for($a) {
          var $post_args, backends, $$15, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          backends = $post_args;;
          return $send($$($nesting, 'Converter'), 'register', [self].concat(Opal.to_a($send(backends, 'map', [], ($$15 = function(backend){var self = $$15.$$s || this;

          
            
            if (backend == null) {
              backend = nil;
            };
            return backend.$to_s();}, $$15.$$s = self, $$15.$$arity = 1, $$15)))));
        }, $Config_register_for$14.$$arity = -1)
      })($nesting[0], $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'Factory');

        var $nesting = [self].concat($parent_nesting), $Factory_new$16, $Factory_default$17, $Factory_create$18, $Factory_register$19, $Factory_for$21, $Factory_create$22, $Factory_converters$23, $Factory_registry$24;

        
        Opal.defs(self, '$new', $Factory_new$16 = function($a, $b) {
          var $post_args, $kwargs, converters, proxy_default, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          $kwargs = Opal.extract_kwargs($post_args);
          
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expected kwargs');
          };
          
          if ($post_args.length > 0) {
            converters = $post_args[0];
            $post_args.splice(0, 1);
          }
          if (converters == null) {
            converters = nil;
          };
          
          proxy_default = $kwargs.$$smap["proxy_default"];
          if (proxy_default == null) {
            proxy_default = true
          };
          if ($truthy(proxy_default)) {
            
            return $$($nesting, 'DefaultFactoryProxy').$new(converters);
          } else {
            
            return $$($nesting, 'CustomFactory').$new(converters);
          };
        }, $Factory_new$16.$$arity = -1);
        Opal.defs(self, '$default', $Factory_default$17 = function($a) {
          var $post_args, args, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $$($nesting, 'Converter');
        }, $Factory_default$17.$$arity = -1);
        Opal.defs(self, '$create', $Factory_create$18 = function $$create(backend, opts) {
          var self = this;

          
          
          if (opts == null) {
            opts = $hash2([], {});
          };
          return self.$default().$create(backend, opts);
        }, $Factory_create$18.$$arity = -2);
        
        Opal.def(self, '$register', $Factory_register$19 = function $$register(converter, $a) {
          var $post_args, backends, $$20, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          backends = $post_args;;
          return $send(backends, 'each', [], ($$20 = function(backend){var self = $$20.$$s || this, $writer = nil;

          
            
            if (backend == null) {
              backend = nil;
            };
            if (backend['$==']("*")) {
              
              
              $writer = [converter];
              $send(self.$registry(), 'default=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];;
            } else {
              
              
              $writer = [backend, converter];
              $send(self.$registry(), '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];;
            };}, $$20.$$s = self, $$20.$$arity = 1, $$20));
        }, $Factory_register$19.$$arity = -2);
        
        Opal.def(self, '$for', $Factory_for$21 = function(backend) {
          var self = this;

          return self.$registry()['$[]'](backend)
        }, $Factory_for$21.$$arity = 1);
        
        Opal.def(self, '$create', $Factory_create$22 = function $$create(backend, opts) {
          var $a, $b, self = this, converter = nil, template_dirs = nil, delegate_backend = nil;

          
          
          if (opts == null) {
            opts = $hash2([], {});
          };
          if ($truthy((converter = self.$for(backend)))) {
            
            if ($truthy($$$('::', 'Class')['$==='](converter))) {
              converter = converter.$new(backend, opts)};
            if ($truthy(($truthy($a = ($truthy($b = (template_dirs = opts['$[]']("template_dirs"))) ? $$($nesting, 'BackendTraits')['$==='](converter) : $b)) ? converter['$supports_templates?']() : $a))) {
              return $$($nesting, 'CompositeConverter').$new(backend, $$($nesting, 'TemplateConverter').$new(backend, template_dirs, opts), converter, $hash2(["backend_traits_source"], {"backend_traits_source": converter}))
            } else {
              return converter
            };
          } else if ($truthy((template_dirs = opts['$[]']("template_dirs")))) {
            if ($truthy(($truthy($a = (delegate_backend = opts['$[]']("delegate_backend"))) ? (converter = self.$for(delegate_backend)) : $a))) {
              
              if ($truthy($$$('::', 'Class')['$==='](converter))) {
                converter = converter.$new(delegate_backend, opts)};
              return $$($nesting, 'CompositeConverter').$new(backend, $$($nesting, 'TemplateConverter').$new(backend, template_dirs, opts), converter, $hash2(["backend_traits_source"], {"backend_traits_source": converter}));
            } else {
              return $$($nesting, 'TemplateConverter').$new(backend, template_dirs, opts)
            }
          } else {
            return nil
          };
        }, $Factory_create$22.$$arity = -2);
        
        Opal.def(self, '$converters', $Factory_converters$23 = function $$converters() {
          var self = this;

          return self.$registry().$merge()
        }, $Factory_converters$23.$$arity = 0);
        self.$private();
        
        Opal.def(self, '$registry', $Factory_registry$24 = function $$registry() {
          var self = this;

          return self.$raise($$$('::', 'NotImplementedError'), "" + ($$($nesting, 'Factory')) + " subclass " + (self.$class()) + " must implement the #" + ("registry") + " method")
        }, $Factory_registry$24.$$arity = 0);
      })($nesting[0], $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'CustomFactory');

        var $nesting = [self].concat($parent_nesting), $CustomFactory_initialize$25, $CustomFactory_unregister_all$26;

        
        self.$include($$($nesting, 'Factory'));
        
        Opal.def(self, '$initialize', $CustomFactory_initialize$25 = function $$initialize(seed_registry) {
          var self = this, $writer = nil;

          
          
          if (seed_registry == null) {
            seed_registry = nil;
          };
          if ($truthy(seed_registry)) {
            
            
            $writer = [seed_registry.$delete("*")];
            $send(seed_registry, 'default=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            return (self.registry = seed_registry);
          } else {
            return (self.registry = $hash2([], {}))
          };
        }, $CustomFactory_initialize$25.$$arity = -1);
        
        Opal.def(self, '$unregister_all', $CustomFactory_unregister_all$26 = function $$unregister_all() {
          var self = this, $writer = nil;

          
          $writer = [nil];
          $send(self.$registry().$clear(), 'default=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        }, $CustomFactory_unregister_all$26.$$arity = 0);
        self.$private();
        return self.$attr_reader("registry");
      })($nesting[0], null, $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'DefaultFactory');

        var $nesting = [self].concat($parent_nesting), $DefaultFactory_registry$27;

        
        self.$include($$($nesting, 'Factory'));
        self.$private();
        (Opal.class_variable_set($nesting[0], '@@registry', $hash2([], {})));
        
        Opal.def(self, '$registry', $DefaultFactory_registry$27 = function $$registry() {
          var $a, self = this;

          return (($a = $nesting[0].$$cvars['@@registry']) == null ? nil : $a)
        }, $DefaultFactory_registry$27.$$arity = 0);
        if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
        } else {
          nil
        };
      })($nesting[0], $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DefaultFactoryProxy');

        var $nesting = [self].concat($parent_nesting);

        
        self.$include($$($nesting, 'DefaultFactory'));
        if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
          return nil
        } else {
          return nil
        };
      })($nesting[0], $$($nesting, 'CustomFactory'), $nesting);
      Opal.defs(self, '$included', $Converter_included$28 = function $$included(into) {
        var self = this;

        
        into.$send("include", $$($nesting, 'BackendTraits'));
        return into.$extend($$($nesting, 'Config'));
      }, $Converter_included$28.$$arity = 1);
      self.$private_class_method("included");
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Base');

        var $nesting = [self].concat($parent_nesting), $Base_convert$29, $Base_handles$ques$30, $Base_content_only$31, $Base_skip$32;

        self.$$prototype.backend = nil;
        
        self.$include($$($nesting, 'Logging'));
        self.$include($$($nesting, 'Converter'));
        
        Opal.def(self, '$convert', $Base_convert$29 = function $$convert(node, transform, opts) {
          var $a, $b, self = this, ex = nil;
          if ($gvars["!"] == null) $gvars["!"] = nil;

          
          
          if (transform == null) {
            transform = node.$node_name();
          };
          
          if (opts == null) {
            opts = nil;
          };
          try {
            if ($truthy(opts)) {
              
              return self.$send($rb_plus("convert_", transform), node, opts);
            } else {
              
              return self.$send($rb_plus("convert_", transform), node);
            }
          } catch ($err) {
            if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
              try {
                
                if ($truthy(($truthy($a = ($truthy($b = $$$('::', 'NoMethodError')['$===']((ex = $gvars["!"]))) ? ex.$receiver()['$=='](self) : $b)) ? ex.$name().$to_s()['$=='](transform) : $a))) {
                } else {
                  self.$raise()
                };
                self.$logger().$warn("" + "missing convert handler for " + (ex.$name()) + " node in " + (self.backend) + " backend (" + (self.$class()) + ")");
                return nil;
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          };
        }, $Base_convert$29.$$arity = -2);
        
        Opal.def(self, '$handles?', $Base_handles$ques$30 = function(transform) {
          var self = this;

          return self['$respond_to?']("" + "convert_" + (transform))
        }, $Base_handles$ques$30.$$arity = 1);
        
        Opal.def(self, '$content_only', $Base_content_only$31 = function $$content_only(node) {
          var self = this;

          return node.$content()
        }, $Base_content_only$31.$$arity = 1);
        return (Opal.def(self, '$skip', $Base_skip$32 = function $$skip(node) {
          var self = this;

          return nil
        }, $Base_skip$32.$$arity = 1), nil) && 'skip';
      })($nesting[0], null, $nesting);
      self.$extend($$($nesting, 'DefaultFactory'));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/document"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2, $hash = Opal.hash, $gvars = Opal.gvars;

  Opal.add_stubs(['$new', '$attr_reader', '$nil?', '$<<', '$[]', '$[]=', '$-', '$include?', '$strip', '$squeeze', '$gsub', '$empty?', '$!', '$rpartition', '$attr_accessor', '$delete', '$base_dir', '$options', '$merge', '$catalog', '$instance_variable_get', '$attributes', '$safe', '$compat_mode', '$outfilesuffix', '$sourcemap', '$path_resolver', '$converter', '$extensions', '$syntax_highlighter', '$each', '$end_with?', '$start_with?', '$slice', '$length', '$chop', '$==', '$downcase', '$===', '$extname', '$value_for_name', '$key?', '$freeze', '$attribute_undefined', '$attribute_missing', '$update', '$&', '$keys', '$name_for_value', '$expand_path', '$pwd', '$to_s', '$>=', '$+', '$abs', '$to_i', '$delete_if', '$update_doctype_attributes', '$cursor', '$parse', '$restore_attributes', '$update_backend_attributes', '$fetch', '$fill_datetime_attributes', '$activate', '$groups', '$create', '$to_proc', '$preprocessors?', '$preprocessors', '$process_method', '$tree_processors?', '$tree_processors', '$!=', '$counter', '$attribute_locked?', '$nil_or_empty?', '$nextval', '$value', '$save_to', '$register', '$tap', '$xreftext', '$>', '$source', '$source_lines', '$doctitle', '$sectname=', '$title=', '$first_section', '$title', '$reftext', '$<', '$find', '$context', '$assign_numeral', '$clear_playback_attributes', '$save_attributes', '$name', '$negate', '$rewind', '$replace', '$apply_attribute_value_subs', '$delete?', '$start', '$doctype', '$content_model', '$warn', '$logger', '$content', '$convert', '$postprocessors?', '$postprocessors', '$record', '$write', '$respond_to?', '$chomp', '$class', '$write_alternate_pages', '$map', '$split', '$resolve_docinfo_subs', '$normalize_system_path', '$read_asset', '$apply_subs', '$docinfo_processors?', '$join', '$concat', '$compact', '$docinfo_processors', '$object_id', '$inspect', '$size', '$private', '$=~', '$resolve_pass_subs', '$apply_header_subs', '$limit_bytesize', '$bytesize', '$valid_encoding?', '$byteslice', '$resolve_subs', '$utc', '$at', '$Integer', '$now', '$index', '$strftime', '$year', '$utc_offset', '$partition', '$create_converter', '$basebackend', '$filetype', '$htmlsyntax', '$derive_backend_traits', '$raise']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Document');

      var $nesting = [self].concat($parent_nesting), $Document$1, $Document_initialize$8, $Document_parse$11, $Document_parsed$ques$14, $Document_counter$15, $Document_increment_and_store_counter$16, $Document_register$17, $Document_resolve_id$18, $Document_sections$ques$22, $Document_footnotes$ques$23, $Document_footnotes$24, $Document_callouts$25, $Document_nested$ques$26, $Document_embedded$ques$27, $Document_extensions$ques$28, $Document_source$29, $Document_source_lines$30, $Document_basebackend$ques$31, $Document_title$32, $Document_title$eq$33, $Document_doctitle$34, $Document_xreftext$35, $Document_author$36, $Document_authors$37, $Document_revdate$38, $Document_notitle$39, $Document_noheader$40, $Document_nofooter$41, $Document_first_section$42, $Document_header$ques$44, $Document_$lt$lt$45, $Document_finalize_header$46, $Document_playback_attributes$47, $Document_restore_attributes$49, $Document_set_attribute$50, $Document_delete_attribute$51, $Document_attribute_locked$ques$52, $Document_set_header_attribute$53, $Document_convert$54, $Document_write$56, $Document_content$57, $Document_docinfo$58, $Document_docinfo_processors$ques$61, $Document_to_s$62, $Document_apply_attribute_value_subs$63, $Document_limit_bytesize$64, $Document_resolve_docinfo_subs$65, $Document_create_converter$66, $Document_clear_playback_attributes$67, $Document_save_attributes$68, $Document_fill_datetime_attributes$70, $Document_update_backend_attributes$71, $Document_update_doctype_attributes$72;

      self.$$prototype.attributes = self.$$prototype.safe = self.$$prototype.sourcemap = self.$$prototype.reader = self.$$prototype.base_dir = self.$$prototype.parsed = self.$$prototype.parent_document = self.$$prototype.extensions = self.$$prototype.options = self.$$prototype.counters = self.$$prototype.catalog = self.$$prototype.reftexts = self.$$prototype.next_section_index = self.$$prototype.header = self.$$prototype.blocks = self.$$prototype.header_attributes = self.$$prototype.attributes_modified = self.$$prototype.backend = self.$$prototype.attribute_overrides = self.$$prototype.timings = self.$$prototype.converter = self.$$prototype.outfilesuffix = self.$$prototype.docinfo_processor_extensions = self.$$prototype.document = self.$$prototype.max_attribute_value_size = self.$$prototype.id = self.$$prototype.doctype = nil;
      
      Opal.const_set($nesting[0], 'ImageReference', $send($$$('::', 'Struct'), 'new', ["target", "imagesdir"], ($Document$1 = function(){var self = $Document$1.$$s || this;

      return Opal.alias(self, "to_s", "target")}, $Document$1.$$s = self, $Document$1.$$arity = 0, $Document$1)));
      Opal.const_set($nesting[0], 'Footnote', $$$('::', 'Struct').$new("index", "id", "text"));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'AttributeEntry');

        var $nesting = [self].concat($parent_nesting), $AttributeEntry_initialize$2, $AttributeEntry_save_to$3;

        
        self.$attr_reader("name", "value", "negate");
        
        Opal.def(self, '$initialize', $AttributeEntry_initialize$2 = function $$initialize(name, value, negate) {
          var self = this;

          
          
          if (negate == null) {
            negate = nil;
          };
          self.name = name;
          self.value = value;
          return (self.negate = (function() {if ($truthy(negate['$nil?']())) {
            return value['$nil?']()
          } else {
            return negate
          }; return nil; })());
        }, $AttributeEntry_initialize$2.$$arity = -3);
        return (Opal.def(self, '$save_to', $AttributeEntry_save_to$3 = function $$save_to(block_attributes) {
          var $a, self = this, $writer = nil;

          
          ($truthy($a = block_attributes['$[]']("attribute_entries")) ? $a : (($writer = ["attribute_entries", []]), $send(block_attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))['$<<'](self);
          return self;
        }, $AttributeEntry_save_to$3.$$arity = 1), nil) && 'save_to';
      })($nesting[0], null, $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Title');

        var $nesting = [self].concat($parent_nesting), $Title_initialize$4, $Title_sanitized$ques$5, $Title_subtitle$ques$6, $Title_to_s$7;

        self.$$prototype.sanitized = self.$$prototype.subtitle = self.$$prototype.combined = nil;
        
        self.$attr_reader("main");
        Opal.alias(self, "title", "main");
        self.$attr_reader("subtitle");
        self.$attr_reader("combined");
        
        Opal.def(self, '$initialize', $Title_initialize$4 = function $$initialize(val, opts) {
          var $a, $b, self = this, sep = nil, _ = nil;

          
          
          if (opts == null) {
            opts = $hash2([], {});
          };
          if ($truthy(($truthy($a = (self.sanitized = opts['$[]']("sanitize"))) ? val['$include?']("<") : $a))) {
            val = val.$gsub($$($nesting, 'XmlSanitizeRx'), "").$squeeze(" ").$strip()};
          if ($truthy(($truthy($a = (sep = ($truthy($b = opts['$[]']("separator")) ? $b : ":"))['$empty?']()) ? $a : val['$include?']((sep = "" + (sep) + " "))['$!']()))) {
            
            self.main = val;
            self.subtitle = nil;
          } else {
            $b = val.$rpartition(sep), $a = Opal.to_ary($b), (self.main = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), (self.subtitle = ($a[2] == null ? nil : $a[2])), $b
          };
          return (self.combined = val);
        }, $Title_initialize$4.$$arity = -2);
        
        Opal.def(self, '$sanitized?', $Title_sanitized$ques$5 = function() {
          var self = this;

          return self.sanitized
        }, $Title_sanitized$ques$5.$$arity = 0);
        
        Opal.def(self, '$subtitle?', $Title_subtitle$ques$6 = function() {
          var self = this;

          if ($truthy(self.subtitle)) {
            return true
          } else {
            return false
          }
        }, $Title_subtitle$ques$6.$$arity = 0);
        return (Opal.def(self, '$to_s', $Title_to_s$7 = function $$to_s() {
          var self = this;

          return self.combined
        }, $Title_to_s$7.$$arity = 0), nil) && 'to_s';
      })($nesting[0], null, $nesting);
      Opal.const_set($nesting[0], 'Author', $$$('::', 'Struct').$new("name", "firstname", "middlename", "lastname", "initials", "email"));
      self.$attr_reader("safe");
      self.$attr_reader("compat_mode");
      self.$attr_reader("backend");
      self.$attr_reader("doctype");
      self.$attr_accessor("sourcemap");
      self.$attr_reader("catalog");
      Opal.alias(self, "references", "catalog");
      self.$attr_reader("counters");
      self.$attr_reader("header");
      self.$attr_reader("base_dir");
      self.$attr_reader("options");
      self.$attr_reader("outfilesuffix");
      self.$attr_reader("parent_document");
      self.$attr_reader("reader");
      self.$attr_reader("path_resolver");
      self.$attr_reader("converter");
      self.$attr_reader("syntax_highlighter");
      self.$attr_reader("extensions");
      
      Opal.def(self, '$initialize', $Document_initialize$8 = function $$initialize(data, options) {
        var $a, $$9, $b, $c, $$10, $d, $e, $f, $g, $iter = $Document_initialize$8.$$p, $yield = $iter || nil, self = this, parent_doc = nil, $writer = nil, attr_overrides = nil, parent_doctype = nil, initialize_extensions = nil, to_file = nil, safe_mode = nil, input_mtime = nil, standalone = nil, attrs = nil, safe_mode_name = nil, base_dir_val = nil, backend_val = nil, doctype_val = nil, size = nil, initial_backend = nil, ext_registry = nil, ext_block = nil;

        if ($iter) $Document_initialize$8.$$p = null;
        
        
        if (data == null) {
          data = nil;
        };
        
        if (options == null) {
          options = $hash2([], {});
        };
        $send(self, Opal.find_super_dispatcher(self, 'initialize', $Document_initialize$8, false), [self, "document"], null);
        if ($truthy((parent_doc = options.$delete("parent")))) {
          
          self.parent_document = parent_doc;
          ($truthy($a = options['$[]']("base_dir")) ? $a : (($writer = ["base_dir", parent_doc.$base_dir()]), $send(options, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
          if ($truthy(parent_doc.$options()['$[]']("catalog_assets"))) {
            
            $writer = ["catalog_assets", true];
            $send(options, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          self.catalog = parent_doc.$catalog().$merge($hash2(["footnotes"], {"footnotes": []}));
          self.attribute_overrides = (attr_overrides = parent_doc.$instance_variable_get("@attribute_overrides").$merge(parent_doc.$attributes()));
          attr_overrides.$delete("compat-mode");
          parent_doctype = attr_overrides.$delete("doctype");
          attr_overrides.$delete("notitle");
          attr_overrides.$delete("showtitle");
          attr_overrides.$delete("toc");
          
          $writer = ["toc-placement", ($truthy($a = attr_overrides.$delete("toc-placement")) ? $a : "auto")];
          $send(self.attributes, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          attr_overrides.$delete("toc-position");
          self.safe = parent_doc.$safe();
          if ($truthy((self.compat_mode = parent_doc.$compat_mode()))) {
            
            $writer = ["compat-mode", ""];
            $send(self.attributes, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          self.outfilesuffix = parent_doc.$outfilesuffix();
          self.sourcemap = parent_doc.$sourcemap();
          self.timings = nil;
          self.path_resolver = parent_doc.$path_resolver();
          self.converter = parent_doc.$converter();
          initialize_extensions = nil;
          self.extensions = parent_doc.$extensions();
          self.syntax_highlighter = parent_doc.$syntax_highlighter();
        } else {
          
          self.parent_document = nil;
          self.catalog = $hash2(["ids", "refs", "footnotes", "links", "images", "callouts", "includes"], {"ids": $hash2([], {}), "refs": $hash2([], {}), "footnotes": [], "links": [], "images": [], "callouts": $$($nesting, 'Callouts').$new(), "includes": $hash2([], {})});
          self.attribute_overrides = (attr_overrides = $hash2([], {}));
          $send(($truthy($a = options['$[]']("attributes")) ? $a : $hash2([], {})), 'each', [], ($$9 = function(key, val){var self = $$9.$$s || this, $b;

          
            
            if (key == null) {
              key = nil;
            };
            
            if (val == null) {
              val = nil;
            };
            if ($truthy(key['$end_with?']("@"))) {
              if ($truthy(key['$start_with?']("!"))) {
                $b = [key.$slice(1, $rb_minus(key.$length(), 2)), false], (key = $b[0]), (val = $b[1]), $b
              } else if ($truthy(key['$end_with?']("!@"))) {
                $b = [key.$slice(0, $rb_minus(key.$length(), 2)), false], (key = $b[0]), (val = $b[1]), $b
              } else {
                $b = [key.$chop(), "" + (val) + "@"], (key = $b[0]), (val = $b[1]), $b
              }
            } else if ($truthy(key['$start_with?']("!"))) {
              $b = [key.$slice(1, key.$length()), (function() {if (val['$==']("@")) {
                return false
              } else {
                return nil
              }; return nil; })()], (key = $b[0]), (val = $b[1]), $b
            } else if ($truthy(key['$end_with?']("!"))) {
              $b = [key.$chop(), (function() {if (val['$==']("@")) {
                return false
              } else {
                return nil
              }; return nil; })()], (key = $b[0]), (val = $b[1]), $b};
            
            $writer = [key.$downcase(), val];
            $send(attr_overrides, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];;}, $$9.$$s = self, $$9.$$arity = 2, $$9));
          if ($truthy($$$('::', 'String')['$===']((to_file = options['$[]']("to_file"))))) {
            
            $writer = ["outfilesuffix", $$($nesting, 'Helpers').$extname(to_file)];
            $send(attr_overrides, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          if ($truthy((safe_mode = options['$[]']("safe"))['$!']())) {
            self.safe = $$$($$($nesting, 'SafeMode'), 'SECURE')
          } else if ($truthy($$$('::', 'Integer')['$==='](safe_mode))) {
            self.safe = safe_mode
          } else {
            self.safe = (function() { try {
              
              return $$($nesting, 'SafeMode').$value_for_name(safe_mode);
            } catch ($err) {
              if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
                try {
                  return $$$($$($nesting, 'SafeMode'), 'SECURE')
                } finally { Opal.pop_exception() }
              } else { throw $err; }
            }})()
          };
          input_mtime = options.$delete("input_mtime");
          self.compat_mode = attr_overrides['$key?']("compat-mode");
          self.sourcemap = options['$[]']("sourcemap");
          self.timings = options.$delete("timings");
          self.path_resolver = $$($nesting, 'PathResolver').$new();
          initialize_extensions = (function() {if ($truthy(($truthy($a = (($c = $$$('::', 'Asciidoctor', 'skip_raise')) && ($b = $$$($c, 'Extensions', 'skip_raise')) ? 'constant' : nil)) ? $a : options['$key?']("extensions")))) {
            return $$$($$$('::', 'Asciidoctor'), 'Extensions')
          } else {
            return nil
          }; return nil; })();
          self.extensions = nil;
          if ($truthy(($truthy($a = options['$key?']("header_footer")) ? options['$key?']("standalone")['$!']() : $a))) {
            
            $writer = ["standalone", options['$[]']("header_footer")];
            $send(options, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
        };
        self.parsed = (self.reftexts = (self.header = (self.header_attributes = nil)));
        self.counters = $hash2([], {});
        self.attributes_modified = $$$('::', 'Set').$new();
        self.docinfo_processor_extensions = $hash2([], {});
        standalone = options['$[]']("standalone");
        (self.options = options).$freeze();
        attrs = self.attributes;
        if ($truthy(parent_doc)) {
        } else {
          
          
          $writer = ["attribute-undefined", $$($nesting, 'Compliance').$attribute_undefined()];
          $send(attrs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = ["attribute-missing", $$($nesting, 'Compliance').$attribute_missing()];
          $send(attrs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          attrs.$update($$($nesting, 'DEFAULT_ATTRIBUTES'));
        };
        if ($truthy(standalone)) {
          
          
          $writer = ["embedded", nil];
          $send(attr_overrides, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = ["copycss", ""];
          $send(attrs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = ["iconfont-remote", ""];
          $send(attrs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = ["stylesheet", ""];
          $send(attrs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = ["webfonts", ""];
          $send(attrs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
        } else {
          
          
          $writer = ["embedded", ""];
          $send(attr_overrides, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          if ($truthy(($truthy($a = attr_overrides['$key?']("showtitle")) ? attr_overrides.$keys()['$&'](["notitle", "showtitle"])['$[]'](-1)['$==']("showtitle") : $a))) {
            
            $writer = ["notitle", $hash(nil, "", false, "@", "@", false)['$[]'](attr_overrides['$[]']("showtitle"))];
            $send(attr_overrides, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          } else if ($truthy(attr_overrides['$key?']("notitle"))) {
            
            $writer = ["showtitle", $hash(nil, "", false, "@", "@", false)['$[]'](attr_overrides['$[]']("notitle"))];
            $send(attr_overrides, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          } else {
            
            $writer = ["notitle", ""];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          };
        };
        
        $writer = ["asciidoctor", ""];
        $send(attr_overrides, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = ["asciidoctor-version", $$$($$$('::', 'Asciidoctor'), 'VERSION')];
        $send(attr_overrides, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = ["safe-mode-name", (safe_mode_name = $$($nesting, 'SafeMode').$name_for_value(self.safe))];
        $send(attr_overrides, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = ["" + "safe-mode-" + (safe_mode_name), ""];
        $send(attr_overrides, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = ["safe-mode-level", self.safe];
        $send(attr_overrides, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        ($truthy($a = attr_overrides['$[]']("max-include-depth")) ? $a : (($writer = ["max-include-depth", 64]), $send(attr_overrides, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        ($truthy($a = attr_overrides['$[]']("allow-uri-read")) ? $a : (($writer = ["allow-uri-read", nil]), $send(attr_overrides, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        if ($truthy(attr_overrides['$key?']("numbered"))) {
          
          $writer = ["sectnums", attr_overrides.$delete("numbered")];
          $send(attr_overrides, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        if ($truthy(attr_overrides['$key?']("hardbreaks"))) {
          
          $writer = ["hardbreaks-option", attr_overrides.$delete("hardbreaks")];
          $send(attr_overrides, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        if ($truthy((base_dir_val = options['$[]']("base_dir")))) {
          self.base_dir = (($writer = ["docdir", $$$('::', 'File').$expand_path(base_dir_val)]), $send(attr_overrides, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])
        } else if ($truthy(attr_overrides['$[]']("docdir"))) {
          self.base_dir = attr_overrides['$[]']("docdir")
        } else {
          self.base_dir = (($writer = ["docdir", $$$('::', 'Dir').$pwd()]), $send(attr_overrides, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])
        };
        if ($truthy((backend_val = options['$[]']("backend")))) {
          
          $writer = ["backend", backend_val.$to_s()];
          $send(attr_overrides, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        if ($truthy((doctype_val = options['$[]']("doctype")))) {
          
          $writer = ["doctype", doctype_val.$to_s()];
          $send(attr_overrides, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        if ($truthy($rb_ge(self.safe, $$$($$($nesting, 'SafeMode'), 'SERVER')))) {
          
          ($truthy($a = attr_overrides['$[]']("copycss")) ? $a : (($writer = ["copycss", nil]), $send(attr_overrides, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
          ($truthy($a = attr_overrides['$[]']("source-highlighter")) ? $a : (($writer = ["source-highlighter", nil]), $send(attr_overrides, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
          ($truthy($a = attr_overrides['$[]']("backend")) ? $a : (($writer = ["backend", $$($nesting, 'DEFAULT_BACKEND')]), $send(attr_overrides, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
          if ($truthy(($truthy($a = parent_doc['$!']()) ? attr_overrides['$key?']("docfile") : $a))) {
            
            $writer = ["docfile", attr_overrides['$[]']("docfile")['$[]'](Opal.Range.$new($rb_plus(attr_overrides['$[]']("docdir").$length(), 1), -1, false))];
            $send(attr_overrides, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          
          $writer = ["docdir", ""];
          $send(attr_overrides, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          ($truthy($a = attr_overrides['$[]']("user-home")) ? $a : (($writer = ["user-home", "."]), $send(attr_overrides, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
          if ($truthy($rb_ge(self.safe, $$$($$($nesting, 'SafeMode'), 'SECURE')))) {
            
            if ($truthy(attr_overrides['$key?']("max-attribute-value-size"))) {
            } else {
              
              $writer = ["max-attribute-value-size", 4096];
              $send(attr_overrides, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            };
            if ($truthy(attr_overrides['$key?']("linkcss"))) {
            } else {
              
              $writer = ["linkcss", ""];
              $send(attr_overrides, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            };
            ($truthy($a = attr_overrides['$[]']("icons")) ? $a : (($writer = ["icons", nil]), $send(attr_overrides, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));};
        } else {
          ($truthy($a = attr_overrides['$[]']("user-home")) ? $a : (($writer = ["user-home", $$($nesting, 'USER_HOME')]), $send(attr_overrides, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))
        };
        self.max_attribute_value_size = (function() {if ($truthy((size = ($truthy($a = attr_overrides['$[]']("max-attribute-value-size")) ? $a : (($writer = ["max-attribute-value-size", nil]), $send(attr_overrides, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))))) {
          return size.$to_i().$abs()
        } else {
          return nil
        }; return nil; })();
        $send(attr_overrides, 'delete_if', [], ($$10 = function(key, val){var self = $$10.$$s || this, $d, verdict = nil;

        
          
          if (key == null) {
            key = nil;
          };
          
          if (val == null) {
            val = nil;
          };
          if ($truthy(val)) {
            
            if ($truthy(($truthy($d = $$$('::', 'String')['$==='](val)) ? val['$end_with?']("@") : $d))) {
              $d = [val.$chop(), true], (val = $d[0]), (verdict = $d[1]), $d};
            
            $writer = [key, val];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
          } else {
            
            attrs.$delete(key);
            verdict = val['$=='](false);
          };
          return verdict;}, $$10.$$s = self, $$10.$$arity = 2, $$10));
        if ($truthy(parent_doc)) {
          
          self.backend = attrs['$[]']("backend");
          if ((self.doctype = (($writer = ["doctype", parent_doctype]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))['$==']($$($nesting, 'DEFAULT_DOCTYPE'))) {
          } else {
            self.$update_doctype_attributes($$($nesting, 'DEFAULT_DOCTYPE'))
          };
          self.reader = $$($nesting, 'Reader').$new(data, options['$[]']("cursor"));
          if ($truthy(self.sourcemap)) {
            self.source_location = self.reader.$cursor()};
          $$($nesting, 'Parser').$parse(self.reader, self);
          self.$restore_attributes();
          return (self.parsed = true);
        } else {
          
          self.backend = nil;
          if ((initial_backend = ($truthy($a = attrs['$[]']("backend")) ? $a : $$($nesting, 'DEFAULT_BACKEND')))['$==']("manpage")) {
            self.doctype = (($writer = ["doctype", (($writer = ["doctype", "manpage"]), $send(attr_overrides, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])
          } else {
            self.doctype = ($truthy($a = attrs['$[]']("doctype")) ? $a : (($writer = ["doctype", $$($nesting, 'DEFAULT_DOCTYPE')]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))
          };
          self.$update_backend_attributes(initial_backend, true);
          ($truthy($a = attrs['$[]']("stylesdir")) ? $a : (($writer = ["stylesdir", "."]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
          ($truthy($a = attrs['$[]']("iconsdir")) ? $a : (($writer = ["iconsdir", "" + (attrs.$fetch("imagesdir", "./images")) + "/icons"]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
          self.$fill_datetime_attributes(attrs, input_mtime);
          if ($truthy(initialize_extensions)) {
            if ($truthy((ext_registry = options['$[]']("extension_registry")))) {
              if ($truthy(($truthy($a = $$$($$($nesting, 'Extensions'), 'Registry')['$==='](ext_registry)) ? $a : ($truthy($d = (($g = $$$('::', 'AsciidoctorJ', 'skip_raise')) && ($f = $$$($g, 'Extensions', 'skip_raise')) && ($e = $$$($f, 'ExtensionRegistry', 'skip_raise')) ? 'constant' : nil)) ? $$$($$$($$$('::', 'AsciidoctorJ'), 'Extensions'), 'ExtensionRegistry')['$==='](ext_registry) : $d)))) {
                self.extensions = ext_registry.$activate(self)}
            } else if ($truthy((ext_block = options['$[]']("extensions"))['$nil?']())) {
              if ($truthy($$($nesting, 'Extensions').$groups()['$empty?']())) {
              } else {
                self.extensions = $$$($$($nesting, 'Extensions'), 'Registry').$new().$activate(self)
              }
            } else if ($truthy($$$('::', 'Proc')['$==='](ext_block))) {
              self.extensions = $send($$($nesting, 'Extensions'), 'create', [], ext_block.$to_proc()).$activate(self)}};
          self.reader = $$($nesting, 'PreprocessorReader').$new(self, data, $$$($$($nesting, 'Reader'), 'Cursor').$new(attrs['$[]']("docfile"), self.base_dir), $hash2(["normalize"], {"normalize": true}));
          if ($truthy(self.sourcemap)) {
            return (self.source_location = self.reader.$cursor())
          } else {
            return nil
          };
        };
      }, $Document_initialize$8.$$arity = -1);
      
      Opal.def(self, '$parse', $Document_parse$11 = function $$parse(data) {
        var $a, $$12, $$13, self = this, doc = nil, exts = nil;

        
        
        if (data == null) {
          data = nil;
        };
        if ($truthy(self.parsed)) {
          return self
        } else {
          
          doc = self;
          if ($truthy(data)) {
            
            self.reader = $$($nesting, 'PreprocessorReader').$new(doc, data, $$$($$($nesting, 'Reader'), 'Cursor').$new(self.attributes['$[]']("docfile"), self.base_dir), $hash2(["normalize"], {"normalize": true}));
            if ($truthy(self.sourcemap)) {
              self.source_location = self.reader.$cursor()};};
          if ($truthy(($truthy($a = (exts = (function() {if ($truthy(self.parent_document)) {
            return nil
          } else {
            return self.extensions
          }; return nil; })())) ? exts['$preprocessors?']() : $a))) {
            $send(exts.$preprocessors(), 'each', [], ($$12 = function(ext){var self = $$12.$$s || this, $b;
              if (self.reader == null) self.reader = nil;

            
              
              if (ext == null) {
                ext = nil;
              };
              return (self.reader = ($truthy($b = ext.$process_method()['$[]'](doc, self.reader)) ? $b : self.reader));}, $$12.$$s = self, $$12.$$arity = 1, $$12))};
          $$($nesting, 'Parser').$parse(self.reader, doc, $hash2(["header_only"], {"header_only": self.options['$[]']("parse_header_only")}));
          self.$restore_attributes();
          if ($truthy(($truthy($a = exts) ? exts['$tree_processors?']() : $a))) {
            $send(exts.$tree_processors(), 'each', [], ($$13 = function(ext){var self = $$13.$$s || this, $b, $c, result = nil;

            
              
              if (ext == null) {
                ext = nil;
              };
              if ($truthy(($truthy($b = ($truthy($c = (result = ext.$process_method()['$[]'](doc))) ? $$($nesting, 'Document')['$==='](result) : $c)) ? result['$!='](doc) : $b))) {
                return (doc = result)
              } else {
                return nil
              };}, $$13.$$s = self, $$13.$$arity = 1, $$13))};
          self.parsed = true;
          return doc;
        };
      }, $Document_parse$11.$$arity = -1);
      
      Opal.def(self, '$parsed?', $Document_parsed$ques$14 = function() {
        var self = this;

        return self.parsed
      }, $Document_parsed$ques$14.$$arity = 0);
      
      Opal.def(self, '$counter', $Document_counter$15 = function $$counter(name, seed) {
        var $a, $b, self = this, locked = nil, curr_val = nil, next_val = nil, $writer = nil;

        
        
        if (seed == null) {
          seed = nil;
        };
        if ($truthy(self.parent_document)) {
          return self.parent_document.$counter(name, seed)};
        if ($truthy(($truthy($a = ($truthy($b = (locked = self['$attribute_locked?'](name))) ? (curr_val = self.counters['$[]'](name)) : $b)) ? $a : (curr_val = self.attributes['$[]'](name))['$nil_or_empty?']()['$!']()))) {
          next_val = (($writer = [name, $$($nesting, 'Helpers').$nextval(curr_val)]), $send(self.counters, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])
        } else if ($truthy(seed)) {
          next_val = (($writer = [name, (function() {if (seed['$=='](seed.$to_i().$to_s())) {
            return seed.$to_i()
          } else {
            return seed
          }; return nil; })()]), $send(self.counters, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])
        } else {
          next_val = (($writer = [name, 1]), $send(self.counters, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])
        };
        if ($truthy(locked)) {
        } else {
          
          $writer = [name, next_val];
          $send(self.attributes, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        };
        return next_val;
      }, $Document_counter$15.$$arity = -2);
      
      Opal.def(self, '$increment_and_store_counter', $Document_increment_and_store_counter$16 = function $$increment_and_store_counter(counter_name, block) {
        var self = this;

        return $$($nesting, 'AttributeEntry').$new(counter_name, self.$counter(counter_name)).$save_to(block.$attributes()).$value()
      }, $Document_increment_and_store_counter$16.$$arity = 2);
      Opal.alias(self, "counter_increment", "increment_and_store_counter");
      
      Opal.def(self, '$register', $Document_register$17 = function $$register(type, value) {
        var $a, self = this, $case = nil, id = nil, $logical_op_recvr_tmp_1 = nil, $writer = nil, ref = nil;

        return (function() {$case = type;
        if ("ids"['$===']($case)) {return self.$register("refs", [(id = value['$[]'](0)), $$($nesting, 'Inline').$new(self, "anchor", value['$[]'](1), $hash2(["type", "id"], {"type": "ref", "id": id}))])}
        else if ("refs"['$===']($case)) {
        
        $logical_op_recvr_tmp_1 = self.catalog['$[]']("refs");
        ($truthy($a = $logical_op_recvr_tmp_1['$[]'](value['$[]'](0))) ? $a : (($writer = [value['$[]'](0), (ref = value['$[]'](1))]), $send($logical_op_recvr_tmp_1, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));;
        return ref;}
        else if ("footnotes"['$===']($case)) {return self.catalog['$[]'](type)['$<<'](value)}
        else {if ($truthy(self.options['$[]']("catalog_assets"))) {
          return self.catalog['$[]'](type)['$<<']((function() {if (type['$==']("images")) {
            
            return $$($nesting, 'ImageReference').$new(value, self.attributes['$[]']("imagesdir"));
          } else {
            return value
          }; return nil; })())
        } else {
          return nil
        }}})()
      }, $Document_register$17.$$arity = 2);
      
      Opal.def(self, '$resolve_id', $Document_resolve_id$18 = function $$resolve_id(text) {
        var $$19, $$21, self = this, resolved_id = nil, accum = nil;

        if ($truthy(self.reftexts)) {
          return self.reftexts['$[]'](text)
        } else if ($truthy(self.parsed)) {
          return $send((self.reftexts = $hash2([], {})), 'tap', [], ($$19 = function(accum){var self = $$19.$$s || this, $$20;
            if (self.catalog == null) self.catalog = nil;

          
            
            if (accum == null) {
              accum = nil;
            };
            return $send(self.catalog['$[]']("refs"), 'each', [], ($$20 = function(id, ref){var self = $$20.$$s || this, $a, $writer = nil;

            
              
              if (id == null) {
                id = nil;
              };
              
              if (ref == null) {
                ref = nil;
              };
              return ($truthy($a = accum['$[]'](ref.$xreftext())) ? $a : (($writer = [ref.$xreftext(), id]), $send(accum, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));}, $$20.$$s = self, $$20.$$arity = 2, $$20));}, $$19.$$s = self, $$19.$$arity = 1, $$19))['$[]'](text)
        } else {
          
          resolved_id = nil;
          self.reftexts = (accum = $hash2([], {}));
          (function(){var $brk = Opal.new_brk(); try {return $send(self.catalog['$[]']("refs"), 'each', [], ($$21 = function(id, ref){var self = $$21.$$s || this, $a, xreftext = nil, $writer = nil;

          
            
            if (id == null) {
              id = nil;
            };
            
            if (ref == null) {
              ref = nil;
            };
            if ((xreftext = ref.$xreftext())['$=='](text)) {
              
              resolved_id = id;
              
              Opal.brk(nil, $brk);};
            return ($truthy($a = accum['$[]'](xreftext)) ? $a : (($writer = [xreftext, id]), $send(accum, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));}, $$21.$$s = self, $$21.$$brk = $brk, $$21.$$arity = 2, $$21))
          } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
          self.reftexts = nil;
          return resolved_id;
        }
      }, $Document_resolve_id$18.$$arity = 1);
      
      Opal.def(self, '$sections?', $Document_sections$ques$22 = function() {
        var self = this;

        return $rb_gt(self.next_section_index, 0)
      }, $Document_sections$ques$22.$$arity = 0);
      
      Opal.def(self, '$footnotes?', $Document_footnotes$ques$23 = function() {
        var self = this;

        if ($truthy(self.catalog['$[]']("footnotes")['$empty?']())) {
          return false
        } else {
          return true
        }
      }, $Document_footnotes$ques$23.$$arity = 0);
      
      Opal.def(self, '$footnotes', $Document_footnotes$24 = function $$footnotes() {
        var self = this;

        return self.catalog['$[]']("footnotes")
      }, $Document_footnotes$24.$$arity = 0);
      
      Opal.def(self, '$callouts', $Document_callouts$25 = function $$callouts() {
        var self = this;

        return self.catalog['$[]']("callouts")
      }, $Document_callouts$25.$$arity = 0);
      
      Opal.def(self, '$nested?', $Document_nested$ques$26 = function() {
        var self = this;

        if ($truthy(self.parent_document)) {
          return true
        } else {
          return false
        }
      }, $Document_nested$ques$26.$$arity = 0);
      
      Opal.def(self, '$embedded?', $Document_embedded$ques$27 = function() {
        var self = this;

        return self.attributes['$key?']("embedded")
      }, $Document_embedded$ques$27.$$arity = 0);
      
      Opal.def(self, '$extensions?', $Document_extensions$ques$28 = function() {
        var self = this;

        if ($truthy(self.extensions)) {
          return true
        } else {
          return false
        }
      }, $Document_extensions$ques$28.$$arity = 0);
      
      Opal.def(self, '$source', $Document_source$29 = function $$source() {
        var self = this;

        if ($truthy(self.reader)) {
          return self.reader.$source()
        } else {
          return nil
        }
      }, $Document_source$29.$$arity = 0);
      
      Opal.def(self, '$source_lines', $Document_source_lines$30 = function $$source_lines() {
        var self = this;

        if ($truthy(self.reader)) {
          return self.reader.$source_lines()
        } else {
          return nil
        }
      }, $Document_source_lines$30.$$arity = 0);
      
      Opal.def(self, '$basebackend?', $Document_basebackend$ques$31 = function(base) {
        var self = this;

        return self.attributes['$[]']("basebackend")['$=='](base)
      }, $Document_basebackend$ques$31.$$arity = 1);
      
      Opal.def(self, '$title', $Document_title$32 = function $$title() {
        var self = this;

        return self.$doctitle()
      }, $Document_title$32.$$arity = 0);
      
      Opal.def(self, '$title=', $Document_title$eq$33 = function(title) {
        var self = this, sect = nil, $writer = nil;

        
        if ($truthy((sect = self.header))) {
        } else {
          
          $writer = ["header"];
          $send((sect = (self.header = $$($nesting, 'Section').$new(self, 0))), 'sectname=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        };
        
        $writer = [title];
        $send(sect, 'title=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];;
      }, $Document_title$eq$33.$$arity = 1);
      
      Opal.def(self, '$doctitle', $Document_doctitle$34 = function $$doctitle(opts) {
        var $a, self = this, val = nil, sect = nil, separator = nil;

        
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        if ($truthy((val = self.attributes['$[]']("title")))) {
        } else if ($truthy((sect = self.$first_section()))) {
          val = sect.$title()
        } else if ($truthy(($truthy($a = opts['$[]']("use_fallback")) ? (val = self.attributes['$[]']("untitled-label")) : $a)['$!']())) {
          return nil};
        if ($truthy((separator = opts['$[]']("partition")))) {
          return $$($nesting, 'Title').$new(val, opts.$merge($hash2(["separator"], {"separator": (function() {if (separator['$=='](true)) {
            return self.attributes['$[]']("title-separator")
          } else {
            return separator
          }; return nil; })()})))
        } else if ($truthy(($truthy($a = opts['$[]']("sanitize")) ? val['$include?']("<") : $a))) {
          return val.$gsub($$($nesting, 'XmlSanitizeRx'), "").$squeeze(" ").$strip()
        } else {
          return val
        };
      }, $Document_doctitle$34.$$arity = -1);
      Opal.alias(self, "name", "doctitle");
      
      Opal.def(self, '$xreftext', $Document_xreftext$35 = function $$xreftext(xrefstyle) {
        var $a, self = this, val = nil;

        
        
        if (xrefstyle == null) {
          xrefstyle = nil;
        };
        if ($truthy(($truthy($a = (val = self.$reftext())) ? val['$empty?']()['$!']() : $a))) {
          return val
        } else {
          return self.$title()
        };
      }, $Document_xreftext$35.$$arity = -1);
      
      Opal.def(self, '$author', $Document_author$36 = function $$author() {
        var self = this;

        return self.attributes['$[]']("author")
      }, $Document_author$36.$$arity = 0);
      
      Opal.def(self, '$authors', $Document_authors$37 = function $$authors() {
        var $a, self = this, attrs = nil, authors = nil, num_authors = nil, idx = nil;

        if ($truthy((attrs = self.attributes)['$key?']("author"))) {
          
          authors = [$$($nesting, 'Author').$new(attrs['$[]']("author"), attrs['$[]']("firstname"), attrs['$[]']("middlename"), attrs['$[]']("lastname"), attrs['$[]']("authorinitials"), attrs['$[]']("email"))];
          if ($truthy($rb_gt((num_authors = ($truthy($a = attrs['$[]']("authorcount")) ? $a : 0)), 1))) {
            
            idx = 1;
            while ($truthy($rb_lt(idx, num_authors))) {
              
              idx = $rb_plus(idx, 1);
              authors['$<<']($$($nesting, 'Author').$new(attrs['$[]']("" + "author_" + (idx)), attrs['$[]']("" + "firstname_" + (idx)), attrs['$[]']("" + "middlename_" + (idx)), attrs['$[]']("" + "lastname_" + (idx)), attrs['$[]']("" + "authorinitials_" + (idx)), attrs['$[]']("" + "email_" + (idx))));
            };};
          return authors;
        } else {
          return []
        }
      }, $Document_authors$37.$$arity = 0);
      
      Opal.def(self, '$revdate', $Document_revdate$38 = function $$revdate() {
        var self = this;

        return self.attributes['$[]']("revdate")
      }, $Document_revdate$38.$$arity = 0);
      
      Opal.def(self, '$notitle', $Document_notitle$39 = function $$notitle() {
        var self = this;

        return self.attributes['$key?']("notitle")
      }, $Document_notitle$39.$$arity = 0);
      
      Opal.def(self, '$noheader', $Document_noheader$40 = function $$noheader() {
        var self = this;

        return self.attributes['$key?']("noheader")
      }, $Document_noheader$40.$$arity = 0);
      
      Opal.def(self, '$nofooter', $Document_nofooter$41 = function $$nofooter() {
        var self = this;

        return self.attributes['$key?']("nofooter")
      }, $Document_nofooter$41.$$arity = 0);
      
      Opal.def(self, '$first_section', $Document_first_section$42 = function $$first_section() {
        var $a, $$43, self = this;

        return ($truthy($a = self.header) ? $a : $send(self.blocks, 'find', [], ($$43 = function(e){var self = $$43.$$s || this;

        
          
          if (e == null) {
            e = nil;
          };
          return e.$context()['$==']("section");}, $$43.$$s = self, $$43.$$arity = 1, $$43)))
      }, $Document_first_section$42.$$arity = 0);
      
      Opal.def(self, '$header?', $Document_header$ques$44 = function() {
        var self = this;

        if ($truthy(self.header)) {
          return true
        } else {
          return false
        }
      }, $Document_header$ques$44.$$arity = 0);
      Opal.alias(self, "has_header?", "header?");
      
      Opal.def(self, '$<<', $Document_$lt$lt$45 = function(block) {
        var $iter = $Document_$lt$lt$45.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $Document_$lt$lt$45.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        if (block.$context()['$==']("section")) {
          self.$assign_numeral(block)};
        return $send(self, Opal.find_super_dispatcher(self, '<<', $Document_$lt$lt$45, false), $zuper, $iter);
      }, $Document_$lt$lt$45.$$arity = 1);
      
      Opal.def(self, '$finalize_header', $Document_finalize_header$46 = function $$finalize_header(unrooted_attributes, header_valid) {
        var self = this, $writer = nil;

        
        
        if (header_valid == null) {
          header_valid = true;
        };
        self.$clear_playback_attributes(unrooted_attributes);
        self.$save_attributes();
        if ($truthy(header_valid)) {
        } else {
          
          $writer = ["invalid-header", true];
          $send(unrooted_attributes, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        };
        return unrooted_attributes;
      }, $Document_finalize_header$46.$$arity = -2);
      
      Opal.def(self, '$playback_attributes', $Document_playback_attributes$47 = function $$playback_attributes(block_attributes) {
        var $$48, self = this;

        if ($truthy(block_attributes['$key?']("attribute_entries"))) {
          return $send(block_attributes['$[]']("attribute_entries"), 'each', [], ($$48 = function(entry){var self = $$48.$$s || this, name = nil, $writer = nil;
            if (self.attributes == null) self.attributes = nil;

          
            
            if (entry == null) {
              entry = nil;
            };
            name = entry.$name();
            if ($truthy(entry.$negate())) {
              
              self.attributes.$delete(name);
              if (name['$==']("compat-mode")) {
                return (self.compat_mode = false)
              } else {
                return nil
              };
            } else {
              
              
              $writer = [name, entry.$value()];
              $send(self.attributes, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              if (name['$==']("compat-mode")) {
                return (self.compat_mode = true)
              } else {
                return nil
              };
            };}, $$48.$$s = self, $$48.$$arity = 1, $$48))
        } else {
          return nil
        }
      }, $Document_playback_attributes$47.$$arity = 1);
      
      Opal.def(self, '$restore_attributes', $Document_restore_attributes$49 = function $$restore_attributes() {
        var self = this;

        
        if ($truthy(self.parent_document)) {
        } else {
          self.catalog['$[]']("callouts").$rewind()
        };
        return self.attributes.$replace(self.header_attributes);
      }, $Document_restore_attributes$49.$$arity = 0);
      
      Opal.def(self, '$set_attribute', $Document_set_attribute$50 = function $$set_attribute(name, value) {
        var $a, self = this, $writer = nil, $case = nil;

        
        
        if (value == null) {
          value = "";
        };
        if ($truthy(self['$attribute_locked?'](name))) {
          return nil
        } else {
          
          if ($truthy(value['$empty?']())) {
          } else {
            value = self.$apply_attribute_value_subs(value)
          };
          if ($truthy(self.header_attributes)) {
            
            $writer = [name, value];
            $send(self.attributes, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          } else {
            
            $case = name;
            if ("backend"['$===']($case)) {self.$update_backend_attributes(value, ($truthy($a = self.attributes_modified['$delete?']("htmlsyntax")) ? value['$=='](self.backend) : $a))}
            else if ("doctype"['$===']($case)) {self.$update_doctype_attributes(value)}
            else {
            $writer = [name, value];
            $send(self.attributes, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
            self.attributes_modified['$<<'](name);
          };
          return value;
        };
      }, $Document_set_attribute$50.$$arity = -2);
      
      Opal.def(self, '$delete_attribute', $Document_delete_attribute$51 = function $$delete_attribute(name) {
        var self = this;

        if ($truthy(self['$attribute_locked?'](name))) {
          return false
        } else {
          
          self.attributes.$delete(name);
          self.attributes_modified['$<<'](name);
          return true;
        }
      }, $Document_delete_attribute$51.$$arity = 1);
      
      Opal.def(self, '$attribute_locked?', $Document_attribute_locked$ques$52 = function(name) {
        var self = this;

        return self.attribute_overrides['$key?'](name)
      }, $Document_attribute_locked$ques$52.$$arity = 1);
      
      Opal.def(self, '$set_header_attribute', $Document_set_header_attribute$53 = function $$set_header_attribute(name, value, overwrite) {
        var $a, self = this, attrs = nil, $writer = nil;

        
        
        if (value == null) {
          value = "";
        };
        
        if (overwrite == null) {
          overwrite = true;
        };
        attrs = ($truthy($a = self.header_attributes) ? $a : self.attributes);
        if ($truthy((($a = overwrite['$=='](false)) ? attrs['$key?'](name) : overwrite['$=='](false)))) {
          return false
        } else {
          
          
          $writer = [name, value];
          $send(attrs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return true;
        };
      }, $Document_set_header_attribute$53.$$arity = -2);
      
      Opal.def(self, '$convert', $Document_convert$54 = function $$convert(opts) {
        var $a, $$55, self = this, $writer = nil, block = nil, output = nil, transform = nil, exts = nil;

        
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        if ($truthy(self.timings)) {
          self.timings.$start("convert")};
        if ($truthy(self.parsed)) {
        } else {
          self.$parse()
        };
        if ($truthy(($truthy($a = $rb_ge(self.safe, $$$($$($nesting, 'SafeMode'), 'SERVER'))) ? $a : opts['$empty?']()))) {
        } else {
          
          if ($truthy((($writer = ["outfile", opts['$[]']("outfile")]), $send(self.attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))) {
          } else {
            self.attributes.$delete("outfile")
          };
          if ($truthy((($writer = ["outdir", opts['$[]']("outdir")]), $send(self.attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))) {
          } else {
            self.attributes.$delete("outdir")
          };
        };
        if (self.$doctype()['$==']("inline")) {
          if ($truthy((block = ($truthy($a = self.blocks['$[]'](0)) ? $a : self.header)))) {
            if ($truthy(($truthy($a = block.$content_model()['$==']("compound")) ? $a : block.$content_model()['$==']("empty")))) {
              self.$logger().$warn("no inline candidate; use the inline doctype to convert a single paragragh, verbatim, or raw block")
            } else {
              output = block.$content()
            }}
        } else {
          
          if ($truthy(opts['$key?']("standalone"))) {
            transform = (function() {if ($truthy(opts['$[]']("standalone"))) {
              return "document"
            } else {
              return "embedded"
            }; return nil; })()
          } else if ($truthy(opts['$key?']("header_footer"))) {
            transform = (function() {if ($truthy(opts['$[]']("header_footer"))) {
              return "document"
            } else {
              return "embedded"
            }; return nil; })()
          } else {
            transform = (function() {if ($truthy(self.options['$[]']("standalone"))) {
              return "document"
            } else {
              return "embedded"
            }; return nil; })()
          };
          output = self.converter.$convert(self, transform);
        };
        if ($truthy(self.parent_document)) {
        } else if ($truthy(($truthy($a = (exts = self.extensions)) ? exts['$postprocessors?']() : $a))) {
          $send(exts.$postprocessors(), 'each', [], ($$55 = function(ext){var self = $$55.$$s || this;

          
            
            if (ext == null) {
              ext = nil;
            };
            return (output = ext.$process_method()['$[]'](self, output));}, $$55.$$s = self, $$55.$$arity = 1, $$55))};
        if ($truthy(self.timings)) {
          self.timings.$record("convert")};
        return output;
      }, $Document_convert$54.$$arity = -1);
      Opal.alias(self, "render", "convert");
      
      Opal.def(self, '$write', $Document_write$56 = function $$write(output, target) {
        var $a, $b, self = this;

        
        if ($truthy(self.timings)) {
          self.timings.$start("write")};
        if ($truthy($$($nesting, 'Writer')['$==='](self.converter))) {
          self.converter.$write(output, target)
        } else {
          
          if ($truthy(target['$respond_to?']("write"))) {
            if ($truthy(output['$nil_or_empty?']())) {
            } else {
              
              target.$write(output.$chomp());
              target.$write($$($nesting, 'LF'));
            }
          } else {
            $$$('::', 'File').$write(target, output, $hash2(["mode"], {"mode": $$($nesting, 'FILE_WRITE_MODE')}))
          };
          if ($truthy(($truthy($a = (($b = self.backend['$==']("manpage")) ? $$$('::', 'String')['$==='](target) : self.backend['$==']("manpage"))) ? self.converter.$class()['$respond_to?']("write_alternate_pages") : $a))) {
            self.converter.$class().$write_alternate_pages(self.attributes['$[]']("mannames"), self.attributes['$[]']("manvolnum"), target)};
        };
        if ($truthy(self.timings)) {
          self.timings.$record("write")};
        return nil;
      }, $Document_write$56.$$arity = 2);
      
      Opal.def(self, '$content', $Document_content$57 = function $$content() {
        var $iter = $Document_content$57.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $Document_content$57.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        self.attributes.$delete("title");
        return $send(self, Opal.find_super_dispatcher(self, 'content', $Document_content$57, false), $zuper, $iter);
      }, $Document_content$57.$$arity = 0);
      
      Opal.def(self, '$docinfo', $Document_docinfo$58 = function $$docinfo(location, suffix) {
        var $a, $$59, $$60, self = this, qualifier = nil, docinfo = nil, content = nil, docinfo_file = nil, docinfo_dir = nil, docinfo_subs = nil, docinfo_path = nil, shared_docinfo = nil, private_docinfo = nil;

        
        
        if (location == null) {
          location = "head";
        };
        
        if (suffix == null) {
          suffix = nil;
        };
        if ($truthy($rb_lt(self.$safe(), $$$($$($nesting, 'SafeMode'), 'SECURE')))) {
          
          if (location['$==']("head")) {
          } else {
            qualifier = "" + "-" + (location)
          };
          suffix = ($truthy($a = suffix) ? $a : self.outfilesuffix);
          if ($truthy((docinfo = self.attributes['$[]']("docinfo"))['$nil_or_empty?']())) {
            if ($truthy(self.attributes['$key?']("docinfo2"))) {
              docinfo = ["private", "shared"]
            } else if ($truthy(self.attributes['$key?']("docinfo1"))) {
              docinfo = ["shared"]
            } else {
              docinfo = (function() {if ($truthy(docinfo)) {
                return ["private"]
              } else {
                return nil
              }; return nil; })()
            }
          } else {
            docinfo = $send(docinfo.$split(","), 'map', [], ($$59 = function(it){var self = $$59.$$s || this;

            
              
              if (it == null) {
                it = nil;
              };
              return it.$strip();}, $$59.$$s = self, $$59.$$arity = 1, $$59))
          };
          if ($truthy(docinfo)) {
            
            content = [];
            $a = ["" + "docinfo" + (qualifier) + (suffix), self.attributes['$[]']("docinfodir"), self.$resolve_docinfo_subs()], (docinfo_file = $a[0]), (docinfo_dir = $a[1]), (docinfo_subs = $a[2]), $a;
            if ($truthy(docinfo['$&'](["shared", "" + "shared-" + (location)])['$empty?']())) {
            } else {
              
              docinfo_path = self.$normalize_system_path(docinfo_file, docinfo_dir);
              if ($truthy((shared_docinfo = self.$read_asset(docinfo_path, $hash2(["normalize"], {"normalize": true}))))) {
                content['$<<'](self.$apply_subs(shared_docinfo, docinfo_subs))};
            };
            if ($truthy(($truthy($a = self.attributes['$[]']("docname")['$nil_or_empty?']()) ? $a : docinfo['$&'](["private", "" + "private-" + (location)])['$empty?']()))) {
            } else {
              
              docinfo_path = self.$normalize_system_path("" + (self.attributes['$[]']("docname")) + "-" + (docinfo_file), docinfo_dir);
              if ($truthy((private_docinfo = self.$read_asset(docinfo_path, $hash2(["normalize"], {"normalize": true}))))) {
                content['$<<'](self.$apply_subs(private_docinfo, docinfo_subs))};
            };};};
        if ($truthy(($truthy($a = self.extensions) ? self['$docinfo_processors?'](location) : $a))) {
          return ($truthy($a = content) ? $a : []).$concat($send(self.docinfo_processor_extensions['$[]'](location), 'map', [], ($$60 = function(ext){var self = $$60.$$s || this;

          
            
            if (ext == null) {
              ext = nil;
            };
            return ext.$process_method()['$[]'](self);}, $$60.$$s = self, $$60.$$arity = 1, $$60)).$compact()).$join($$($nesting, 'LF'))
        } else if ($truthy(content)) {
          return content.$join($$($nesting, 'LF'))
        } else {
          return ""
        };
      }, $Document_docinfo$58.$$arity = -1);
      
      Opal.def(self, '$docinfo_processors?', $Document_docinfo_processors$ques$61 = function(location) {
        var $a, self = this, $writer = nil;

        
        
        if (location == null) {
          location = "head";
        };
        if ($truthy(self.docinfo_processor_extensions['$key?'](location))) {
          return self.docinfo_processor_extensions['$[]'](location)['$!='](false)
        } else if ($truthy(($truthy($a = self.extensions) ? self.document.$extensions()['$docinfo_processors?'](location) : $a))) {
          return (($writer = [location, self.document.$extensions().$docinfo_processors(location)]), $send(self.docinfo_processor_extensions, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])['$!']()['$!']()
        } else {
          
          $writer = [location, false];
          $send(self.docinfo_processor_extensions, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        };
      }, $Document_docinfo_processors$ques$61.$$arity = -1);
      
      Opal.def(self, '$to_s', $Document_to_s$62 = function $$to_s() {
        var $a, self = this;

        return "" + "#<" + (self.$class()) + "@" + (self.$object_id()) + " {doctype: " + (self.$doctype().$inspect()) + ", doctitle: " + (($truthy($a = self.header) ? self.header.$title() : $a).$inspect()) + ", blocks: " + (self.blocks.$size()) + "}>"
      }, $Document_to_s$62.$$arity = 0);
      self.$private();
      
      Opal.def(self, '$apply_attribute_value_subs', $Document_apply_attribute_value_subs$63 = function $$apply_attribute_value_subs(value) {
        var $a, self = this;

        
        if ($truthy($$($nesting, 'AttributeEntryPassMacroRx')['$=~'](value))) {
          
          value = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2));
          if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)))) {
            value = self.$apply_subs(value, self.$resolve_pass_subs((($a = $gvars['~']) === nil ? nil : $a['$[]'](1))))};
        } else {
          value = self.$apply_header_subs(value)
        };
        if ($truthy(self.max_attribute_value_size)) {
          
          return self.$limit_bytesize(value, self.max_attribute_value_size);
        } else {
          return value
        };
      }, $Document_apply_attribute_value_subs$63.$$arity = 1);
      
      Opal.def(self, '$limit_bytesize', $Document_limit_bytesize$64 = function $$limit_bytesize(str, max) {
        var $a, self = this;

        
        if ($truthy($rb_gt(str.$bytesize(), max))) {
          while (!($truthy((str = str.$byteslice(0, max))['$valid_encoding?']()))) {
            max = $rb_minus(max, 1)
          }};
        return str;
      }, $Document_limit_bytesize$64.$$arity = 2);
      
      Opal.def(self, '$resolve_docinfo_subs', $Document_resolve_docinfo_subs$65 = function $$resolve_docinfo_subs() {
        var self = this;

        if ($truthy(self.attributes['$key?']("docinfosubs"))) {
          
          return self.$resolve_subs(self.attributes['$[]']("docinfosubs"), "block", nil, "docinfo");
        } else {
          return ["attributes"]
        }
      }, $Document_resolve_docinfo_subs$65.$$arity = 0);
      
      Opal.def(self, '$create_converter', $Document_create_converter$66 = function $$create_converter(backend, delegate_backend) {
        var $a, self = this, converter_opts = nil, template_dirs = nil, opts = nil, $writer = nil, converter = nil;

        
        converter_opts = $hash2(["document", "htmlsyntax"], {"document": self, "htmlsyntax": self.attributes['$[]']("htmlsyntax")});
        if ($truthy((template_dirs = ($truthy($a = (opts = self.options)['$[]']("template_dirs")) ? $a : opts['$[]']("template_dir"))))) {
          
          
          $writer = ["template_dirs", [].concat(Opal.to_a(template_dirs))];
          $send(converter_opts, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = ["template_cache", opts.$fetch("template_cache", true)];
          $send(converter_opts, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = ["template_engine", opts['$[]']("template_engine")];
          $send(converter_opts, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = ["template_engine_options", opts['$[]']("template_engine_options")];
          $send(converter_opts, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = ["eruby", opts['$[]']("eruby")];
          $send(converter_opts, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = ["safe", self.safe];
          $send(converter_opts, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          if ($truthy(delegate_backend)) {
            
            $writer = ["delegate_backend", delegate_backend];
            $send(converter_opts, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};};
        if ($truthy((converter = opts['$[]']("converter")))) {
          return $$$($$($nesting, 'Converter'), 'CustomFactory').$new($hash(backend, converter)).$create(backend, converter_opts)
        } else {
          return opts.$fetch("converter_factory", $$($nesting, 'Converter')).$create(backend, converter_opts)
        };
      }, $Document_create_converter$66.$$arity = 2);
      
      Opal.def(self, '$clear_playback_attributes', $Document_clear_playback_attributes$67 = function $$clear_playback_attributes(attributes) {
        var self = this;

        return attributes.$delete("attribute_entries")
      }, $Document_clear_playback_attributes$67.$$arity = 1);
      
      Opal.def(self, '$save_attributes', $Document_save_attributes$68 = function $$save_attributes() {
        var $a, $$69, self = this, attrs = nil, doctitle_val = nil, $writer = nil, toc_val = nil, toc_position_val = nil, toc_placement_val = nil, default_toc_position = nil, default_toc_class = nil, position = nil, $case = nil, icons_val = nil, basebackend = nil, syntax_hl_name = nil, syntax_hl_factory = nil, syntax_hls = nil;

        
        if ($truthy(($truthy($a = (attrs = self.attributes)['$key?']("doctitle")) ? $a : (doctitle_val = self.$doctitle())['$!']()))) {
        } else {
          
          $writer = ["doctitle", doctitle_val];
          $send(attrs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        };
        self.id = ($truthy($a = self.id) ? $a : attrs['$[]']("css-signature"));
        if ($truthy((toc_val = (function() {if ($truthy(attrs.$delete("toc2"))) {
          return "left"
        } else {
          return attrs['$[]']("toc")
        }; return nil; })()))) {
          
          toc_position_val = (function() {if ($truthy(($truthy($a = (toc_placement_val = attrs.$fetch("toc-placement", "macro"))) ? toc_placement_val['$!=']("auto") : $a))) {
            return toc_placement_val
          } else {
            return attrs['$[]']("toc-position")
          }; return nil; })();
          if ($truthy(($truthy($a = toc_val['$empty?']()) ? toc_position_val['$nil_or_empty?']() : $a))) {
          } else {
            
            default_toc_position = "left";
            default_toc_class = "toc2";
            position = (function() {if ($truthy(toc_position_val['$nil_or_empty?']())) {
              
              if ($truthy(toc_val['$empty?']())) {
                return default_toc_position
              } else {
                return toc_val
              };
            } else {
              return toc_position_val
            }; return nil; })();
            
            $writer = ["toc", ""];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = ["toc-placement", "auto"];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            $case = position;
            if ("left"['$===']($case) || "<"['$===']($case) || "&lt;"['$===']($case)) {
            $writer = ["toc-position", "left"];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];}
            else if ("right"['$===']($case) || ">"['$===']($case) || "&gt;"['$===']($case)) {
            $writer = ["toc-position", "right"];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];}
            else if ("top"['$===']($case) || "^"['$===']($case)) {
            $writer = ["toc-position", "top"];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];}
            else if ("bottom"['$===']($case) || "v"['$===']($case)) {
            $writer = ["toc-position", "bottom"];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];}
            else if ("preamble"['$===']($case) || "macro"['$===']($case)) {
            
            $writer = ["toc-position", "content"];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = ["toc-placement", position];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            default_toc_class = nil;}
            else {
            attrs.$delete("toc-position");
            default_toc_class = nil;};
            if ($truthy(default_toc_class)) {
              ($truthy($a = attrs['$[]']("toc-class")) ? $a : (($writer = ["toc-class", default_toc_class]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))};
          };};
        if ($truthy(($truthy($a = (icons_val = attrs['$[]']("icons"))) ? attrs['$key?']("icontype")['$!']() : $a))) {
          $case = icons_val;
          if (""['$===']($case) || "font"['$===']($case)) {nil}
          else {
          
          $writer = ["icons", ""];
          $send(attrs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          if (icons_val['$==']("image")) {
          } else {
            
            $writer = ["icontype", icons_val];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          };}};
        if ($truthy(($truthy($a = (self.compat_mode = attrs['$key?']("compat-mode"))) ? attrs['$key?']("language") : $a))) {
          
          $writer = ["source-language", attrs['$[]']("language")];
          $send(attrs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        if ($truthy(self.parent_document)) {
        } else {
          
          if ((basebackend = attrs['$[]']("basebackend"))['$==']("html")) {
            if ($truthy(($truthy($a = (syntax_hl_name = attrs['$[]']("source-highlighter"))) ? attrs['$[]']("" + (syntax_hl_name) + "-unavailable")['$!']() : $a))) {
              if ($truthy((syntax_hl_factory = self.options['$[]']("syntax_highlighter_factory")))) {
                self.syntax_highlighter = syntax_hl_factory.$create(syntax_hl_name, self.backend, $hash2(["document"], {"document": self}))
              } else if ($truthy((syntax_hls = self.options['$[]']("syntax_highlighters")))) {
                self.syntax_highlighter = $$$($$($nesting, 'SyntaxHighlighter'), 'DefaultFactoryProxy').$new(syntax_hls).$create(syntax_hl_name, self.backend, $hash2(["document"], {"document": self}))
              } else {
                self.syntax_highlighter = $$($nesting, 'SyntaxHighlighter').$create(syntax_hl_name, self.backend, $hash2(["document"], {"document": self}))
              }}
          } else if (basebackend['$==']("docbook")) {
            
            if ($truthy(($truthy($a = self['$attribute_locked?']("toc")) ? $a : self.attributes_modified['$include?']("toc")))) {
            } else {
              
              $writer = ["toc", ""];
              $send(attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            };
            if ($truthy(($truthy($a = self['$attribute_locked?']("sectnums")) ? $a : self.attributes_modified['$include?']("sectnums")))) {
            } else {
              
              $writer = ["sectnums", ""];
              $send(attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            };};
          self.outfilesuffix = attrs['$[]']("outfilesuffix");
          $send($$($nesting, 'FLEXIBLE_ATTRIBUTES'), 'each', [], ($$69 = function(name){var self = $$69.$$s || this, $b;
            if (self.attribute_overrides == null) self.attribute_overrides = nil;

          
            
            if (name == null) {
              name = nil;
            };
            if ($truthy(($truthy($b = self.attribute_overrides['$key?'](name)) ? self.attribute_overrides['$[]'](name) : $b))) {
              return self.attribute_overrides.$delete(name)
            } else {
              return nil
            };}, $$69.$$s = self, $$69.$$arity = 1, $$69));
        };
        return (self.header_attributes = attrs.$merge());
      }, $Document_save_attributes$68.$$arity = 0);
      
      Opal.def(self, '$fill_datetime_attributes', $Document_fill_datetime_attributes$70 = function $$fill_datetime_attributes(attrs, input_mtime) {
        var $a, $b, self = this, now = nil, source_date_epoch = nil, localdate = nil, $writer = nil, localtime = nil, docdate = nil, doctime = nil;

        
        now = (function() {if ($truthy($$$('::', 'ENV')['$key?']("SOURCE_DATE_EPOCH"))) {
          
          return (source_date_epoch = $$$('::', 'Time').$at(self.$Integer($$$('::', 'ENV')['$[]']("SOURCE_DATE_EPOCH"))).$utc());
        } else {
          return $$$('::', 'Time').$now()
        }; return nil; })();
        if ($truthy((localdate = attrs['$[]']("localdate")))) {
          ($truthy($a = attrs['$[]']("localyear")) ? $a : (($writer = ["localyear", (function() {if (localdate.$index("-")['$=='](4)) {
            
            return localdate.$slice(0, 4);
          } else {
            return nil
          }; return nil; })()]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))
        } else {
          
          localdate = (($writer = ["localdate", now.$strftime("%F")]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]);
          ($truthy($a = attrs['$[]']("localyear")) ? $a : (($writer = ["localyear", now.$year().$to_s()]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        };
        localtime = ($truthy($a = attrs['$[]']("localtime")) ? $a : (($writer = ["localtime", now.$strftime("" + "%T " + ((function() {if (now.$utc_offset()['$=='](0)) {
          return "UTC"
        } else {
          return "%z"
        }; return nil; })()))]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        ($truthy($a = attrs['$[]']("localdatetime")) ? $a : (($writer = ["localdatetime", "" + (localdate) + " " + (localtime)]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        input_mtime = ($truthy($a = ($truthy($b = source_date_epoch) ? $b : input_mtime)) ? $a : now);
        if ($truthy((docdate = attrs['$[]']("docdate")))) {
          ($truthy($a = attrs['$[]']("docyear")) ? $a : (($writer = ["docyear", (function() {if (docdate.$index("-")['$=='](4)) {
            
            return docdate.$slice(0, 4);
          } else {
            return nil
          }; return nil; })()]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))
        } else {
          
          docdate = (($writer = ["docdate", input_mtime.$strftime("%F")]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]);
          ($truthy($a = attrs['$[]']("docyear")) ? $a : (($writer = ["docyear", input_mtime.$year().$to_s()]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        };
        doctime = ($truthy($a = attrs['$[]']("doctime")) ? $a : (($writer = ["doctime", input_mtime.$strftime("" + "%T " + ((function() {if (input_mtime.$utc_offset()['$=='](0)) {
          return "UTC"
        } else {
          return "%z"
        }; return nil; })()))]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        ($truthy($a = attrs['$[]']("docdatetime")) ? $a : (($writer = ["docdatetime", "" + (docdate) + " " + (doctime)]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        return nil;
      }, $Document_fill_datetime_attributes$70.$$arity = 2);
      
      Opal.def(self, '$update_backend_attributes', $Document_update_backend_attributes$71 = function $$update_backend_attributes(new_backend, init) {
        var $a, $b, self = this, current_backend = nil, current_basebackend = nil, attrs = nil, current_doctype = nil, actual_backend = nil, _ = nil, $writer = nil, delegate_backend = nil, converter = nil, new_basebackend = nil, new_filetype = nil, htmlsyntax = nil, backend_traits = nil, current_filetype = nil, page_width = nil;

        
        
        if (init == null) {
          init = nil;
        };
        if ($truthy(($truthy($a = init) ? $a : new_backend['$!='](self.backend)))) {
          
          current_backend = self.backend;
          current_basebackend = (attrs = self.attributes)['$[]']("basebackend");
          current_doctype = self.doctype;
          if ($truthy(new_backend['$include?'](":"))) {
            $b = new_backend.$partition(":"), $a = Opal.to_ary($b), (actual_backend = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), (new_backend = ($a[2] == null ? nil : $a[2])), $b};
          if ($truthy(new_backend['$start_with?']("xhtml"))) {
            
            
            $writer = ["htmlsyntax", "xml"];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            new_backend = new_backend.$slice(1, new_backend.$length());
          } else if ($truthy(new_backend['$start_with?']("html"))) {
            ($truthy($a = attrs['$[]']("htmlsyntax")) ? $a : (($writer = ["htmlsyntax", "html"]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))};
          new_backend = ($truthy($a = $$($nesting, 'BACKEND_ALIASES')['$[]'](new_backend)) ? $a : new_backend);
          if ($truthy(actual_backend)) {
            $a = [actual_backend, new_backend], (new_backend = $a[0]), (delegate_backend = $a[1]), $a};
          if ($truthy(current_doctype)) {
            
            if ($truthy(current_backend)) {
              
              attrs.$delete("" + "backend-" + (current_backend));
              attrs.$delete("" + "backend-" + (current_backend) + "-doctype-" + (current_doctype));};
            
            $writer = ["" + "backend-" + (new_backend) + "-doctype-" + (current_doctype), ""];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = ["" + "doctype-" + (current_doctype), ""];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
          } else if ($truthy(current_backend)) {
            attrs.$delete("" + "backend-" + (current_backend))};
          
          $writer = ["" + "backend-" + (new_backend), ""];
          $send(attrs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          self.backend = (($writer = ["backend", new_backend]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]);
          if ($truthy($$$($$($nesting, 'Converter'), 'BackendTraits')['$===']((converter = self.$create_converter(new_backend, delegate_backend))))) {
            
            new_basebackend = converter.$basebackend();
            new_filetype = converter.$filetype();
            if ($truthy((htmlsyntax = converter.$htmlsyntax()))) {
              
              $writer = ["htmlsyntax", htmlsyntax];
              $send(attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            if ($truthy(init)) {
              ($truthy($a = attrs['$[]']("outfilesuffix")) ? $a : (($writer = ["outfilesuffix", converter.$outfilesuffix()]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))
            } else if ($truthy(self['$attribute_locked?']("outfilesuffix"))) {
            } else {
              
              $writer = ["outfilesuffix", converter.$outfilesuffix()];
              $send(attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            };
          } else if ($truthy(converter)) {
            
            backend_traits = $$($nesting, 'Converter').$derive_backend_traits(new_backend);
            new_basebackend = backend_traits['$[]']("basebackend");
            new_filetype = backend_traits['$[]']("filetype");
            if ($truthy(init)) {
              ($truthy($a = attrs['$[]']("outfilesuffix")) ? $a : (($writer = ["outfilesuffix", backend_traits['$[]']("outfilesuffix")]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))
            } else if ($truthy(self['$attribute_locked?']("outfilesuffix"))) {
            } else {
              
              $writer = ["outfilesuffix", backend_traits['$[]']("outfilesuffix")];
              $send(attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            };
          } else {
            self.$raise($$$('::', 'NotImplementedError'), "" + "asciidoctor: FAILED: missing converter for backend '" + (new_backend) + "'. Processing aborted.")
          };
          self.converter = converter;
          if ($truthy((current_filetype = attrs['$[]']("filetype")))) {
            attrs.$delete("" + "filetype-" + (current_filetype))};
          
          $writer = ["filetype", new_filetype];
          $send(attrs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = ["" + "filetype-" + (new_filetype), ""];
          $send(attrs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          if ($truthy((page_width = $$($nesting, 'DEFAULT_PAGE_WIDTHS')['$[]'](new_basebackend)))) {
            
            $writer = ["pagewidth", page_width];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          } else {
            attrs.$delete("pagewidth")
          };
          if ($truthy(new_basebackend['$!='](current_basebackend))) {
            
            if ($truthy(current_doctype)) {
              
              if ($truthy(current_basebackend)) {
                
                attrs.$delete("" + "basebackend-" + (current_basebackend));
                attrs.$delete("" + "basebackend-" + (current_basebackend) + "-doctype-" + (current_doctype));};
              
              $writer = ["" + "basebackend-" + (new_basebackend) + "-doctype-" + (current_doctype), ""];
              $send(attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
            } else if ($truthy(current_basebackend)) {
              attrs.$delete("" + "basebackend-" + (current_basebackend))};
            
            $writer = ["" + "basebackend-" + (new_basebackend), ""];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = ["basebackend", new_basebackend];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;};
          return new_backend;
        } else {
          return nil
        };
      }, $Document_update_backend_attributes$71.$$arity = -2);
      return (Opal.def(self, '$update_doctype_attributes', $Document_update_doctype_attributes$72 = function $$update_doctype_attributes(new_doctype) {
        var $a, self = this, attrs = nil, current_backend = nil, current_basebackend = nil, current_doctype = nil, $writer = nil;

        if ($truthy(($truthy($a = new_doctype) ? new_doctype['$!='](self.doctype) : $a))) {
          
          $a = [self.backend, (attrs = self.attributes)['$[]']("basebackend"), self.doctype], (current_backend = $a[0]), (current_basebackend = $a[1]), (current_doctype = $a[2]), $a;
          if ($truthy(current_doctype)) {
            
            attrs.$delete("" + "doctype-" + (current_doctype));
            if ($truthy(current_backend)) {
              
              attrs.$delete("" + "backend-" + (current_backend) + "-doctype-" + (current_doctype));
              
              $writer = ["" + "backend-" + (current_backend) + "-doctype-" + (new_doctype), ""];
              $send(attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;};
            if ($truthy(current_basebackend)) {
              
              attrs.$delete("" + "basebackend-" + (current_basebackend) + "-doctype-" + (current_doctype));
              
              $writer = ["" + "basebackend-" + (current_basebackend) + "-doctype-" + (new_doctype), ""];
              $send(attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;};
          } else {
            
            if ($truthy(current_backend)) {
              
              $writer = ["" + "backend-" + (current_backend) + "-doctype-" + (new_doctype), ""];
              $send(attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            if ($truthy(current_basebackend)) {
              
              $writer = ["" + "basebackend-" + (current_basebackend) + "-doctype-" + (new_doctype), ""];
              $send(attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
          };
          
          $writer = ["" + "doctype-" + (new_doctype), ""];
          $send(attrs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return (self.doctype = (($writer = ["doctype", new_doctype]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        } else {
          return nil
        }
      }, $Document_update_doctype_attributes$72.$$arity = 1), nil) && 'update_doctype_attributes';
    })($nesting[0], $$($nesting, 'AbstractBlock'), $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/inline"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_accessor', '$attr_reader', '$[]', '$convert', '$converter', '$attr', '$==', '$apply_reftext_subs', '$reftext']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Inline');

      var $nesting = [self].concat($parent_nesting), $Inline_initialize$1, $Inline_block$ques$2, $Inline_inline$ques$3, $Inline_convert$4, $Inline_alt$5, $Inline_reftext$ques$6, $Inline_reftext$7, $Inline_xreftext$8;

      self.$$prototype.text = self.$$prototype.type = nil;
      
      self.$attr_accessor("text");
      self.$attr_reader("type");
      self.$attr_accessor("target");
      
      Opal.def(self, '$initialize', $Inline_initialize$1 = function $$initialize(parent, context, text, opts) {
        var $iter = $Inline_initialize$1.$$p, $yield = $iter || nil, self = this;

        if ($iter) $Inline_initialize$1.$$p = null;
        
        
        if (text == null) {
          text = nil;
        };
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        $send(self, Opal.find_super_dispatcher(self, 'initialize', $Inline_initialize$1, false), [parent, context, opts], null);
        self.node_name = "" + "inline_" + (context);
        self.text = text;
        self.id = opts['$[]']("id");
        self.type = opts['$[]']("type");
        return (self.target = opts['$[]']("target"));
      }, $Inline_initialize$1.$$arity = -3);
      
      Opal.def(self, '$block?', $Inline_block$ques$2 = function() {
        var self = this;

        return false
      }, $Inline_block$ques$2.$$arity = 0);
      
      Opal.def(self, '$inline?', $Inline_inline$ques$3 = function() {
        var self = this;

        return true
      }, $Inline_inline$ques$3.$$arity = 0);
      
      Opal.def(self, '$convert', $Inline_convert$4 = function $$convert() {
        var self = this;

        return self.$converter().$convert(self)
      }, $Inline_convert$4.$$arity = 0);
      Opal.alias(self, "render", "convert");
      
      Opal.def(self, '$alt', $Inline_alt$5 = function $$alt() {
        var $a, self = this;

        return ($truthy($a = self.$attr("alt")) ? $a : "")
      }, $Inline_alt$5.$$arity = 0);
      
      Opal.def(self, '$reftext?', $Inline_reftext$ques$6 = function() {
        var $a, $b, self = this;

        return ($truthy($a = self.text) ? ($truthy($b = self.type['$==']("ref")) ? $b : self.type['$==']("bibref")) : $a)
      }, $Inline_reftext$ques$6.$$arity = 0);
      
      Opal.def(self, '$reftext', $Inline_reftext$7 = function $$reftext() {
        var self = this, val = nil;

        if ($truthy((val = self.text))) {
          
          return self.$apply_reftext_subs(val);
        } else {
          return nil
        }
      }, $Inline_reftext$7.$$arity = 0);
      return (Opal.def(self, '$xreftext', $Inline_xreftext$8 = function $$xreftext(xrefstyle) {
        var self = this;

        
        
        if (xrefstyle == null) {
          xrefstyle = nil;
        };
        return self.$reftext();
      }, $Inline_xreftext$8.$$arity = -1), nil) && 'xreftext';
    })($nesting[0], $$($nesting, 'AbstractNode'), $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/list"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$==', '$next_list', '$callouts', '$class', '$object_id', '$inspect', '$size', '$items', '$attr_accessor', '$level', '$drop', '$nil_or_empty?', '$apply_subs', '$attr_writer', '$empty?', '$===', '$[]', '$outline?', '$!', '$simple?', '$source', '$shift', '$context', '$parent']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'List');

      var $nesting = [self].concat($parent_nesting), $List_initialize$1, $List_outline$ques$2, $List_convert$3, $List_to_s$4;

      self.$$prototype.context = self.$$prototype.document = self.$$prototype.style = nil;
      
      Opal.alias(self, "items", "blocks");
      Opal.alias(self, "content", "blocks");
      Opal.alias(self, "items?", "blocks?");
      
      Opal.def(self, '$initialize', $List_initialize$1 = function $$initialize(parent, context, opts) {
        var $iter = $List_initialize$1.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $List_initialize$1.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        return $send(self, Opal.find_super_dispatcher(self, 'initialize', $List_initialize$1, false), $zuper, $iter);
      }, $List_initialize$1.$$arity = -3);
      
      Opal.def(self, '$outline?', $List_outline$ques$2 = function() {
        var $a, self = this;

        return ($truthy($a = self.context['$==']("ulist")) ? $a : self.context['$==']("olist"))
      }, $List_outline$ques$2.$$arity = 0);
      
      Opal.def(self, '$convert', $List_convert$3 = function $$convert() {
        var $iter = $List_convert$3.$$p, $yield = $iter || nil, self = this, result = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $List_convert$3.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        if (self.context['$==']("colist")) {
          
          result = $send(self, Opal.find_super_dispatcher(self, 'convert', $List_convert$3, false), $zuper, $iter);
          self.document.$callouts().$next_list();
          return result;
        } else {
          return $send(self, Opal.find_super_dispatcher(self, 'convert', $List_convert$3, false), $zuper, $iter)
        }
      }, $List_convert$3.$$arity = 0);
      Opal.alias(self, "render", "convert");
      return (Opal.def(self, '$to_s', $List_to_s$4 = function $$to_s() {
        var self = this;

        return "" + "#<" + (self.$class()) + "@" + (self.$object_id()) + " {context: " + (self.context.$inspect()) + ", style: " + (self.style.$inspect()) + ", items: " + (self.$items().$size()) + "}>"
      }, $List_to_s$4.$$arity = 0), nil) && 'to_s';
    })($nesting[0], $$($nesting, 'AbstractBlock'), $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'ListItem');

      var $nesting = [self].concat($parent_nesting), $ListItem_initialize$5, $ListItem_text$ques$6, $ListItem_text$7, $ListItem_simple$ques$8, $ListItem_compound$ques$9, $ListItem_fold_first$10, $ListItem_to_s$11;

      self.$$prototype.text = self.$$prototype.subs = self.$$prototype.blocks = nil;
      
      Opal.alias(self, "list", "parent");
      self.$attr_accessor("marker");
      
      Opal.def(self, '$initialize', $ListItem_initialize$5 = function $$initialize(parent, text) {
        var $iter = $ListItem_initialize$5.$$p, $yield = $iter || nil, self = this;

        if ($iter) $ListItem_initialize$5.$$p = null;
        
        
        if (text == null) {
          text = nil;
        };
        $send(self, Opal.find_super_dispatcher(self, 'initialize', $ListItem_initialize$5, false), [parent, "list_item"], null);
        self.text = text;
        self.level = parent.$level();
        return (self.subs = $$($nesting, 'NORMAL_SUBS').$drop(0));
      }, $ListItem_initialize$5.$$arity = -2);
      
      Opal.def(self, '$text?', $ListItem_text$ques$6 = function() {
        var self = this;

        if ($truthy(self.text['$nil_or_empty?']())) {
          return false
        } else {
          return true
        }
      }, $ListItem_text$ques$6.$$arity = 0);
      
      Opal.def(self, '$text', $ListItem_text$7 = function $$text() {
        var $a, self = this;

        return ($truthy($a = self.text) ? self.$apply_subs(self.text, self.subs) : $a)
      }, $ListItem_text$7.$$arity = 0);
      self.$attr_writer("text");
      
      Opal.def(self, '$simple?', $ListItem_simple$ques$8 = function() {
        var $a, $b, $c, self = this, blk = nil;

        return ($truthy($a = self.blocks['$empty?']()) ? $a : ($truthy($b = (($c = self.blocks.$size()['$=='](1)) ? $$($nesting, 'List')['$===']((blk = self.blocks['$[]'](0))) : self.blocks.$size()['$=='](1))) ? blk['$outline?']() : $b))
      }, $ListItem_simple$ques$8.$$arity = 0);
      
      Opal.def(self, '$compound?', $ListItem_compound$ques$9 = function() {
        var self = this;

        return self['$simple?']()['$!']()
      }, $ListItem_compound$ques$9.$$arity = 0);
      
      Opal.def(self, '$fold_first', $ListItem_fold_first$10 = function $$fold_first() {
        var self = this;

        
        self.text = (function() {if ($truthy(self.text['$nil_or_empty?']())) {
          return self.blocks.$shift().$source()
        } else {
          return "" + (self.text) + ($$($nesting, 'LF')) + (self.blocks.$shift().$source())
        }; return nil; })();
        return nil;
      }, $ListItem_fold_first$10.$$arity = 0);
      return (Opal.def(self, '$to_s', $ListItem_to_s$11 = function $$to_s() {
        var $a, self = this;

        return "" + "#<" + (self.$class()) + "@" + (self.$object_id()) + " {list_context: " + (self.$parent().$context().$inspect()) + ", text: " + (self.text.$inspect()) + ", blocks: " + (($truthy($a = self.blocks) ? $a : []).$size()) + "}>"
      }, $ListItem_to_s$11.$$arity = 0), nil) && 'to_s';
    })($nesting[0], $$($nesting, 'AbstractBlock'), $nesting);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/parser"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2, $gvars = Opal.gvars;

  Opal.add_stubs(['$include', '$new', '$proc', '$start_with?', '$match?', '$is_delimited_block?', '$private_class_method', '$parse_document_header', '$[]', '$has_more_lines?', '$next_section', '$assign_numeral', '$<<', '$blocks', '$skip_blank_lines', '$parse_block_metadata_lines', '$attributes', '$is_next_line_doctitle?', '$[]=', '$-', '$finalize_header', '$nil_or_empty?', '$title=', '$sourcemap', '$cursor', '$parse_section_title', '$id=', '$include?', '$sub_specialchars', '$sub_attributes', '$source_location=', '$header', '$attribute_locked?', '$id', '$clear', '$delete', '$instance_variable_get', '$parse_header_metadata', '$==', '$!', '$register', '$process_authors', '$update', '$doctype', '$parse_manpage_header', '$=~', '$downcase', '$error', '$logger', '$message_with_context', '$cursor_at_line', '$backend', '$save', '$is_next_line_section?', '$initialize_section', '$join', '$map', '$read_lines_until', '$lstrip', '$split', '$title', '$restore_save', '$discard_save', '$context', '$empty?', '$header?', '$!=', '$attr?', '$attr', '$key?', '$document', '$+', '$level', '$special', '$sectname', '$to_i', '$<', '$>', '$warn', '$next_block', '$blocks?', '$style', '$context=', '$style=', '$parent=', '$size', '$content_model', '$shift', '$unwrap_standalone_preamble', '$source_location', '$merge', '$fetch', '$parse_block_metadata_line', '$extensions', '$block_macros?', '$mark', '$read_line', '$terminator', '$to_s', '$masq', '$to_sym', '$registered_for_block?', '$debug?', '$debug', '$cursor_at_mark', '$strict_verbatim_paragraphs', '$unshift_line', '$markdown_syntax', '$keys', '$chr', '$uniform?', '$length', '$end_with?', '$===', '$parse_attributes', '$attribute_missing', '$tr', '$basename', '$assign_caption', '$registered_for_block_macro?', '$config', '$process_method', '$replace', '$parse_callout_list', '$callouts', '$parse_list', '$parse_description_list', '$underline_style_section_titles', '$is_section_title?', '$peek_line', '$atx_section_title?', '$generate_id', '$level=', '$read_paragraph_lines', '$adjust_indentation!', '$map!', '$slice', '$pop', '$build_block', '$apply_subs', '$chop', '$catalog_inline_anchors', '$rekey', '$index', '$strip', '$parse_table', '$each', '$raise', '$title?', '$update_attributes', '$commit_subs', '$sub?', '$catalog_callouts', '$source', '$remove_sub', '$block_terminates_paragraph', '$to_proc', '$nil?', '$lines', '$parse_blocks', '$parse_list_item', '$items', '$scan', '$gsub', '$count', '$advance', '$dup', '$match', '$callout_ids', '$next_list', '$catalog_inline_anchor', '$marker=', '$catalog_inline_biblio_anchor', '$set_option', '$text=', '$resolve_ordered_list_marker', '$read_lines_for_list_item', '$skip_line_comments', '$unshift_lines', '$fold_first', '$text?', '$is_sibling_list_item?', '$concat', '$find', '$casecmp', '$sectname=', '$special=', '$numbered=', '$numbered', '$lineno', '$peek_lines', '$setext_section_title?', '$abs', '$cursor_at_prev_line', '$process_attribute_entries', '$next_line_empty?', '$apply_header_subs', '$rstrip', '$each_with_index', '$compact', '$to_h', '$squeeze', '$to_a', '$parse_style_attribute', '$process_attribute_entry', '$skip_comment_lines', '$store_attribute', '$sanitize_attribute_name', '$set_attribute', '$save_to', '$delete_attribute', '$ord', '$int_to_roman', '$resolve_list_marker', '$parse_colspecs', '$create_columns', '$has_header_option=', '$format', '$starts_with_delimiter?', '$close_open_cell', '$parse_cellspec', '$delimiter', '$match_delimiter', '$pre_match', '$post_match', '$buffer_has_unclosed_quotes?', '$skip_past_delimiter', '$buffer', '$buffer=', '$skip_past_escaped_delimiter', '$keep_cell_open', '$push_cellspec', '$close_cell', '$cell_open?', '$columns', '$assign_column_widths', '$partition_header_footer', '$upto', '$partition', '$shorthand_property_syntax', '$each_char', '$yield_buffered_attribute', '$any?', '$*', '$each_byte', '$%']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Parser');

      var $nesting = [self].concat($parent_nesting), $Parser$1, $Parser$2, $Parser$3, $Parser_parse$4, $Parser_parse_document_header$5, $Parser_parse_manpage_header$6, $Parser_next_section$9, $Parser_next_block$10, $Parser_read_paragraph_lines$14, $Parser_is_delimited_block$ques$15, $Parser_build_block$16, $Parser_parse_blocks$17, $Parser_parse_list$18, $Parser_catalog_callouts$19, $Parser_catalog_inline_anchor$21, $Parser_catalog_inline_anchors$22, $Parser_catalog_inline_biblio_anchor$24, $Parser_parse_description_list$25, $Parser_parse_callout_list$26, $Parser_parse_list_item$27, $Parser_read_lines_for_list_item$28, $Parser_initialize_section$34, $Parser_is_next_line_section$ques$35, $Parser_is_next_line_doctitle$ques$36, $Parser_is_section_title$ques$37, $Parser_atx_section_title$ques$38, $Parser_setext_section_title$ques$39, $Parser_parse_section_title$40, $Parser_parse_header_metadata$41, $Parser_process_authors$46, $Parser_parse_block_metadata_lines$51, $Parser_parse_block_metadata_line$52, $Parser_process_attribute_entries$53, $Parser_process_attribute_entry$54, $Parser_store_attribute$55, $Parser_resolve_list_marker$56, $Parser_resolve_ordered_list_marker$57, $Parser_is_sibling_list_item$ques$59, $Parser_parse_table$60, $Parser_parse_colspecs$61, $Parser_parse_cellspec$65, $Parser_parse_style_attribute$66, $Parser_yield_buffered_attribute$69, $Parser_adjust_indentation$excl$70, $Parser_uniform$ques$79, $Parser_sanitize_attribute_name$80;

      
      self.$include($$($nesting, 'Logging'));
      Opal.const_set($nesting[0], 'BlockMatchData', $$($nesting, 'Struct').$new("context", "masq", "tip", "terminator"));
      Opal.const_set($nesting[0], 'TAB', "\t");
      Opal.const_set($nesting[0], 'TabIndentRx', /^\t+/);
      Opal.const_set($nesting[0], 'StartOfBlockProc', $send(self, 'proc', [], ($Parser$1 = function(l){var self = $Parser$1.$$s || this, $a, $b;

      
        
        if (l == null) {
          l = nil;
        };
        return ($truthy($a = ($truthy($b = l['$start_with?']("[")) ? $$($nesting, 'BlockAttributeLineRx')['$match?'](l) : $b)) ? $a : self['$is_delimited_block?'](l));}, $Parser$1.$$s = self, $Parser$1.$$arity = 1, $Parser$1)));
      Opal.const_set($nesting[0], 'StartOfListProc', $send(self, 'proc', [], ($Parser$2 = function(l){var self = $Parser$2.$$s || this;

      
        
        if (l == null) {
          l = nil;
        };
        return $$($nesting, 'AnyListRx')['$match?'](l);}, $Parser$2.$$s = self, $Parser$2.$$arity = 1, $Parser$2)));
      Opal.const_set($nesting[0], 'StartOfBlockOrListProc', $send(self, 'proc', [], ($Parser$3 = function(l){var self = $Parser$3.$$s || this, $a, $b, $c;

      
        
        if (l == null) {
          l = nil;
        };
        return ($truthy($a = ($truthy($b = self['$is_delimited_block?'](l)) ? $b : ($truthy($c = l['$start_with?']("[")) ? $$($nesting, 'BlockAttributeLineRx')['$match?'](l) : $c))) ? $a : $$($nesting, 'AnyListRx')['$match?'](l));}, $Parser$3.$$s = self, $Parser$3.$$arity = 1, $Parser$3)));
      Opal.const_set($nesting[0], 'NoOp', nil);
      Opal.const_set($nesting[0], 'AuthorKeys', ["author", "authorinitials", "firstname", "middlename", "lastname", "email"]);
      Opal.const_set($nesting[0], 'TableCellHorzAlignments', $hash2(["<", ">", "^"], {"<": "left", ">": "right", "^": "center"}));
      Opal.const_set($nesting[0], 'TableCellVertAlignments', $hash2(["<", ">", "^"], {"<": "top", ">": "bottom", "^": "middle"}));
      Opal.const_set($nesting[0], 'TableCellStyles', $hash2(["d", "s", "e", "m", "h", "l", "a"], {"d": "none", "s": "strong", "e": "emphasis", "m": "monospaced", "h": "header", "l": "literal", "a": "asciidoc"}));
      self.$private_class_method("new");
      Opal.defs(self, '$parse', $Parser_parse$4 = function $$parse(reader, document, options) {
        var $a, $b, $c, self = this, block_attributes = nil, header_only = nil, new_section = nil;

        
        
        if (options == null) {
          options = $hash2([], {});
        };
        block_attributes = self.$parse_document_header(reader, document, (header_only = options['$[]']("header_only")));
        if ($truthy(header_only)) {
        } else {
          while ($truthy(reader['$has_more_lines?']())) {
            
            $c = self.$next_section(reader, document, block_attributes), $b = Opal.to_ary($c), (new_section = ($b[0] == null ? nil : $b[0])), (block_attributes = ($b[1] == null ? nil : $b[1])), $c;
            if ($truthy(new_section)) {
              
              document.$assign_numeral(new_section);
              document.$blocks()['$<<'](new_section);};
          }
        };
        return document;
      }, $Parser_parse$4.$$arity = -3);
      Opal.defs(self, '$parse_document_header', $Parser_parse_document_header$5 = function $$parse_document_header(reader, document, header_only) {
        var $a, $b, self = this, block_attrs = nil, doc_attrs = nil, implicit_doctitle = nil, $writer = nil, val = nil, doctitle_attr_val = nil, source_location = nil, _ = nil, l0_section_title = nil, atx = nil, separator = nil, doc_id = nil, role = nil, reftext = nil, modified_attrs = nil, author = nil, author_metadata = nil;

        
        
        if (header_only == null) {
          header_only = false;
        };
        block_attrs = (function() {if ($truthy(reader.$skip_blank_lines())) {
          
          return self.$parse_block_metadata_lines(reader, document);
        } else {
          return $hash2([], {})
        }; return nil; })();
        doc_attrs = document.$attributes();
        if ($truthy(($truthy($a = (implicit_doctitle = self['$is_next_line_doctitle?'](reader, block_attrs, doc_attrs['$[]']("leveloffset")))) ? block_attrs['$[]']("title") : $a))) {
          
          
          $writer = ["authorcount", 0];
          $send(doc_attrs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return document.$finalize_header(block_attrs, false);};
        if ($truthy((val = doc_attrs['$[]']("doctitle"))['$nil_or_empty?']())) {
        } else {
          
          $writer = [(doctitle_attr_val = val)];
          $send(document, 'title=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        };
        if ($truthy(implicit_doctitle)) {
          
          if ($truthy(document.$sourcemap())) {
            source_location = reader.$cursor()};
          $b = self.$parse_section_title(reader, document), $a = Opal.to_ary($b), document['$id='](($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), (l0_section_title = ($a[2] == null ? nil : $a[2])), (_ = ($a[3] == null ? nil : $a[3])), (atx = ($a[4] == null ? nil : $a[4])), $b;
          if ($truthy(doctitle_attr_val)) {
            l0_section_title = nil
          } else {
            
            
            $writer = [l0_section_title];
            $send(document, 'title=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            if ($truthy((($writer = ["doctitle", (doctitle_attr_val = document.$sub_specialchars(l0_section_title))]), $send(doc_attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])['$include?']($$($nesting, 'ATTR_REF_HEAD')))) {
              
              $writer = ["doctitle", (doctitle_attr_val = document.$sub_attributes(doctitle_attr_val, $hash2(["attribute_missing"], {"attribute_missing": "skip"})))];
              $send(doc_attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
          };
          if ($truthy(source_location)) {
            
            $writer = [source_location];
            $send(document.$header(), 'source_location=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          if ($truthy(($truthy($a = atx) ? $a : document['$attribute_locked?']("compat-mode")))) {
          } else {
            
            $writer = ["compat-mode", ""];
            $send(doc_attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          };
          if ($truthy((separator = block_attrs['$[]']("separator")))) {
            if ($truthy(document['$attribute_locked?']("title-separator"))) {
            } else {
              
              $writer = ["title-separator", separator];
              $send(doc_attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            }};
          if ($truthy((doc_id = block_attrs['$[]']("id")))) {
            
            $writer = [doc_id];
            $send(document, 'id=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          } else {
            doc_id = document.$id()
          };
          if ($truthy((role = block_attrs['$[]']("role")))) {
            
            $writer = ["role", role];
            $send(doc_attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          if ($truthy((reftext = block_attrs['$[]']("reftext")))) {
            
            $writer = ["reftext", reftext];
            $send(doc_attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          block_attrs.$clear();
          (modified_attrs = document.$instance_variable_get("@attributes_modified")).$delete("doctitle");
          self.$parse_header_metadata(reader, document, nil);
          if ($truthy(modified_attrs['$include?']("doctitle"))) {
            if ($truthy(($truthy($a = (val = doc_attrs['$[]']("doctitle"))['$nil_or_empty?']()) ? $a : val['$=='](doctitle_attr_val)))) {
              
              $writer = ["doctitle", doctitle_attr_val];
              $send(doc_attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            } else {
              
              $writer = [val];
              $send(document, 'title=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            }
          } else if ($truthy(l0_section_title['$!']())) {
            modified_attrs['$<<']("doctitle")};
          if ($truthy(doc_id)) {
            document.$register("refs", [doc_id, document])};
        } else if ($truthy((author = doc_attrs['$[]']("author")))) {
          
          author_metadata = self.$process_authors(author, true, false);
          if ($truthy(doc_attrs['$[]']("authorinitials"))) {
            author_metadata.$delete("authorinitials")};
          doc_attrs.$update(author_metadata);
        } else if ($truthy((author = doc_attrs['$[]']("authors")))) {
          
          author_metadata = self.$process_authors(author, true);
          doc_attrs.$update(author_metadata);
        } else {
          
          $writer = ["authorcount", 0];
          $send(doc_attrs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        };
        if (document.$doctype()['$==']("manpage")) {
          self.$parse_manpage_header(reader, document, block_attrs, header_only)};
        return document.$finalize_header(block_attrs);
      }, $Parser_parse_document_header$5.$$arity = -3);
      Opal.defs(self, '$parse_manpage_header', $Parser_parse_manpage_header$6 = function $$parse_manpage_header(reader, document, block_attributes, header_only) {
        var $a, $b, $$7, $$8, self = this, doc_attrs = nil, $writer = nil, manvolnum = nil, mantitle = nil, manname = nil, name_section_level = nil, name_section = nil, name_section_buffer = nil, mannames = nil, manpurpose = nil, error_msg = nil;

        
        
        if (header_only == null) {
          header_only = false;
        };
        if ($truthy($$($nesting, 'ManpageTitleVolnumRx')['$=~']((doc_attrs = document.$attributes())['$[]']("doctitle")))) {
          
          
          $writer = ["manvolnum", (manvolnum = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)))];
          $send(doc_attrs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = ["mantitle", (function() {if ($truthy((mantitle = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1)))['$include?']($$($nesting, 'ATTR_REF_HEAD')))) {
            
            return document.$sub_attributes(mantitle);
          } else {
            return mantitle
          }; return nil; })().$downcase()];
          $send(doc_attrs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
        } else {
          
          self.$logger().$error(self.$message_with_context("non-conforming manpage title", $hash2(["source_location"], {"source_location": reader.$cursor_at_line(1)})));
          
          $writer = ["mantitle", ($truthy($a = ($truthy($b = doc_attrs['$[]']("doctitle")) ? $b : doc_attrs['$[]']("docname"))) ? $a : "command")];
          $send(doc_attrs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = ["manvolnum", (manvolnum = "1")];
          $send(doc_attrs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
        };
        if ($truthy(($truthy($a = (manname = doc_attrs['$[]']("manname"))) ? doc_attrs['$[]']("manpurpose") : $a))) {
          
          ($truthy($a = doc_attrs['$[]']("manname-title")) ? $a : (($writer = ["manname-title", "Name"]), $send(doc_attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
          
          $writer = ["mannames", [manname]];
          $send(doc_attrs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          if (document.$backend()['$==']("manpage")) {
            
            
            $writer = ["docname", manname];
            $send(doc_attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = ["outfilesuffix", "" + "." + (manvolnum)];
            $send(doc_attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;};
        } else if ($truthy(header_only)) {
        } else {
          
          reader.$skip_blank_lines();
          reader.$save();
          block_attributes.$update(self.$parse_block_metadata_lines(reader, document));
          if ($truthy((name_section_level = self['$is_next_line_section?'](reader, $hash2([], {}))))) {
            if (name_section_level['$=='](1)) {
              
              name_section = self.$initialize_section(reader, document, $hash2([], {}));
              name_section_buffer = $send(reader.$read_lines_until($hash2(["break_on_blank_lines", "skip_line_comments"], {"break_on_blank_lines": true, "skip_line_comments": true})), 'map', [], ($$7 = function(l){var self = $$7.$$s || this;

              
                
                if (l == null) {
                  l = nil;
                };
                return l.$lstrip();}, $$7.$$s = self, $$7.$$arity = 1, $$7)).$join(" ");
              if ($truthy($$($nesting, 'ManpageNamePurposeRx')['$=~'](name_section_buffer))) {
                
                if ($truthy((manname = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1)))['$include?']($$($nesting, 'ATTR_REF_HEAD')))) {
                  manname = document.$sub_attributes(manname)};
                if ($truthy(manname['$include?'](","))) {
                  manname = (mannames = $send(manname.$split(","), 'map', [], ($$8 = function(n){var self = $$8.$$s || this;

                  
                    
                    if (n == null) {
                      n = nil;
                    };
                    return n.$lstrip();}, $$8.$$s = self, $$8.$$arity = 1, $$8)))['$[]'](0)
                } else {
                  mannames = [manname]
                };
                if ($truthy((manpurpose = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)))['$include?']($$($nesting, 'ATTR_REF_HEAD')))) {
                  manpurpose = document.$sub_attributes(manpurpose)};
                ($truthy($a = doc_attrs['$[]']("manname-title")) ? $a : (($writer = ["manname-title", name_section.$title()]), $send(doc_attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
                if ($truthy(name_section.$id())) {
                  
                  $writer = ["manname-id", name_section.$id()];
                  $send(doc_attrs, '[]=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];};
                
                $writer = ["manname", manname];
                $send(doc_attrs, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
                
                $writer = ["mannames", mannames];
                $send(doc_attrs, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
                
                $writer = ["manpurpose", manpurpose];
                $send(doc_attrs, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
                if (document.$backend()['$==']("manpage")) {
                  
                  
                  $writer = ["docname", manname];
                  $send(doc_attrs, '[]=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];;
                  
                  $writer = ["outfilesuffix", "" + "." + (manvolnum)];
                  $send(doc_attrs, '[]=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];;};
              } else {
                error_msg = "non-conforming name section body"
              };
            } else {
              error_msg = "name section must be at level 1"
            }
          } else {
            error_msg = "name section expected"
          };
          if ($truthy(error_msg)) {
            
            reader.$restore_save();
            self.$logger().$error(self.$message_with_context(error_msg, $hash2(["source_location"], {"source_location": reader.$cursor()})));
            
            $writer = ["manname", (manname = ($truthy($a = doc_attrs['$[]']("docname")) ? $a : "command"))];
            $send(doc_attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = ["mannames", [manname]];
            $send(doc_attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            if (document.$backend()['$==']("manpage")) {
              
              
              $writer = ["docname", manname];
              $send(doc_attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              
              $writer = ["outfilesuffix", "" + "." + (manvolnum)];
              $send(doc_attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;};
          } else {
            reader.$discard_save()
          };
        };
        return nil;
      }, $Parser_parse_manpage_header$6.$$arity = -4);
      Opal.defs(self, '$next_section', $Parser_next_section$9 = function $$next_section(reader, parent, attributes) {
        var $a, $b, $c, $d, self = this, preamble = nil, intro = nil, part = nil, has_header = nil, book = nil, document = nil, $writer = nil, section = nil, current_level = nil, expected_next_level = nil, expected_next_level_alt = nil, title = nil, sectname = nil, next_level = nil, expected_condition = nil, new_section = nil, block_cursor = nil, new_block = nil, first_block = nil, child_block = nil;

        
        
        if (attributes == null) {
          attributes = $hash2([], {});
        };
        preamble = (intro = (part = false));
        if ($truthy(($truthy($a = (($b = parent.$context()['$==']("document")) ? parent.$blocks()['$empty?']() : parent.$context()['$==']("document"))) ? ($truthy($b = ($truthy($c = (has_header = parent['$header?']())) ? $c : attributes.$delete("invalid-header"))) ? $b : self['$is_next_line_section?'](reader, attributes)['$!']()) : $a))) {
          
          book = (document = parent).$doctype()['$==']("book");
          if ($truthy(($truthy($a = has_header) ? $a : ($truthy($b = book) ? attributes['$[]'](1)['$!=']("abstract") : $b)))) {
            
            preamble = (intro = $$($nesting, 'Block').$new(parent, "preamble", $hash2(["content_model"], {"content_model": "compound"})));
            if ($truthy(($truthy($a = book) ? parent['$attr?']("preface-title") : $a))) {
              
              $writer = [parent.$attr("preface-title")];
              $send(preamble, 'title=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            parent.$blocks()['$<<'](preamble);};
          section = parent;
          current_level = 0;
          if ($truthy(parent.$attributes()['$key?']("fragment"))) {
            expected_next_level = -1
          } else if ($truthy(book)) {
            $a = [1, 0], (expected_next_level = $a[0]), (expected_next_level_alt = $a[1]), $a
          } else {
            expected_next_level = 1
          };
        } else {
          
          book = (document = parent.$document()).$doctype()['$==']("book");
          section = self.$initialize_section(reader, parent, attributes);
          attributes = (function() {if ($truthy((title = attributes['$[]']("title")))) {
            return $hash2(["title"], {"title": title})
          } else {
            return $hash2([], {})
          }; return nil; })();
          expected_next_level = $rb_plus((current_level = section.$level()), 1);
          if (current_level['$=='](0)) {
            part = book
          } else if ($truthy((($a = current_level['$=='](1)) ? section.$special() : current_level['$=='](1)))) {
            if ($truthy(($truthy($a = ($truthy($b = (sectname = section.$sectname())['$==']("appendix")) ? $b : sectname['$==']("preface"))) ? $a : sectname['$==']("abstract")))) {
            } else {
              expected_next_level = nil
            }};
        };
        reader.$skip_blank_lines();
        while ($truthy(reader['$has_more_lines?']())) {
          
          self.$parse_block_metadata_lines(reader, document, attributes);
          if ($truthy((next_level = self['$is_next_line_section?'](reader, attributes)))) {
            
            if ($truthy(document['$attr?']("leveloffset"))) {
              
              next_level = $rb_plus(next_level, document.$attr("leveloffset").$to_i());
              if ($truthy($rb_lt(next_level, 0))) {
                next_level = 0};};
            if ($truthy($rb_gt(next_level, current_level))) {
              
              if ($truthy(expected_next_level)) {
                if ($truthy(($truthy($b = ($truthy($c = next_level['$=='](expected_next_level)) ? $c : ($truthy($d = expected_next_level_alt) ? next_level['$=='](expected_next_level_alt) : $d))) ? $b : $rb_lt(expected_next_level, 0)))) {
                } else {
                  
                  expected_condition = (function() {if ($truthy(expected_next_level_alt)) {
                    return "" + "expected levels " + (expected_next_level_alt) + " or " + (expected_next_level)
                  } else {
                    return "" + "expected level " + (expected_next_level)
                  }; return nil; })();
                  self.$logger().$warn(self.$message_with_context("" + "section title out of sequence: " + (expected_condition) + ", got level " + (next_level), $hash2(["source_location"], {"source_location": reader.$cursor()})));
                }
              } else {
                self.$logger().$error(self.$message_with_context("" + (sectname) + " sections do not support nested sections", $hash2(["source_location"], {"source_location": reader.$cursor()})))
              };
              $c = self.$next_section(reader, section, attributes), $b = Opal.to_ary($c), (new_section = ($b[0] == null ? nil : $b[0])), (attributes = ($b[1] == null ? nil : $b[1])), $c;
              section.$assign_numeral(new_section);
              section.$blocks()['$<<'](new_section);
            } else if ($truthy((($b = next_level['$=='](0)) ? section['$=='](document) : next_level['$=='](0)))) {
              
              if ($truthy(book)) {
              } else {
                self.$logger().$error(self.$message_with_context("level 0 sections can only be used when doctype is book", $hash2(["source_location"], {"source_location": reader.$cursor()})))
              };
              $c = self.$next_section(reader, section, attributes), $b = Opal.to_ary($c), (new_section = ($b[0] == null ? nil : $b[0])), (attributes = ($b[1] == null ? nil : $b[1])), $c;
              section.$assign_numeral(new_section);
              section.$blocks()['$<<'](new_section);
            } else {
              break;
            };
          } else {
            
            block_cursor = reader.$cursor();
            if ($truthy((new_block = self.$next_block(reader, ($truthy($b = intro) ? $b : section), attributes, $hash2(["parse_metadata"], {"parse_metadata": false}))))) {
              
              if ($truthy(part)) {
                if ($truthy(section['$blocks?']()['$!']())) {
                  if ($truthy(new_block.$style()['$!=']("partintro"))) {
                    if (new_block.$context()['$==']("paragraph")) {
                      
                      
                      $writer = ["open"];
                      $send(new_block, 'context=', Opal.to_a($writer));
                      $writer[$rb_minus($writer["length"], 1)];;
                      
                      $writer = ["partintro"];
                      $send(new_block, 'style=', Opal.to_a($writer));
                      $writer[$rb_minus($writer["length"], 1)];;
                    } else {
                      
                      
                      $writer = [(intro = $$($nesting, 'Block').$new(section, "open", $hash2(["content_model"], {"content_model": "compound"})))];
                      $send(new_block, 'parent=', Opal.to_a($writer));
                      $writer[$rb_minus($writer["length"], 1)];;
                      
                      $writer = ["partintro"];
                      $send(intro, 'style=', Opal.to_a($writer));
                      $writer[$rb_minus($writer["length"], 1)];;
                      section.$blocks()['$<<'](intro);
                    }}
                } else if (section.$blocks().$size()['$=='](1)) {
                  
                  first_block = section.$blocks()['$[]'](0);
                  if ($truthy(($truthy($b = intro['$!']()) ? first_block.$content_model()['$==']("compound") : $b))) {
                    self.$logger().$error(self.$message_with_context("illegal block content outside of partintro block", $hash2(["source_location"], {"source_location": block_cursor})))
                  } else if ($truthy(first_block.$content_model()['$!=']("compound"))) {
                    
                    
                    $writer = [(intro = $$($nesting, 'Block').$new(section, "open", $hash2(["content_model"], {"content_model": "compound"})))];
                    $send(new_block, 'parent=', Opal.to_a($writer));
                    $writer[$rb_minus($writer["length"], 1)];;
                    
                    $writer = ["partintro"];
                    $send(intro, 'style=', Opal.to_a($writer));
                    $writer[$rb_minus($writer["length"], 1)];;
                    section.$blocks().$shift();
                    if (first_block.$style()['$==']("partintro")) {
                      
                      
                      $writer = ["paragraph"];
                      $send(first_block, 'context=', Opal.to_a($writer));
                      $writer[$rb_minus($writer["length"], 1)];;
                      
                      $writer = [nil];
                      $send(first_block, 'style=', Opal.to_a($writer));
                      $writer[$rb_minus($writer["length"], 1)];;};
                    intro['$<<'](first_block);
                    section.$blocks()['$<<'](intro);};}};
              ($truthy($b = intro) ? $b : section).$blocks()['$<<'](new_block);
              attributes.$clear();};
          };
          if ($truthy($b = reader.$skip_blank_lines())) {
            $b
          } else {
            break;
          };
        };
        if ($truthy(part)) {
          if ($truthy(($truthy($a = section['$blocks?']()) ? section.$blocks()['$[]'](-1).$context()['$==']("section") : $a))) {
          } else {
            self.$logger().$error(self.$message_with_context("invalid part, must have at least one section (e.g., chapter, appendix, etc.)", $hash2(["source_location"], {"source_location": reader.$cursor()})))
          }
        } else if ($truthy(preamble)) {
          if ($truthy(preamble['$blocks?']())) {
            if ($truthy(($truthy($a = ($truthy($b = book) ? $b : document.$blocks()['$[]'](1))) ? $a : $$($nesting, 'Compliance').$unwrap_standalone_preamble()['$!']()))) {
              if ($truthy(document.$sourcemap())) {
                
                $writer = [preamble.$blocks()['$[]'](0).$source_location()];
                $send(preamble, 'source_location=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];}
            } else {
              
              document.$blocks().$shift();
              while ($truthy((child_block = preamble.$blocks().$shift()))) {
                document['$<<'](child_block)
              };
            }
          } else {
            document.$blocks().$shift()
          }};
        return [(function() {if (section['$=='](parent)) {
          return nil
        } else {
          return section
        }; return nil; })(), attributes.$merge()];
      }, $Parser_next_section$9.$$arity = -3);
      Opal.defs(self, '$next_block', $Parser_next_block$10 = function $$next_block(reader, parent, attributes, options) {try {

        var $a, $b, $c, $d, $$11, $$12, $$13, self = this, skipped = nil, text_only = nil, document = nil, extensions = nil, block_extensions = nil, block_macro_extensions = nil, this_line = nil, doc_attrs = nil, style = nil, block = nil, block_context = nil, cloaked_context = nil, terminator = nil, delimited_block = nil, $writer = nil, indented = nil, md_syntax = nil, ch0 = nil, layout_break_chars = nil, ll = nil, blk_ctx = nil, target = nil, blk_attrs = nil, $case = nil, posattrs = nil, expanded_target = nil, scaledwidth = nil, block_title = nil, extension = nil, report_unknown_block_macro = nil, content = nil, ext_config = nil, default_attrs = nil, float_id = nil, float_reftext = nil, float_level = nil, lines = nil, content_adjacent = nil, admonition_name = nil, credit_line = nil, attribution = nil, citetitle = nil, language = nil, comma_idx = nil, block_cursor = nil, block_reader = nil, content_model = nil, positional_attrs = nil, block_id = nil;
        if ($gvars["~"] == null) $gvars["~"] = nil;

        
        
        if (attributes == null) {
          attributes = $hash2([], {});
        };
        
        if (options == null) {
          options = $hash2([], {});
        };
        if ($truthy((skipped = reader.$skip_blank_lines()))) {
        } else {
          return nil
        };
        if ($truthy(($truthy($a = (text_only = options['$[]']("text_only"))) ? $rb_gt(skipped, 0) : $a))) {
          
          options.$delete("text_only");
          text_only = nil;};
        document = parent.$document();
        if ($truthy(options.$fetch("parse_metadata", true))) {
          while ($truthy(self.$parse_block_metadata_line(reader, document, attributes, options))) {
            
            reader.$shift();
            ($truthy($b = reader.$skip_blank_lines()) ? $b : Opal.ret(nil));
          }};
        if ($truthy((extensions = document.$extensions()))) {
          $a = [extensions['$blocks?'](), extensions['$block_macros?']()], (block_extensions = $a[0]), (block_macro_extensions = $a[1]), $a};
        reader.$mark();
        $a = [reader.$read_line(), document.$attributes(), attributes['$[]'](1)], (this_line = $a[0]), (doc_attrs = $a[1]), (style = $a[2]), $a;
        block = (block_context = (cloaked_context = (terminator = nil)));
        if ($truthy((delimited_block = self['$is_delimited_block?'](this_line, true)))) {
          
          block_context = (cloaked_context = delimited_block.$context());
          terminator = delimited_block.$terminator();
          if ($truthy(style)) {
            if (style['$=='](block_context.$to_s())) {
            } else if ($truthy(delimited_block.$masq()['$include?'](style))) {
              block_context = style.$to_sym()
            } else if ($truthy(($truthy($a = delimited_block.$masq()['$include?']("admonition")) ? $$($nesting, 'ADMONITION_STYLES')['$include?'](style) : $a))) {
              block_context = "admonition"
            } else if ($truthy(($truthy($a = block_extensions) ? extensions['$registered_for_block?'](style, block_context) : $a))) {
              block_context = style.$to_sym()
            } else {
              
              if ($truthy(self.$logger()['$debug?']())) {
                self.$logger().$debug(self.$message_with_context("" + "unknown style for " + (block_context) + " block: " + (style), $hash2(["source_location"], {"source_location": reader.$cursor_at_mark()})))};
              style = block_context.$to_s();
            }
          } else {
            style = (($writer = ["style", block_context.$to_s()]), $send(attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])
          };};
        if ($truthy(delimited_block)) {
        } else {
          while ($truthy(true)) {
            
            if ($truthy(($truthy($b = ($truthy($c = style) ? $$($nesting, 'Compliance').$strict_verbatim_paragraphs() : $c)) ? $$($nesting, 'VERBATIM_STYLES')['$include?'](style) : $b))) {
              
              block_context = style.$to_sym();
              reader.$unshift_line(this_line);
              break;;};
            if ($truthy(text_only)) {
              indented = this_line['$start_with?'](" ", $$($nesting, 'TAB'))
            } else {
              
              md_syntax = $$($nesting, 'Compliance').$markdown_syntax();
              if ($truthy(this_line['$start_with?'](" "))) {
                
                $b = [true, " "], (indented = $b[0]), (ch0 = $b[1]), $b;
                if ($truthy(($truthy($b = ($truthy($c = md_syntax) ? $send(this_line.$lstrip(), 'start_with?', Opal.to_a($$($nesting, 'MARKDOWN_THEMATIC_BREAK_CHARS').$keys())) : $c)) ? $$($nesting, 'MarkdownThematicBreakRx')['$match?'](this_line) : $b))) {
                  
                  block = $$($nesting, 'Block').$new(parent, "thematic_break", $hash2(["content_model"], {"content_model": "empty"}));
                  break;;};
              } else if ($truthy(this_line['$start_with?']($$($nesting, 'TAB')))) {
                $b = [true, $$($nesting, 'TAB')], (indented = $b[0]), (ch0 = $b[1]), $b
              } else {
                
                $b = [false, this_line.$chr()], (indented = $b[0]), (ch0 = $b[1]), $b;
                layout_break_chars = (function() {if ($truthy(md_syntax)) {
                  return $$($nesting, 'HYBRID_LAYOUT_BREAK_CHARS')
                } else {
                  return $$($nesting, 'LAYOUT_BREAK_CHARS')
                }; return nil; })();
                if ($truthy(($truthy($b = layout_break_chars['$key?'](ch0)) ? (function() {if ($truthy(md_syntax)) {
                  
                  return $$($nesting, 'ExtLayoutBreakRx')['$match?'](this_line);
                } else {
                  return ($truthy($c = self['$uniform?'](this_line, ch0, (ll = this_line.$length()))) ? $rb_gt(ll, 2) : $c)
                }; return nil; })() : $b))) {
                  
                  block = $$($nesting, 'Block').$new(parent, layout_break_chars['$[]'](ch0), $hash2(["content_model"], {"content_model": "empty"}));
                  break;;
                } else if ($truthy(($truthy($b = this_line['$end_with?']("]")) ? this_line['$include?']("::") : $b))) {
                  if ($truthy(($truthy($b = ($truthy($c = ch0['$==']("i")) ? $c : this_line['$start_with?']("video:", "audio:"))) ? $$($nesting, 'BlockMediaMacroRx')['$=~'](this_line) : $b))) {
                    
                    $b = [(($c = $gvars['~']) === nil ? nil : $c['$[]'](1)).$to_sym(), (($c = $gvars['~']) === nil ? nil : $c['$[]'](2)), (($c = $gvars['~']) === nil ? nil : $c['$[]'](3))], (blk_ctx = $b[0]), (target = $b[1]), (blk_attrs = $b[2]), $b;
                    block = $$($nesting, 'Block').$new(parent, blk_ctx, $hash2(["content_model"], {"content_model": "empty"}));
                    if ($truthy(blk_attrs)) {
                      
                      $case = blk_ctx;
                      if ("video"['$===']($case)) {posattrs = ["poster", "width", "height"]}
                      else if ("audio"['$===']($case)) {posattrs = []}
                      else {posattrs = ["alt", "width", "height"]};
                      block.$parse_attributes(blk_attrs, posattrs, $hash2(["sub_input", "into"], {"sub_input": true, "into": attributes}));};
                    if ($truthy(attributes['$key?']("style"))) {
                      attributes.$delete("style")};
                    if ($truthy(target['$include?']($$($nesting, 'ATTR_REF_HEAD')))) {
                      if ($truthy(($truthy($b = ($truthy($c = (expanded_target = block.$sub_attributes(target))['$empty?']()) ? ($truthy($d = doc_attrs['$[]']("attribute-missing")) ? $d : $$($nesting, 'Compliance').$attribute_missing())['$==']("drop-line") : $c)) ? block.$sub_attributes($rb_plus(target, " "), $hash2(["attribute_missing", "drop_line_severity"], {"attribute_missing": "drop-line", "drop_line_severity": "ignore"}))['$empty?']() : $b))) {
                        
                        attributes.$clear();
                        return nil;
                      } else {
                        target = expanded_target
                      }};
                    if (blk_ctx['$==']("image")) {
                      
                      document.$register("images", target);
                      
                      $writer = ["imagesdir", doc_attrs['$[]']("imagesdir")];
                      $send(attributes, '[]=', Opal.to_a($writer));
                      $writer[$rb_minus($writer["length"], 1)];;
                      ($truthy($b = attributes['$[]']("alt")) ? $b : (($writer = ["alt", ($truthy($c = style) ? $c : (($writer = ["default-alt", $$($nesting, 'Helpers').$basename(target, true).$tr("_-", " ")]), $send(attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))]), $send(attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
                      if ($truthy((scaledwidth = attributes.$delete("scaledwidth"))['$nil_or_empty?']())) {
                      } else {
                        
                        $writer = ["scaledwidth", (function() {if ($truthy($$($nesting, 'TrailingDigitsRx')['$match?'](scaledwidth))) {
                          return "" + (scaledwidth) + "%"
                        } else {
                          return scaledwidth
                        }; return nil; })()];
                        $send(attributes, '[]=', Opal.to_a($writer));
                        $writer[$rb_minus($writer["length"], 1)];
                      };
                      if ($truthy(attributes['$[]']("title"))) {
                        
                        
                        $writer = [(block_title = attributes.$delete("title"))];
                        $send(block, 'title=', Opal.to_a($writer));
                        $writer[$rb_minus($writer["length"], 1)];;
                        block.$assign_caption(attributes.$delete("caption"), "figure");};};
                    
                    $writer = ["target", target];
                    $send(attributes, '[]=', Opal.to_a($writer));
                    $writer[$rb_minus($writer["length"], 1)];;
                    break;;
                  } else if ($truthy(($truthy($b = (($c = ch0['$==']("t")) ? this_line['$start_with?']("toc:") : ch0['$==']("t"))) ? $$($nesting, 'BlockTocMacroRx')['$=~'](this_line) : $b))) {
                    
                    block = $$($nesting, 'Block').$new(parent, "toc", $hash2(["content_model"], {"content_model": "empty"}));
                    if ($truthy((($b = $gvars['~']) === nil ? nil : $b['$[]'](1)))) {
                      block.$parse_attributes((($b = $gvars['~']) === nil ? nil : $b['$[]'](1)), [], $hash2(["into"], {"into": attributes}))};
                    break;;
                  } else if ($truthy((function() {if ($truthy(block_macro_extensions)) {
                    
                    return ($truthy($b = ($truthy($c = $$($nesting, 'CustomBlockMacroRx')['$=~'](this_line)) ? (extension = extensions['$registered_for_block_macro?']((($d = $gvars['~']) === nil ? nil : $d['$[]'](1)))) : $c)) ? $b : (report_unknown_block_macro = self.$logger()['$debug?']()));
                  } else {
                    
                    return ($truthy($b = self.$logger()['$debug?']()) ? (report_unknown_block_macro = $$($nesting, 'CustomBlockMacroRx')['$=~'](this_line)) : $b);
                  }; return nil; })())) {
                    if ($truthy(report_unknown_block_macro)) {
                      self.$logger().$debug(self.$message_with_context("" + "unknown name for block macro: " + ((($b = $gvars['~']) === nil ? nil : $b['$[]'](1))), $hash2(["source_location"], {"source_location": reader.$cursor_at_mark()})))
                    } else {
                      
                      content = (($b = $gvars['~']) === nil ? nil : $b['$[]'](3));
                      if ($truthy((target = (($b = $gvars['~']) === nil ? nil : $b['$[]'](2)))['$include?']($$($nesting, 'ATTR_REF_HEAD')))) {
                        if ($truthy(($truthy($b = ($truthy($c = (expanded_target = parent.$sub_attributes(target))['$empty?']()) ? ($truthy($d = doc_attrs['$[]']("attribute-missing")) ? $d : $$($nesting, 'Compliance').$attribute_missing())['$==']("drop-line") : $c)) ? parent.$sub_attributes($rb_plus(target, " "), $hash2(["attribute_missing", "drop_line_severity"], {"attribute_missing": "drop-line", "drop_line_severity": "ignore"}))['$empty?']() : $b))) {
                          
                          attributes.$clear();
                          return nil;
                        } else {
                          target = expanded_target
                        }};
                      if ((ext_config = extension.$config())['$[]']("content_model")['$==']("attributes")) {
                        if ($truthy(content)) {
                          document.$parse_attributes(content, ($truthy($b = ($truthy($c = ext_config['$[]']("positional_attrs")) ? $c : ext_config['$[]']("pos_attrs"))) ? $b : []), $hash2(["sub_input", "into"], {"sub_input": true, "into": attributes}))}
                      } else {
                        
                        $writer = ["text", ($truthy($b = content) ? $b : "")];
                        $send(attributes, '[]=', Opal.to_a($writer));
                        $writer[$rb_minus($writer["length"], 1)];
                      };
                      if ($truthy((default_attrs = ext_config['$[]']("default_attrs")))) {
                        $send(attributes, 'update', [default_attrs], ($$11 = function(_, old_v){var self = $$11.$$s || this;

                        
                          
                          if (_ == null) {
                            _ = nil;
                          };
                          
                          if (old_v == null) {
                            old_v = nil;
                          };
                          return old_v;}, $$11.$$s = self, $$11.$$arity = 2, $$11))};
                      if ($truthy(($truthy($b = (block = extension.$process_method()['$[]'](parent, target, attributes))) ? block['$!='](parent) : $b))) {
                        
                        attributes.$replace(block.$attributes());
                        break;;
                      } else {
                        
                        attributes.$clear();
                        return nil;
                      };
                    }}};
              };
            };
            if ($truthy(($truthy($b = ($truthy($c = indented['$!']()) ? (ch0 = ($truthy($d = ch0) ? $d : this_line.$chr()))['$==']("<") : $c)) ? $$($nesting, 'CalloutListRx')['$=~'](this_line) : $b))) {
              
              reader.$unshift_line(this_line);
              block = self.$parse_callout_list(reader, $gvars["~"], parent, document.$callouts());
              
              $writer = ["style", "arabic"];
              $send(attributes, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              break;;
            } else if ($truthy($$($nesting, 'UnorderedListRx')['$match?'](this_line))) {
              
              reader.$unshift_line(this_line);
              if ($truthy(($truthy($b = ($truthy($c = style['$!']()) ? $$($nesting, 'Section')['$==='](parent) : $c)) ? parent.$sectname()['$==']("bibliography") : $b))) {
                
                $writer = ["style", (style = "bibliography")];
                $send(attributes, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];};
              block = self.$parse_list(reader, "ulist", parent, style);
              break;;
            } else if ($truthy($$($nesting, 'OrderedListRx')['$match?'](this_line))) {
              
              reader.$unshift_line(this_line);
              block = self.$parse_list(reader, "olist", parent, style);
              if ($truthy(block.$style())) {
                
                $writer = ["style", block.$style()];
                $send(attributes, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];};
              break;;
            } else if ($truthy(($truthy($b = ($truthy($c = this_line['$include?']("::")) ? $c : this_line['$include?'](";;"))) ? $$($nesting, 'DescriptionListRx')['$=~'](this_line) : $b))) {
              
              reader.$unshift_line(this_line);
              block = self.$parse_description_list(reader, $gvars["~"], parent);
              break;;
            } else if ($truthy(($truthy($b = ($truthy($c = style['$==']("float")) ? $c : style['$==']("discrete"))) ? (function() {if ($truthy($$($nesting, 'Compliance').$underline_style_section_titles())) {
              
              return self['$is_section_title?'](this_line, reader.$peek_line());
            } else {
              return ($truthy($c = indented['$!']()) ? self['$atx_section_title?'](this_line) : $c)
            }; return nil; })() : $b))) {
              
              reader.$unshift_line(this_line);
              $c = self.$parse_section_title(reader, document, attributes['$[]']("id")), $b = Opal.to_ary($c), (float_id = ($b[0] == null ? nil : $b[0])), (float_reftext = ($b[1] == null ? nil : $b[1])), (block_title = ($b[2] == null ? nil : $b[2])), (float_level = ($b[3] == null ? nil : $b[3])), $c;
              if ($truthy(float_reftext)) {
                
                $writer = ["reftext", float_reftext];
                $send(attributes, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];};
              block = $$($nesting, 'Block').$new(parent, "floating_title", $hash2(["content_model"], {"content_model": "empty"}));
              
              $writer = [block_title];
              $send(block, 'title=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              attributes.$delete("title");
              
              $writer = [($truthy($b = float_id) ? $b : (function() {if ($truthy(doc_attrs['$key?']("sectids"))) {
                
                return $$($nesting, 'Section').$generate_id(block.$title(), document);
              } else {
                return nil
              }; return nil; })())];
              $send(block, 'id=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              
              $writer = [float_level];
              $send(block, 'level=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              break;;
            } else if ($truthy(($truthy($b = style) ? style['$!=']("normal") : $b))) {
              if ($truthy($$($nesting, 'PARAGRAPH_STYLES')['$include?'](style))) {
                
                block_context = style.$to_sym();
                cloaked_context = "paragraph";
                reader.$unshift_line(this_line);
                break;;
              } else if ($truthy($$($nesting, 'ADMONITION_STYLES')['$include?'](style))) {
                
                block_context = "admonition";
                cloaked_context = "paragraph";
                reader.$unshift_line(this_line);
                break;;
              } else if ($truthy(($truthy($b = block_extensions) ? extensions['$registered_for_block?'](style, "paragraph") : $b))) {
                
                block_context = style.$to_sym();
                cloaked_context = "paragraph";
                reader.$unshift_line(this_line);
                break;;
              } else {
                
                if ($truthy(self.$logger()['$debug?']())) {
                  self.$logger().$debug(self.$message_with_context("" + "unknown style for paragraph: " + (style), $hash2(["source_location"], {"source_location": reader.$cursor_at_mark()})))};
                style = nil;
              }};
            reader.$unshift_line(this_line);
            if ($truthy(($truthy($b = indented) ? style['$!']() : $b))) {
              
              lines = self.$read_paragraph_lines(reader, (content_adjacent = (function() {if (skipped['$=='](0)) {
                return options['$[]']("list_type")
              } else {
                return nil
              }; return nil; })()), $hash2(["skip_line_comments"], {"skip_line_comments": text_only}));
              self['$adjust_indentation!'](lines);
              if ($truthy(($truthy($b = text_only) ? $b : content_adjacent['$==']("dlist")))) {
                block = $$($nesting, 'Block').$new(parent, "paragraph", $hash2(["content_model", "source", "attributes"], {"content_model": "simple", "source": lines, "attributes": attributes}))
              } else {
                block = $$($nesting, 'Block').$new(parent, "literal", $hash2(["content_model", "source", "attributes"], {"content_model": "verbatim", "source": lines, "attributes": attributes}))
              };
            } else {
              
              lines = self.$read_paragraph_lines(reader, (($b = skipped['$=='](0)) ? options['$[]']("list_type") : skipped['$=='](0)), $hash2(["skip_line_comments"], {"skip_line_comments": true}));
              if ($truthy(text_only)) {
                
                if ($truthy(($truthy($b = indented) ? style['$==']("normal") : $b))) {
                  self['$adjust_indentation!'](lines)};
                block = $$($nesting, 'Block').$new(parent, "paragraph", $hash2(["content_model", "source", "attributes"], {"content_model": "simple", "source": lines, "attributes": attributes}));
              } else if ($truthy(($truthy($b = ($truthy($c = $$($nesting, 'ADMONITION_STYLE_HEADS')['$include?'](ch0)) ? this_line['$include?'](":") : $c)) ? $$($nesting, 'AdmonitionParagraphRx')['$=~'](this_line) : $b))) {
                
                
                $writer = [0, (($b = $gvars['~']) === nil ? nil : $b.$post_match())];
                $send(lines, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
                
                $writer = ["name", (admonition_name = (($writer = ["style", (($b = $gvars['~']) === nil ? nil : $b['$[]'](1))]), $send(attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]).$downcase())];
                $send(attributes, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
                
                $writer = ["textlabel", ($truthy($b = attributes.$delete("caption")) ? $b : doc_attrs['$[]']("" + (admonition_name) + "-caption"))];
                $send(attributes, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
                block = $$($nesting, 'Block').$new(parent, "admonition", $hash2(["content_model", "source", "attributes"], {"content_model": "simple", "source": lines, "attributes": attributes}));
              } else if ($truthy(($truthy($b = ($truthy($c = md_syntax) ? ch0['$=='](">") : $c)) ? this_line['$start_with?']("> ") : $b))) {
                
                $send(lines, 'map!', [], ($$12 = function(line){var self = $$12.$$s || this;

                
                  
                  if (line == null) {
                    line = nil;
                  };
                  if (line['$=='](">")) {
                    
                    return line.$slice(1, line.$length());
                  } else {
                    
                    if ($truthy(line['$start_with?']("> "))) {
                      
                      return line.$slice(2, line.$length());
                    } else {
                      return line
                    };
                  };}, $$12.$$s = self, $$12.$$arity = 1, $$12));
                if ($truthy(lines['$[]'](-1)['$start_with?']("-- "))) {
                  
                  credit_line = (credit_line = lines.$pop()).$slice(3, credit_line.$length());
                  if ($truthy(lines['$empty?']())) {
                  } else {
                    while ($truthy(lines['$[]'](-1)['$empty?']())) {
                      lines.$pop()
                    }
                  };};
                
                $writer = ["style", "quote"];
                $send(attributes, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
                block = self.$build_block("quote", "compound", false, parent, $$($nesting, 'Reader').$new(lines), attributes);
                if ($truthy(credit_line)) {
                  
                  $c = block.$apply_subs(credit_line).$split(", ", 2), $b = Opal.to_ary($c), (attribution = ($b[0] == null ? nil : $b[0])), (citetitle = ($b[1] == null ? nil : $b[1])), $c;
                  if ($truthy(attribution)) {
                    
                    $writer = ["attribution", attribution];
                    $send(attributes, '[]=', Opal.to_a($writer));
                    $writer[$rb_minus($writer["length"], 1)];};
                  if ($truthy(citetitle)) {
                    
                    $writer = ["citetitle", citetitle];
                    $send(attributes, '[]=', Opal.to_a($writer));
                    $writer[$rb_minus($writer["length"], 1)];};};
              } else if ($truthy(($truthy($b = ($truthy($c = (($d = ch0['$==']("\"")) ? $rb_gt(lines.$size(), 1) : ch0['$==']("\""))) ? lines['$[]'](-1)['$start_with?']("-- ") : $c)) ? lines['$[]'](-2)['$end_with?']("\"") : $b))) {
                
                
                $writer = [0, this_line.$slice(1, this_line.$length())];
                $send(lines, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
                credit_line = (credit_line = lines.$pop()).$slice(3, credit_line.$length());
                while ($truthy(lines['$[]'](-1)['$empty?']())) {
                  lines.$pop()
                };
                lines['$<<'](lines.$pop().$chop());
                
                $writer = ["style", "quote"];
                $send(attributes, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
                block = $$($nesting, 'Block').$new(parent, "quote", $hash2(["content_model", "source", "attributes"], {"content_model": "simple", "source": lines, "attributes": attributes}));
                $c = block.$apply_subs(credit_line).$split(", ", 2), $b = Opal.to_ary($c), (attribution = ($b[0] == null ? nil : $b[0])), (citetitle = ($b[1] == null ? nil : $b[1])), $c;
                if ($truthy(attribution)) {
                  
                  $writer = ["attribution", attribution];
                  $send(attributes, '[]=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];};
                if ($truthy(citetitle)) {
                  
                  $writer = ["citetitle", citetitle];
                  $send(attributes, '[]=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];};
              } else {
                
                if ($truthy(($truthy($b = indented) ? style['$==']("normal") : $b))) {
                  self['$adjust_indentation!'](lines)};
                block = $$($nesting, 'Block').$new(parent, "paragraph", $hash2(["content_model", "source", "attributes"], {"content_model": "simple", "source": lines, "attributes": attributes}));
              };
              self.$catalog_inline_anchors(lines.$join($$($nesting, 'LF')), block, document, reader);
            };
            break;;
          }
        };
        if ($truthy(block)) {
        } else {
          $case = block_context;
          if ("listing"['$===']($case) || "source"['$===']($case)) {
          if ($truthy(($truthy($a = block_context['$==']("source")) ? $a : ($truthy($b = attributes['$[]'](1)['$!']()) ? (language = ($truthy($c = attributes['$[]'](2)) ? $c : doc_attrs['$[]']("source-language"))) : $b)))) {
            
            if ($truthy(language)) {
              
              
              $writer = ["style", "source"];
              $send(attributes, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              
              $writer = ["language", language];
              $send(attributes, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              $$($nesting, 'AttributeList').$rekey(attributes, [nil, nil, "linenums"]);
            } else {
              
              $$($nesting, 'AttributeList').$rekey(attributes, [nil, "language", "linenums"]);
              if ($truthy(attributes['$key?']("language"))) {
              } else if ($truthy(doc_attrs['$key?']("source-language"))) {
                
                $writer = ["language", doc_attrs['$[]']("source-language")];
                $send(attributes, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];};
            };
            if ($truthy(attributes['$key?']("linenums"))) {
            } else if ($truthy(($truthy($a = attributes['$[]']("linenums-option")) ? $a : doc_attrs['$[]']("source-linenums-option")))) {
              
              $writer = ["linenums", ""];
              $send(attributes, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            if ($truthy(attributes['$key?']("indent"))) {
            } else if ($truthy(doc_attrs['$key?']("source-indent"))) {
              
              $writer = ["indent", doc_attrs['$[]']("source-indent")];
              $send(attributes, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};};
          block = self.$build_block("listing", "verbatim", terminator, parent, reader, attributes);}
          else if ("fenced_code"['$===']($case)) {
          
          $writer = ["style", "source"];
          $send(attributes, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          if ($truthy($rb_gt((ll = this_line.$length()), 3))) {
            if ($truthy((comma_idx = (language = this_line.$slice(3, ll)).$index(",")))) {
              if ($truthy($rb_gt(comma_idx, 0))) {
                
                language = language.$slice(0, comma_idx).$strip();
                if ($truthy($rb_lt(comma_idx, $rb_minus(ll, 4)))) {
                  
                  $writer = ["linenums", ""];
                  $send(attributes, '[]=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];};
              } else if ($truthy($rb_gt(ll, 4))) {
                
                $writer = ["linenums", ""];
                $send(attributes, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];}
            } else {
              language = language.$lstrip()
            }};
          if ($truthy(language['$nil_or_empty?']())) {
            if ($truthy(doc_attrs['$key?']("source-language"))) {
              
              $writer = ["language", doc_attrs['$[]']("source-language")];
              $send(attributes, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];}
          } else {
            
            $writer = ["language", language];
            $send(attributes, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          };
          if ($truthy(attributes['$key?']("linenums"))) {
          } else if ($truthy(($truthy($a = attributes['$[]']("linenums-option")) ? $a : doc_attrs['$[]']("source-linenums-option")))) {
            
            $writer = ["linenums", ""];
            $send(attributes, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          if ($truthy(attributes['$key?']("indent"))) {
          } else if ($truthy(doc_attrs['$key?']("source-indent"))) {
            
            $writer = ["indent", doc_attrs['$[]']("source-indent")];
            $send(attributes, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          terminator = terminator.$slice(0, 3);
          block = self.$build_block("listing", "verbatim", terminator, parent, reader, attributes);}
          else if ("table"['$===']($case)) {
          block_cursor = reader.$cursor();
          block_reader = $$($nesting, 'Reader').$new(reader.$read_lines_until($hash2(["terminator", "skip_line_comments", "context", "cursor"], {"terminator": terminator, "skip_line_comments": true, "context": "table", "cursor": "at_mark"})), block_cursor);
          if ($truthy(terminator['$start_with?']("|", "!"))) {
          } else {
            ($truthy($a = attributes['$[]']("format")) ? $a : (($writer = ["format", (function() {if ($truthy(terminator['$start_with?'](","))) {
              return "csv"
            } else {
              return "dsv"
            }; return nil; })()]), $send(attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))
          };
          block = self.$parse_table(block_reader, parent, attributes);}
          else if ("sidebar"['$===']($case)) {block = self.$build_block(block_context, "compound", terminator, parent, reader, attributes)}
          else if ("admonition"['$===']($case)) {
          
          $writer = ["name", (admonition_name = style.$downcase())];
          $send(attributes, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          
          $writer = ["textlabel", ($truthy($a = attributes.$delete("caption")) ? $a : doc_attrs['$[]']("" + (admonition_name) + "-caption"))];
          $send(attributes, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          block = self.$build_block(block_context, "compound", terminator, parent, reader, attributes);}
          else if ("open"['$===']($case) || "abstract"['$===']($case) || "partintro"['$===']($case)) {block = self.$build_block("open", "compound", terminator, parent, reader, attributes)}
          else if ("literal"['$===']($case)) {block = self.$build_block(block_context, "verbatim", terminator, parent, reader, attributes)}
          else if ("example"['$===']($case)) {
          if ($truthy(attributes['$[]']("collapsible-option"))) {
            
            $writer = ["caption", ""];
            $send(attributes, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          block = self.$build_block(block_context, "compound", terminator, parent, reader, attributes);}
          else if ("quote"['$===']($case) || "verse"['$===']($case)) {
          $$($nesting, 'AttributeList').$rekey(attributes, [nil, "attribution", "citetitle"]);
          block = self.$build_block(block_context, (function() {if (block_context['$==']("verse")) {
            return "verbatim"
          } else {
            return "compound"
          }; return nil; })(), terminator, parent, reader, attributes);}
          else if ("stem"['$===']($case) || "latexmath"['$===']($case) || "asciimath"['$===']($case)) {
          if (block_context['$==']("stem")) {
            
            $writer = ["style", $$($nesting, 'STEM_TYPE_ALIASES')['$[]'](($truthy($a = attributes['$[]'](2)) ? $a : doc_attrs['$[]']("stem")))];
            $send(attributes, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          block = self.$build_block("stem", "raw", terminator, parent, reader, attributes);}
          else if ("pass"['$===']($case)) {block = self.$build_block(block_context, "raw", terminator, parent, reader, attributes)}
          else if ("comment"['$===']($case)) {
          self.$build_block(block_context, "skip", terminator, parent, reader, attributes);
          attributes.$clear();
          return nil;}
          else {if ($truthy(($truthy($a = block_extensions) ? (extension = extensions['$registered_for_block?'](block_context, cloaked_context)) : $a))) {
            
            if ((content_model = (ext_config = extension.$config())['$[]']("content_model"))['$==']("skip")) {
            } else {
              
              if ($truthy((positional_attrs = ($truthy($a = ext_config['$[]']("positional_attrs")) ? $a : ext_config['$[]']("pos_attrs")))['$nil_or_empty?']())) {
              } else {
                $$($nesting, 'AttributeList').$rekey(attributes, $rb_plus([nil], positional_attrs))
              };
              if ($truthy((default_attrs = ext_config['$[]']("default_attrs")))) {
                $send(default_attrs, 'each', [], ($$13 = function(k, v){var self = $$13.$$s || this, $e;

                
                  
                  if (k == null) {
                    k = nil;
                  };
                  
                  if (v == null) {
                    v = nil;
                  };
                  return ($truthy($e = attributes['$[]'](k)) ? $e : (($writer = [k, v]), $send(attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));}, $$13.$$s = self, $$13.$$arity = 2, $$13))};
              
              $writer = ["cloaked-context", cloaked_context];
              $send(attributes, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
            };
            if ($truthy((block = self.$build_block(block_context, content_model, terminator, parent, reader, attributes, $hash2(["extension"], {"extension": extension}))))) {
            } else {
              
              attributes.$clear();
              return nil;
            };
          } else {
            self.$raise("" + "Unsupported block type " + (block_context) + " at " + (reader.$cursor()))
          }}
        };
        if ($truthy(document.$sourcemap())) {
          
          $writer = [reader.$cursor_at_mark()];
          $send(block, 'source_location=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        if ($truthy(attributes['$[]']("title"))) {
          
          
          $writer = [(block_title = attributes.$delete("title"))];
          $send(block, 'title=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          if ($truthy($$($nesting, 'CAPTION_ATTRIBUTE_NAMES')['$[]'](block.$context()))) {
            block.$assign_caption(attributes.$delete("caption"))};};
        
        $writer = [attributes['$[]']("style")];
        $send(block, 'style=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        if ($truthy((block_id = ($truthy($a = block.$id()) ? $a : (($writer = [attributes['$[]']("id")]), $send(block, 'id=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))))) {
          
          if ($truthy((function() {if ($truthy(block_title)) {
            
            return block_title['$include?']($$($nesting, 'ATTR_REF_HEAD'));
          } else {
            return block['$title?']()
          }; return nil; })())) {
            block.$title()};
          if ($truthy(document.$register("refs", [block_id, block]))) {
          } else {
            self.$logger().$warn(self.$message_with_context("" + "id assigned to block already in use: " + (block_id), $hash2(["source_location"], {"source_location": reader.$cursor_at_mark()})))
          };};
        if ($truthy(attributes['$empty?']())) {
        } else {
          block.$update_attributes(attributes)
        };
        block.$commit_subs();
        if ($truthy(block['$sub?']("callouts"))) {
          if ($truthy(self.$catalog_callouts(block.$source(), document))) {
          } else {
            block.$remove_sub("callouts")
          }};
        return block;
        } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
      }, $Parser_next_block$10.$$arity = -3);
      Opal.defs(self, '$read_paragraph_lines', $Parser_read_paragraph_lines$14 = function $$read_paragraph_lines(reader, break_at_list, opts) {
        var self = this, $writer = nil, break_condition = nil;

        
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        
        $writer = ["break_on_blank_lines", true];
        $send(opts, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = ["break_on_list_continuation", true];
        $send(opts, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = ["preserve_last_line", true];
        $send(opts, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        break_condition = (function() {if ($truthy(break_at_list)) {
          
          if ($truthy($$($nesting, 'Compliance').$block_terminates_paragraph())) {
            return $$($nesting, 'StartOfBlockOrListProc')
          } else {
            return $$($nesting, 'StartOfListProc')
          };
        } else {
          
          if ($truthy($$($nesting, 'Compliance').$block_terminates_paragraph())) {
            return $$($nesting, 'StartOfBlockProc')
          } else {
            return $$($nesting, 'NoOp')
          };
        }; return nil; })();
        return $send(reader, 'read_lines_until', [opts], break_condition.$to_proc());
      }, $Parser_read_paragraph_lines$14.$$arity = -3);
      Opal.defs(self, '$is_delimited_block?', $Parser_is_delimited_block$ques$15 = function(line, return_match_data) {
        var $a, $b, self = this, line_len = nil, tip = nil, tip_len = nil, context = nil, masq = nil;

        
        
        if (return_match_data == null) {
          return_match_data = nil;
        };
        if ($truthy(($truthy($a = $rb_gt((line_len = line.$length()), 1)) ? $$($nesting, 'DELIMITED_BLOCK_HEADS')['$[]'](line.$slice(0, 2)) : $a))) {
        } else {
          return nil
        };
        if (line_len['$=='](2)) {
          
          tip = line;
          tip_len = 2;
        } else {
          
          if ($truthy($rb_lt(line_len, 5))) {
            
            tip = line;
            tip_len = line_len;
          } else {
            tip = line.$slice(0, (tip_len = 4))
          };
          if ($truthy(($truthy($a = $$($nesting, 'Compliance').$markdown_syntax()) ? tip['$start_with?']("`") : $a))) {
            if (tip_len['$=='](4)) {
              
              if ($truthy(($truthy($a = tip['$==']("````")) ? $a : (tip = tip.$chop())['$!=']("```")))) {
                return nil};
              line = tip;
              line_len = (tip_len = 3);
            } else if ($truthy(tip['$!=']("```"))) {
              return nil}
          } else if (tip_len['$=='](3)) {
            return nil};
        };
        $b = $$($nesting, 'DELIMITED_BLOCKS')['$[]'](tip), $a = Opal.to_ary($b), (context = ($a[0] == null ? nil : $a[0])), (masq = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy(($truthy($a = context) ? ($truthy($b = line_len['$=='](tip_len)) ? $b : self['$uniform?'](line.$slice(1, line_len), $$($nesting, 'DELIMITED_BLOCK_TAILS')['$[]'](tip), $rb_minus(line_len, 1))) : $a))) {
          if ($truthy(return_match_data)) {
            
            return $$($nesting, 'BlockMatchData').$new(context, masq, tip, line);
          } else {
            return true
          }
        } else {
          return nil
        };
      }, $Parser_is_delimited_block$ques$15.$$arity = -2);
      Opal.defs(self, '$build_block', $Parser_build_block$16 = function $$build_block(block_context, content_model, terminator, parent, reader, attributes, options) {
        var $a, $b, self = this, $case = nil, skip_processing = nil, parse_as_content_model = nil, lines = nil, block_reader = nil, block_cursor = nil, tab_size = nil, indent = nil, extension = nil, block = nil;

        
        
        if (options == null) {
          options = $hash2([], {});
        };
        $case = content_model;
        if ("skip"['$===']($case)) {$a = [true, "simple"], (skip_processing = $a[0]), (parse_as_content_model = $a[1]), $a}
        else if ("raw"['$===']($case)) {$a = [false, "simple"], (skip_processing = $a[0]), (parse_as_content_model = $a[1]), $a}
        else {$a = [false, content_model], (skip_processing = $a[0]), (parse_as_content_model = $a[1]), $a};
        if ($truthy(terminator['$nil?']())) {
          
          if (parse_as_content_model['$==']("verbatim")) {
            lines = reader.$read_lines_until($hash2(["break_on_blank_lines", "break_on_list_continuation"], {"break_on_blank_lines": true, "break_on_list_continuation": true}))
          } else {
            
            if (content_model['$==']("compound")) {
              content_model = "simple"};
            lines = self.$read_paragraph_lines(reader, false, $hash2(["skip_line_comments", "skip_processing"], {"skip_line_comments": true, "skip_processing": skip_processing}));
          };
          block_reader = nil;
        } else if ($truthy(parse_as_content_model['$!=']("compound"))) {
          
          lines = reader.$read_lines_until($hash2(["terminator", "skip_processing", "context", "cursor"], {"terminator": terminator, "skip_processing": skip_processing, "context": block_context, "cursor": "at_mark"}));
          block_reader = nil;
        } else if (terminator['$=='](false)) {
          
          lines = nil;
          block_reader = reader;
        } else {
          
          lines = nil;
          block_cursor = reader.$cursor();
          block_reader = $$($nesting, 'Reader').$new(reader.$read_lines_until($hash2(["terminator", "skip_processing", "context", "cursor"], {"terminator": terminator, "skip_processing": skip_processing, "context": block_context, "cursor": "at_mark"})), block_cursor);
        };
        $case = content_model;
        if ("verbatim"['$===']($case)) {
        tab_size = ($truthy($a = attributes['$[]']("tabsize")) ? $a : parent.$document().$attributes()['$[]']("tabsize")).$to_i();
        if ($truthy((indent = attributes['$[]']("indent")))) {
          self['$adjust_indentation!'](lines, indent.$to_i(), tab_size)
        } else if ($truthy($rb_gt(tab_size, 0))) {
          self['$adjust_indentation!'](lines, -1, tab_size)};}
        else if ("skip"['$===']($case)) {return nil};
        if ($truthy((extension = options['$[]']("extension")))) {
          
          attributes.$delete("style");
          if ($truthy(($truthy($a = (block = extension.$process_method()['$[]'](parent, ($truthy($b = block_reader) ? $b : $$($nesting, 'Reader').$new(lines)), attributes.$merge()))) ? block['$!='](parent) : $a))) {
            
            attributes.$replace(block.$attributes());
            if ($truthy(($truthy($a = (($b = block.$content_model()['$==']("compound")) ? $$($nesting, 'Block')['$==='](block) : block.$content_model()['$==']("compound"))) ? (lines = block.$lines())['$empty?']()['$!']() : $a))) {
              
              content_model = "compound";
              block_reader = $$($nesting, 'Reader').$new(lines);};
          } else {
            return nil
          };
        } else {
          block = $$($nesting, 'Block').$new(parent, block_context, $hash2(["content_model", "source", "attributes"], {"content_model": content_model, "source": lines, "attributes": attributes}))
        };
        if (content_model['$==']("compound")) {
          self.$parse_blocks(block_reader, block)};
        return block;
      }, $Parser_build_block$16.$$arity = -7);
      Opal.defs(self, '$parse_blocks', $Parser_parse_blocks$17 = function $$parse_blocks(reader, parent, attributes) {
        var $a, $b, $c, self = this, block = nil;

        
        
        if (attributes == null) {
          attributes = nil;
        };
        if ($truthy(attributes)) {
          while ($truthy(($truthy($b = ($truthy($c = (block = self.$next_block(reader, parent, attributes.$merge()))) ? parent.$blocks()['$<<'](block) : $c)) ? $b : reader['$has_more_lines?']()))) {
            
          }
        } else {
          while ($truthy(($truthy($b = ($truthy($c = (block = self.$next_block(reader, parent))) ? parent.$blocks()['$<<'](block) : $c)) ? $b : reader['$has_more_lines?']()))) {
            
          }
        };
        return nil;
      }, $Parser_parse_blocks$17.$$arity = -3);
      Opal.defs(self, '$parse_list', $Parser_parse_list$18 = function $$parse_list(reader, list_type, parent, style) {
        var $a, $b, self = this, list_block = nil, list_rx = nil, list_item = nil;
        if ($gvars["~"] == null) $gvars["~"] = nil;

        
        list_block = $$($nesting, 'List').$new(parent, list_type);
        list_rx = $$($nesting, 'ListRxMap')['$[]'](list_type);
        while ($truthy(($truthy($b = reader['$has_more_lines?']()) ? list_rx['$=~'](reader.$peek_line()) : $b))) {
          
          if ($truthy((list_item = self.$parse_list_item(reader, list_block, $gvars["~"], (($b = $gvars['~']) === nil ? nil : $b['$[]'](1)), style)))) {
            list_block.$items()['$<<'](list_item)};
          if ($truthy($b = reader.$skip_blank_lines())) {
            $b
          } else {
            break;
          };
        };
        return list_block;
      }, $Parser_parse_list$18.$$arity = 4);
      Opal.defs(self, '$catalog_callouts', $Parser_catalog_callouts$19 = function $$catalog_callouts(text, document) {
        var $$20, self = this, found = nil, autonum = nil;

        
        found = false;
        autonum = 0;
        if ($truthy(text['$include?']("<"))) {
          $send(text, 'scan', [$$($nesting, 'CalloutScanRx')], ($$20 = function(){var self = $$20.$$s || this, $a;

          
            if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](0))['$start_with?']("\\"))) {
            } else {
              document.$callouts().$register((function() {if ((($a = $gvars['~']) === nil ? nil : $a['$[]'](2))['$=='](".")) {
                return (autonum = $rb_plus(autonum, 1)).$to_s()
              } else {
                return (($a = $gvars['~']) === nil ? nil : $a['$[]'](2))
              }; return nil; })())
            };
            return (found = true);}, $$20.$$s = self, $$20.$$arity = 0, $$20))};
        return found;
      }, $Parser_catalog_callouts$19.$$arity = 2);
      Opal.defs(self, '$catalog_inline_anchor', $Parser_catalog_inline_anchor$21 = function $$catalog_inline_anchor(id, reftext, node, location, doc) {
        var $a, self = this;

        
        
        if (doc == null) {
          doc = node.$document();
        };
        if ($truthy(($truthy($a = reftext) ? reftext['$include?']($$($nesting, 'ATTR_REF_HEAD')) : $a))) {
          reftext = doc.$sub_attributes(reftext)};
        if ($truthy(doc.$register("refs", [id, $$($nesting, 'Inline').$new(node, "anchor", reftext, $hash2(["type", "id"], {"type": "ref", "id": id}))]))) {
        } else {
          
          if ($truthy($$($nesting, 'Reader')['$==='](location))) {
            location = location.$cursor()};
          self.$logger().$warn(self.$message_with_context("" + "id assigned to anchor already in use: " + (id), $hash2(["source_location"], {"source_location": location})));
        };
        return nil;
      }, $Parser_catalog_inline_anchor$21.$$arity = -5);
      Opal.defs(self, '$catalog_inline_anchors', $Parser_catalog_inline_anchors$22 = function $$catalog_inline_anchors(text, block, document, reader) {
        var $a, $$23, self = this;

        
        if ($truthy(($truthy($a = text['$include?']("[[")) ? $a : text['$include?']("or:")))) {
          $send(text, 'scan', [$$($nesting, 'InlineAnchorScanRx')], ($$23 = function(){var self = $$23.$$s || this, $b, $c, $d, id = nil, reftext = nil, location = nil, offset = nil;

          
            if ($truthy((id = (($b = $gvars['~']) === nil ? nil : $b['$[]'](1))))) {
              if ($truthy(($truthy($b = ($truthy($c = (reftext = (($d = $gvars['~']) === nil ? nil : $d['$[]'](2)))) ? reftext['$include?']($$($nesting, 'ATTR_REF_HEAD')) : $c)) ? (reftext = document.$sub_attributes(reftext))['$empty?']() : $b))) {
                return nil;}
            } else {
              
              id = (($b = $gvars['~']) === nil ? nil : $b['$[]'](3));
              if ($truthy((reftext = (($b = $gvars['~']) === nil ? nil : $b['$[]'](4))))) {
                if ($truthy(reftext['$include?']("]"))) {
                  
                  reftext = reftext.$gsub("\\]", "]");
                  if ($truthy(reftext['$include?']($$($nesting, 'ATTR_REF_HEAD')))) {
                    reftext = document.$sub_attributes(reftext)};
                } else if ($truthy(($truthy($b = reftext['$include?']($$($nesting, 'ATTR_REF_HEAD'))) ? (reftext = document.$sub_attributes(reftext))['$empty?']() : $b))) {
                  return nil;}};
            };
            if ($truthy(document.$register("refs", [id, $$($nesting, 'Inline').$new(block, "anchor", reftext, $hash2(["type", "id"], {"type": "ref", "id": id}))]))) {
              return nil
            } else {
              
              location = reader.$cursor_at_mark();
              if ($truthy($rb_gt((offset = $rb_plus((($b = $gvars['~']) === nil ? nil : $b.$pre_match()).$count($$($nesting, 'LF')), (function() {if ($truthy((($b = $gvars['~']) === nil ? nil : $b['$[]'](0))['$start_with?']($$($nesting, 'LF')))) {
                return 1
              } else {
                return 0
              }; return nil; })())), 0))) {
                (location = location.$dup()).$advance(offset)};
              return self.$logger().$warn(self.$message_with_context("" + "id assigned to anchor already in use: " + (id), $hash2(["source_location"], {"source_location": location})));
            };}, $$23.$$s = self, $$23.$$arity = 0, $$23))};
        return nil;
      }, $Parser_catalog_inline_anchors$22.$$arity = 4);
      Opal.defs(self, '$catalog_inline_biblio_anchor', $Parser_catalog_inline_biblio_anchor$24 = function $$catalog_inline_biblio_anchor(id, reftext, node, reader) {
        var $a, self = this;

        
        if ($truthy(node.$document().$register("refs", [id, $$($nesting, 'Inline').$new(node, "anchor", ($truthy($a = reftext) ? "" + "[" + (reftext) + "]" : $a), $hash2(["type", "id"], {"type": "bibref", "id": id}))]))) {
        } else {
          self.$logger().$warn(self.$message_with_context("" + "id assigned to bibliography anchor already in use: " + (id), $hash2(["source_location"], {"source_location": reader.$cursor()})))
        };
        return nil;
      }, $Parser_catalog_inline_biblio_anchor$24.$$arity = 4);
      Opal.defs(self, '$parse_description_list', $Parser_parse_description_list$25 = function $$parse_description_list(reader, match, parent) {
        var $a, $b, self = this, list_block = nil, sibling_pattern = nil, current_pair = nil, next_pair = nil, $writer = nil;
        if ($gvars["~"] == null) $gvars["~"] = nil;

        
        list_block = $$($nesting, 'List').$new(parent, "dlist");
        sibling_pattern = $$($nesting, 'DescriptionListSiblingRx')['$[]'](match['$[]'](2));
        list_block.$items()['$<<']((current_pair = self.$parse_list_item(reader, list_block, match, sibling_pattern)));
        while ($truthy(($truthy($b = reader['$has_more_lines?']()) ? sibling_pattern['$=~'](reader.$peek_line()) : $b))) {
          
          next_pair = self.$parse_list_item(reader, list_block, $gvars["~"], sibling_pattern);
          if ($truthy(current_pair['$[]'](1))) {
            list_block.$items()['$<<']((current_pair = next_pair))
          } else {
            
            current_pair['$[]'](0)['$<<'](next_pair['$[]'](0)['$[]'](0));
            
            $writer = [1, next_pair['$[]'](1)];
            $send(current_pair, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
          };
        };
        return list_block;
      }, $Parser_parse_description_list$25.$$arity = 3);
      Opal.defs(self, '$parse_callout_list', $Parser_parse_callout_list$26 = function $$parse_callout_list(reader, match, parent, callouts) {
        var $a, $b, $c, self = this, list_block = nil, next_index = nil, autonum = nil, num = nil, list_item = nil, coids = nil, $writer = nil;

        
        list_block = $$($nesting, 'List').$new(parent, "colist");
        next_index = 1;
        autonum = 0;
        while ($truthy(($truthy($b = match) ? $b : ($truthy($c = (match = $$($nesting, 'CalloutListRx').$match(reader.$peek_line()))) ? reader.$mark() : $c)))) {
          
          if ((num = match['$[]'](1))['$=='](".")) {
            num = (autonum = $rb_plus(autonum, 1)).$to_s()};
          if (num['$=='](next_index.$to_s())) {
          } else {
            self.$logger().$warn(self.$message_with_context("" + "callout list item index: expected " + (next_index) + ", got " + (num), $hash2(["source_location"], {"source_location": reader.$cursor_at_mark()})))
          };
          if ($truthy((list_item = self.$parse_list_item(reader, list_block, match, "<1>")))) {
            
            list_block.$items()['$<<'](list_item);
            if ($truthy((coids = callouts.$callout_ids(list_block.$items().$size()))['$empty?']())) {
              self.$logger().$warn(self.$message_with_context("" + "no callout found for <" + (list_block.$items().$size()) + ">", $hash2(["source_location"], {"source_location": reader.$cursor_at_mark()})))
            } else {
              
              $writer = ["coids", coids];
              $send(list_item.$attributes(), '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            };};
          next_index = $rb_plus(next_index, 1);
          match = nil;
        };
        callouts.$next_list();
        return list_block;
      }, $Parser_parse_callout_list$26.$$arity = 4);
      Opal.defs(self, '$parse_list_item', $Parser_parse_list_item$27 = function $$parse_list_item(reader, list_block, match, sibling_trait, style) {
        var $a, $b, self = this, list_type = nil, dlist = nil, list_term = nil, term_text = nil, item_text = nil, has_text = nil, list_item = nil, $writer = nil, sourcemap_assignment_deferred = nil, $case = nil, ordinal = nil, implicit_style = nil, block_cursor = nil, list_item_reader = nil, comment_lines = nil, subsequent_line = nil, content_adjacent = nil, block = nil, first_block = nil;

        
        
        if (style == null) {
          style = nil;
        };
        if ((list_type = list_block.$context())['$==']("dlist")) {
          
          dlist = true;
          list_term = $$($nesting, 'ListItem').$new(list_block, (term_text = match['$[]'](1)));
          if ($truthy(($truthy($a = term_text['$start_with?']("[[")) ? $$($nesting, 'LeadingInlineAnchorRx')['$=~'](term_text) : $a))) {
            self.$catalog_inline_anchor((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), ($truthy($a = (($b = $gvars['~']) === nil ? nil : $b['$[]'](2))) ? $a : (($b = $gvars['~']) === nil ? nil : $b.$post_match()).$lstrip()), list_term, reader)};
          if ($truthy((item_text = match['$[]'](3)))) {
            has_text = true};
          list_item = $$($nesting, 'ListItem').$new(list_block, item_text);
          if ($truthy(list_block.$document().$sourcemap())) {
            
            
            $writer = [reader.$cursor()];
            $send(list_term, 'source_location=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            if ($truthy(has_text)) {
              
              $writer = [list_term.$source_location()];
              $send(list_item, 'source_location=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            } else {
              sourcemap_assignment_deferred = true
            };};
        } else {
          
          has_text = true;
          list_item = $$($nesting, 'ListItem').$new(list_block, (item_text = match['$[]'](2)));
          if ($truthy(list_block.$document().$sourcemap())) {
            
            $writer = [reader.$cursor()];
            $send(list_item, 'source_location=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          $case = list_type;
          if ("ulist"['$===']($case)) {
          
          $writer = [sibling_trait];
          $send(list_item, 'marker=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          if ($truthy(item_text['$start_with?']("["))) {
            if ($truthy(($truthy($a = style) ? style['$==']("bibliography") : $a))) {
              if ($truthy($$($nesting, 'InlineBiblioAnchorRx')['$=~'](item_text))) {
                self.$catalog_inline_biblio_anchor((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), list_item, reader)}
            } else if ($truthy(item_text['$start_with?']("[["))) {
              if ($truthy($$($nesting, 'LeadingInlineAnchorRx')['$=~'](item_text))) {
                self.$catalog_inline_anchor((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), list_item, reader)}
            } else if ($truthy(item_text['$start_with?']("[ ] ", "[x] ", "[*] "))) {
              
              list_block.$set_option("checklist");
              
              $writer = ["checkbox", ""];
              $send(list_item.$attributes(), '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              if ($truthy(item_text['$start_with?']("[ "))) {
              } else {
                
                $writer = ["checked", ""];
                $send(list_item.$attributes(), '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
              };
              
              $writer = [item_text.$slice(4, item_text.$length())];
              $send(list_item, 'text=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;}};}
          else if ("olist"['$===']($case)) {
          $b = self.$resolve_ordered_list_marker(sibling_trait, (ordinal = list_block.$items().$size()), true, reader), $a = Opal.to_ary($b), (sibling_trait = ($a[0] == null ? nil : $a[0])), (implicit_style = ($a[1] == null ? nil : $a[1])), $b;
          
          $writer = [sibling_trait];
          $send(list_item, 'marker=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          if ($truthy((($a = ordinal['$=='](0)) ? style['$!']() : ordinal['$=='](0)))) {
            
            $writer = [($truthy($a = implicit_style) ? $a : ($truthy($b = $$($nesting, 'ORDERED_LIST_STYLES')['$[]']($rb_minus(sibling_trait.$length(), 1))) ? $b : "arabic").$to_s())];
            $send(list_block, 'style=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          if ($truthy(($truthy($a = item_text['$start_with?']("[[")) ? $$($nesting, 'LeadingInlineAnchorRx')['$=~'](item_text) : $a))) {
            self.$catalog_inline_anchor((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), list_item, reader)};}
          else {
          
          $writer = [sibling_trait];
          $send(list_item, 'marker=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          if ($truthy(($truthy($a = item_text['$start_with?']("[[")) ? $$($nesting, 'LeadingInlineAnchorRx')['$=~'](item_text) : $a))) {
            self.$catalog_inline_anchor((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), list_item, reader)};};
        };
        reader.$shift();
        block_cursor = reader.$cursor();
        list_item_reader = $$($nesting, 'Reader').$new(self.$read_lines_for_list_item(reader, list_type, sibling_trait, has_text), block_cursor);
        if ($truthy(list_item_reader['$has_more_lines?']())) {
          
          if ($truthy(sourcemap_assignment_deferred)) {
            
            $writer = [block_cursor];
            $send(list_item, 'source_location=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          comment_lines = list_item_reader.$skip_line_comments();
          if ($truthy((subsequent_line = list_item_reader.$peek_line()))) {
            
            if ($truthy(comment_lines['$empty?']())) {
            } else {
              list_item_reader.$unshift_lines(comment_lines)
            };
            if ($truthy(subsequent_line['$empty?']())) {
            } else {
              
              content_adjacent = true;
              if ($truthy(dlist)) {
              } else {
                has_text = nil
              };
            };};
          if ($truthy((block = self.$next_block(list_item_reader, list_item, $hash2([], {}), $hash2(["text_only", "list_type"], {"text_only": (function() {if ($truthy(has_text)) {
            return nil
          } else {
            return true
          }; return nil; })(), "list_type": list_type}))))) {
            list_item.$blocks()['$<<'](block)};
          while ($truthy(list_item_reader['$has_more_lines?']())) {
            if ($truthy((block = self.$next_block(list_item_reader, list_item, $hash2([], {}), $hash2(["list_type"], {"list_type": list_type}))))) {
              list_item.$blocks()['$<<'](block)}
          };
          if ($truthy(($truthy($a = ($truthy($b = content_adjacent) ? (first_block = list_item.$blocks()['$[]'](0)) : $b)) ? first_block.$context()['$==']("paragraph") : $a))) {
            list_item.$fold_first()};};
        if ($truthy(dlist)) {
          return [[list_term], (function() {if ($truthy(($truthy($a = list_item['$text?']()) ? $a : list_item['$blocks?']()))) {
            return list_item
          } else {
            return nil
          }; return nil; })()]
        } else {
          return list_item
        };
      }, $Parser_parse_list_item$27.$$arity = -5);
      Opal.defs(self, '$read_lines_for_list_item', $Parser_read_lines_for_list_item$28 = function $$read_lines_for_list_item(reader, list_type, sibling_trait, has_text) {
        var $a, $b, $c, $$29, $$30, $$31, $$32, $$33, self = this, buffer = nil, continuation = nil, within_nested_list = nil, detached_continuation = nil, dlist = nil, this_line = nil, prev_line = nil, $writer = nil, match = nil, nested_list_type = nil, last_line = nil;

        
        
        if (sibling_trait == null) {
          sibling_trait = nil;
        };
        
        if (has_text == null) {
          has_text = true;
        };
        buffer = [];
        continuation = "inactive";
        within_nested_list = false;
        detached_continuation = nil;
        dlist = list_type['$==']("dlist");
        while ($truthy(reader['$has_more_lines?']())) {
          
          this_line = reader.$read_line();
          if ($truthy(self['$is_sibling_list_item?'](this_line, list_type, sibling_trait))) {
            break;};
          prev_line = (function() {if ($truthy(buffer['$empty?']())) {
            return nil
          } else {
            return buffer['$[]'](-1)
          }; return nil; })();
          if (prev_line['$==']($$($nesting, 'LIST_CONTINUATION'))) {
            
            if (continuation['$==']("inactive")) {
              
              continuation = "active";
              has_text = true;
              if ($truthy(within_nested_list)) {
              } else {
                
                $writer = [-1, ""];
                $send(buffer, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
              };};
            if (this_line['$==']($$($nesting, 'LIST_CONTINUATION'))) {
              
              if ($truthy(continuation['$!=']("frozen"))) {
                
                continuation = "frozen";
                buffer['$<<'](this_line);};
              this_line = nil;
              continue;;};};
          if ($truthy((match = self['$is_delimited_block?'](this_line, true)))) {
            if (continuation['$==']("active")) {
              
              buffer['$<<'](this_line);
              buffer.$concat(reader.$read_lines_until($hash2(["terminator", "read_last_line", "context"], {"terminator": match.$terminator(), "read_last_line": true, "context": nil})));
              continuation = "inactive";
            } else {
              break;
            }
          } else if ($truthy(($truthy($b = ($truthy($c = dlist) ? continuation['$!=']("active") : $c)) ? $$($nesting, 'BlockAttributeLineRx')['$match?'](this_line) : $b))) {
            break;
          } else if ($truthy((($b = continuation['$==']("active")) ? this_line['$empty?']()['$!']() : continuation['$==']("active")))) {
            if ($truthy($$($nesting, 'LiteralParagraphRx')['$match?'](this_line))) {
              
              reader.$unshift_line(this_line);
              if ($truthy(dlist)) {
                buffer.$concat($send(reader, 'read_lines_until', [$hash2(["preserve_last_line", "break_on_blank_lines", "break_on_list_continuation"], {"preserve_last_line": true, "break_on_blank_lines": true, "break_on_list_continuation": true})], ($$29 = function(line){var self = $$29.$$s || this;

                
                  
                  if (line == null) {
                    line = nil;
                  };
                  return self['$is_sibling_list_item?'](line, list_type, sibling_trait);}, $$29.$$s = self, $$29.$$arity = 1, $$29)))
              } else {
                buffer.$concat(reader.$read_lines_until($hash2(["preserve_last_line", "break_on_blank_lines", "break_on_list_continuation"], {"preserve_last_line": true, "break_on_blank_lines": true, "break_on_list_continuation": true})))
              };
              continuation = "inactive";
            } else if ($truthy(($truthy($b = ($truthy($c = $$($nesting, 'BlockTitleRx')['$match?'](this_line)) ? $c : $$($nesting, 'BlockAttributeLineRx')['$match?'](this_line))) ? $b : $$($nesting, 'AttributeEntryRx')['$match?'](this_line)))) {
              buffer['$<<'](this_line)
            } else {
              
              if ($truthy((nested_list_type = $send((function() {if ($truthy(within_nested_list)) {
                return ["dlist"]
              } else {
                return $$($nesting, 'NESTABLE_LIST_CONTEXTS')
              }; return nil; })(), 'find', [], ($$30 = function(ctx){var self = $$30.$$s || this;

              
                
                if (ctx == null) {
                  ctx = nil;
                };
                return $$($nesting, 'ListRxMap')['$[]'](ctx)['$match?'](this_line);}, $$30.$$s = self, $$30.$$arity = 1, $$30))))) {
                
                within_nested_list = true;
                if ($truthy((($b = nested_list_type['$==']("dlist")) ? (($c = $gvars['~']) === nil ? nil : $c['$[]'](3))['$nil_or_empty?']() : nested_list_type['$==']("dlist")))) {
                  has_text = false};};
              buffer['$<<'](this_line);
              continuation = "inactive";
            }
          } else if ($truthy(($truthy($b = prev_line) ? prev_line['$empty?']() : $b))) {
            
            if ($truthy(this_line['$empty?']())) {
              
              if ($truthy((this_line = ($truthy($b = reader.$skip_blank_lines()) ? reader.$read_line() : $b)))) {
              } else {
                break;
              };
              if ($truthy(self['$is_sibling_list_item?'](this_line, list_type, sibling_trait))) {
                break;};};
            if (this_line['$==']($$($nesting, 'LIST_CONTINUATION'))) {
              
              detached_continuation = buffer.$size();
              buffer['$<<'](this_line);
            } else if ($truthy(has_text)) {
              if ($truthy(self['$is_sibling_list_item?'](this_line, list_type, sibling_trait))) {
                break;
              } else if ($truthy((nested_list_type = $send($$($nesting, 'NESTABLE_LIST_CONTEXTS'), 'find', [], ($$31 = function(ctx){var self = $$31.$$s || this;

              
                
                if (ctx == null) {
                  ctx = nil;
                };
                return $$($nesting, 'ListRxMap')['$[]'](ctx)['$=~'](this_line);}, $$31.$$s = self, $$31.$$arity = 1, $$31))))) {
                
                buffer['$<<'](this_line);
                within_nested_list = true;
                if ($truthy((($b = nested_list_type['$==']("dlist")) ? (($c = $gvars['~']) === nil ? nil : $c['$[]'](3))['$nil_or_empty?']() : nested_list_type['$==']("dlist")))) {
                  has_text = false};
              } else if ($truthy($$($nesting, 'LiteralParagraphRx')['$match?'](this_line))) {
                
                reader.$unshift_line(this_line);
                if ($truthy(dlist)) {
                  buffer.$concat($send(reader, 'read_lines_until', [$hash2(["preserve_last_line", "break_on_blank_lines", "break_on_list_continuation"], {"preserve_last_line": true, "break_on_blank_lines": true, "break_on_list_continuation": true})], ($$32 = function(line){var self = $$32.$$s || this;

                  
                    
                    if (line == null) {
                      line = nil;
                    };
                    return self['$is_sibling_list_item?'](line, list_type, sibling_trait);}, $$32.$$s = self, $$32.$$arity = 1, $$32)))
                } else {
                  buffer.$concat(reader.$read_lines_until($hash2(["preserve_last_line", "break_on_blank_lines", "break_on_list_continuation"], {"preserve_last_line": true, "break_on_blank_lines": true, "break_on_list_continuation": true})))
                };
              } else {
                break;
              }
            } else {
              
              if ($truthy(within_nested_list)) {
              } else {
                buffer.$pop()
              };
              buffer['$<<'](this_line);
              has_text = true;
            };
          } else {
            
            if ($truthy(this_line['$empty?']())) {
            } else {
              has_text = true
            };
            if ($truthy((nested_list_type = $send((function() {if ($truthy(within_nested_list)) {
              return ["dlist"]
            } else {
              return $$($nesting, 'NESTABLE_LIST_CONTEXTS')
            }; return nil; })(), 'find', [], ($$33 = function(ctx){var self = $$33.$$s || this;

            
              
              if (ctx == null) {
                ctx = nil;
              };
              return $$($nesting, 'ListRxMap')['$[]'](ctx)['$=~'](this_line);}, $$33.$$s = self, $$33.$$arity = 1, $$33))))) {
              
              within_nested_list = true;
              if ($truthy((($b = nested_list_type['$==']("dlist")) ? (($c = $gvars['~']) === nil ? nil : $c['$[]'](3))['$nil_or_empty?']() : nested_list_type['$==']("dlist")))) {
                has_text = false};};
            buffer['$<<'](this_line);
          };
          this_line = nil;
        };
        if ($truthy(this_line)) {
          reader.$unshift_line(this_line)};
        if ($truthy(detached_continuation)) {
          
          $writer = [detached_continuation, ""];
          $send(buffer, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        while (!($truthy(buffer['$empty?']()))) {
          if ($truthy((last_line = buffer['$[]'](-1))['$empty?']())) {
            buffer.$pop()
          } else {
            
            if (last_line['$==']($$($nesting, 'LIST_CONTINUATION'))) {
              buffer.$pop()};
            break;;
          }
        };
        return buffer;
      }, $Parser_read_lines_for_list_item$28.$$arity = -3);
      Opal.defs(self, '$initialize_section', $Parser_initialize_section$34 = function $$initialize_section(reader, parent, attributes) {
        var $a, $b, self = this, document = nil, book = nil, doctype = nil, source_location = nil, sect_style = nil, sect_id = nil, sect_reftext = nil, sect_title = nil, sect_level = nil, sect_atx = nil, sect_name = nil, sect_special = nil, sect_numbered = nil, $writer = nil, section = nil, id = nil, generated_id = nil;

        
        
        if (attributes == null) {
          attributes = $hash2([], {});
        };
        document = parent.$document();
        book = (doctype = document.$doctype())['$==']("book");
        if ($truthy(document.$sourcemap())) {
          source_location = reader.$cursor()};
        sect_style = attributes['$[]'](1);
        $b = self.$parse_section_title(reader, document, attributes['$[]']("id")), $a = Opal.to_ary($b), (sect_id = ($a[0] == null ? nil : $a[0])), (sect_reftext = ($a[1] == null ? nil : $a[1])), (sect_title = ($a[2] == null ? nil : $a[2])), (sect_level = ($a[3] == null ? nil : $a[3])), (sect_atx = ($a[4] == null ? nil : $a[4])), $b;
        if ($truthy(sect_style)) {
          if ($truthy(($truthy($a = book) ? sect_style['$==']("abstract") : $a))) {
            $a = ["chapter", 1], (sect_name = $a[0]), (sect_level = $a[1]), $a
          } else if ($truthy(($truthy($a = sect_style['$start_with?']("sect")) ? $$($nesting, 'SectionLevelStyleRx')['$match?'](sect_style) : $a))) {
            sect_name = "section"
          } else {
            
            $a = [sect_style, true], (sect_name = $a[0]), (sect_special = $a[1]), $a;
            if (sect_level['$=='](0)) {
              sect_level = 1};
            sect_numbered = sect_name['$==']("appendix");
          }
        } else if ($truthy(book)) {
          sect_name = (function() {if (sect_level['$=='](0)) {
            return "part"
          } else {
            
            if ($truthy($rb_gt(sect_level, 1))) {
              return "section"
            } else {
              return "chapter"
            };
          }; return nil; })()
        } else if ($truthy((($a = doctype['$==']("manpage")) ? sect_title.$casecmp("synopsis")['$=='](0) : doctype['$==']("manpage")))) {
          $a = ["synopsis", true], (sect_name = $a[0]), (sect_special = $a[1]), $a
        } else {
          sect_name = "section"
        };
        if ($truthy(sect_reftext)) {
          
          $writer = ["reftext", sect_reftext];
          $send(attributes, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        section = $$($nesting, 'Section').$new(parent, sect_level);
        $a = [sect_id, sect_title, sect_name, source_location], section['$id=']($a[0]), section['$title=']($a[1]), section['$sectname=']($a[2]), section['$source_location=']($a[3]), $a;
        if ($truthy(sect_special)) {
          
          
          $writer = [true];
          $send(section, 'special=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          if ($truthy(sect_numbered)) {
            
            $writer = [true];
            $send(section, 'numbered=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          } else if (document.$attributes()['$[]']("sectnums")['$==']("all")) {
            
            $writer = [(function() {if ($truthy(($truthy($a = book) ? sect_level['$=='](1) : $a))) {
              return "chapter"
            } else {
              return true
            }; return nil; })()];
            $send(section, 'numbered=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
        } else if ($truthy(($truthy($a = document.$attributes()['$[]']("sectnums")) ? $rb_gt(sect_level, 0) : $a))) {
          
          $writer = [(function() {if ($truthy(section.$special())) {
            return ($truthy($a = parent.$numbered()) ? true : $a)
          } else {
            return true
          }; return nil; })()];
          $send(section, 'numbered=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        } else if ($truthy(($truthy($a = ($truthy($b = book) ? sect_level['$=='](0) : $b)) ? document.$attributes()['$[]']("partnums") : $a))) {
          
          $writer = [true];
          $send(section, 'numbered=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        if ($truthy((id = ($truthy($a = section.$id()) ? $a : (($writer = [(function() {if ($truthy(document.$attributes()['$key?']("sectids"))) {
          
          return (generated_id = $$($nesting, 'Section').$generate_id(section.$title(), document));
        } else {
          return nil
        }; return nil; })()]), $send(section, 'id=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))))) {
          
          if ($truthy(($truthy($a = generated_id) ? $a : sect_title['$include?']($$($nesting, 'ATTR_REF_HEAD'))['$!']()))) {
          } else {
            section.$title()
          };
          if ($truthy(document.$register("refs", [id, section]))) {
          } else {
            self.$logger().$warn(self.$message_with_context("" + "id assigned to section already in use: " + (id), $hash2(["source_location"], {"source_location": reader.$cursor_at_line($rb_minus(reader.$lineno(), (function() {if ($truthy(sect_atx)) {
              return 1
            } else {
              return 2
            }; return nil; })()))})))
          };};
        section.$update_attributes(attributes);
        reader.$skip_blank_lines();
        return section;
      }, $Parser_initialize_section$34.$$arity = -3);
      Opal.defs(self, '$is_next_line_section?', $Parser_is_next_line_section$ques$35 = function(reader, attributes) {
        var $a, $b, self = this, style = nil, next_lines = nil;

        
        if ($truthy(($truthy($a = (style = attributes['$[]'](1))) ? ($truthy($b = style['$==']("discrete")) ? $b : style['$==']("float")) : $a))) {
          return nil};
        if ($truthy($$($nesting, 'Compliance').$underline_style_section_titles())) {
          
          next_lines = reader.$peek_lines(2, ($truthy($a = style) ? style['$==']("comment") : $a));
          return self['$is_section_title?'](($truthy($a = next_lines['$[]'](0)) ? $a : ""), next_lines['$[]'](1));
        } else {
          return self['$atx_section_title?'](($truthy($a = reader.$peek_line()) ? $a : ""))
        };
      }, $Parser_is_next_line_section$ques$35.$$arity = 2);
      Opal.defs(self, '$is_next_line_doctitle?', $Parser_is_next_line_doctitle$ques$36 = function(reader, attributes, leveloffset) {
        var $a, self = this, sect_level = nil;

        if ($truthy(leveloffset)) {
          return ($truthy($a = (sect_level = self['$is_next_line_section?'](reader, attributes))) ? $rb_plus(sect_level, leveloffset.$to_i())['$=='](0) : $a)
        } else {
          return self['$is_next_line_section?'](reader, attributes)['$=='](0)
        }
      }, $Parser_is_next_line_doctitle$ques$36.$$arity = 3);
      Opal.defs(self, '$is_section_title?', $Parser_is_section_title$ques$37 = function(line1, line2) {
        var $a, self = this;

        
        
        if (line2 == null) {
          line2 = nil;
        };
        return ($truthy($a = self['$atx_section_title?'](line1)) ? $a : (function() {if ($truthy(line2['$nil_or_empty?']())) {
          return nil
        } else {
          return self['$setext_section_title?'](line1, line2)
        }; return nil; })());
      }, $Parser_is_section_title$ques$37.$$arity = -2);
      Opal.defs(self, '$atx_section_title?', $Parser_atx_section_title$ques$38 = function(line) {
        var $a, self = this;

        if ($truthy((function() {if ($truthy($$($nesting, 'Compliance').$markdown_syntax())) {
          
          return ($truthy($a = line['$start_with?']("=", "#")) ? $$($nesting, 'ExtAtxSectionTitleRx')['$=~'](line) : $a);
        } else {
          
          return ($truthy($a = line['$start_with?']("=")) ? $$($nesting, 'AtxSectionTitleRx')['$=~'](line) : $a);
        }; return nil; })())) {
          return $rb_minus((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)).$length(), 1)
        } else {
          return nil
        }
      }, $Parser_atx_section_title$ques$38.$$arity = 1);
      Opal.defs(self, '$setext_section_title?', $Parser_setext_section_title$ques$39 = function(line1, line2) {
        var $a, $b, $c, self = this, level = nil, line2_ch0 = nil, line2_len = nil;

        if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = (level = $$($nesting, 'SETEXT_SECTION_LEVELS')['$[]']((line2_ch0 = line2.$chr())))) ? self['$uniform?'](line2, line2_ch0, (line2_len = line2.$length())) : $c)) ? $$($nesting, 'SetextSectionTitleRx')['$match?'](line1) : $b)) ? $rb_lt($rb_minus(line1.$length(), line2_len).$abs(), 2) : $a))) {
          return level
        } else {
          return nil
        }
      }, $Parser_setext_section_title$ques$39.$$arity = 2);
      Opal.defs(self, '$parse_section_title', $Parser_parse_section_title$40 = function $$parse_section_title(reader, document, sect_id) {
        var $a, $b, $c, $d, $e, self = this, sect_reftext = nil, line1 = nil, sect_level = nil, sect_title = nil, atx = nil, line2 = nil, line2_ch0 = nil, line2_len = nil;

        
        
        if (sect_id == null) {
          sect_id = nil;
        };
        sect_reftext = nil;
        line1 = reader.$read_line();
        if ($truthy((function() {if ($truthy($$($nesting, 'Compliance').$markdown_syntax())) {
          
          return ($truthy($a = line1['$start_with?']("=", "#")) ? $$($nesting, 'ExtAtxSectionTitleRx')['$=~'](line1) : $a);
        } else {
          
          return ($truthy($a = line1['$start_with?']("=")) ? $$($nesting, 'AtxSectionTitleRx')['$=~'](line1) : $a);
        }; return nil; })())) {
          
          $a = [$rb_minus((($b = $gvars['~']) === nil ? nil : $b['$[]'](1)).$length(), 1), (($b = $gvars['~']) === nil ? nil : $b['$[]'](2)), true], (sect_level = $a[0]), (sect_title = $a[1]), (atx = $a[2]), $a;
          if ($truthy(sect_id)) {
          } else if ($truthy(($truthy($a = ($truthy($b = sect_title['$end_with?']("]]")) ? $$($nesting, 'InlineSectionAnchorRx')['$=~'](sect_title) : $b)) ? (($b = $gvars['~']) === nil ? nil : $b['$[]'](1))['$!']() : $a))) {
            $a = [sect_title.$slice(0, $rb_minus(sect_title.$length(), (($b = $gvars['~']) === nil ? nil : $b['$[]'](0)).$length())), (($b = $gvars['~']) === nil ? nil : $b['$[]'](2)), (($b = $gvars['~']) === nil ? nil : $b['$[]'](3))], (sect_title = $a[0]), (sect_id = $a[1]), (sect_reftext = $a[2]), $a};
        } else if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = ($truthy($d = ($truthy($e = $$($nesting, 'Compliance').$underline_style_section_titles()) ? (line2 = reader.$peek_line(true)) : $e)) ? (sect_level = $$($nesting, 'SETEXT_SECTION_LEVELS')['$[]']((line2_ch0 = line2.$chr()))) : $d)) ? self['$uniform?'](line2, line2_ch0, (line2_len = line2.$length())) : $c)) ? (sect_title = ($truthy($c = $$($nesting, 'SetextSectionTitleRx')['$=~'](line1)) ? (($d = $gvars['~']) === nil ? nil : $d['$[]'](1)) : $c)) : $b)) ? $rb_lt($rb_minus(line1.$length(), line2_len).$abs(), 2) : $a))) {
          
          atx = false;
          if ($truthy(sect_id)) {
          } else if ($truthy(($truthy($a = ($truthy($b = sect_title['$end_with?']("]]")) ? $$($nesting, 'InlineSectionAnchorRx')['$=~'](sect_title) : $b)) ? (($b = $gvars['~']) === nil ? nil : $b['$[]'](1))['$!']() : $a))) {
            $a = [sect_title.$slice(0, $rb_minus(sect_title.$length(), (($b = $gvars['~']) === nil ? nil : $b['$[]'](0)).$length())), (($b = $gvars['~']) === nil ? nil : $b['$[]'](2)), (($b = $gvars['~']) === nil ? nil : $b['$[]'](3))], (sect_title = $a[0]), (sect_id = $a[1]), (sect_reftext = $a[2]), $a};
          reader.$shift();
        } else {
          self.$raise("" + "Unrecognized section at " + (reader.$cursor_at_prev_line()))
        };
        if ($truthy(document['$attr?']("leveloffset"))) {
          
          sect_level = $rb_plus(sect_level, document.$attr("leveloffset").$to_i());
          if ($truthy($rb_lt(sect_level, 0))) {
            sect_level = 0};};
        return [sect_id, sect_reftext, sect_title, sect_level, atx];
      }, $Parser_parse_section_title$40.$$arity = -3);
      Opal.defs(self, '$parse_header_metadata', $Parser_parse_header_metadata$41 = function $$parse_header_metadata(reader, document, retrieve) {
        var $a, $$42, $$43, $$44, self = this, doc_attrs = nil, authorcount = nil, implicit_author_metadata = nil, $writer = nil, implicit_author = nil, implicit_authorinitials = nil, implicit_authors = nil, rev_line = nil, match = nil, rev_metadata = nil, component = nil, author_line = nil, author_metadata = nil, authors = nil, author_idx = nil, author_key = nil, explicit = nil, sparse = nil, author_override = nil;

        
        
        if (document == null) {
          document = nil;
        };
        
        if (retrieve == null) {
          retrieve = true;
        };
        doc_attrs = ($truthy($a = document) ? document.$attributes() : $a);
        self.$process_attribute_entries(reader, document);
        if ($truthy(($truthy($a = reader['$has_more_lines?']()) ? reader['$next_line_empty?']()['$!']() : $a))) {
          
          authorcount = (implicit_author_metadata = self.$process_authors(reader.$read_line())).$delete("authorcount");
          if ($truthy(($truthy($a = document) ? $rb_gt((($writer = ["authorcount", authorcount]), $send(doc_attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]), 0) : $a))) {
            
            $send(implicit_author_metadata, 'each', [], ($$42 = function(key, val){var self = $$42.$$s || this;

            
              
              if (key == null) {
                key = nil;
              };
              
              if (val == null) {
                val = nil;
              };
              if ($truthy(doc_attrs['$key?'](key))) {
                return nil
              } else {
                
                $writer = [key, document.$apply_header_subs(val)];
                $send(doc_attrs, '[]=', Opal.to_a($writer));
                return $writer[$rb_minus($writer["length"], 1)];
              };}, $$42.$$s = self, $$42.$$arity = 2, $$42));
            implicit_author = doc_attrs['$[]']("author");
            implicit_authorinitials = doc_attrs['$[]']("authorinitials");
            implicit_authors = doc_attrs['$[]']("authors");};
          
          $writer = ["authorcount", authorcount];
          $send(implicit_author_metadata, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          self.$process_attribute_entries(reader, document);
          if ($truthy(($truthy($a = reader['$has_more_lines?']()) ? reader['$next_line_empty?']()['$!']() : $a))) {
            
            rev_line = reader.$read_line();
            if ($truthy((match = $$($nesting, 'RevisionInfoLineRx').$match(rev_line)))) {
              
              rev_metadata = $hash2([], {});
              if ($truthy(match['$[]'](1))) {
                
                $writer = ["revnumber", match['$[]'](1).$rstrip()];
                $send(rev_metadata, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];};
              if ($truthy((component = match['$[]'](2).$strip())['$empty?']())) {
              } else if ($truthy(($truthy($a = match['$[]'](1)['$!']()) ? component['$start_with?']("v") : $a))) {
                
                $writer = ["revnumber", component.$slice(1, component.$length())];
                $send(rev_metadata, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
              } else {
                
                $writer = ["revdate", component];
                $send(rev_metadata, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
              };
              if ($truthy(match['$[]'](3))) {
                
                $writer = ["revremark", match['$[]'](3).$rstrip()];
                $send(rev_metadata, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];};
              if ($truthy(($truthy($a = document) ? rev_metadata['$empty?']()['$!']() : $a))) {
                $send(rev_metadata, 'each', [], ($$43 = function(key, val){var self = $$43.$$s || this;

                
                  
                  if (key == null) {
                    key = nil;
                  };
                  
                  if (val == null) {
                    val = nil;
                  };
                  if ($truthy(doc_attrs['$key?'](key))) {
                    return nil
                  } else {
                    
                    $writer = [key, document.$apply_header_subs(val)];
                    $send(doc_attrs, '[]=', Opal.to_a($writer));
                    return $writer[$rb_minus($writer["length"], 1)];
                  };}, $$43.$$s = self, $$43.$$arity = 2, $$43))};
            } else {
              reader.$unshift_line(rev_line)
            };};
          self.$process_attribute_entries(reader, document);
          reader.$skip_blank_lines();
        } else {
          implicit_author_metadata = $hash2([], {})
        };
        if ($truthy(document)) {
          
          if ($truthy(($truthy($a = doc_attrs['$key?']("author")) ? (author_line = doc_attrs['$[]']("author"))['$!='](implicit_author) : $a))) {
            
            author_metadata = self.$process_authors(author_line, true, false);
            if ($truthy(doc_attrs['$[]']("authorinitials")['$!='](implicit_authorinitials))) {
              author_metadata.$delete("authorinitials")};
          } else if ($truthy(($truthy($a = doc_attrs['$key?']("authors")) ? (author_line = doc_attrs['$[]']("authors"))['$!='](implicit_authors) : $a))) {
            author_metadata = self.$process_authors(author_line, true)
          } else {
            
            $a = [[], 1, "author_1", false, false], (authors = $a[0]), (author_idx = $a[1]), (author_key = $a[2]), (explicit = $a[3]), (sparse = $a[4]), $a;
            while ($truthy(doc_attrs['$key?'](author_key))) {
              
              if ((author_override = doc_attrs['$[]'](author_key))['$=='](implicit_author_metadata['$[]'](author_key))) {
                
                authors['$<<'](nil);
                sparse = true;
              } else {
                
                authors['$<<'](author_override);
                explicit = true;
              };
              author_key = "" + "author_" + ((author_idx = $rb_plus(author_idx, 1)));
            };
            if ($truthy(explicit)) {
              
              if ($truthy(sparse)) {
                $send(authors, 'each_with_index', [], ($$44 = function(author, idx){var self = $$44.$$s || this, $$45, name_idx = nil;

                
                  
                  if (author == null) {
                    author = nil;
                  };
                  
                  if (idx == null) {
                    idx = nil;
                  };
                  if ($truthy(author)) {
                    return nil;};
                  
                  $writer = [idx, $send([implicit_author_metadata['$[]']("" + "firstname_" + ((name_idx = $rb_plus(idx, 1)))), implicit_author_metadata['$[]']("" + "middlename_" + (name_idx)), implicit_author_metadata['$[]']("" + "lastname_" + (name_idx))].$compact(), 'map', [], ($$45 = function(it){var self = $$45.$$s || this;

                  
                    
                    if (it == null) {
                      it = nil;
                    };
                    return it.$tr(" ", "_");}, $$45.$$s = self, $$45.$$arity = 1, $$45)).$join(" ")];
                  $send(authors, '[]=', Opal.to_a($writer));
                  return $writer[$rb_minus($writer["length"], 1)];;}, $$44.$$s = self, $$44.$$arity = 2, $$44))};
              author_metadata = self.$process_authors(authors, true, false);
            } else {
              author_metadata = $hash2(["authorcount"], {"authorcount": 0})
            };
          };
          if (author_metadata['$[]']("authorcount")['$=='](0)) {
            if ($truthy(authorcount)) {
              author_metadata = nil
            } else {
              
              $writer = ["authorcount", 0];
              $send(doc_attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            }
          } else {
            
            doc_attrs.$update(author_metadata);
            if ($truthy(($truthy($a = doc_attrs['$key?']("email")['$!']()) ? doc_attrs['$key?']("email_1") : $a))) {
              
              $writer = ["email", doc_attrs['$[]']("email_1")];
              $send(doc_attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
          };};
        if ($truthy(retrieve)) {
          return implicit_author_metadata.$merge(rev_metadata.$to_h(), author_metadata.$to_h())
        } else {
          return nil
        };
      }, $Parser_parse_header_metadata$41.$$arity = -2);
      Opal.defs(self, '$process_authors', $Parser_process_authors$46 = function $$process_authors(author_line, names_only, multiple) {
        var $a, $$47, self = this, author_metadata = nil, author_idx = nil, $writer = nil;

        
        
        if (names_only == null) {
          names_only = false;
        };
        
        if (multiple == null) {
          multiple = true;
        };
        author_metadata = $hash2([], {});
        author_idx = 0;
        $send((function() {if ($truthy(($truthy($a = multiple) ? author_line['$include?'](";") : $a))) {
          
          return author_line.$split($$($nesting, 'AuthorDelimiterRx'));
        } else {
          return [].concat(Opal.to_a(author_line))
        }; return nil; })(), 'each', [], ($$47 = function(author_entry){var self = $$47.$$s || this, $$48, $$49, $b, $$50, key_map = nil, $writer = nil, segments = nil, match = nil, author = nil, fname = nil, mname = nil, lname = nil;

        
          
          if (author_entry == null) {
            author_entry = nil;
          };
          if ($truthy(author_entry['$empty?']())) {
            return nil;};
          key_map = $hash2([], {});
          if ((author_idx = $rb_plus(author_idx, 1))['$=='](1)) {
            $send($$($nesting, 'AuthorKeys'), 'each', [], ($$48 = function(key){var self = $$48.$$s || this, $writer = nil;

            
              
              if (key == null) {
                key = nil;
              };
              $writer = [key.$to_sym(), key];
              $send(key_map, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];}, $$48.$$s = self, $$48.$$arity = 1, $$48))
          } else {
            $send($$($nesting, 'AuthorKeys'), 'each', [], ($$49 = function(key){var self = $$49.$$s || this, $writer = nil;

            
              
              if (key == null) {
                key = nil;
              };
              $writer = [key.$to_sym(), "" + (key) + "_" + (author_idx)];
              $send(key_map, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];}, $$49.$$s = self, $$49.$$arity = 1, $$49))
          };
          if ($truthy(names_only)) {
            
            if ($truthy(author_entry['$include?']("<"))) {
              
              
              $writer = [key_map['$[]']("author"), author_entry.$tr("_", " ")];
              $send(author_metadata, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              author_entry = author_entry.$gsub($$($nesting, 'XmlSanitizeRx'), "");};
            if ((segments = author_entry.$split(nil, 3)).$size()['$=='](3)) {
              segments['$<<'](segments.$pop().$squeeze(" "))};
          } else if ($truthy((match = $$($nesting, 'AuthorInfoLineRx').$match(author_entry)))) {
            (segments = match.$to_a()).$shift()};
          if ($truthy(segments)) {
            
            author = (($writer = [key_map['$[]']("firstname"), (fname = segments['$[]'](0).$tr("_", " "))]), $send(author_metadata, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]);
            
            $writer = [key_map['$[]']("authorinitials"), fname.$chr()];
            $send(author_metadata, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            if ($truthy(segments['$[]'](1))) {
              if ($truthy(segments['$[]'](2))) {
                
                
                $writer = [key_map['$[]']("middlename"), (mname = segments['$[]'](1).$tr("_", " "))];
                $send(author_metadata, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
                
                $writer = [key_map['$[]']("lastname"), (lname = segments['$[]'](2).$tr("_", " "))];
                $send(author_metadata, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
                author = $rb_plus($rb_plus($rb_plus($rb_plus(fname, " "), mname), " "), lname);
                
                $writer = [key_map['$[]']("authorinitials"), "" + (fname.$chr()) + (mname.$chr()) + (lname.$chr())];
                $send(author_metadata, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
              } else {
                
                
                $writer = [key_map['$[]']("lastname"), (lname = segments['$[]'](1).$tr("_", " "))];
                $send(author_metadata, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
                author = $rb_plus($rb_plus(fname, " "), lname);
                
                $writer = [key_map['$[]']("authorinitials"), "" + (fname.$chr()) + (lname.$chr())];
                $send(author_metadata, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
              }};
            ($truthy($b = author_metadata['$[]'](key_map['$[]']("author"))) ? $b : (($writer = [key_map['$[]']("author"), author]), $send(author_metadata, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
            if ($truthy(($truthy($b = names_only) ? $b : segments['$[]'](3)['$!']()))) {
            } else {
              
              $writer = [key_map['$[]']("email"), segments['$[]'](3)];
              $send(author_metadata, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            };
          } else {
            
            
            $writer = [key_map['$[]']("author"), (($writer = [key_map['$[]']("firstname"), (fname = author_entry.$squeeze(" ").$strip())]), $send(author_metadata, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])];
            $send(author_metadata, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = [key_map['$[]']("authorinitials"), fname.$chr()];
            $send(author_metadata, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
          };
          if (author_idx['$=='](1)) {
            
            $writer = ["authors", author_metadata['$[]'](key_map['$[]']("author"))];
            $send(author_metadata, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          } else {
            
            if (author_idx['$=='](2)) {
              $send($$($nesting, 'AuthorKeys'), 'each', [], ($$50 = function(key){var self = $$50.$$s || this;

              
                
                if (key == null) {
                  key = nil;
                };
                if ($truthy(author_metadata['$key?'](key))) {
                  
                  $writer = ["" + (key) + "_1", author_metadata['$[]'](key)];
                  $send(author_metadata, '[]=', Opal.to_a($writer));
                  return $writer[$rb_minus($writer["length"], 1)];
                } else {
                  return nil
                };}, $$50.$$s = self, $$50.$$arity = 1, $$50))};
            
            $writer = ["authors", "" + (author_metadata['$[]']("authors")) + ", " + (author_metadata['$[]'](key_map['$[]']("author")))];
            $send(author_metadata, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];;
          };}, $$47.$$s = self, $$47.$$arity = 1, $$47));
        
        $writer = ["authorcount", author_idx];
        $send(author_metadata, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        return author_metadata;
      }, $Parser_process_authors$46.$$arity = -2);
      Opal.defs(self, '$parse_block_metadata_lines', $Parser_parse_block_metadata_lines$51 = function $$parse_block_metadata_lines(reader, document, attributes, options) {
        var $a, $b, self = this;

        
        
        if (attributes == null) {
          attributes = $hash2([], {});
        };
        
        if (options == null) {
          options = $hash2([], {});
        };
        while ($truthy(self.$parse_block_metadata_line(reader, document, attributes, options))) {
          
          reader.$shift();
          if ($truthy($b = reader.$skip_blank_lines())) {
            $b
          } else {
            break;
          };
        };
        return attributes;
      }, $Parser_parse_block_metadata_lines$51.$$arity = -3);
      Opal.defs(self, '$parse_block_metadata_line', $Parser_parse_block_metadata_line$52 = function $$parse_block_metadata_line(reader, document, attributes, options) {
        var $a, $b, self = this, next_line = nil, normal = nil, $writer = nil, reftext = nil, current_style = nil, ll = nil;
        if ($gvars["~"] == null) $gvars["~"] = nil;

        
        
        if (options == null) {
          options = $hash2([], {});
        };
        if ($truthy(($truthy($a = (next_line = reader.$peek_line())) ? (function() {if ($truthy(options['$[]']("text_only"))) {
          
          return next_line['$start_with?']("[", "/");
        } else {
          
          return (normal = next_line['$start_with?']("[", ".", "/", ":"));
        }; return nil; })() : $a))) {
          if ($truthy(next_line['$start_with?']("["))) {
            if ($truthy(next_line['$start_with?']("[["))) {
              if ($truthy(($truthy($a = next_line['$end_with?']("]]")) ? $$($nesting, 'BlockAnchorRx')['$=~'](next_line) : $a))) {
                
                
                $writer = ["id", (($a = $gvars['~']) === nil ? nil : $a['$[]'](1))];
                $send(attributes, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;
                if ($truthy((reftext = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2))))) {
                  
                  $writer = ["reftext", (function() {if ($truthy(reftext['$include?']($$($nesting, 'ATTR_REF_HEAD')))) {
                    
                    return document.$sub_attributes(reftext);
                  } else {
                    return reftext
                  }; return nil; })()];
                  $send(attributes, '[]=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];};
                return true;}
            } else if ($truthy(($truthy($a = next_line['$end_with?']("]")) ? $$($nesting, 'BlockAttributeListRx')['$=~'](next_line) : $a))) {
              
              current_style = attributes['$[]'](1);
              if ($truthy(document.$parse_attributes((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), [], $hash2(["sub_input", "sub_result", "into"], {"sub_input": true, "sub_result": true, "into": attributes}))['$[]'](1))) {
                
                $writer = [1, ($truthy($a = self.$parse_style_attribute(attributes, reader)) ? $a : current_style)];
                $send(attributes, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];};
              return true;}
          } else if ($truthy(($truthy($a = normal) ? next_line['$start_with?'](".") : $a))) {
            if ($truthy($$($nesting, 'BlockTitleRx')['$=~'](next_line))) {
              
              
              $writer = ["title", (($a = $gvars['~']) === nil ? nil : $a['$[]'](1))];
              $send(attributes, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              return true;}
          } else if ($truthy(($truthy($a = normal['$!']()) ? $a : next_line['$start_with?']("/")))) {
            if ($truthy(next_line['$start_with?']("//"))) {
              if (next_line['$==']("//")) {
                return true
              } else if ($truthy(($truthy($a = normal) ? self['$uniform?'](next_line, "/", (ll = next_line.$length())) : $a))) {
                if (ll['$=='](3)) {
                } else {
                  
                  reader.$read_lines_until($hash2(["terminator", "skip_first_line", "preserve_last_line", "skip_processing", "context"], {"terminator": next_line, "skip_first_line": true, "preserve_last_line": true, "skip_processing": true, "context": "comment"}));
                  return true;
                }
              } else if ($truthy(next_line['$start_with?']("///"))) {
              } else {
                return true
              }}
          } else if ($truthy(($truthy($a = ($truthy($b = normal) ? next_line['$start_with?'](":") : $b)) ? $$($nesting, 'AttributeEntryRx')['$=~'](next_line) : $a))) {
            
            self.$process_attribute_entry(reader, document, attributes, $gvars["~"]);
            return true;}};
        return nil;
      }, $Parser_parse_block_metadata_line$52.$$arity = -4);
      Opal.defs(self, '$process_attribute_entries', $Parser_process_attribute_entries$53 = function $$process_attribute_entries(reader, document, attributes) {
        var $a, self = this;

        
        
        if (attributes == null) {
          attributes = nil;
        };
        reader.$skip_comment_lines();
        while ($truthy(self.$process_attribute_entry(reader, document, attributes))) {
          
          reader.$shift();
          reader.$skip_comment_lines();
        };
      }, $Parser_process_attribute_entries$53.$$arity = -3);
      Opal.defs(self, '$process_attribute_entry', $Parser_process_attribute_entry$54 = function $$process_attribute_entry(reader, document, attributes, match) {
        var $a, $b, $c, self = this, value = nil, con = nil, next_line = nil, keep_open = nil;

        
        
        if (attributes == null) {
          attributes = nil;
        };
        
        if (match == null) {
          match = nil;
        };
        if ($truthy(($truthy($a = match) ? $a : (match = (function() {if ($truthy(reader['$has_more_lines?']())) {
          
          return $$($nesting, 'AttributeEntryRx').$match(reader.$peek_line());
        } else {
          return nil
        }; return nil; })())))) {
          
          if ($truthy((value = match['$[]'](2))['$nil_or_empty?']())) {
            value = ""
          } else if ($truthy(value['$end_with?']($$($nesting, 'LINE_CONTINUATION'), $$($nesting, 'LINE_CONTINUATION_LEGACY')))) {
            
            $a = [value.$slice($rb_minus(value.$length(), 2), 2), value.$slice(0, $rb_minus(value.$length(), 2)).$rstrip()], (con = $a[0]), (value = $a[1]), $a;
            while ($truthy(($truthy($b = reader.$advance()) ? (next_line = ($truthy($c = reader.$peek_line()) ? $c : ""))['$empty?']()['$!']() : $b))) {
              
              next_line = next_line.$lstrip();
              if ($truthy((keep_open = next_line['$end_with?'](con)))) {
                next_line = next_line.$slice(0, $rb_minus(next_line.$length(), 2)).$rstrip()};
              value = "" + (value) + ((function() {if ($truthy(value['$end_with?']($$($nesting, 'HARD_LINE_BREAK')))) {
                return $$($nesting, 'LF')
              } else {
                return " "
              }; return nil; })()) + (next_line);
              if ($truthy(keep_open)) {
              } else {
                break;
              };
            };};
          self.$store_attribute(match['$[]'](1), value, document, attributes);
          return true;
        } else {
          return nil
        };
      }, $Parser_process_attribute_entry$54.$$arity = -3);
      Opal.defs(self, '$store_attribute', $Parser_store_attribute$55 = function $$store_attribute(name, value, doc, attrs) {
        var $a, self = this, resolved_value = nil;

        
        
        if (doc == null) {
          doc = nil;
        };
        
        if (attrs == null) {
          attrs = nil;
        };
        if ($truthy(name['$end_with?']("!"))) {
          
          name = name.$chop();
          value = nil;
        } else if ($truthy(name['$start_with?']("!"))) {
          
          name = name.$slice(1, name.$length());
          value = nil;};
        if ((name = self.$sanitize_attribute_name(name))['$==']("numbered")) {
          name = "sectnums"
        } else if (name['$==']("hardbreaks")) {
          name = "hardbreaks-option"
        } else if (name['$==']("showtitle")) {
          self.$store_attribute("notitle", (function() {if ($truthy(value)) {
            return nil
          } else {
            return ""
          }; return nil; })(), doc, attrs)};
        if ($truthy(doc)) {
          if ($truthy(value)) {
            
            if (name['$==']("leveloffset")) {
              if ($truthy(value['$start_with?']("+"))) {
                value = $rb_plus(doc.$attr("leveloffset", 0).$to_i(), value.$slice(1, value.$length()).$to_i()).$to_s()
              } else if ($truthy(value['$start_with?']("-"))) {
                value = $rb_minus(doc.$attr("leveloffset", 0).$to_i(), value.$slice(1, value.$length()).$to_i()).$to_s()}};
            if ($truthy((resolved_value = doc.$set_attribute(name, value)))) {
              
              value = resolved_value;
              if ($truthy(attrs)) {
                $$$($$($nesting, 'Document'), 'AttributeEntry').$new(name, value).$save_to(attrs)};};
          } else if ($truthy(($truthy($a = doc.$delete_attribute(name)) ? attrs : $a))) {
            $$$($$($nesting, 'Document'), 'AttributeEntry').$new(name, value).$save_to(attrs)}
        } else if ($truthy(attrs)) {
          $$$($$($nesting, 'Document'), 'AttributeEntry').$new(name, value).$save_to(attrs)};
        return [name, value];
      }, $Parser_store_attribute$55.$$arity = -3);
      Opal.defs(self, '$resolve_list_marker', $Parser_resolve_list_marker$56 = function $$resolve_list_marker(list_type, marker, ordinal, validate, reader) {
        var self = this, $case = nil;

        
        
        if (ordinal == null) {
          ordinal = 0;
        };
        
        if (validate == null) {
          validate = false;
        };
        
        if (reader == null) {
          reader = nil;
        };
        return (function() {$case = list_type;
        if ("ulist"['$===']($case)) {return marker}
        else if ("olist"['$===']($case)) {return self.$resolve_ordered_list_marker(marker, ordinal, validate, reader)['$[]'](0)}
        else {return "<1>"}})();
      }, $Parser_resolve_list_marker$56.$$arity = -3);
      Opal.defs(self, '$resolve_ordered_list_marker', $Parser_resolve_ordered_list_marker$57 = function $$resolve_ordered_list_marker(marker, ordinal, validate, reader) {
        var $$58, $a, self = this, $case = nil, style = nil, expected = nil, actual = nil;

        
        
        if (ordinal == null) {
          ordinal = 0;
        };
        
        if (validate == null) {
          validate = false;
        };
        
        if (reader == null) {
          reader = nil;
        };
        if ($truthy(marker['$start_with?']("."))) {
          return [marker]};
        $case = (style = $send($$($nesting, 'ORDERED_LIST_STYLES'), 'find', [], ($$58 = function(s){var self = $$58.$$s || this;

        
          
          if (s == null) {
            s = nil;
          };
          return $$($nesting, 'OrderedListMarkerRxMap')['$[]'](s)['$match?'](marker);}, $$58.$$s = self, $$58.$$arity = 1, $$58)));
        if ("arabic"['$===']($case)) {
        if ($truthy(validate)) {
          
          expected = $rb_plus(ordinal, 1);
          actual = marker.$to_i();};
        marker = "1.";}
        else if ("loweralpha"['$===']($case)) {
        if ($truthy(validate)) {
          
          expected = $rb_plus("a"['$[]'](0).$ord(), ordinal).$chr();
          actual = marker.$chop();};
        marker = "a.";}
        else if ("upperalpha"['$===']($case)) {
        if ($truthy(validate)) {
          
          expected = $rb_plus("A"['$[]'](0).$ord(), ordinal).$chr();
          actual = marker.$chop();};
        marker = "A.";}
        else if ("lowerroman"['$===']($case)) {
        if ($truthy(validate)) {
          
          expected = $$($nesting, 'Helpers').$int_to_roman($rb_plus(ordinal, 1)).$downcase();
          actual = marker.$chop();};
        marker = "i)";}
        else if ("upperroman"['$===']($case)) {
        if ($truthy(validate)) {
          
          expected = $$($nesting, 'Helpers').$int_to_roman($rb_plus(ordinal, 1));
          actual = marker.$chop();};
        marker = "I)";};
        if ($truthy(($truthy($a = validate) ? expected['$!='](actual) : $a))) {
          self.$logger().$warn(self.$message_with_context("" + "list item index: expected " + (expected) + ", got " + (actual), $hash2(["source_location"], {"source_location": reader.$cursor()})))};
        return [marker, style];
      }, $Parser_resolve_ordered_list_marker$57.$$arity = -2);
      Opal.defs(self, '$is_sibling_list_item?', $Parser_is_sibling_list_item$ques$59 = function(line, list_type, sibling_trait) {
        var $a, $b, self = this;

        if ($truthy($$$('::', 'Regexp')['$==='](sibling_trait))) {
          return sibling_trait['$match?'](line)
        } else {
          return ($truthy($a = $$($nesting, 'ListRxMap')['$[]'](list_type)['$=~'](line)) ? sibling_trait['$=='](self.$resolve_list_marker(list_type, (($b = $gvars['~']) === nil ? nil : $b['$[]'](1)))) : $a)
        }
      }, $Parser_is_sibling_list_item$ques$59.$$arity = 3);
      Opal.defs(self, '$parse_table', $Parser_parse_table$60 = function $$parse_table(table_reader, parent, attributes) {
        var $a, $b, $c, $d, self = this, table = nil, colspecs = nil, explicit_colspecs = nil, skipped = nil, $writer = nil, implicit_header = nil, parser_ctx = nil, format = nil, loop_idx = nil, implicit_header_boundary = nil, line = nil, beyond_first = nil, next_cellspec = nil, m = nil, pre_match = nil, post_match = nil, $case = nil, cell_text = nil, $logical_op_recvr_tmp_2 = nil;

        
        table = $$($nesting, 'Table').$new(parent, attributes);
        if ($truthy(($truthy($a = attributes['$key?']("cols")) ? (colspecs = self.$parse_colspecs(attributes['$[]']("cols")))['$empty?']()['$!']() : $a))) {
          
          table.$create_columns(colspecs);
          explicit_colspecs = true;};
        skipped = ($truthy($a = table_reader.$skip_blank_lines()) ? $a : 0);
        if ($truthy(attributes['$[]']("header-option"))) {
          
          $writer = [true];
          $send(table, 'has_header_option=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        } else if ($truthy((($a = skipped['$=='](0)) ? attributes['$[]']("noheader-option")['$!']() : skipped['$=='](0)))) {
          
          
          $writer = ["implicit"];
          $send(table, 'has_header_option=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          implicit_header = true;};
        parser_ctx = $$$($$($nesting, 'Table'), 'ParserContext').$new(table_reader, table, attributes);
        $a = [parser_ctx.$format(), -1, nil], (format = $a[0]), (loop_idx = $a[1]), (implicit_header_boundary = $a[2]), $a;
        $a = false; while ($a || $truthy((line = table_reader.$read_line()))) {$a = false;
          
          if ($truthy(($truthy($b = (beyond_first = $rb_gt((loop_idx = $rb_plus(loop_idx, 1)), 0))) ? line['$empty?']() : $b))) {
            
            line = nil;
            if ($truthy(implicit_header_boundary)) {
              implicit_header_boundary = $rb_plus(implicit_header_boundary, 1)};
          } else if (format['$==']("psv")) {
            if ($truthy(parser_ctx['$starts_with_delimiter?'](line))) {
              
              line = line.$slice(1, line.$length());
              parser_ctx.$close_open_cell();
              if ($truthy(implicit_header_boundary)) {
                implicit_header_boundary = nil};
            } else {
              
              $c = self.$parse_cellspec(line, "start", parser_ctx.$delimiter()), $b = Opal.to_ary($c), (next_cellspec = ($b[0] == null ? nil : $b[0])), (line = ($b[1] == null ? nil : $b[1])), $c;
              if ($truthy(next_cellspec)) {
                
                parser_ctx.$close_open_cell(next_cellspec);
                if ($truthy(implicit_header_boundary)) {
                  implicit_header_boundary = nil};
              } else if ($truthy(($truthy($b = implicit_header_boundary) ? implicit_header_boundary['$=='](loop_idx) : $b))) {
                
                $writer = [(implicit_header = (implicit_header_boundary = nil))];
                $send(table, 'has_header_option=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];};
            }};
          if ($truthy(beyond_first)) {
          } else {
            
            table_reader.$mark();
            if ($truthy(implicit_header)) {
              if ($truthy(($truthy($b = table_reader['$has_more_lines?']()) ? table_reader.$peek_line()['$empty?']() : $b))) {
                implicit_header_boundary = 1
              } else {
                
                $writer = [(implicit_header = nil)];
                $send(table, 'has_header_option=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
              }};
          };
          $b = false; while ($b || $truthy(true)) {$b = false;
            if ($truthy(($truthy($c = line) ? (m = parser_ctx.$match_delimiter(line)) : $c))) {
              
              $c = [m.$pre_match(), m.$post_match()], (pre_match = $c[0]), (post_match = $c[1]), $c;
              $case = format;
              if ("csv"['$===']($case)) {
              if ($truthy(parser_ctx['$buffer_has_unclosed_quotes?'](pre_match))) {
                
                parser_ctx.$skip_past_delimiter(pre_match);
                if ($truthy((line = post_match)['$empty?']())) {
                  break;};
                $b = true; continue;;};
              
              $writer = ["" + (parser_ctx.$buffer()) + (pre_match)];
              $send(parser_ctx, 'buffer=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;}
              else if ("dsv"['$===']($case)) {
              if ($truthy(pre_match['$end_with?']("\\"))) {
                
                parser_ctx.$skip_past_escaped_delimiter(pre_match);
                if ($truthy((line = post_match)['$empty?']())) {
                  
                  
                  $writer = ["" + (parser_ctx.$buffer()) + ($$($nesting, 'LF'))];
                  $send(parser_ctx, 'buffer=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];;
                  parser_ctx.$keep_cell_open();
                  break;;};
                $b = true; continue;;};
              
              $writer = ["" + (parser_ctx.$buffer()) + (pre_match)];
              $send(parser_ctx, 'buffer=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;}
              else {
              if ($truthy(pre_match['$end_with?']("\\"))) {
                
                parser_ctx.$skip_past_escaped_delimiter(pre_match);
                if ($truthy((line = post_match)['$empty?']())) {
                  
                  
                  $writer = ["" + (parser_ctx.$buffer()) + ($$($nesting, 'LF'))];
                  $send(parser_ctx, 'buffer=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];;
                  parser_ctx.$keep_cell_open();
                  break;;};
                $b = true; continue;;};
              $d = self.$parse_cellspec(pre_match), $c = Opal.to_ary($d), (next_cellspec = ($c[0] == null ? nil : $c[0])), (cell_text = ($c[1] == null ? nil : $c[1])), $d;
              parser_ctx.$push_cellspec(next_cellspec);
              
              $writer = ["" + (parser_ctx.$buffer()) + (cell_text)];
              $send(parser_ctx, 'buffer=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;};
              if ($truthy((line = post_match)['$empty?']())) {
                line = nil};
              parser_ctx.$close_cell();
            } else {
              
              
              $writer = ["" + (parser_ctx.$buffer()) + (line) + ($$($nesting, 'LF'))];
              $send(parser_ctx, 'buffer=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              $case = format;
              if ("csv"['$===']($case)) {if ($truthy(parser_ctx['$buffer_has_unclosed_quotes?']())) {
                
                if ($truthy(($truthy($c = implicit_header_boundary) ? loop_idx['$=='](0) : $c))) {
                  
                  $writer = [(implicit_header = (implicit_header_boundary = nil))];
                  $send(table, 'has_header_option=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];};
                parser_ctx.$keep_cell_open();
              } else {
                parser_ctx.$close_cell(true)
              }}
              else if ("dsv"['$===']($case)) {parser_ctx.$close_cell(true)}
              else {parser_ctx.$keep_cell_open()};
              break;;
            }
          };
          if ($truthy(parser_ctx['$cell_open?']())) {
            if ($truthy(table_reader['$has_more_lines?']())) {
            } else {
              parser_ctx.$close_cell(true)
            }
          } else {
            if ($truthy($b = table_reader.$skip_blank_lines())) {
              $b
            } else {
              break;
            }
          };
        };
        if ($truthy(($truthy($a = (($logical_op_recvr_tmp_2 = table.$attributes()), ($truthy($b = $logical_op_recvr_tmp_2['$[]']("colcount")) ? $b : (($writer = ["colcount", table.$columns().$size()]), $send($logical_op_recvr_tmp_2, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])))['$=='](0)) ? $a : explicit_colspecs))) {
        } else {
          table.$assign_column_widths()
        };
        if ($truthy(implicit_header)) {
          
          $writer = [true];
          $send(table, 'has_header_option=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        table.$partition_header_footer(attributes);
        return table;
      }, $Parser_parse_table$60.$$arity = 3);
      Opal.defs(self, '$parse_colspecs', $Parser_parse_colspecs$61 = function $$parse_colspecs(records) {
        var $$62, $$63, self = this, specs = nil;

        
        if ($truthy(records['$include?'](" "))) {
          records = records.$delete(" ")};
        if (records['$=='](records.$to_i().$to_s())) {
          return $send($$$('::', 'Array'), 'new', [records.$to_i()], ($$62 = function(){var self = $$62.$$s || this;

          return $hash2(["width"], {"width": 1})}, $$62.$$s = self, $$62.$$arity = 0, $$62))};
        specs = [];
        $send((function() {if ($truthy(records['$include?'](","))) {
          
          return records.$split(",", -1);
        } else {
          
          return records.$split(";", -1);
        }; return nil; })(), 'each', [], ($$63 = function(record){var self = $$63.$$s || this, $a, $b, $$64, m = nil, spec = nil, colspec = nil, rowspec = nil, $writer = nil, width = nil;

        
          
          if (record == null) {
            record = nil;
          };
          if ($truthy(record['$empty?']())) {
            return specs['$<<']($hash2(["width"], {"width": 1}))
          } else if ($truthy((m = $$($nesting, 'ColumnSpecRx').$match(record)))) {
            
            spec = $hash2([], {});
            if ($truthy(m['$[]'](2))) {
              
              $b = m['$[]'](2).$split("."), $a = Opal.to_ary($b), (colspec = ($a[0] == null ? nil : $a[0])), (rowspec = ($a[1] == null ? nil : $a[1])), $b;
              if ($truthy(($truthy($a = colspec['$nil_or_empty?']()['$!']()) ? $$($nesting, 'TableCellHorzAlignments')['$key?'](colspec) : $a))) {
                
                $writer = ["halign", $$($nesting, 'TableCellHorzAlignments')['$[]'](colspec)];
                $send(spec, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];};
              if ($truthy(($truthy($a = rowspec['$nil_or_empty?']()['$!']()) ? $$($nesting, 'TableCellVertAlignments')['$key?'](rowspec) : $a))) {
                
                $writer = ["valign", $$($nesting, 'TableCellVertAlignments')['$[]'](rowspec)];
                $send(spec, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];};};
            if ($truthy((width = m['$[]'](3)))) {
              
              $writer = ["width", (function() {if (width['$==']("~")) {
                return -1
              } else {
                return width.$to_i()
              }; return nil; })()];
              $send(spec, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            } else {
              
              $writer = ["width", 1];
              $send(spec, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            };
            if ($truthy(($truthy($a = m['$[]'](4)) ? $$($nesting, 'TableCellStyles')['$key?'](m['$[]'](4)) : $a))) {
              
              $writer = ["style", $$($nesting, 'TableCellStyles')['$[]'](m['$[]'](4))];
              $send(spec, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            if ($truthy(m['$[]'](1))) {
              return $send((1), 'upto', [m['$[]'](1).$to_i()], ($$64 = function(){var self = $$64.$$s || this;

              return specs['$<<'](spec.$merge())}, $$64.$$s = self, $$64.$$arity = 0, $$64))
            } else {
              return specs['$<<'](spec)
            };
          } else {
            return nil
          };}, $$63.$$s = self, $$63.$$arity = 1, $$63));
        return specs;
      }, $Parser_parse_colspecs$61.$$arity = 1);
      Opal.defs(self, '$parse_cellspec', $Parser_parse_cellspec$65 = function $$parse_cellspec(line, pos, delimiter) {
        var $a, $b, self = this, m = nil, rest = nil, spec_part = nil, _ = nil, spec = nil, colspec = nil, rowspec = nil, $case = nil, $writer = nil;

        
        
        if (pos == null) {
          pos = "end";
        };
        
        if (delimiter == null) {
          delimiter = nil;
        };
        $a = [nil, ""], (m = $a[0]), (rest = $a[1]), $a;
        if (pos['$==']("start")) {
          if ($truthy(line['$include?'](delimiter))) {
            
            $b = line.$partition(delimiter), $a = Opal.to_ary($b), (spec_part = ($a[0] == null ? nil : $a[0])), (_ = ($a[1] == null ? nil : $a[1])), (rest = ($a[2] == null ? nil : $a[2])), $b;
            if ($truthy((m = $$($nesting, 'CellSpecStartRx').$match(spec_part)))) {
              if ($truthy(m['$[]'](0)['$empty?']())) {
                return [$hash2([], {}), rest]}
            } else {
              return [nil, line]
            };
          } else {
            return [nil, line]
          }
        } else if ($truthy((m = $$($nesting, 'CellSpecEndRx').$match(line)))) {
          
          if ($truthy(m['$[]'](0).$lstrip()['$empty?']())) {
            return [$hash2([], {}), line.$rstrip()]};
          rest = m.$pre_match();
        } else {
          return [$hash2([], {}), line]
        };
        spec = $hash2([], {});
        if ($truthy(m['$[]'](1))) {
          
          $b = m['$[]'](1).$split("."), $a = Opal.to_ary($b), (colspec = ($a[0] == null ? nil : $a[0])), (rowspec = ($a[1] == null ? nil : $a[1])), $b;
          colspec = (function() {if ($truthy(colspec['$nil_or_empty?']())) {
            return 1
          } else {
            return colspec.$to_i()
          }; return nil; })();
          rowspec = (function() {if ($truthy(rowspec['$nil_or_empty?']())) {
            return 1
          } else {
            return rowspec.$to_i()
          }; return nil; })();
          $case = m['$[]'](2);
          if ("+"['$===']($case)) {
          if (colspec['$=='](1)) {
          } else {
            
            $writer = ["colspan", colspec];
            $send(spec, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          };
          if (rowspec['$=='](1)) {
          } else {
            
            $writer = ["rowspan", rowspec];
            $send(spec, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          };}
          else if ("*"['$===']($case)) {if (colspec['$=='](1)) {
          } else {
            
            $writer = ["repeatcol", colspec];
            $send(spec, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          }};};
        if ($truthy(m['$[]'](3))) {
          
          $b = m['$[]'](3).$split("."), $a = Opal.to_ary($b), (colspec = ($a[0] == null ? nil : $a[0])), (rowspec = ($a[1] == null ? nil : $a[1])), $b;
          if ($truthy(($truthy($a = colspec['$nil_or_empty?']()['$!']()) ? $$($nesting, 'TableCellHorzAlignments')['$key?'](colspec) : $a))) {
            
            $writer = ["halign", $$($nesting, 'TableCellHorzAlignments')['$[]'](colspec)];
            $send(spec, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          if ($truthy(($truthy($a = rowspec['$nil_or_empty?']()['$!']()) ? $$($nesting, 'TableCellVertAlignments')['$key?'](rowspec) : $a))) {
            
            $writer = ["valign", $$($nesting, 'TableCellVertAlignments')['$[]'](rowspec)];
            $send(spec, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};};
        if ($truthy(($truthy($a = m['$[]'](4)) ? $$($nesting, 'TableCellStyles')['$key?'](m['$[]'](4)) : $a))) {
          
          $writer = ["style", $$($nesting, 'TableCellStyles')['$[]'](m['$[]'](4))];
          $send(spec, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        return [spec, rest];
      }, $Parser_parse_cellspec$65.$$arity = -2);
      Opal.defs(self, '$parse_style_attribute', $Parser_parse_style_attribute$66 = function $$parse_style_attribute(attributes, reader) {
        var $a, $b, $$67, $$68, self = this, raw_style = nil, name = nil, accum = nil, parsed_attrs = nil, parsed_style = nil, $writer = nil, existing_role = nil;

        
        
        if (reader == null) {
          reader = nil;
        };
        if ($truthy(($truthy($a = ($truthy($b = (raw_style = attributes['$[]'](1))) ? raw_style['$include?'](" ")['$!']() : $b)) ? $$($nesting, 'Compliance').$shorthand_property_syntax() : $a))) {
          
          name = nil;
          accum = "";
          parsed_attrs = $hash2([], {});
          $send(raw_style, 'each_char', [], ($$67 = function(c){var self = $$67.$$s || this, $case = nil;

          
            
            if (c == null) {
              c = nil;
            };
            return (function() {$case = c;
            if ("."['$===']($case)) {
            self.$yield_buffered_attribute(parsed_attrs, name, accum, reader);
            accum = "";
            return (name = "role");}
            else if ("#"['$===']($case)) {
            self.$yield_buffered_attribute(parsed_attrs, name, accum, reader);
            accum = "";
            return (name = "id");}
            else if ("%"['$===']($case)) {
            self.$yield_buffered_attribute(parsed_attrs, name, accum, reader);
            accum = "";
            return (name = "option");}
            else {return (accum = $rb_plus(accum, c))}})();}, $$67.$$s = self, $$67.$$arity = 1, $$67));
          if ($truthy(name)) {
            
            self.$yield_buffered_attribute(parsed_attrs, name, accum, reader);
            if ($truthy((parsed_style = parsed_attrs['$[]']("style")))) {
              
              $writer = ["style", parsed_style];
              $send(attributes, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            if ($truthy(parsed_attrs['$key?']("id"))) {
              
              $writer = ["id", parsed_attrs['$[]']("id")];
              $send(attributes, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            if ($truthy(parsed_attrs['$key?']("role"))) {
              
              $writer = ["role", (function() {if ($truthy((existing_role = attributes['$[]']("role"))['$nil_or_empty?']())) {
                
                return parsed_attrs['$[]']("role").$join(" ");
              } else {
                return "" + (existing_role) + " " + (parsed_attrs['$[]']("role").$join(" "))
              }; return nil; })()];
              $send(attributes, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            if ($truthy(parsed_attrs['$key?']("option"))) {
              $send(parsed_attrs['$[]']("option"), 'each', [], ($$68 = function(opt){var self = $$68.$$s || this;

              
                
                if (opt == null) {
                  opt = nil;
                };
                $writer = ["" + (opt) + "-option", ""];
                $send(attributes, '[]=', Opal.to_a($writer));
                return $writer[$rb_minus($writer["length"], 1)];}, $$68.$$s = self, $$68.$$arity = 1, $$68))};
            return parsed_style;
          } else {
            
            $writer = ["style", raw_style];
            $send(attributes, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          };
        } else {
          
          $writer = ["style", raw_style];
          $send(attributes, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        };
      }, $Parser_parse_style_attribute$66.$$arity = -2);
      Opal.defs(self, '$yield_buffered_attribute', $Parser_yield_buffered_attribute$69 = function $$yield_buffered_attribute(attrs, name, value, reader) {
        var $a, self = this, $writer = nil;

        
        if ($truthy(name)) {
          if ($truthy(value['$empty?']())) {
            if ($truthy(reader)) {
              self.$logger().$warn(self.$message_with_context("" + "invalid empty " + (name) + " detected in style attribute", $hash2(["source_location"], {"source_location": reader.$cursor_at_prev_line()})))
            } else {
              self.$logger().$warn("" + "invalid empty " + (name) + " detected in style attribute")
            }
          } else if (name['$==']("id")) {
            
            if ($truthy(attrs['$key?']("id"))) {
              if ($truthy(reader)) {
                self.$logger().$warn(self.$message_with_context("multiple ids detected in style attribute", $hash2(["source_location"], {"source_location": reader.$cursor_at_prev_line()})))
              } else {
                self.$logger().$warn("multiple ids detected in style attribute")
              }};
            
            $writer = [name, value];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
          } else {
            ($truthy($a = attrs['$[]'](name)) ? $a : (($writer = [name, []]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))['$<<'](value)
          }
        } else if ($truthy(value['$empty?']())) {
        } else {
          
          $writer = ["style", value];
          $send(attrs, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        };
        return nil;
      }, $Parser_yield_buffered_attribute$69.$$arity = 4);
      Opal.defs(self, '$adjust_indentation!', $Parser_adjust_indentation$excl$70 = function(lines, indent_size, tab_size) {
        var $a, $$71, $$72, $$75, $$76, $$77, $$78, self = this, full_tab_space = nil, block_indent = nil, new_block_indent = nil;

        
        
        if (indent_size == null) {
          indent_size = 0;
        };
        
        if (tab_size == null) {
          tab_size = 0;
        };
        if ($truthy(lines['$empty?']())) {
          return nil};
        if ($truthy(($truthy($a = $rb_gt(tab_size, 0)) ? $send(lines, 'any?', [], ($$71 = function(line){var self = $$71.$$s || this;

        
          
          if (line == null) {
            line = nil;
          };
          return line['$include?']($$($nesting, 'TAB'));}, $$71.$$s = self, $$71.$$arity = 1, $$71)) : $a))) {
          
          full_tab_space = $rb_times(" ", tab_size);
          (function(){var $brk = Opal.new_brk(); try {return $send(lines, 'map!', [], ($$72 = function(line){var self = $$72.$$s || this, $b, $$73, $$74, tab_idx = nil, leading_tabs = nil, spaces_added = nil, idx = nil, result = nil;

          
            
            if (line == null) {
              line = nil;
            };
            if ($truthy(($truthy($b = line['$empty?']()) ? $b : (tab_idx = line.$index($$($nesting, 'TAB')))['$nil?']()))) {
              return line
            } else {
              
              if (tab_idx['$=='](0)) {
                
                leading_tabs = 0;
                (function(){var $brk = Opal.new_brk(); try {return $send(line, 'each_byte', [], ($$73 = function(b){var self = $$73.$$s || this;

                
                  
                  if (b == null) {
                    b = nil;
                  };
                  if (b['$=='](9)) {
                  } else {
                    
                    Opal.brk(nil, $brk)
                  };
                  return (leading_tabs = $rb_plus(leading_tabs, 1));}, $$73.$$s = self, $$73.$$brk = $brk, $$73.$$arity = 1, $$73))
                } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
                line = "" + ($rb_times(full_tab_space, leading_tabs)) + (line.$slice(leading_tabs, line.$length()));
                if ($truthy(line['$include?']($$($nesting, 'TAB')))) {
                } else {
                  return line;
                };};
              spaces_added = 0;
              idx = 0;
              result = "";
              $send(line, 'each_char', [], ($$74 = function(c){var self = $$74.$$s || this, offset = nil, spaces = nil;

              
                
                if (c == null) {
                  c = nil;
                };
                if (c['$==']($$($nesting, 'TAB'))) {
                  if ((offset = $rb_plus(idx, spaces_added))['$%'](tab_size)['$=='](0)) {
                    
                    spaces_added = $rb_plus(spaces_added, $rb_minus(tab_size, 1));
                    result = $rb_plus(result, full_tab_space);
                  } else {
                    
                    if ((spaces = $rb_minus(tab_size, offset['$%'](tab_size)))['$=='](1)) {
                    } else {
                      spaces_added = $rb_plus(spaces_added, $rb_minus(spaces, 1))
                    };
                    result = $rb_plus(result, $rb_times(" ", spaces));
                  }
                } else {
                  result = $rb_plus(result, c)
                };
                return (idx = $rb_plus(idx, 1));}, $$74.$$s = self, $$74.$$arity = 1, $$74));
              return result;
            };}, $$72.$$s = self, $$72.$$brk = $brk, $$72.$$arity = 1, $$72))
          } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();};
        if ($truthy($rb_lt(indent_size, 0))) {
          return nil};
        block_indent = nil;
        (function(){var $brk = Opal.new_brk(); try {return $send(lines, 'each', [], ($$75 = function(line){var self = $$75.$$s || this, $b, line_indent = nil;

        
          
          if (line == null) {
            line = nil;
          };
          if ($truthy(line['$empty?']())) {
            return nil;};
          if ((line_indent = $rb_minus(line.$length(), line.$lstrip().$length()))['$=='](0)) {
            
            block_indent = nil;
            
            Opal.brk(nil, $brk);};
          if ($truthy(($truthy($b = block_indent) ? $rb_lt(block_indent, line_indent) : $b))) {
            return nil
          } else {
            return (block_indent = line_indent)
          };}, $$75.$$s = self, $$75.$$brk = $brk, $$75.$$arity = 1, $$75))
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
        if (indent_size['$=='](0)) {
          if ($truthy(block_indent)) {
            $send(lines, 'map!', [], ($$76 = function(line){var self = $$76.$$s || this;

            
              
              if (line == null) {
                line = nil;
              };
              if ($truthy(line['$empty?']())) {
                return line
              } else {
                
                return line.$slice(block_indent, line.$length());
              };}, $$76.$$s = self, $$76.$$arity = 1, $$76))}
        } else {
          
          new_block_indent = $rb_times(" ", indent_size);
          if ($truthy(block_indent)) {
            $send(lines, 'map!', [], ($$77 = function(line){var self = $$77.$$s || this;

            
              
              if (line == null) {
                line = nil;
              };
              if ($truthy(line['$empty?']())) {
                return line
              } else {
                return $rb_plus(new_block_indent, line.$slice(block_indent, line.$length()))
              };}, $$77.$$s = self, $$77.$$arity = 1, $$77))
          } else {
            $send(lines, 'map!', [], ($$78 = function(line){var self = $$78.$$s || this;

            
              
              if (line == null) {
                line = nil;
              };
              if ($truthy(line['$empty?']())) {
                return line
              } else {
                return $rb_plus(new_block_indent, line)
              };}, $$78.$$s = self, $$78.$$arity = 1, $$78))
          };
        };
        return nil;
      }, $Parser_adjust_indentation$excl$70.$$arity = -2);
      Opal.defs(self, '$uniform?', $Parser_uniform$ques$79 = function(str, chr, len) {
        var self = this;

        return str.$count(chr)['$=='](len)
      }, $Parser_uniform$ques$79.$$arity = 3);
      return (Opal.defs(self, '$sanitize_attribute_name', $Parser_sanitize_attribute_name$80 = function $$sanitize_attribute_name(name) {
        var self = this;

        return name.$gsub($$($nesting, 'InvalidAttributeNameCharsRx'), "").$downcase()
      }, $Parser_sanitize_attribute_name$80.$$arity = 1), nil) && 'sanitize_attribute_name';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/path_resolver"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send, $gvars = Opal.gvars;

  Opal.add_stubs(['$include', '$attr_accessor', '$root?', '$posixify', '$expand_path', '$pwd', '$start_with?', '$==', '$match?', '$absolute_path?', '$+', '$length', '$descends_from?', '$slice', '$to_s', '$relative_path_from', '$new', '$include?', '$tr', '$partition_path', '$each', '$pop', '$<<', '$join_path', '$[]', '$web_root?', '$unc?', '$index', '$split', '$delete', '$[]=', '$-', '$join', '$raise', '$!', '$fetch', '$warn', '$logger', '$empty?', '$nil_or_empty?', '$chomp', '$!=', '$>', '$size', '$extract_uri_prefix', '$end_with?', '$gsub', '$private', '$=~']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'PathResolver');

      var $nesting = [self].concat($parent_nesting), $PathResolver_initialize$1, $PathResolver_absolute_path$ques$2, $a, $PathResolver_root$ques$3, $PathResolver_unc$ques$4, $PathResolver_web_root$ques$5, $PathResolver_descends_from$ques$6, $PathResolver_relative_path$7, $PathResolver_posixify$8, $PathResolver_expand_path$9, $PathResolver_partition_path$11, $PathResolver_join_path$12, $PathResolver_system_path$13, $PathResolver_web_path$16, $PathResolver_extract_uri_prefix$18;

      self.$$prototype.file_separator = self.$$prototype._partition_path_web = self.$$prototype._partition_path_sys = self.$$prototype.working_dir = nil;
      
      self.$include($$($nesting, 'Logging'));
      Opal.const_set($nesting[0], 'DOT', ".");
      Opal.const_set($nesting[0], 'DOT_DOT', "..");
      Opal.const_set($nesting[0], 'DOT_SLASH', "./");
      Opal.const_set($nesting[0], 'SLASH', "/");
      Opal.const_set($nesting[0], 'BACKSLASH', "\\");
      Opal.const_set($nesting[0], 'DOUBLE_SLASH', "//");
      Opal.const_set($nesting[0], 'WindowsRootRx', /^(?:[a-zA-Z]:)?[\\\/]/);
      self.$attr_accessor("file_separator");
      self.$attr_accessor("working_dir");
      
      Opal.def(self, '$initialize', $PathResolver_initialize$1 = function $$initialize(file_separator, working_dir) {
        var $a, $b, self = this;

        
        
        if (file_separator == null) {
          file_separator = nil;
        };
        
        if (working_dir == null) {
          working_dir = nil;
        };
        self.file_separator = ($truthy($a = ($truthy($b = file_separator) ? $b : $$$($$$('::', 'File'), 'ALT_SEPARATOR'))) ? $a : $$$($$$('::', 'File'), 'SEPARATOR'));
        self.working_dir = (function() {if ($truthy(working_dir)) {
          
          if ($truthy(self['$root?'](working_dir))) {
            
            return self.$posixify(working_dir);
          } else {
            
            return $$$('::', 'File').$expand_path(working_dir);
          };
        } else {
          return $$$('::', 'Dir').$pwd()
        }; return nil; })();
        self._partition_path_sys = $hash2([], {});
        return (self._partition_path_web = $hash2([], {}));
      }, $PathResolver_initialize$1.$$arity = -1);
      
      Opal.def(self, '$absolute_path?', $PathResolver_absolute_path$ques$2 = function(path) {
        var $a, $b, self = this;

        return ($truthy($a = path['$start_with?']($$($nesting, 'SLASH'))) ? $a : (($b = self.file_separator['$==']($$($nesting, 'BACKSLASH'))) ? $$($nesting, 'WindowsRootRx')['$match?'](path) : self.file_separator['$==']($$($nesting, 'BACKSLASH'))))
      }, $PathResolver_absolute_path$ques$2.$$arity = 1);
      if ($truthy((($a = $$($nesting, 'RUBY_ENGINE')['$==']("opal")) ? $$$('::', 'JAVASCRIPT_IO_MODULE')['$==']("xmlhttprequest") : $$($nesting, 'RUBY_ENGINE')['$==']("opal")))) {
        
        Opal.def(self, '$root?', $PathResolver_root$ques$3 = function(path) {
          var $a, self = this;

          return ($truthy($a = self['$absolute_path?'](path)) ? $a : path['$start_with?']("file://", "http://", "https://"))
        }, $PathResolver_root$ques$3.$$arity = 1)
      } else {
        Opal.alias(self, "root?", "absolute_path?")
      };
      
      Opal.def(self, '$unc?', $PathResolver_unc$ques$4 = function(path) {
        var self = this;

        return path['$start_with?']($$($nesting, 'DOUBLE_SLASH'))
      }, $PathResolver_unc$ques$4.$$arity = 1);
      
      Opal.def(self, '$web_root?', $PathResolver_web_root$ques$5 = function(path) {
        var self = this;

        return path['$start_with?']($$($nesting, 'SLASH'))
      }, $PathResolver_web_root$ques$5.$$arity = 1);
      
      Opal.def(self, '$descends_from?', $PathResolver_descends_from$ques$6 = function(path, base) {
        var $a, self = this;

        if (base['$=='](path)) {
          return 0
        } else if (base['$==']($$($nesting, 'SLASH'))) {
          return ($truthy($a = path['$start_with?']($$($nesting, 'SLASH'))) ? 1 : $a)
        } else {
          return ($truthy($a = path['$start_with?']($rb_plus(base, $$($nesting, 'SLASH')))) ? $rb_plus(base.$length(), 1) : $a)
        }
      }, $PathResolver_descends_from$ques$6.$$arity = 2);
      
      Opal.def(self, '$relative_path', $PathResolver_relative_path$7 = function $$relative_path(path, base) {
        var self = this, offset = nil;

        if ($truthy(self['$root?'](path))) {
          if ($truthy((offset = self['$descends_from?'](path, base)))) {
            return path.$slice(offset, path.$length())
          } else {
            
            try {
              return $$($nesting, 'Pathname').$new(path).$relative_path_from($$($nesting, 'Pathname').$new(base)).$to_s()
            } catch ($err) {
              if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
                try {
                  return path
                } finally { Opal.pop_exception() }
              } else { throw $err; }
            };
          }
        } else {
          return path
        }
      }, $PathResolver_relative_path$7.$$arity = 2);
      
      Opal.def(self, '$posixify', $PathResolver_posixify$8 = function $$posixify(path) {
        var $a, self = this;

        if ($truthy(path)) {
          if ($truthy((($a = self.file_separator['$==']($$($nesting, 'BACKSLASH'))) ? path['$include?']($$($nesting, 'BACKSLASH')) : self.file_separator['$==']($$($nesting, 'BACKSLASH'))))) {
            
            return path.$tr($$($nesting, 'BACKSLASH'), $$($nesting, 'SLASH'));
          } else {
            return path
          }
        } else {
          return ""
        }
      }, $PathResolver_posixify$8.$$arity = 1);
      Opal.alias(self, "posixfy", "posixify");
      
      Opal.def(self, '$expand_path', $PathResolver_expand_path$9 = function $$expand_path(path) {
        var $a, $b, $$10, self = this, path_segments = nil, path_root = nil, resolved_segments = nil;

        
        $b = self.$partition_path(path), $a = Opal.to_ary($b), (path_segments = ($a[0] == null ? nil : $a[0])), (path_root = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy(path['$include?']($$($nesting, 'DOT_DOT')))) {
          
          resolved_segments = [];
          $send(path_segments, 'each', [], ($$10 = function(segment){var self = $$10.$$s || this;

          
            
            if (segment == null) {
              segment = nil;
            };
            if (segment['$==']($$($nesting, 'DOT_DOT'))) {
              return resolved_segments.$pop()
            } else {
              return resolved_segments['$<<'](segment)
            };}, $$10.$$s = self, $$10.$$arity = 1, $$10));
          return self.$join_path(resolved_segments, path_root);
        } else {
          return self.$join_path(path_segments, path_root)
        };
      }, $PathResolver_expand_path$9.$$arity = 1);
      
      Opal.def(self, '$partition_path', $PathResolver_partition_path$11 = function $$partition_path(path, web) {
        var self = this, result = nil, cache = nil, posix_path = nil, root = nil, path_segments = nil, $writer = nil;

        
        
        if (web == null) {
          web = nil;
        };
        if ($truthy((result = (cache = (function() {if ($truthy(web)) {
          return self._partition_path_web
        } else {
          return self._partition_path_sys
        }; return nil; })())['$[]'](path)))) {
          return result};
        posix_path = self.$posixify(path);
        if ($truthy(web)) {
          if ($truthy(self['$web_root?'](posix_path))) {
            root = $$($nesting, 'SLASH')
          } else if ($truthy(posix_path['$start_with?']($$($nesting, 'DOT_SLASH')))) {
            root = $$($nesting, 'DOT_SLASH')}
        } else if ($truthy(self['$root?'](posix_path))) {
          if ($truthy(self['$unc?'](posix_path))) {
            root = $$($nesting, 'DOUBLE_SLASH')
          } else if ($truthy(posix_path['$start_with?']($$($nesting, 'SLASH')))) {
            root = $$($nesting, 'SLASH')
          } else {
            root = posix_path.$slice(0, $rb_plus(posix_path.$index($$($nesting, 'SLASH')), 1))
          }
        } else if ($truthy(posix_path['$start_with?']($$($nesting, 'DOT_SLASH')))) {
          root = $$($nesting, 'DOT_SLASH')};
        path_segments = (function() {if ($truthy(root)) {
          
          return posix_path.$slice(root.$length(), posix_path.$length());
        } else {
          return posix_path
        }; return nil; })().$split($$($nesting, 'SLASH'));
        path_segments.$delete($$($nesting, 'DOT'));
        
        $writer = [path, [path_segments, root]];
        $send(cache, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];;
      }, $PathResolver_partition_path$11.$$arity = -2);
      
      Opal.def(self, '$join_path', $PathResolver_join_path$12 = function $$join_path(segments, root) {
        var self = this;

        
        
        if (root == null) {
          root = nil;
        };
        if ($truthy(root)) {
          return "" + (root) + (segments.$join($$($nesting, 'SLASH')))
        } else {
          
          return segments.$join($$($nesting, 'SLASH'));
        };
      }, $PathResolver_join_path$12.$$arity = -2);
      
      Opal.def(self, '$system_path', $PathResolver_system_path$13 = function $$system_path(target, start, jail, opts) {
        var $a, $b, $$14, $$15, self = this, target_path = nil, target_segments = nil, jail_segments = nil, jail_root = nil, recheck = nil, start_segments = nil, start_root = nil, resolved_segments = nil, unresolved_segments = nil, warned = nil;

        
        
        if (start == null) {
          start = nil;
        };
        
        if (jail == null) {
          jail = nil;
        };
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        if ($truthy(jail)) {
          
          if ($truthy(self['$root?'](jail))) {
          } else {
            self.$raise($$$('::', 'SecurityError'), "" + "Jail is not an absolute path: " + (jail))
          };
          jail = self.$posixify(jail);};
        if ($truthy(target)) {
          if ($truthy(self['$root?'](target))) {
            
            target_path = self.$expand_path(target);
            if ($truthy(($truthy($a = jail) ? self['$descends_from?'](target_path, jail)['$!']() : $a))) {
              if ($truthy(opts.$fetch("recover", true))) {
                
                self.$logger().$warn("" + (($truthy($a = opts['$[]']("target_name")) ? $a : "path")) + " is outside of jail; recovering automatically");
                $b = self.$partition_path(target_path), $a = Opal.to_ary($b), (target_segments = ($a[0] == null ? nil : $a[0])), $b;
                $b = self.$partition_path(jail), $a = Opal.to_ary($b), (jail_segments = ($a[0] == null ? nil : $a[0])), (jail_root = ($a[1] == null ? nil : $a[1])), $b;
                return self.$join_path($rb_plus(jail_segments, target_segments), jail_root);
              } else {
                self.$raise($$$('::', 'SecurityError'), "" + (($truthy($a = opts['$[]']("target_name")) ? $a : "path")) + " " + (target) + " is outside of jail: " + (jail) + " (disallowed in safe mode)")
              }};
            return target_path;
          } else {
            $b = self.$partition_path(target), $a = Opal.to_ary($b), (target_segments = ($a[0] == null ? nil : $a[0])), $b
          }
        } else {
          target_segments = []
        };
        if ($truthy(target_segments['$empty?']())) {
          if ($truthy(start['$nil_or_empty?']())) {
            return ($truthy($a = jail) ? $a : self.working_dir)
          } else if ($truthy(self['$root?'](start))) {
            if ($truthy(jail)) {
              start = self.$posixify(start)
            } else {
              return self.$expand_path(start)
            }
          } else {
            
            $b = self.$partition_path(start), $a = Opal.to_ary($b), (target_segments = ($a[0] == null ? nil : $a[0])), $b;
            start = ($truthy($a = jail) ? $a : self.working_dir);
          }
        } else if ($truthy(start['$nil_or_empty?']())) {
          start = ($truthy($a = jail) ? $a : self.working_dir)
        } else if ($truthy(self['$root?'](start))) {
          if ($truthy(jail)) {
            start = self.$posixify(start)}
        } else {
          start = "" + (($truthy($a = jail) ? $a : self.working_dir).$chomp("/")) + "/" + (start)
        };
        if ($truthy(($truthy($a = ($truthy($b = jail) ? (recheck = self['$descends_from?'](start, jail)['$!']()) : $b)) ? self.file_separator['$==']($$($nesting, 'BACKSLASH')) : $a))) {
          
          $b = self.$partition_path(start), $a = Opal.to_ary($b), (start_segments = ($a[0] == null ? nil : $a[0])), (start_root = ($a[1] == null ? nil : $a[1])), $b;
          $b = self.$partition_path(jail), $a = Opal.to_ary($b), (jail_segments = ($a[0] == null ? nil : $a[0])), (jail_root = ($a[1] == null ? nil : $a[1])), $b;
          if ($truthy(start_root['$!='](jail_root))) {
            if ($truthy(opts.$fetch("recover", true))) {
              
              self.$logger().$warn("" + "start path for " + (($truthy($a = opts['$[]']("target_name")) ? $a : "path")) + " is outside of jail root; recovering automatically");
              start_segments = jail_segments;
              recheck = false;
            } else {
              self.$raise($$$('::', 'SecurityError'), "" + "start path for " + (($truthy($a = opts['$[]']("target_name")) ? $a : "path")) + " " + (start) + " refers to location outside jail root: " + (jail) + " (disallowed in safe mode)")
            }};
        } else {
          $b = self.$partition_path(start), $a = Opal.to_ary($b), (start_segments = ($a[0] == null ? nil : $a[0])), (jail_root = ($a[1] == null ? nil : $a[1])), $b
        };
        if ($truthy((resolved_segments = $rb_plus(start_segments, target_segments))['$include?']($$($nesting, 'DOT_DOT')))) {
          
          $a = [resolved_segments, []], (unresolved_segments = $a[0]), (resolved_segments = $a[1]), $a;
          if ($truthy(jail)) {
            
            if ($truthy(jail_segments)) {
            } else {
              $b = self.$partition_path(jail), $a = Opal.to_ary($b), (jail_segments = ($a[0] == null ? nil : $a[0])), $b
            };
            warned = false;
            $send(unresolved_segments, 'each', [], ($$14 = function(segment){var self = $$14.$$s || this, $c;

            
              
              if (segment == null) {
                segment = nil;
              };
              if (segment['$==']($$($nesting, 'DOT_DOT'))) {
                if ($truthy($rb_gt(resolved_segments.$size(), jail_segments.$size()))) {
                  return resolved_segments.$pop()
                } else if ($truthy(opts.$fetch("recover", true))) {
                  if ($truthy(warned)) {
                    return nil
                  } else {
                    
                    self.$logger().$warn("" + (($truthy($c = opts['$[]']("target_name")) ? $c : "path")) + " has illegal reference to ancestor of jail; recovering automatically");
                    return (warned = true);
                  }
                } else {
                  return self.$raise($$$('::', 'SecurityError'), "" + (($truthy($c = opts['$[]']("target_name")) ? $c : "path")) + " " + (target) + " refers to location outside jail: " + (jail) + " (disallowed in safe mode)")
                }
              } else {
                return resolved_segments['$<<'](segment)
              };}, $$14.$$s = self, $$14.$$arity = 1, $$14));
          } else {
            $send(unresolved_segments, 'each', [], ($$15 = function(segment){var self = $$15.$$s || this;

            
              
              if (segment == null) {
                segment = nil;
              };
              if (segment['$==']($$($nesting, 'DOT_DOT'))) {
                return resolved_segments.$pop()
              } else {
                return resolved_segments['$<<'](segment)
              };}, $$15.$$s = self, $$15.$$arity = 1, $$15))
          };};
        if ($truthy(recheck)) {
          
          target_path = self.$join_path(resolved_segments, jail_root);
          if ($truthy(self['$descends_from?'](target_path, jail))) {
            return target_path
          } else if ($truthy(opts.$fetch("recover", true))) {
            
            self.$logger().$warn("" + (($truthy($a = opts['$[]']("target_name")) ? $a : "path")) + " is outside of jail; recovering automatically");
            if ($truthy(jail_segments)) {
            } else {
              $b = self.$partition_path(jail), $a = Opal.to_ary($b), (jail_segments = ($a[0] == null ? nil : $a[0])), $b
            };
            return self.$join_path($rb_plus(jail_segments, target_segments), jail_root);
          } else {
            return self.$raise($$$('::', 'SecurityError'), "" + (($truthy($a = opts['$[]']("target_name")) ? $a : "path")) + " " + (target) + " is outside of jail: " + (jail) + " (disallowed in safe mode)")
          };
        } else {
          return self.$join_path(resolved_segments, jail_root)
        };
      }, $PathResolver_system_path$13.$$arity = -2);
      
      Opal.def(self, '$web_path', $PathResolver_web_path$16 = function $$web_path(target, start) {
        var $a, $b, $$17, self = this, uri_prefix = nil, target_segments = nil, target_root = nil, resolved_segments = nil, resolved_path = nil;

        
        
        if (start == null) {
          start = nil;
        };
        target = self.$posixify(target);
        start = self.$posixify(start);
        if ($truthy(($truthy($a = start['$nil_or_empty?']()) ? $a : self['$web_root?'](target)))) {
        } else {
          $b = self.$extract_uri_prefix("" + (start) + ((function() {if ($truthy(start['$end_with?']($$($nesting, 'SLASH')))) {
            return ""
          } else {
            return $$($nesting, 'SLASH')
          }; return nil; })()) + (target)), $a = Opal.to_ary($b), (target = ($a[0] == null ? nil : $a[0])), (uri_prefix = ($a[1] == null ? nil : $a[1])), $b
        };
        $b = self.$partition_path(target, true), $a = Opal.to_ary($b), (target_segments = ($a[0] == null ? nil : $a[0])), (target_root = ($a[1] == null ? nil : $a[1])), $b;
        resolved_segments = [];
        $send(target_segments, 'each', [], ($$17 = function(segment){var self = $$17.$$s || this, $c;

        
          
          if (segment == null) {
            segment = nil;
          };
          if (segment['$==']($$($nesting, 'DOT_DOT'))) {
            if ($truthy(resolved_segments['$empty?']())) {
              if ($truthy(($truthy($c = target_root) ? target_root['$!=']($$($nesting, 'DOT_SLASH')) : $c))) {
                return nil
              } else {
                return resolved_segments['$<<'](segment)
              }
            } else if (resolved_segments['$[]'](-1)['$==']($$($nesting, 'DOT_DOT'))) {
              return resolved_segments['$<<'](segment)
            } else {
              return resolved_segments.$pop()
            }
          } else {
            return resolved_segments['$<<'](segment)
          };}, $$17.$$s = self, $$17.$$arity = 1, $$17));
        if ($truthy((resolved_path = self.$join_path(resolved_segments, target_root))['$include?'](" "))) {
          resolved_path = resolved_path.$gsub(" ", "%20")};
        if ($truthy(uri_prefix)) {
          return "" + (uri_prefix) + (resolved_path)
        } else {
          return resolved_path
        };
      }, $PathResolver_web_path$16.$$arity = -2);
      self.$private();
      return (Opal.def(self, '$extract_uri_prefix', $PathResolver_extract_uri_prefix$18 = function $$extract_uri_prefix(str) {
        var $a, self = this;

        if ($truthy(($truthy($a = str['$include?'](":")) ? $$($nesting, 'UriSniffRx')['$=~'](str) : $a))) {
          return [str.$slice((($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$length(), str.$length()), (($a = $gvars['~']) === nil ? nil : $a['$[]'](0))]
        } else {
          return str
        }
      }, $PathResolver_extract_uri_prefix$18.$$arity = 1), nil) && 'extract_uri_prefix';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/reader"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $gvars = Opal.gvars, $hash = Opal.hash;

  Opal.add_stubs(['$include', '$attr_reader', '$+', '$attr_accessor', '$!', '$===', '$split', '$file', '$dir', '$dirname', '$path', '$basename', '$lineno', '$reverse', '$prepare_lines', '$empty?', '$nil_or_empty?', '$peek_line', '$>', '$slice', '$[]', '$length', '$process_line', '$times', '$shift', '$read_line', '$<<', '$-', '$unshift_all', '$has_more_lines?', '$join', '$read_lines', '$unshift', '$start_with?', '$==', '$*', '$read_lines_until', '$size', '$clear', '$cursor', '$[]=', '$!=', '$fetch', '$cursor_at_mark', '$warn', '$logger', '$message_with_context', '$pop', '$push', '$respond_to?', '$reverse_each', '$new', '$tap', '$each', '$instance_variables', '$instance_variable_get', '$drop', '$instance_variable_set', '$class', '$object_id', '$inspect', '$private', '$prepare_source_array', '$prepare_source_string', '$chomp', '$valid_encoding?', '$to_s', '$raise', '$to_i', '$attributes', '$catalog', '$pop_include', '$parse', '$path=', '$dup', '$end_with?', '$keys', '$rindex', '$rootname', '$key?', '$attr', '$reverse!', '$>=', '$nil?', '$extensions?', '$include_processors?', '$extensions', '$include_processors', '$map', '$skip_front_matter!', '$adjust_indentation!', '$include?', '$=~', '$preprocess_conditional_directive', '$preprocess_include_directive', '$downcase', '$error', '$none?', '$any?', '$all?', '$strip', '$send', '$resolve_expr_val', '$replace_next_line', '$rstrip', '$sub_attributes', '$attribute_missing', '$info', '$parse_attributes', '$find', '$handles?', '$instance', '$process_method', '$safe', '$resolve_include_path', '$method', '$split_delimited_value', '$partition', '$<', '$to_a', '$uniq', '$sort', '$call', '$each_line', '$infinite?', '$push_include', '$delete', '$first', '$values', '$value?', '$create_include_cursor', '$delete_at', '$keep_if', '$read', '$uriish?', '$attr?', '$require_library', '$normalize_system_path', '$file?', '$relative_path', '$path_resolver', '$base_dir', '$to_f']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Reader');

      var $nesting = [self].concat($parent_nesting), $Reader_initialize$4, $Reader_has_more_lines$ques$5, $Reader_empty$ques$6, $Reader_next_line_empty$ques$7, $Reader_peek_line$8, $Reader_peek_lines$9, $Reader_read_line$11, $Reader_read_lines$12, $Reader_read$13, $Reader_advance$14, $Reader_unshift_line$15, $Reader_unshift_lines$16, $Reader_replace_next_line$17, $Reader_skip_blank_lines$18, $Reader_skip_comment_lines$19, $Reader_skip_line_comments$20, $Reader_terminate$21, $Reader_read_lines_until$22, $Reader_shift$23, $Reader_unshift$24, $Reader_unshift_all$25, $Reader_unshift_all$27, $Reader_cursor$28, $Reader_cursor_at_line$29, $Reader_cursor_at_mark$30, $Reader_cursor_before_mark$31, $Reader_cursor_at_prev_line$32, $Reader_mark$33, $Reader_line_info$34, $Reader_lines$35, $Reader_string$36, $Reader_source$37, $Reader_save$38, $Reader_restore_save$41, $Reader_discard_save$43, $Reader_to_s$44, $Reader_prepare_lines$45, $Reader_process_line$46;

      self.$$prototype.file = self.$$prototype.lines = self.$$prototype.look_ahead = self.$$prototype.unescape_next_line = self.$$prototype.lineno = self.$$prototype.process_lines = self.$$prototype.dir = self.$$prototype.path = self.$$prototype.mark = self.$$prototype.source_lines = self.$$prototype.saved = nil;
      
      self.$include($$($nesting, 'Logging'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Cursor');

        var $nesting = [self].concat($parent_nesting), $Cursor_initialize$1, $Cursor_advance$2, $Cursor_line_info$3;

        self.$$prototype.lineno = self.$$prototype.path = nil;
        
        self.$attr_reader("file", "dir", "path", "lineno");
        
        Opal.def(self, '$initialize', $Cursor_initialize$1 = function $$initialize(file, dir, path, lineno) {
          var $a, self = this;

          
          
          if (dir == null) {
            dir = nil;
          };
          
          if (path == null) {
            path = nil;
          };
          
          if (lineno == null) {
            lineno = 1;
          };
          return $a = [file, dir, path, lineno], (self.file = $a[0]), (self.dir = $a[1]), (self.path = $a[2]), (self.lineno = $a[3]), $a;
        }, $Cursor_initialize$1.$$arity = -2);
        
        Opal.def(self, '$advance', $Cursor_advance$2 = function $$advance(num) {
          var self = this;

          return (self.lineno = $rb_plus(self.lineno, num))
        }, $Cursor_advance$2.$$arity = 1);
        
        Opal.def(self, '$line_info', $Cursor_line_info$3 = function $$line_info() {
          var self = this;

          return "" + (self.path) + ": line " + (self.lineno)
        }, $Cursor_line_info$3.$$arity = 0);
        return Opal.alias(self, "to_s", "line_info");
      })($nesting[0], null, $nesting);
      self.$attr_reader("file");
      self.$attr_reader("dir");
      self.$attr_reader("path");
      self.$attr_reader("lineno");
      self.$attr_reader("source_lines");
      self.$attr_accessor("process_lines");
      self.$attr_accessor("unterminated");
      
      Opal.def(self, '$initialize', $Reader_initialize$4 = function $$initialize(data, cursor, opts) {
        var $a, $b, self = this;

        
        
        if (data == null) {
          data = nil;
        };
        
        if (cursor == null) {
          cursor = nil;
        };
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        if ($truthy(cursor['$!']())) {
          
          self.file = nil;
          self.dir = ".";
          self.path = "<stdin>";
          self.lineno = 1;
        } else if ($truthy($$$('::', 'String')['$==='](cursor))) {
          
          self.file = cursor;
          $b = $$$('::', 'File').$split(self.file), $a = Opal.to_ary($b), (self.dir = ($a[0] == null ? nil : $a[0])), (self.path = ($a[1] == null ? nil : $a[1])), $b;
          self.lineno = 1;
        } else {
          
          if ($truthy((self.file = cursor.$file()))) {
            
            self.dir = ($truthy($a = cursor.$dir()) ? $a : $$$('::', 'File').$dirname(self.file));
            self.path = ($truthy($a = cursor.$path()) ? $a : $$$('::', 'File').$basename(self.file));
          } else {
            
            self.dir = ($truthy($a = cursor.$dir()) ? $a : ".");
            self.path = ($truthy($a = cursor.$path()) ? $a : "<stdin>");
          };
          self.lineno = ($truthy($a = cursor.$lineno()) ? $a : 1);
        };
        self.lines = (self.source_lines = self.$prepare_lines(data, opts)).$reverse();
        self.mark = nil;
        self.look_ahead = 0;
        self.process_lines = true;
        self.unescape_next_line = false;
        self.unterminated = nil;
        return (self.saved = nil);
      }, $Reader_initialize$4.$$arity = -1);
      
      Opal.def(self, '$has_more_lines?', $Reader_has_more_lines$ques$5 = function() {
        var self = this;

        if ($truthy(self.lines['$empty?']())) {
          
          self.look_ahead = 0;
          return false;
        } else {
          return true
        }
      }, $Reader_has_more_lines$ques$5.$$arity = 0);
      
      Opal.def(self, '$empty?', $Reader_empty$ques$6 = function() {
        var self = this;

        if ($truthy(self.lines['$empty?']())) {
          
          self.look_ahead = 0;
          return true;
        } else {
          return false
        }
      }, $Reader_empty$ques$6.$$arity = 0);
      Opal.alias(self, "eof?", "empty?");
      
      Opal.def(self, '$next_line_empty?', $Reader_next_line_empty$ques$7 = function() {
        var self = this;

        return self.$peek_line()['$nil_or_empty?']()
      }, $Reader_next_line_empty$ques$7.$$arity = 0);
      
      Opal.def(self, '$peek_line', $Reader_peek_line$8 = function $$peek_line(direct) {
        var $a, self = this, line = nil;

        
        
        if (direct == null) {
          direct = false;
        };
        if ($truthy(($truthy($a = direct) ? $a : $rb_gt(self.look_ahead, 0)))) {
          if ($truthy(self.unescape_next_line)) {
            
            return (line = self.lines['$[]'](-1)).$slice(1, line.$length());
          } else {
            return self.lines['$[]'](-1)
          }
        } else if ($truthy(self.lines['$empty?']())) {
          
          self.look_ahead = 0;
          return nil;
        } else {
          return ($truthy($a = self.$process_line(self.lines['$[]'](-1))) ? $a : self.$peek_line())
        };
      }, $Reader_peek_line$8.$$arity = -1);
      
      Opal.def(self, '$peek_lines', $Reader_peek_lines$9 = function $$peek_lines(num, direct) {
        var $a, $$10, self = this, old_look_ahead = nil, result = nil;

        
        
        if (num == null) {
          num = nil;
        };
        
        if (direct == null) {
          direct = false;
        };
        old_look_ahead = self.look_ahead;
        result = [];
        (function(){var $brk = Opal.new_brk(); try {return $send(($truthy($a = num) ? $a : $$($nesting, 'MAX_INT')), 'times', [], ($$10 = function(){var self = $$10.$$s || this, line = nil;
          if (self.lineno == null) self.lineno = nil;

        if ($truthy((line = (function() {if ($truthy(direct)) {
            return self.$shift()
          } else {
            return self.$read_line()
          }; return nil; })()))) {
            return result['$<<'](line)
          } else {
            
            if ($truthy(direct)) {
              self.lineno = $rb_minus(self.lineno, 1)};
            
            Opal.brk(nil, $brk);
          }}, $$10.$$s = self, $$10.$$brk = $brk, $$10.$$arity = 0, $$10))
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
        if ($truthy(result['$empty?']())) {
        } else {
          
          self.$unshift_all(result);
          if ($truthy(direct)) {
            self.look_ahead = old_look_ahead};
        };
        return result;
      }, $Reader_peek_lines$9.$$arity = -1);
      
      Opal.def(self, '$read_line', $Reader_read_line$11 = function $$read_line() {
        var $a, self = this;

        if ($truthy(($truthy($a = $rb_gt(self.look_ahead, 0)) ? $a : self['$has_more_lines?']()))) {
          return self.$shift()
        } else {
          return nil
        }
      }, $Reader_read_line$11.$$arity = 0);
      
      Opal.def(self, '$read_lines', $Reader_read_lines$12 = function $$read_lines() {
        var $a, self = this, lines = nil;

        
        lines = [];
        while ($truthy(self['$has_more_lines?']())) {
          lines['$<<'](self.$shift())
        };
        return lines;
      }, $Reader_read_lines$12.$$arity = 0);
      Opal.alias(self, "readlines", "read_lines");
      
      Opal.def(self, '$read', $Reader_read$13 = function $$read() {
        var self = this;

        return self.$read_lines().$join($$($nesting, 'LF'))
      }, $Reader_read$13.$$arity = 0);
      
      Opal.def(self, '$advance', $Reader_advance$14 = function $$advance() {
        var self = this;

        if ($truthy(self.$shift())) {
          return true
        } else {
          return false
        }
      }, $Reader_advance$14.$$arity = 0);
      
      Opal.def(self, '$unshift_line', $Reader_unshift_line$15 = function $$unshift_line(line_to_restore) {
        var self = this;

        
        self.$unshift(line_to_restore);
        return nil;
      }, $Reader_unshift_line$15.$$arity = 1);
      Opal.alias(self, "restore_line", "unshift_line");
      
      Opal.def(self, '$unshift_lines', $Reader_unshift_lines$16 = function $$unshift_lines(lines_to_restore) {
        var self = this;

        return self.$unshift_all(lines_to_restore)
      }, $Reader_unshift_lines$16.$$arity = 1);
      Opal.alias(self, "restore_lines", "unshift_lines");
      
      Opal.def(self, '$replace_next_line', $Reader_replace_next_line$17 = function $$replace_next_line(replacement) {
        var self = this;

        
        self.$shift();
        self.$unshift(replacement);
        return true;
      }, $Reader_replace_next_line$17.$$arity = 1);
      Opal.alias(self, "replace_line", "replace_next_line");
      
      Opal.def(self, '$skip_blank_lines', $Reader_skip_blank_lines$18 = function $$skip_blank_lines() {
        var $a, self = this, num_skipped = nil, next_line = nil;

        
        if ($truthy(self['$empty?']())) {
          return nil};
        num_skipped = 0;
        while ($truthy((next_line = self.$peek_line()))) {
          if ($truthy(next_line['$empty?']())) {
            
            self.$shift();
            num_skipped = $rb_plus(num_skipped, 1);
          } else {
            return num_skipped
          }
        };
      }, $Reader_skip_blank_lines$18.$$arity = 0);
      
      Opal.def(self, '$skip_comment_lines', $Reader_skip_comment_lines$19 = function $$skip_comment_lines() {
        var $a, $b, self = this, next_line = nil, ll = nil;

        
        if ($truthy(self['$empty?']())) {
          return nil};
        while ($truthy(($truthy($b = (next_line = self.$peek_line())) ? next_line['$empty?']()['$!']() : $b))) {
          if ($truthy(next_line['$start_with?']("//"))) {
            if ($truthy(next_line['$start_with?']("///"))) {
              if ($truthy(($truthy($b = $rb_gt((ll = next_line.$length()), 3)) ? next_line['$==']($rb_times("/", ll)) : $b))) {
                self.$read_lines_until($hash2(["terminator", "skip_first_line", "read_last_line", "skip_processing", "context"], {"terminator": next_line, "skip_first_line": true, "read_last_line": true, "skip_processing": true, "context": "comment"}))
              } else {
                break;
              }
            } else {
              self.$shift()
            }
          } else {
            break;
          }
        };
        return nil;
      }, $Reader_skip_comment_lines$19.$$arity = 0);
      
      Opal.def(self, '$skip_line_comments', $Reader_skip_line_comments$20 = function $$skip_line_comments() {
        var $a, $b, self = this, comment_lines = nil, next_line = nil;

        
        if ($truthy(self['$empty?']())) {
          return []};
        comment_lines = [];
        while ($truthy(($truthy($b = (next_line = self.$peek_line())) ? next_line['$empty?']()['$!']() : $b))) {
          if ($truthy(next_line['$start_with?']("//"))) {
            comment_lines['$<<'](self.$shift())
          } else {
            break;
          }
        };
        return comment_lines;
      }, $Reader_skip_line_comments$20.$$arity = 0);
      
      Opal.def(self, '$terminate', $Reader_terminate$21 = function $$terminate() {
        var self = this;

        
        self.lineno = $rb_plus(self.lineno, self.lines.$size());
        self.lines.$clear();
        self.look_ahead = 0;
        return nil;
      }, $Reader_terminate$21.$$arity = 0);
      
      Opal.def(self, '$read_lines_until', $Reader_read_lines_until$22 = function $$read_lines_until(options) {
        var $a, $b, $c, $d, $e, $f, $iter = $Reader_read_lines_until$22.$$p, $yield = $iter || nil, self = this, result = nil, restore_process_lines = nil, terminator = nil, start_cursor = nil, break_on_blank_lines = nil, break_on_list_continuation = nil, skip_comments = nil, line_read = nil, line_restored = nil, line = nil, $writer = nil, context = nil;

        if ($iter) $Reader_read_lines_until$22.$$p = null;
        
        
        if (options == null) {
          options = $hash2([], {});
        };
        result = [];
        if ($truthy(($truthy($a = self.process_lines) ? options['$[]']("skip_processing") : $a))) {
          
          self.process_lines = false;
          restore_process_lines = true;};
        if ($truthy((terminator = options['$[]']("terminator")))) {
          
          start_cursor = ($truthy($a = options['$[]']("cursor")) ? $a : self.$cursor());
          break_on_blank_lines = false;
          break_on_list_continuation = false;
        } else {
          
          break_on_blank_lines = options['$[]']("break_on_blank_lines");
          break_on_list_continuation = options['$[]']("break_on_list_continuation");
        };
        skip_comments = options['$[]']("skip_line_comments");
        line_read = (line_restored = nil);
        if ($truthy(options['$[]']("skip_first_line"))) {
          self.$shift()};
        while ($truthy((line = self.$read_line()))) {
          
          if ($truthy((function() {if ($truthy(terminator)) {
            return line['$=='](terminator)
          } else {
            
            return ($truthy($b = ($truthy($c = ($truthy($d = break_on_blank_lines) ? line['$empty?']() : $d)) ? $c : ($truthy($d = ($truthy($e = ($truthy($f = break_on_list_continuation) ? line_read : $f)) ? line['$==']($$($nesting, 'LIST_CONTINUATION')) : $e)) ? (($writer = ["preserve_last_line", true]), $send(options, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]) : $d))) ? $b : (($c = ($yield !== nil)) ? Opal.yield1($yield, line) : ($yield !== nil)));
          }; return nil; })())) {
            
            if ($truthy(options['$[]']("read_last_line"))) {
              result['$<<'](line)};
            if ($truthy(options['$[]']("preserve_last_line"))) {
              
              self.$unshift(line);
              line_restored = true;};
            break;;};
          if ($truthy(($truthy($b = ($truthy($c = skip_comments) ? line['$start_with?']("//") : $c)) ? line['$start_with?']("///")['$!']() : $b))) {
          } else {
            
            result['$<<'](line);
            line_read = true;
          };
        };
        if ($truthy(restore_process_lines)) {
          
          self.process_lines = true;
          if ($truthy(($truthy($a = line_restored) ? terminator['$!']() : $a))) {
            self.look_ahead = $rb_minus(self.look_ahead, 1)};};
        if ($truthy(($truthy($a = ($truthy($b = terminator) ? terminator['$!='](line) : $b)) ? (context = options.$fetch("context", terminator)) : $a))) {
          
          if (start_cursor['$==']("at_mark")) {
            start_cursor = self.$cursor_at_mark()};
          self.$logger().$warn(self.$message_with_context("" + "unterminated " + (context) + " block", $hash2(["source_location"], {"source_location": start_cursor})));
          self.unterminated = true;};
        return result;
      }, $Reader_read_lines_until$22.$$arity = -1);
      
      Opal.def(self, '$shift', $Reader_shift$23 = function $$shift() {
        var self = this;

        
        self.lineno = $rb_plus(self.lineno, 1);
        if (self.look_ahead['$=='](0)) {
        } else {
          self.look_ahead = $rb_minus(self.look_ahead, 1)
        };
        return self.lines.$pop();
      }, $Reader_shift$23.$$arity = 0);
      
      Opal.def(self, '$unshift', $Reader_unshift$24 = function $$unshift(line) {
        var self = this;

        
        self.lineno = $rb_minus(self.lineno, 1);
        self.look_ahead = $rb_plus(self.look_ahead, 1);
        self.lines.$push(line);
        return nil;
      }, $Reader_unshift$24.$$arity = 1);
      if ($$$('::', 'RUBY_ENGINE')['$==']("jruby")) {
        
        Opal.def(self, '$unshift_all', $Reader_unshift_all$25 = function $$unshift_all(lines_to_restore) {
          var $$26, self = this;

          
          self.lineno = $rb_minus(self.lineno, lines_to_restore.$size());
          self.look_ahead = $rb_plus(self.look_ahead, lines_to_restore.$size());
          if ($truthy(lines_to_restore['$respond_to?']("reverse"))) {
            $send(self.lines, 'push', Opal.to_a(lines_to_restore.$reverse()))
          } else {
            $send(lines_to_restore, 'reverse_each', [], ($$26 = function(it){var self = $$26.$$s || this;
              if (self.lines == null) self.lines = nil;

            
              
              if (it == null) {
                it = nil;
              };
              return self.lines.$push(it);}, $$26.$$s = self, $$26.$$arity = 1, $$26))
          };
          return nil;
        }, $Reader_unshift_all$25.$$arity = 1)
      } else {
        
        Opal.def(self, '$unshift_all', $Reader_unshift_all$27 = function $$unshift_all(lines_to_restore) {
          var self = this;

          
          self.lineno = $rb_minus(self.lineno, lines_to_restore.$size());
          self.look_ahead = $rb_plus(self.look_ahead, lines_to_restore.$size());
          $send(self.lines, 'push', Opal.to_a(lines_to_restore.$reverse()));
          return nil;
        }, $Reader_unshift_all$27.$$arity = 1)
      };
      
      Opal.def(self, '$cursor', $Reader_cursor$28 = function $$cursor() {
        var self = this;

        return $$($nesting, 'Cursor').$new(self.file, self.dir, self.path, self.lineno)
      }, $Reader_cursor$28.$$arity = 0);
      
      Opal.def(self, '$cursor_at_line', $Reader_cursor_at_line$29 = function $$cursor_at_line(lineno) {
        var self = this;

        return $$($nesting, 'Cursor').$new(self.file, self.dir, self.path, lineno)
      }, $Reader_cursor_at_line$29.$$arity = 1);
      
      Opal.def(self, '$cursor_at_mark', $Reader_cursor_at_mark$30 = function $$cursor_at_mark() {
        var self = this;

        if ($truthy(self.mark)) {
          return $send($$($nesting, 'Cursor'), 'new', Opal.to_a(self.mark))
        } else {
          return self.$cursor()
        }
      }, $Reader_cursor_at_mark$30.$$arity = 0);
      
      Opal.def(self, '$cursor_before_mark', $Reader_cursor_before_mark$31 = function $$cursor_before_mark() {
        var $a, $b, self = this, m_file = nil, m_dir = nil, m_path = nil, m_lineno = nil;

        if ($truthy(self.mark)) {
          
          $b = self.mark, $a = Opal.to_ary($b), (m_file = ($a[0] == null ? nil : $a[0])), (m_dir = ($a[1] == null ? nil : $a[1])), (m_path = ($a[2] == null ? nil : $a[2])), (m_lineno = ($a[3] == null ? nil : $a[3])), $b;
          return $$($nesting, 'Cursor').$new(m_file, m_dir, m_path, $rb_minus(m_lineno, 1));
        } else {
          return $$($nesting, 'Cursor').$new(self.file, self.dir, self.path, $rb_minus(self.lineno, 1))
        }
      }, $Reader_cursor_before_mark$31.$$arity = 0);
      
      Opal.def(self, '$cursor_at_prev_line', $Reader_cursor_at_prev_line$32 = function $$cursor_at_prev_line() {
        var self = this;

        return $$($nesting, 'Cursor').$new(self.file, self.dir, self.path, $rb_minus(self.lineno, 1))
      }, $Reader_cursor_at_prev_line$32.$$arity = 0);
      
      Opal.def(self, '$mark', $Reader_mark$33 = function $$mark() {
        var self = this;

        return (self.mark = [self.file, self.dir, self.path, self.lineno])
      }, $Reader_mark$33.$$arity = 0);
      
      Opal.def(self, '$line_info', $Reader_line_info$34 = function $$line_info() {
        var self = this;

        return "" + (self.path) + ": line " + (self.lineno)
      }, $Reader_line_info$34.$$arity = 0);
      
      Opal.def(self, '$lines', $Reader_lines$35 = function $$lines() {
        var self = this;

        return self.lines.$reverse()
      }, $Reader_lines$35.$$arity = 0);
      
      Opal.def(self, '$string', $Reader_string$36 = function $$string() {
        var self = this;

        return self.lines.$reverse().$join($$($nesting, 'LF'))
      }, $Reader_string$36.$$arity = 0);
      
      Opal.def(self, '$source', $Reader_source$37 = function $$source() {
        var self = this;

        return self.source_lines.$join($$($nesting, 'LF'))
      }, $Reader_source$37.$$arity = 0);
      
      Opal.def(self, '$save', $Reader_save$38 = function $$save() {
        var $$39, self = this;

        
        self.saved = $send($hash2([], {}), 'tap', [], ($$39 = function(accum){var self = $$39.$$s || this, $$40;

        
          
          if (accum == null) {
            accum = nil;
          };
          return $send(self.$instance_variables(), 'each', [], ($$40 = function(name){var self = $$40.$$s || this, $a, $writer = nil, val = nil;

          
            
            if (name == null) {
              name = nil;
            };
            if ($truthy(($truthy($a = name['$==']("@saved")) ? $a : name['$==']("@source_lines")))) {
              return nil
            } else {
              
              $writer = [name, (function() {if ($truthy($$$('::', 'Array')['$===']((val = self.$instance_variable_get(name))))) {
                
                return val.$drop(0);
              } else {
                return val
              }; return nil; })()];
              $send(accum, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];
            };}, $$40.$$s = self, $$40.$$arity = 1, $$40));}, $$39.$$s = self, $$39.$$arity = 1, $$39));
        return nil;
      }, $Reader_save$38.$$arity = 0);
      
      Opal.def(self, '$restore_save', $Reader_restore_save$41 = function $$restore_save() {
        var $$42, self = this;

        if ($truthy(self.saved)) {
          
          $send(self.saved, 'each', [], ($$42 = function(name, val){var self = $$42.$$s || this;

          
            
            if (name == null) {
              name = nil;
            };
            
            if (val == null) {
              val = nil;
            };
            return self.$instance_variable_set(name, val);}, $$42.$$s = self, $$42.$$arity = 2, $$42));
          return (self.saved = nil);
        } else {
          return nil
        }
      }, $Reader_restore_save$41.$$arity = 0);
      
      Opal.def(self, '$discard_save', $Reader_discard_save$43 = function $$discard_save() {
        var self = this;

        return (self.saved = nil)
      }, $Reader_discard_save$43.$$arity = 0);
      
      Opal.def(self, '$to_s', $Reader_to_s$44 = function $$to_s() {
        var self = this;

        return "" + "#<" + (self.$class()) + "@" + (self.$object_id()) + " {path: " + (self.path.$inspect()) + ", line: " + (self.lineno) + "}>"
      }, $Reader_to_s$44.$$arity = 0);
      self.$private();
      
      Opal.def(self, '$prepare_lines', $Reader_prepare_lines$45 = function $$prepare_lines(data, opts) {
        var self = this, normalize = nil;

        
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        try {
          if ($truthy((normalize = opts['$[]']("normalize")))) {
            if ($truthy($$$('::', 'Array')['$==='](data))) {
              
              return $$($nesting, 'Helpers').$prepare_source_array(data, normalize['$!=']("chomp"));
            } else {
              
              return $$($nesting, 'Helpers').$prepare_source_string(data, normalize['$!=']("chomp"));
            }
          } else if ($truthy($$$('::', 'Array')['$==='](data))) {
            return data.$drop(0)
          } else if ($truthy(data)) {
            return data.$chomp().$split($$($nesting, 'LF'), -1)
          } else {
            return []
          }
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
            try {
              if ($truthy((function() {if ($truthy($$$('::', 'Array')['$==='](data))) {
                return data.$join()
              } else {
                return data.$to_s()
              }; return nil; })()['$valid_encoding?']())) {
                return self.$raise()
              } else {
                return self.$raise($$$('::', 'ArgumentError'), "source is either binary or contains invalid Unicode data")
              }
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };
      }, $Reader_prepare_lines$45.$$arity = -2);
      return (Opal.def(self, '$process_line', $Reader_process_line$46 = function $$process_line(line) {
        var self = this;

        
        if ($truthy(self.process_lines)) {
          self.look_ahead = $rb_plus(self.look_ahead, 1)};
        return line;
      }, $Reader_process_line$46.$$arity = 1), nil) && 'process_line';
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'PreprocessorReader');

      var $nesting = [self].concat($parent_nesting), $PreprocessorReader_initialize$47, $PreprocessorReader_has_more_lines$ques$48, $PreprocessorReader_empty$ques$49, $PreprocessorReader_peek_line$50, $PreprocessorReader_push_include$51, $PreprocessorReader_include_depth$52, $PreprocessorReader_exceeds_max_depth$ques$53, $PreprocessorReader_shift$54, $PreprocessorReader_include_processors$ques$55, $PreprocessorReader_create_include_cursor$56, $PreprocessorReader_to_s$57, $PreprocessorReader_prepare_lines$59, $PreprocessorReader_process_line$60, $PreprocessorReader_preprocess_conditional_directive$61, $PreprocessorReader_preprocess_include_directive$66, $PreprocessorReader_resolve_include_path$80, $PreprocessorReader_pop_include$82, $PreprocessorReader_split_delimited_value$83, $PreprocessorReader_skip_front_matter$excl$84, $PreprocessorReader_resolve_expr_val$85;

      self.$$prototype.include_stack = self.$$prototype.lines = self.$$prototype.file = self.$$prototype.dir = self.$$prototype.path = self.$$prototype.lineno = self.$$prototype.maxdepth = self.$$prototype.process_lines = self.$$prototype.includes = self.$$prototype.document = self.$$prototype.unescape_next_line = self.$$prototype.include_processor_extensions = self.$$prototype.look_ahead = self.$$prototype.skipping = self.$$prototype.conditional_stack = nil;
      
      self.$attr_reader("include_stack");
      
      Opal.def(self, '$initialize', $PreprocessorReader_initialize$47 = function $$initialize(document, data, cursor, opts) {
        var $a, $iter = $PreprocessorReader_initialize$47.$$p, $yield = $iter || nil, self = this, default_include_depth = nil;

        if ($iter) $PreprocessorReader_initialize$47.$$p = null;
        
        
        if (data == null) {
          data = nil;
        };
        
        if (cursor == null) {
          cursor = nil;
        };
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        self.document = document;
        $send(self, Opal.find_super_dispatcher(self, 'initialize', $PreprocessorReader_initialize$47, false), [data, cursor, opts], null);
        if ($truthy($rb_gt((default_include_depth = ($truthy($a = document.$attributes()['$[]']("max-include-depth")) ? $a : 64).$to_i()), 0))) {
          self.maxdepth = $hash2(["abs", "curr", "rel"], {"abs": default_include_depth, "curr": default_include_depth, "rel": default_include_depth})
        } else {
          self.maxdepth = nil
        };
        self.include_stack = [];
        self.includes = document.$catalog()['$[]']("includes");
        self.skipping = false;
        self.conditional_stack = [];
        return (self.include_processor_extensions = nil);
      }, $PreprocessorReader_initialize$47.$$arity = -2);
      
      Opal.def(self, '$has_more_lines?', $PreprocessorReader_has_more_lines$ques$48 = function() {
        var self = this;

        if ($truthy(self.$peek_line())) {
          return true
        } else {
          return false
        }
      }, $PreprocessorReader_has_more_lines$ques$48.$$arity = 0);
      
      Opal.def(self, '$empty?', $PreprocessorReader_empty$ques$49 = function() {
        var self = this;

        if ($truthy(self.$peek_line())) {
          return false
        } else {
          return true
        }
      }, $PreprocessorReader_empty$ques$49.$$arity = 0);
      Opal.alias(self, "eof?", "empty?");
      
      Opal.def(self, '$peek_line', $PreprocessorReader_peek_line$50 = function $$peek_line(direct) {
        var $iter = $PreprocessorReader_peek_line$50.$$p, $yield = $iter || nil, self = this, line = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $PreprocessorReader_peek_line$50.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        
        if (direct == null) {
          direct = false;
        };
        if ($truthy((line = $send(self, Opal.find_super_dispatcher(self, 'peek_line', $PreprocessorReader_peek_line$50, false), $zuper, $iter)))) {
          return line
        } else if ($truthy(self.include_stack['$empty?']())) {
          return nil
        } else {
          
          self.$pop_include();
          return self.$peek_line(direct);
        };
      }, $PreprocessorReader_peek_line$50.$$arity = -1);
      
      Opal.def(self, '$push_include', $PreprocessorReader_push_include$51 = function $$push_include(data, file, path, lineno, attributes) {
        var $a, self = this, $writer = nil, dir = nil, rel_maxdepth = nil, curr_maxdepth = nil, abs_maxdepth = nil, leveloffset = nil;

        
        
        if (file == null) {
          file = nil;
        };
        
        if (path == null) {
          path = nil;
        };
        
        if (lineno == null) {
          lineno = 1;
        };
        
        if (attributes == null) {
          attributes = $hash2([], {});
        };
        self.include_stack['$<<']([self.lines, self.file, self.dir, self.path, self.lineno, self.maxdepth, self.process_lines]);
        if ($truthy((self.file = file))) {
          
          if ($truthy($$$('::', 'String')['$==='](file))) {
            self.dir = $$$('::', 'File').$dirname(file)
          } else if ($truthy($$($nesting, 'RUBY_ENGINE_OPAL'))) {
            self.dir = $$$('::', 'URI').$parse($$$('::', 'File').$dirname((file = file.$to_s())))
          } else {
            
            
            $writer = [(function() {if ((dir = $$$('::', 'File').$dirname(file.$path()))['$==']("/")) {
              return ""
            } else {
              return dir
            }; return nil; })()];
            $send((self.dir = file.$dup()), 'path=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            file = file.$to_s();
          };
          self.path = (path = ($truthy($a = path) ? $a : $$$('::', 'File').$basename(file)));
          if ($truthy((self.process_lines = $send(file, 'end_with?', Opal.to_a($$($nesting, 'ASCIIDOC_EXTENSIONS').$keys()))))) {
            
            $writer = [path.$slice(0, path.$rindex(".")), (function() {if ($truthy(attributes['$[]']("partial-option"))) {
              return nil
            } else {
              return true
            }; return nil; })()];
            $send(self.includes, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
        } else {
          
          self.dir = ".";
          self.process_lines = true;
          if ($truthy((self.path = path))) {
            
            $writer = [$$($nesting, 'Helpers').$rootname(path), (function() {if ($truthy(attributes['$[]']("partial-option"))) {
              return nil
            } else {
              return true
            }; return nil; })()];
            $send(self.includes, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          } else {
            self.path = "<stdin>"
          };
        };
        self.lineno = lineno;
        if ($truthy(($truthy($a = self.maxdepth) ? attributes['$key?']("depth") : $a))) {
          if ($truthy($rb_gt((rel_maxdepth = attributes['$[]']("depth").$to_i()), 0))) {
            
            if ($truthy($rb_gt((curr_maxdepth = $rb_plus(self.include_stack.$size(), rel_maxdepth)), (abs_maxdepth = self.maxdepth['$[]']("abs"))))) {
              curr_maxdepth = (rel_maxdepth = abs_maxdepth)};
            self.maxdepth = $hash2(["abs", "curr", "rel"], {"abs": abs_maxdepth, "curr": curr_maxdepth, "rel": rel_maxdepth});
          } else {
            self.maxdepth = $hash2(["abs", "curr", "rel"], {"abs": self.maxdepth['$[]']("abs"), "curr": self.include_stack.$size(), "rel": 0})
          }};
        if ($truthy((self.lines = self.$prepare_lines(data, $hash2(["normalize", "condense", "indent"], {"normalize": ($truthy($a = self.process_lines) ? $a : "chomp"), "condense": false, "indent": attributes['$[]']("indent")})))['$empty?']())) {
          self.$pop_include()
        } else {
          
          if ($truthy(attributes['$key?']("leveloffset"))) {
            
            self.lines = $rb_plus($rb_plus([(function() {if ($truthy((leveloffset = self.document.$attr("leveloffset")))) {
              return "" + ":leveloffset: " + (leveloffset)
            } else {
              return ":leveloffset!:"
            }; return nil; })(), ""], self.lines.$reverse()), ["", "" + ":leveloffset: " + (attributes['$[]']("leveloffset"))]);
            self.lineno = $rb_minus(self.lineno, 2);
          } else {
            self.lines['$reverse!']()
          };
          self.look_ahead = 0;
        };
        return self;
      }, $PreprocessorReader_push_include$51.$$arity = -2);
      
      Opal.def(self, '$include_depth', $PreprocessorReader_include_depth$52 = function $$include_depth() {
        var self = this;

        return self.include_stack.$size()
      }, $PreprocessorReader_include_depth$52.$$arity = 0);
      
      Opal.def(self, '$exceeds_max_depth?', $PreprocessorReader_exceeds_max_depth$ques$53 = function() {
        var $a, $b, self = this;

        return ($truthy($a = ($truthy($b = self.maxdepth) ? $rb_ge(self.include_stack.$size(), self.maxdepth['$[]']("curr")) : $b)) ? self.maxdepth['$[]']("rel") : $a)
      }, $PreprocessorReader_exceeds_max_depth$ques$53.$$arity = 0);
      Opal.alias(self, "exceeded_max_depth?", "exceeds_max_depth?");
      
      Opal.def(self, '$shift', $PreprocessorReader_shift$54 = function $$shift() {
        var $iter = $PreprocessorReader_shift$54.$$p, $yield = $iter || nil, self = this, line = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $PreprocessorReader_shift$54.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        if ($truthy(self.unescape_next_line)) {
          
          self.unescape_next_line = false;
          return (line = $send(self, Opal.find_super_dispatcher(self, 'shift', $PreprocessorReader_shift$54, false), $zuper, $iter)).$slice(1, line.$length());
        } else {
          return $send(self, Opal.find_super_dispatcher(self, 'shift', $PreprocessorReader_shift$54, false), $zuper, $iter)
        }
      }, $PreprocessorReader_shift$54.$$arity = 0);
      
      Opal.def(self, '$include_processors?', $PreprocessorReader_include_processors$ques$55 = function() {
        var $a, self = this;

        if ($truthy(self.include_processor_extensions['$nil?']())) {
          if ($truthy(($truthy($a = self.document['$extensions?']()) ? self.document.$extensions()['$include_processors?']() : $a))) {
            return (self.include_processor_extensions = self.document.$extensions().$include_processors())['$!']()['$!']()
          } else {
            return (self.include_processor_extensions = false)
          }
        } else {
          return self.include_processor_extensions['$!='](false)
        }
      }, $PreprocessorReader_include_processors$ques$55.$$arity = 0);
      
      Opal.def(self, '$create_include_cursor', $PreprocessorReader_create_include_cursor$56 = function $$create_include_cursor(file, path, lineno) {
        var self = this, dir = nil;

        
        if ($truthy($$$('::', 'String')['$==='](file))) {
          dir = $$$('::', 'File').$dirname(file)
        } else if ($truthy($$($nesting, 'RUBY_ENGINE_OPAL'))) {
          dir = $$$('::', 'File').$dirname((file = file.$to_s()))
        } else {
          
          dir = (function() {if ((dir = $$$('::', 'File').$dirname(file.$path()))['$==']("")) {
            return "/"
          } else {
            return dir
          }; return nil; })();
          file = file.$to_s();
        };
        return $$($nesting, 'Cursor').$new(file, dir, path, lineno);
      }, $PreprocessorReader_create_include_cursor$56.$$arity = 3);
      
      Opal.def(self, '$to_s', $PreprocessorReader_to_s$57 = function $$to_s() {
        var $$58, self = this;

        return "" + "#<" + (self.$class()) + "@" + (self.$object_id()) + " {path: " + (self.path.$inspect()) + ", line: " + (self.lineno) + ", include depth: " + (self.include_stack.$size()) + ", include stack: [" + ($send(self.include_stack, 'map', [], ($$58 = function(inc){var self = $$58.$$s || this;

        
          
          if (inc == null) {
            inc = nil;
          };
          return inc.$to_s();}, $$58.$$s = self, $$58.$$arity = 1, $$58)).$join(", ")) + "]}>"
      }, $PreprocessorReader_to_s$57.$$arity = 0);
      self.$private();
      
      Opal.def(self, '$prepare_lines', $PreprocessorReader_prepare_lines$59 = function $$prepare_lines(data, opts) {
        var $a, $b, $iter = $PreprocessorReader_prepare_lines$59.$$p, $yield = $iter || nil, self = this, result = nil, front_matter = nil, $writer = nil, last = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $PreprocessorReader_prepare_lines$59.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        result = $send(self, Opal.find_super_dispatcher(self, 'prepare_lines', $PreprocessorReader_prepare_lines$59, false), $zuper, $iter);
        if ($truthy(($truthy($a = ($truthy($b = self.document) ? self.document.$attributes()['$[]']("skip-front-matter") : $b)) ? (front_matter = self['$skip_front_matter!'](result)) : $a))) {
          
          $writer = ["front-matter", front_matter.$join($$($nesting, 'LF'))];
          $send(self.document.$attributes(), '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        if ($truthy(opts.$fetch("condense", true))) {
          while ($truthy(($truthy($b = (last = result['$[]'](-1))) ? last['$empty?']() : $b))) {
            result.$pop()
          }};
        if ($truthy(opts['$[]']("indent"))) {
          $$($nesting, 'Parser')['$adjust_indentation!'](result, opts['$[]']("indent").$to_i(), self.document.$attr("tabsize").$to_i())};
        return result;
      }, $PreprocessorReader_prepare_lines$59.$$arity = -2);
      
      Opal.def(self, '$process_line', $PreprocessorReader_process_line$60 = function $$process_line(line) {
        var $a, $b, self = this;

        
        if ($truthy(self.process_lines)) {
        } else {
          return line
        };
        if ($truthy(line['$empty?']())) {
          
          self.look_ahead = $rb_plus(self.look_ahead, 1);
          return line;};
        if ($truthy(($truthy($a = ($truthy($b = line['$end_with?']("]")) ? line['$start_with?']("[")['$!']() : $b)) ? line['$include?']("::") : $a))) {
          if ($truthy(($truthy($a = line['$include?']("if")) ? $$($nesting, 'ConditionalDirectiveRx')['$=~'](line) : $a))) {
            if ((($a = $gvars['~']) === nil ? nil : $a['$[]'](1))['$==']("\\")) {
              
              self.unescape_next_line = true;
              self.look_ahead = $rb_plus(self.look_ahead, 1);
              return line.$slice(1, line.$length());
            } else if ($truthy(self.$preprocess_conditional_directive((($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](3)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](4)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](5))))) {
              
              self.$shift();
              return nil;
            } else {
              
              self.look_ahead = $rb_plus(self.look_ahead, 1);
              return line;
            }
          } else if ($truthy(self.skipping)) {
            
            self.$shift();
            return nil;
          } else if ($truthy(($truthy($a = line['$start_with?']("inc", "\\inc")) ? $$($nesting, 'IncludeDirectiveRx')['$=~'](line) : $a))) {
            if ((($a = $gvars['~']) === nil ? nil : $a['$[]'](1))['$==']("\\")) {
              
              self.unescape_next_line = true;
              self.look_ahead = $rb_plus(self.look_ahead, 1);
              return line.$slice(1, line.$length());
            } else if ($truthy(self.$preprocess_include_directive((($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](3))))) {
              return nil
            } else {
              
              self.look_ahead = $rb_plus(self.look_ahead, 1);
              return line;
            }
          } else {
            
            self.look_ahead = $rb_plus(self.look_ahead, 1);
            return line;
          }
        } else if ($truthy(self.skipping)) {
          
          self.$shift();
          return nil;
        } else {
          
          self.look_ahead = $rb_plus(self.look_ahead, 1);
          return line;
        };
      }, $PreprocessorReader_process_line$60.$$arity = 1);
      
      Opal.def(self, '$preprocess_conditional_directive', $PreprocessorReader_preprocess_conditional_directive$61 = function $$preprocess_conditional_directive(keyword, target, delimiter, text) {
        var $a, $$62, $$63, $$64, $$65, self = this, no_target = nil, pair = nil, skip = nil, $case = nil, lhs = nil, op = nil, rhs = nil;

        
        if ($truthy((no_target = target['$empty?']()))) {
        } else {
          target = target.$downcase()
        };
        if (keyword['$==']("endif")) {
          
          if ($truthy(text)) {
            self.$logger().$error(self.$message_with_context("" + "malformed preprocessor directive - text not permitted: endif::" + (target) + "[" + (text) + "]", $hash2(["source_location"], {"source_location": self.$cursor()})))
          } else if ($truthy(self.conditional_stack['$empty?']())) {
            self.$logger().$error(self.$message_with_context("" + "unmatched preprocessor directive: endif::" + (target) + "[]", $hash2(["source_location"], {"source_location": self.$cursor()})))
          } else if ($truthy(($truthy($a = no_target) ? $a : target['$==']((pair = self.conditional_stack['$[]'](-1))['$[]']("target"))))) {
            
            self.conditional_stack.$pop();
            self.skipping = (function() {if ($truthy(self.conditional_stack['$empty?']())) {
              return false
            } else {
              return self.conditional_stack['$[]'](-1)['$[]']("skipping")
            }; return nil; })();
          } else {
            self.$logger().$error(self.$message_with_context("" + "mismatched preprocessor directive: endif::" + (target) + "[], expected endif::" + (pair['$[]']("target")) + "[]", $hash2(["source_location"], {"source_location": self.$cursor()})))
          };
          return true;
        } else if ($truthy(self.skipping)) {
          skip = false
        } else {
          $case = keyword;
          if ("ifdef"['$===']($case)) {
          if ($truthy(no_target)) {
            
            self.$logger().$error(self.$message_with_context("" + "malformed preprocessor directive - missing target: ifdef::[" + (text) + "]", $hash2(["source_location"], {"source_location": self.$cursor()})));
            return true;};
          $case = delimiter;
          if (","['$===']($case)) {skip = $send(target.$split(",", -1), 'none?', [], ($$62 = function(name){var self = $$62.$$s || this;
            if (self.document == null) self.document = nil;

          
            
            if (name == null) {
              name = nil;
            };
            return self.document.$attributes()['$key?'](name);}, $$62.$$s = self, $$62.$$arity = 1, $$62))}
          else if ("+"['$===']($case)) {skip = $send(target.$split("+", -1), 'any?', [], ($$63 = function(name){var self = $$63.$$s || this;
            if (self.document == null) self.document = nil;

          
            
            if (name == null) {
              name = nil;
            };
            return self.document.$attributes()['$key?'](name)['$!']();}, $$63.$$s = self, $$63.$$arity = 1, $$63))}
          else {skip = self.document.$attributes()['$key?'](target)['$!']()};}
          else if ("ifndef"['$===']($case)) {
          if ($truthy(no_target)) {
            
            self.$logger().$error(self.$message_with_context("" + "malformed preprocessor directive - missing target: ifndef::[" + (text) + "]", $hash2(["source_location"], {"source_location": self.$cursor()})));
            return true;};
          $case = delimiter;
          if (","['$===']($case)) {skip = $send(target.$split(",", -1), 'any?', [], ($$64 = function(name){var self = $$64.$$s || this;
            if (self.document == null) self.document = nil;

          
            
            if (name == null) {
              name = nil;
            };
            return self.document.$attributes()['$key?'](name);}, $$64.$$s = self, $$64.$$arity = 1, $$64))}
          else if ("+"['$===']($case)) {skip = $send(target.$split("+", -1), 'all?', [], ($$65 = function(name){var self = $$65.$$s || this;
            if (self.document == null) self.document = nil;

          
            
            if (name == null) {
              name = nil;
            };
            return self.document.$attributes()['$key?'](name);}, $$65.$$s = self, $$65.$$arity = 1, $$65))}
          else {skip = self.document.$attributes()['$key?'](target)};}
          else if ("ifeval"['$===']($case)) {if ($truthy(no_target)) {
            if ($truthy(($truthy($a = text) ? $$($nesting, 'EvalExpressionRx')['$=~'](text.$strip()) : $a))) {
              
              lhs = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1));
              op = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2));
              rhs = (($a = $gvars['~']) === nil ? nil : $a['$[]'](3));
              skip = (function() { try {
                if ($truthy(self.$resolve_expr_val(lhs).$send(op, self.$resolve_expr_val(rhs)))) {
                  return false
                } else {
                  return true
                }
              } catch ($err) {
                if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
                  try {
                    return true
                  } finally { Opal.pop_exception() }
                } else { throw $err; }
              }})();
            } else {
              
              self.$logger().$error(self.$message_with_context("" + "malformed preprocessor directive - " + ((function() {if ($truthy(text)) {
                return "invalid expression"
              } else {
                return "missing expression"
              }; return nil; })()) + ": ifeval::[" + (text) + "]", $hash2(["source_location"], {"source_location": self.$cursor()})));
              return true;
            }
          } else {
            
            self.$logger().$error(self.$message_with_context("" + "malformed preprocessor directive - target not permitted: ifeval::" + (target) + "[" + (text) + "]", $hash2(["source_location"], {"source_location": self.$cursor()})));
            return true;
          }}
        };
        if ($truthy(($truthy($a = keyword['$==']("ifeval")) ? $a : text['$!']()))) {
          
          if ($truthy(skip)) {
            self.skipping = true};
          self.conditional_stack['$<<']($hash2(["target", "skip", "skipping"], {"target": target, "skip": skip, "skipping": self.skipping}));
        } else if ($truthy(($truthy($a = self.skipping) ? $a : skip))) {
        } else {
          
          self.$replace_next_line(text.$rstrip());
          self.$unshift("");
          if ($truthy(text['$start_with?']("include::"))) {
            self.look_ahead = $rb_minus(self.look_ahead, 1)};
        };
        return true;
      }, $PreprocessorReader_preprocess_conditional_directive$61.$$arity = 4);
      
      Opal.def(self, '$preprocess_include_directive', $PreprocessorReader_preprocess_include_directive$66 = function $$preprocess_include_directive(target, attrlist) {
        var $a, $b, $$67, $$68, $$69, $$70, $$71, $$72, $$74, $$77, $$78, $$79, self = this, doc = nil, expanded_target = nil, attr_missing = nil, ext = nil, parsed_attrs = nil, inc_path = nil, target_type = nil, relpath = nil, $case = nil, reader = nil, read_mode = nil, enc = nil, $writer = nil, read_mode_params = nil, inc_linenos = nil, inc_tags = nil, tag = nil, inc_lines = nil, inc_offset = nil, inc_lineno = nil, tag_stack = nil, tags_selected = nil, active_tag = nil, select = nil, base_select = nil, wildcard = nil, missing_tags = nil, inc_content = nil;

        
        doc = self.document;
        if ($truthy(($truthy($a = (expanded_target = target)['$include?']($$($nesting, 'ATTR_REF_HEAD'))) ? (expanded_target = doc.$sub_attributes(target, $hash2(["attribute_missing"], {"attribute_missing": (function() {if ((attr_missing = ($truthy($b = doc.$attributes()['$[]']("attribute-missing")) ? $b : $$($nesting, 'Compliance').$attribute_missing()))['$==']("warn")) {
          return "drop-line"
        } else {
          return attr_missing
        }; return nil; })()})))['$empty?']() : $a))) {
          if ($truthy((($a = attr_missing['$==']("drop-line")) ? doc.$sub_attributes($rb_plus(target, " "), $hash2(["attribute_missing", "drop_line_severity"], {"attribute_missing": "drop-line", "drop_line_severity": "ignore"}))['$empty?']() : attr_missing['$==']("drop-line")))) {
            
            $send(self.$logger(), 'info', [], ($$67 = function(){var self = $$67.$$s || this;

            return self.$message_with_context("" + "include dropped due to missing attribute: include::" + (target) + "[" + (attrlist) + "]", $hash2(["source_location"], {"source_location": self.$cursor()}))}, $$67.$$s = self, $$67.$$arity = 0, $$67));
            self.$shift();
            return true;
          } else if ($truthy(doc.$parse_attributes(attrlist, [], $hash2(["sub_input"], {"sub_input": true}))['$[]']("optional-option"))) {
            
            $send(self.$logger(), 'info', [], ($$68 = function(){var self = $$68.$$s || this, $c;

            return self.$message_with_context("" + "optional include dropped " + ((function() {if ($truthy((($c = attr_missing['$==']("warn")) ? doc.$sub_attributes($rb_plus(target, " "), $hash2(["attribute_missing", "drop_line_severity"], {"attribute_missing": "drop-line", "drop_line_severity": "ignore"}))['$empty?']() : attr_missing['$==']("warn")))) {
                return "due to missing attribute"
              } else {
                return "because resolved target is blank"
              }; return nil; })()) + ": include::" + (target) + "[" + (attrlist) + "]", $hash2(["source_location"], {"source_location": self.$cursor()}))}, $$68.$$s = self, $$68.$$arity = 0, $$68));
            self.$shift();
            return true;
          } else {
            
            self.$logger().$warn(self.$message_with_context("" + "include dropped " + ((function() {if ($truthy((($a = attr_missing['$==']("warn")) ? doc.$sub_attributes($rb_plus(target, " "), $hash2(["attribute_missing", "drop_line_severity"], {"attribute_missing": "drop-line", "drop_line_severity": "ignore"}))['$empty?']() : attr_missing['$==']("warn")))) {
              return "due to missing attribute"
            } else {
              return "because resolved target is blank"
            }; return nil; })()) + ": include::" + (target) + "[" + (attrlist) + "]", $hash2(["source_location"], {"source_location": self.$cursor()})));
            return self.$replace_next_line("" + "Unresolved directive in " + (self.path) + " - include::" + (target) + "[" + (attrlist) + "]");
          }
        } else if ($truthy(($truthy($a = self['$include_processors?']()) ? (ext = $send(self.include_processor_extensions, 'find', [], ($$69 = function(candidate){var self = $$69.$$s || this;

        
          
          if (candidate == null) {
            candidate = nil;
          };
          return candidate.$instance()['$handles?'](expanded_target);}, $$69.$$s = self, $$69.$$arity = 1, $$69))) : $a))) {
          
          self.$shift();
          ext.$process_method()['$[]'](doc, self, expanded_target, doc.$parse_attributes(attrlist, [], $hash2(["sub_input"], {"sub_input": true})));
          return true;
        } else if ($truthy($rb_ge(doc.$safe(), $$$($$($nesting, 'SafeMode'), 'SECURE')))) {
          return self.$replace_next_line("" + "link:" + (expanded_target) + "[]")
        } else if ($truthy(self.maxdepth)) {
          
          if ($truthy($rb_ge(self.include_stack.$size(), self.maxdepth['$[]']("curr")))) {
            
            self.$logger().$error(self.$message_with_context("" + "maximum include depth of " + (self.maxdepth['$[]']("rel")) + " exceeded", $hash2(["source_location"], {"source_location": self.$cursor()})));
            return nil;};
          parsed_attrs = doc.$parse_attributes(attrlist, [], $hash2(["sub_input"], {"sub_input": true}));
          $b = self.$resolve_include_path(expanded_target, attrlist, parsed_attrs), $a = Opal.to_ary($b), (inc_path = ($a[0] == null ? nil : $a[0])), (target_type = ($a[1] == null ? nil : $a[1])), (relpath = ($a[2] == null ? nil : $a[2])), $b;
          $case = target_type;
          if ("file"['$===']($case)) {
          reader = $$$('::', 'File').$method("open");
          read_mode = $$($nesting, 'FILE_READ_MODE');}
          else if ("uri"['$===']($case)) {
          reader = $$$('::', 'OpenURI').$method("open_uri");
          read_mode = $$($nesting, 'URI_READ_MODE');}
          else {return inc_path};
          if ($truthy($$($nesting, 'RUBY_ENGINE_OPAL'))) {
          } else if ($truthy(($truthy($a = (enc = parsed_attrs['$[]']("encoding"))) ? (function() { try {
            return $$$('::', 'Encoding').$find(enc)
          } catch ($err) {
            if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
              try {
                return nil
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          }})() : $a))) {
            
            
            $writer = [1, enc];
            $send((read_mode_params = read_mode.$split(":")), '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            read_mode = read_mode_params.$join(":");};
          inc_linenos = (inc_tags = nil);
          if ($truthy(attrlist)) {
            if ($truthy(parsed_attrs['$key?']("lines"))) {
              
              inc_linenos = [];
              $send(self.$split_delimited_value(parsed_attrs['$[]']("lines")), 'each', [], ($$70 = function(linedef){var self = $$70.$$s || this, $c, $d, from = nil, _ = nil, to = nil;

              
                
                if (linedef == null) {
                  linedef = nil;
                };
                if ($truthy(linedef['$include?'](".."))) {
                  
                  $d = linedef.$partition(".."), $c = Opal.to_ary($d), (from = ($c[0] == null ? nil : $c[0])), (_ = ($c[1] == null ? nil : $c[1])), (to = ($c[2] == null ? nil : $c[2])), $d;
                  return (inc_linenos = $rb_plus(inc_linenos, (function() {if ($truthy(($truthy($c = to['$empty?']()) ? $c : $rb_lt((to = to.$to_i()), 0)))) {
                    return [from.$to_i(), $$$($$$('::', 'Float'), 'INFINITY')]
                  } else {
                    return Opal.Range.$new(from.$to_i(), to, false).$to_a()
                  }; return nil; })()));
                } else {
                  return inc_linenos['$<<'](linedef.$to_i())
                };}, $$70.$$s = self, $$70.$$arity = 1, $$70));
              inc_linenos = (function() {if ($truthy(inc_linenos['$empty?']())) {
                return nil
              } else {
                return inc_linenos.$sort().$uniq()
              }; return nil; })();
            } else if ($truthy(parsed_attrs['$key?']("tag"))) {
              if ($truthy(($truthy($a = (tag = parsed_attrs['$[]']("tag"))['$empty?']()) ? $a : tag['$==']("!")))) {
              } else {
                inc_tags = (function() {if ($truthy(tag['$start_with?']("!"))) {
                  return $hash(tag.$slice(1, tag.$length()), false)
                } else {
                  return $hash(tag, true)
                }; return nil; })()
              }
            } else if ($truthy(parsed_attrs['$key?']("tags"))) {
              
              inc_tags = $hash2([], {});
              $send(self.$split_delimited_value(parsed_attrs['$[]']("tags")), 'each', [], ($$71 = function(tagdef){var self = $$71.$$s || this, $c;

              
                
                if (tagdef == null) {
                  tagdef = nil;
                };
                if ($truthy(($truthy($c = tagdef['$empty?']()) ? $c : tagdef['$==']("!")))) {
                  return nil
                } else if ($truthy(tagdef['$start_with?']("!"))) {
                  
                  $writer = [tagdef.$slice(1, tagdef.$length()), false];
                  $send(inc_tags, '[]=', Opal.to_a($writer));
                  return $writer[$rb_minus($writer["length"], 1)];
                } else {
                  
                  $writer = [tagdef, true];
                  $send(inc_tags, '[]=', Opal.to_a($writer));
                  return $writer[$rb_minus($writer["length"], 1)];
                };}, $$71.$$s = self, $$71.$$arity = 1, $$71));
              if ($truthy(inc_tags['$empty?']())) {
                inc_tags = nil};}};
          if ($truthy(inc_linenos)) {
            
            $a = [[], nil, 0], (inc_lines = $a[0]), (inc_offset = $a[1]), (inc_lineno = $a[2]), $a;
            
            try {
              (function(){var $brk = Opal.new_brk(); try {return $send(reader, 'call', [inc_path, read_mode], ($$72 = function(f){var self = $$72.$$s || this, $$73, select_remaining = nil;

              
                
                if (f == null) {
                  f = nil;
                };
                select_remaining = nil;
                return (function(){var $brk = Opal.new_brk(); try {return $send(f, 'each_line', [], ($$73 = function(l){var self = $$73.$$s || this, $c, $d, select = nil;

                
                  
                  if (l == null) {
                    l = nil;
                  };
                  inc_lineno = $rb_plus(inc_lineno, 1);
                  if ($truthy(($truthy($c = select_remaining) ? $c : ($truthy($d = $$$('::', 'Float')['$===']((select = inc_linenos['$[]'](0)))) ? (select_remaining = select['$infinite?']()) : $d)))) {
                    
                    inc_offset = ($truthy($c = inc_offset) ? $c : inc_lineno);
                    return inc_lines['$<<'](l);
                  } else {
                    
                    if (select['$=='](inc_lineno)) {
                      
                      inc_offset = ($truthy($c = inc_offset) ? $c : inc_lineno);
                      inc_lines['$<<'](l);
                      inc_linenos.$shift();};
                    if ($truthy(inc_linenos['$empty?']())) {
                      
                      Opal.brk(nil, $brk)
                    } else {
                      return nil
                    };
                  };}, $$73.$$s = self, $$73.$$brk = $brk, $$73.$$arity = 1, $$73))
                } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();}, $$72.$$s = self, $$72.$$brk = $brk, $$72.$$arity = 1, $$72))
              } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})()
            } catch ($err) {
              if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
                try {
                  
                  self.$logger().$error(self.$message_with_context("" + "include " + (target_type) + " not readable: " + (inc_path), $hash2(["source_location"], {"source_location": self.$cursor()})));
                  return self.$replace_next_line("" + "Unresolved directive in " + (self.path) + " - include::" + (expanded_target) + "[" + (attrlist) + "]");
                } finally { Opal.pop_exception() }
              } else { throw $err; }
            };;
            self.$shift();
            if ($truthy(inc_offset)) {
              
              
              $writer = ["partial-option", ""];
              $send(parsed_attrs, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;
              self.$push_include(inc_lines, inc_path, relpath, inc_offset, parsed_attrs);};
          } else if ($truthy(inc_tags)) {
            
            $a = [[], nil, 0, [], $$$('::', 'Set').$new(), nil], (inc_lines = $a[0]), (inc_offset = $a[1]), (inc_lineno = $a[2]), (tag_stack = $a[3]), (tags_selected = $a[4]), (active_tag = $a[5]), $a;
            if ($truthy(inc_tags['$key?']("**"))) {
              
              select = (base_select = inc_tags.$delete("**"));
              if ($truthy(inc_tags['$key?']("*"))) {
                wildcard = inc_tags.$delete("*")
              } else if ($truthy(($truthy($a = select['$!']()) ? inc_tags.$values().$first()['$=='](false) : $a))) {
                wildcard = true};
            } else if ($truthy(inc_tags['$key?']("*"))) {
              if (inc_tags.$keys().$first()['$==']("*")) {
                select = (base_select = (wildcard = inc_tags.$delete("*"))['$!']())
              } else {
                
                select = (base_select = false);
                wildcard = inc_tags.$delete("*");
              }
            } else {
              select = (base_select = inc_tags['$value?'](true)['$!']())
            };
            
            try {
              $send(reader, 'call', [inc_path, read_mode], ($$74 = function(f){var self = $$74.$$s || this, $c, $$75, dbl_co = nil, dbl_sb = nil;

              
                
                if (f == null) {
                  f = nil;
                };
                $c = ["::", "[]"], (dbl_co = $c[0]), (dbl_sb = $c[1]), $c;
                return $send(f, 'each_line', [], ($$75 = function(l){var self = $$75.$$s || this, $d, $e, $$76, this_tag = nil, include_cursor = nil, idx = nil;

                
                  
                  if (l == null) {
                    l = nil;
                  };
                  inc_lineno = $rb_plus(inc_lineno, 1);
                  if ($truthy(($truthy($d = ($truthy($e = l['$include?'](dbl_co)) ? l['$include?'](dbl_sb) : $e)) ? $$($nesting, 'TagDirectiveRx')['$=~'](l) : $d))) {
                    
                    this_tag = (($d = $gvars['~']) === nil ? nil : $d['$[]'](2));
                    if ($truthy((($d = $gvars['~']) === nil ? nil : $d['$[]'](1)))) {
                      if (this_tag['$=='](active_tag)) {
                        
                        tag_stack.$pop();
                        return $e = (function() {if ($truthy(tag_stack['$empty?']())) {
                          return [nil, base_select]
                        } else {
                          return tag_stack['$[]'](-1)
                        }; return nil; })(), $d = Opal.to_ary($e), (active_tag = ($d[0] == null ? nil : $d[0])), (select = ($d[1] == null ? nil : $d[1])), $e;
                      } else if ($truthy(inc_tags['$key?'](this_tag))) {
                        
                        include_cursor = self.$create_include_cursor(inc_path, expanded_target, inc_lineno);
                        if ($truthy((idx = $send(tag_stack, 'rindex', [], ($$76 = function(key){var self = $$76.$$s || this;

                        
                          
                          if (key == null) {
                            key = nil;
                          };
                          return key['$=='](this_tag);}, $$76.$$s = self, $$76.$$arity = 1, $$76.$$has_trailing_comma_in_args = true, $$76))))) {
                          
                          if (idx['$=='](0)) {
                            tag_stack.$shift()
                          } else {
                            
                            tag_stack.$delete_at(idx);
                          };
                          return self.$logger().$warn(self.$message_with_context("" + "mismatched end tag (expected '" + (active_tag) + "' but found '" + (this_tag) + "') at line " + (inc_lineno) + " of include " + (target_type) + ": " + (inc_path), $hash2(["source_location", "include_location"], {"source_location": self.$cursor(), "include_location": include_cursor})));
                        } else {
                          return self.$logger().$warn(self.$message_with_context("" + "unexpected end tag '" + (this_tag) + "' at line " + (inc_lineno) + " of include " + (target_type) + ": " + (inc_path), $hash2(["source_location", "include_location"], {"source_location": self.$cursor(), "include_location": include_cursor})))
                        };
                      } else {
                        return nil
                      }
                    } else if ($truthy(inc_tags['$key?'](this_tag))) {
                      
                      if ($truthy((select = inc_tags['$[]'](this_tag)))) {
                        tags_selected['$<<'](this_tag)};
                      return tag_stack['$<<']([(active_tag = this_tag), select, inc_lineno]);
                    } else if ($truthy(wildcard['$nil?']()['$!']())) {
                      
                      select = (function() {if ($truthy(($truthy($d = active_tag) ? select['$!']() : $d))) {
                        return false
                      } else {
                        return wildcard
                      }; return nil; })();
                      return tag_stack['$<<']([(active_tag = this_tag), select, inc_lineno]);
                    } else {
                      return nil
                    };
                  } else if ($truthy(select)) {
                    
                    inc_offset = ($truthy($d = inc_offset) ? $d : inc_lineno);
                    return inc_lines['$<<'](l);
                  } else {
                    return nil
                  };}, $$75.$$s = self, $$75.$$arity = 1, $$75));}, $$74.$$s = self, $$74.$$arity = 1, $$74))
            } catch ($err) {
              if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
                try {
                  
                  self.$logger().$error(self.$message_with_context("" + "include " + (target_type) + " not readable: " + (inc_path), $hash2(["source_location"], {"source_location": self.$cursor()})));
                  return self.$replace_next_line("" + "Unresolved directive in " + (self.path) + " - include::" + (expanded_target) + "[" + (attrlist) + "]");
                } finally { Opal.pop_exception() }
              } else { throw $err; }
            };;
            if ($truthy(tag_stack['$empty?']())) {
            } else {
              $send(tag_stack, 'each', [], ($$77 = function(tag_name, _, tag_lineno){var self = $$77.$$s || this;

              
                
                if (tag_name == null) {
                  tag_name = nil;
                };
                
                if (_ == null) {
                  _ = nil;
                };
                
                if (tag_lineno == null) {
                  tag_lineno = nil;
                };
                return self.$logger().$warn(self.$message_with_context("" + "detected unclosed tag '" + (tag_name) + "' starting at line " + (tag_lineno) + " of include " + (target_type) + ": " + (inc_path), $hash2(["source_location", "include_location"], {"source_location": self.$cursor(), "include_location": self.$create_include_cursor(inc_path, expanded_target, tag_lineno)})));}, $$77.$$s = self, $$77.$$arity = 3, $$77))
            };
            if ($truthy((missing_tags = $rb_minus($send(inc_tags, 'keep_if', [], ($$78 = function(_, v){var self = $$78.$$s || this;

            
              
              if (_ == null) {
                _ = nil;
              };
              
              if (v == null) {
                v = nil;
              };
              return v;}, $$78.$$s = self, $$78.$$arity = 2, $$78)).$keys(), tags_selected.$to_a()))['$empty?']())) {
            } else {
              self.$logger().$warn(self.$message_with_context("" + "tag" + ((function() {if ($truthy($rb_gt(missing_tags.$size(), 1))) {
                return "s"
              } else {
                return ""
              }; return nil; })()) + " '" + (missing_tags.$join(", ")) + "' not found in include " + (target_type) + ": " + (inc_path), $hash2(["source_location"], {"source_location": self.$cursor()})))
            };
            self.$shift();
            if ($truthy(inc_offset)) {
              
              if ($truthy(($truthy($a = ($truthy($b = base_select) ? wildcard['$!='](false) : $b)) ? inc_tags['$empty?']() : $a))) {
              } else {
                
                $writer = ["partial-option", ""];
                $send(parsed_attrs, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];
              };
              self.$push_include(inc_lines, inc_path, relpath, inc_offset, parsed_attrs);};
          } else {
            
            try {
              
              inc_content = $send(reader, 'call', [inc_path, read_mode], ($$79 = function(f){var self = $$79.$$s || this;

              
                
                if (f == null) {
                  f = nil;
                };
                return f.$read();}, $$79.$$s = self, $$79.$$arity = 1, $$79));
              self.$shift();
              self.$push_include(inc_content, inc_path, relpath, 1, parsed_attrs);
            } catch ($err) {
              if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
                try {
                  
                  self.$logger().$error(self.$message_with_context("" + "include " + (target_type) + " not readable: " + (inc_path), $hash2(["source_location"], {"source_location": self.$cursor()})));
                  return self.$replace_next_line("" + "Unresolved directive in " + (self.path) + " - include::" + (expanded_target) + "[" + (attrlist) + "]");
                } finally { Opal.pop_exception() }
              } else { throw $err; }
            };
          };
          return true;
        } else {
          return nil
        };
      }, $PreprocessorReader_preprocess_include_directive$66.$$arity = 2);
      
      Opal.def(self, '$resolve_include_path', $PreprocessorReader_resolve_include_path$80 = function $$resolve_include_path(target, attrlist, attributes) {
        var $a, $b, $$81, self = this, doc = nil, inc_path = nil, relpath = nil;

        
        doc = self.document;
        if ($truthy(($truthy($a = $$($nesting, 'Helpers')['$uriish?'](target)) ? $a : (function() {if ($truthy($$$('::', 'String')['$==='](self.dir))) {
          return nil
        } else {
          
          return (target = "" + (self.dir) + "/" + (target));
        }; return nil; })()))) {
          
          if ($truthy(doc['$attr?']("allow-uri-read"))) {
          } else {
            return self.$replace_next_line("" + "link:" + (target) + "[" + (attrlist) + "]")
          };
          if ($truthy(doc['$attr?']("cache-uri"))) {
            if ($truthy((($b = $$$('::', 'OpenURI', 'skip_raise')) && ($a = $$$($b, 'Cache', 'skip_raise')) ? 'constant' : nil))) {
            } else {
              $$($nesting, 'Helpers').$require_library("open-uri/cached", "open-uri-cached")
            }
          } else if ($truthy($$($nesting, 'RUBY_ENGINE_OPAL')['$!']())) {
            $$$('::', 'OpenURI')};
          return [$$$('::', 'URI').$parse(target), "uri", target];
        } else {
          
          inc_path = doc.$normalize_system_path(target, self.dir, nil, $hash2(["target_name"], {"target_name": "include file"}));
          if ($truthy($$$('::', 'File')['$file?'](inc_path))) {
          } else if ($truthy(attributes['$[]']("optional-option"))) {
            
            $send(self.$logger(), 'info', [], ($$81 = function(){var self = $$81.$$s || this;

            return self.$message_with_context("" + "optional include dropped because include file not found: " + (inc_path), $hash2(["source_location"], {"source_location": self.$cursor()}))}, $$81.$$s = self, $$81.$$arity = 0, $$81));
            self.$shift();
            return true;
          } else {
            
            self.$logger().$error(self.$message_with_context("" + "include file not found: " + (inc_path), $hash2(["source_location"], {"source_location": self.$cursor()})));
            return self.$replace_next_line("" + "Unresolved directive in " + (self.path) + " - include::" + (target) + "[" + (attrlist) + "]");
          };
          relpath = doc.$path_resolver().$relative_path(inc_path, doc.$base_dir());
          return [inc_path, "file", relpath];
        };
      }, $PreprocessorReader_resolve_include_path$80.$$arity = 3);
      
      Opal.def(self, '$pop_include', $PreprocessorReader_pop_include$82 = function $$pop_include() {
        var $a, $b, self = this;

        if ($truthy(self.include_stack['$empty?']())) {
          return nil
        } else {
          
          $b = self.include_stack.$pop(), $a = Opal.to_ary($b), (self.lines = ($a[0] == null ? nil : $a[0])), (self.file = ($a[1] == null ? nil : $a[1])), (self.dir = ($a[2] == null ? nil : $a[2])), (self.path = ($a[3] == null ? nil : $a[3])), (self.lineno = ($a[4] == null ? nil : $a[4])), (self.maxdepth = ($a[5] == null ? nil : $a[5])), (self.process_lines = ($a[6] == null ? nil : $a[6])), $b;
          self.look_ahead = 0;
          return nil;
        }
      }, $PreprocessorReader_pop_include$82.$$arity = 0);
      
      Opal.def(self, '$split_delimited_value', $PreprocessorReader_split_delimited_value$83 = function $$split_delimited_value(val) {
        var self = this;

        if ($truthy(val['$include?'](","))) {
          
          return val.$split(",");
        } else {
          
          return val.$split(";");
        }
      }, $PreprocessorReader_split_delimited_value$83.$$arity = 1);
      
      Opal.def(self, '$skip_front_matter!', $PreprocessorReader_skip_front_matter$excl$84 = function(data, increment_linenos) {
        var $a, $b, self = this, front_matter = nil, original_data = nil;

        
        
        if (increment_linenos == null) {
          increment_linenos = true;
        };
        front_matter = nil;
        if (data['$[]'](0)['$==']("---")) {
          
          original_data = data.$drop(0);
          data.$shift();
          front_matter = [];
          if ($truthy(increment_linenos)) {
            self.lineno = $rb_plus(self.lineno, 1)};
          while ($truthy(($truthy($b = data['$empty?']()['$!']()) ? data['$[]'](0)['$!=']("---") : $b))) {
            
            front_matter['$<<'](data.$shift());
            if ($truthy(increment_linenos)) {
              self.lineno = $rb_plus(self.lineno, 1)};
          };
          if ($truthy(data['$empty?']())) {
            
            $send(data, 'unshift', Opal.to_a(original_data));
            if ($truthy(increment_linenos)) {
              self.lineno = 0};
            front_matter = nil;
          } else {
            
            data.$shift();
            if ($truthy(increment_linenos)) {
              self.lineno = $rb_plus(self.lineno, 1)};
          };};
        return front_matter;
      }, $PreprocessorReader_skip_front_matter$excl$84.$$arity = -2);
      return (Opal.def(self, '$resolve_expr_val', $PreprocessorReader_resolve_expr_val$85 = function $$resolve_expr_val(val) {
        var $a, $b, self = this, quoted = nil;

        
        if ($truthy(($truthy($a = ($truthy($b = val['$start_with?']("\"")) ? val['$end_with?']("\"") : $b)) ? $a : ($truthy($b = val['$start_with?']("'")) ? val['$end_with?']("'") : $b)))) {
          
          quoted = true;
          val = val.$slice(1, $rb_minus(val.$length(), 1));
        } else {
          quoted = false
        };
        if ($truthy(val['$include?']($$($nesting, 'ATTR_REF_HEAD')))) {
          val = self.document.$sub_attributes(val, $hash2(["attribute_missing"], {"attribute_missing": "drop"}))};
        if ($truthy(quoted)) {
          return val
        } else if ($truthy(val['$empty?']())) {
          return nil
        } else if (val['$==']("true")) {
          return true
        } else if (val['$==']("false")) {
          return false
        } else if ($truthy(val.$rstrip()['$empty?']())) {
          return " "
        } else if ($truthy(val['$include?']("."))) {
          return val.$to_f()
        } else {
          return val.$to_i()
        };
      }, $PreprocessorReader_resolve_expr_val$85.$$arity = 1), nil) && 'resolve_expr_val';
    })($nesting[0], $$($nesting, 'Reader'), $nesting);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/section"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_accessor', '$attr_reader', '$===', '$+', '$level', '$special', '$generate_id', '$title', '$>', '$==', '$sectnum', '$reftext', '$!', '$empty?', '$sub_placeholder', '$sub_quotes', '$compat_mode', '$[]', '$attributes', '$context', '$assign_numeral', '$class', '$object_id', '$inspect', '$size', '$length', '$chr', '$[]=', '$-', '$gsub', '$downcase', '$delete', '$tr_s', '$end_with?', '$chop', '$start_with?', '$slice', '$key?', '$catalog', '$unique_id_start_index']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Section');

      var $nesting = [self].concat($parent_nesting), $Section_initialize$1, $Section_generate_id$2, $Section_sections$ques$3, $Section_sectnum$4, $Section_xreftext$5, $Section_$lt$lt$6, $Section_to_s$7, $Section_generate_id$8;

      self.$$prototype.document = self.$$prototype.next_section_index = self.$$prototype.level = self.$$prototype.parent = self.$$prototype.numeral = self.$$prototype.numbered = self.$$prototype.sectname = self.$$prototype.title = self.$$prototype.blocks = nil;
      
      self.$attr_accessor("index");
      self.$attr_accessor("sectname");
      self.$attr_accessor("special");
      self.$attr_accessor("numbered");
      self.$attr_reader("caption");
      
      Opal.def(self, '$initialize', $Section_initialize$1 = function $$initialize(parent, level, numbered, opts) {
        var $a, $b, $iter = $Section_initialize$1.$$p, $yield = $iter || nil, self = this;

        if ($iter) $Section_initialize$1.$$p = null;
        
        
        if (parent == null) {
          parent = nil;
        };
        
        if (level == null) {
          level = nil;
        };
        
        if (numbered == null) {
          numbered = false;
        };
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        $send(self, Opal.find_super_dispatcher(self, 'initialize', $Section_initialize$1, false), [parent, "section", opts], null);
        if ($truthy($$($nesting, 'Section')['$==='](parent))) {
          $a = [($truthy($b = level) ? $b : $rb_plus(parent.$level(), 1)), parent.$special()], (self.level = $a[0]), (self.special = $a[1]), $a
        } else {
          $a = [($truthy($b = level) ? $b : 1), false], (self.level = $a[0]), (self.special = $a[1]), $a
        };
        self.numbered = numbered;
        return (self.index = 0);
      }, $Section_initialize$1.$$arity = -1);
      Opal.alias(self, "name", "title");
      
      Opal.def(self, '$generate_id', $Section_generate_id$2 = function $$generate_id() {
        var self = this;

        return $$($nesting, 'Section').$generate_id(self.$title(), self.document)
      }, $Section_generate_id$2.$$arity = 0);
      
      Opal.def(self, '$sections?', $Section_sections$ques$3 = function() {
        var self = this;

        return $rb_gt(self.next_section_index, 0)
      }, $Section_sections$ques$3.$$arity = 0);
      
      Opal.def(self, '$sectnum', $Section_sectnum$4 = function $$sectnum(delimiter, append) {
        var $a, self = this;

        
        
        if (delimiter == null) {
          delimiter = ".";
        };
        
        if (append == null) {
          append = nil;
        };
        append = ($truthy($a = append) ? $a : (function() {if (append['$=='](false)) {
          return ""
        } else {
          return delimiter
        }; return nil; })());
        if ($truthy(($truthy($a = $rb_gt(self.level, 1)) ? $$($nesting, 'Section')['$==='](self.parent) : $a))) {
          return "" + (self.parent.$sectnum(delimiter, delimiter)) + (self.numeral) + (append)
        } else {
          return "" + (self.numeral) + (append)
        };
      }, $Section_sectnum$4.$$arity = -1);
      
      Opal.def(self, '$xreftext', $Section_xreftext$5 = function $$xreftext(xrefstyle) {
        var $a, self = this, val = nil, $case = nil, type = nil, quoted_title = nil, signifier = nil;

        
        
        if (xrefstyle == null) {
          xrefstyle = nil;
        };
        if ($truthy(($truthy($a = (val = self.$reftext())) ? val['$empty?']()['$!']() : $a))) {
          return val
        } else if ($truthy(xrefstyle)) {
          if ($truthy(self.numbered)) {
            return (function() {$case = xrefstyle;
            if ("full"['$===']($case)) {
            if ($truthy(($truthy($a = (type = self.sectname)['$==']("chapter")) ? $a : type['$==']("appendix")))) {
              quoted_title = self.$sub_placeholder(self.$sub_quotes("_%s_"), self.$title())
            } else {
              quoted_title = self.$sub_placeholder(self.$sub_quotes((function() {if ($truthy(self.document.$compat_mode())) {
                return "``%s''"
              } else {
                return "\"`%s`\""
              }; return nil; })()), self.$title())
            };
            if ($truthy((signifier = self.document.$attributes()['$[]']("" + (type) + "-refsig")))) {
              return "" + (signifier) + " " + (self.$sectnum(".", ",")) + " " + (quoted_title)
            } else {
              return "" + (self.$sectnum(".", ",")) + " " + (quoted_title)
            };}
            else if ("short"['$===']($case)) {if ($truthy((signifier = self.document.$attributes()['$[]']("" + (self.sectname) + "-refsig")))) {
              return "" + (signifier) + " " + (self.$sectnum(".", ""))
            } else {
              return self.$sectnum(".", "")
            }}
            else {if ($truthy(($truthy($a = (type = self.sectname)['$==']("chapter")) ? $a : type['$==']("appendix")))) {
              
              return self.$sub_placeholder(self.$sub_quotes("_%s_"), self.$title());
            } else {
              return self.$title()
            }}})()
          } else if ($truthy(($truthy($a = (type = self.sectname)['$==']("chapter")) ? $a : type['$==']("appendix")))) {
            
            return self.$sub_placeholder(self.$sub_quotes("_%s_"), self.$title());
          } else {
            return self.$title()
          }
        } else {
          return self.$title()
        };
      }, $Section_xreftext$5.$$arity = -1);
      
      Opal.def(self, '$<<', $Section_$lt$lt$6 = function(block) {
        var $iter = $Section_$lt$lt$6.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $Section_$lt$lt$6.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        if (block.$context()['$==']("section")) {
          self.$assign_numeral(block)};
        return $send(self, Opal.find_super_dispatcher(self, '<<', $Section_$lt$lt$6, false), $zuper, $iter);
      }, $Section_$lt$lt$6.$$arity = 1);
      
      Opal.def(self, '$to_s', $Section_to_s$7 = function $$to_s() {
        var $iter = $Section_to_s$7.$$p, $yield = $iter || nil, self = this, formal_title = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $Section_to_s$7.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        if ($truthy(self.title)) {
          
          formal_title = (function() {if ($truthy(self.numbered)) {
            return "" + (self.$sectnum()) + " " + (self.title)
          } else {
            return self.title
          }; return nil; })();
          return "" + "#<" + (self.$class()) + "@" + (self.$object_id()) + " {level: " + (self.level) + ", title: " + (formal_title.$inspect()) + ", blocks: " + (self.blocks.$size()) + "}>";
        } else {
          return $send(self, Opal.find_super_dispatcher(self, 'to_s', $Section_to_s$7, false), $zuper, $iter)
        }
      }, $Section_to_s$7.$$arity = 0);
      return (Opal.defs(self, '$generate_id', $Section_generate_id$8 = function $$generate_id(title, document) {
        var $a, $b, self = this, attrs = nil, pre = nil, sep = nil, no_sep = nil, $writer = nil, sep_sub = nil, gen_id = nil, ids = nil, cnt = nil, candidate_id = nil;

        
        attrs = document.$attributes();
        pre = ($truthy($a = attrs['$[]']("idprefix")) ? $a : "_");
        if ($truthy((sep = attrs['$[]']("idseparator")))) {
          if ($truthy(($truthy($a = sep.$length()['$=='](1)) ? $a : ($truthy($b = (no_sep = sep['$empty?']())['$!']()) ? (sep = (($writer = ["idseparator", sep.$chr()]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])) : $b)))) {
            sep_sub = (function() {if ($truthy(($truthy($a = sep['$==']("-")) ? $a : sep['$=='](".")))) {
              return " .-"
            } else {
              return "" + " " + (sep) + ".-"
            }; return nil; })()}
        } else {
          $a = ["_", " _.-"], (sep = $a[0]), (sep_sub = $a[1]), $a
        };
        gen_id = "" + (pre) + (title.$downcase().$gsub($$($nesting, 'InvalidSectionIdCharsRx'), ""));
        if ($truthy(no_sep)) {
          gen_id = gen_id.$delete(" ")
        } else {
          
          gen_id = gen_id.$tr_s(sep_sub, sep);
          if ($truthy(gen_id['$end_with?'](sep))) {
            gen_id = gen_id.$chop()};
          if ($truthy(($truthy($a = pre['$empty?']()) ? gen_id['$start_with?'](sep) : $a))) {
            gen_id = gen_id.$slice(1, gen_id.$length())};
        };
        if ($truthy(document.$catalog()['$[]']("refs")['$key?'](gen_id))) {
          
          ids = document.$catalog()['$[]']("refs");
          cnt = $$($nesting, 'Compliance').$unique_id_start_index();
          while ($truthy(ids['$[]']((candidate_id = "" + (gen_id) + (sep) + (cnt))))) {
            cnt = $rb_plus(cnt, 1)
          };
          return candidate_id;
        } else {
          return gen_id
        };
      }, $Section_generate_id$8.$$arity = 2), nil) && 'generate_id';
    })($nesting[0], $$($nesting, 'AbstractBlock'), $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/stylesheets"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$join', '$new', '$rstrip', '$read', '$primary_stylesheet_data', '$write', '$primary_stylesheet_name', '$stylesheet_basename', '$for', '$read_stylesheet', '$coderay_stylesheet_data', '$coderay_stylesheet_name', '$pygments_stylesheet_data', '$pygments_stylesheet_name']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Stylesheets');

      var $nesting = [self].concat($parent_nesting), $Stylesheets_instance$1, $Stylesheets_primary_stylesheet_name$2, $Stylesheets_primary_stylesheet_data$3, $Stylesheets_embed_primary_stylesheet$4, $Stylesheets_write_primary_stylesheet$5, $Stylesheets_coderay_stylesheet_name$6, $Stylesheets_coderay_stylesheet_data$7, $Stylesheets_embed_coderay_stylesheet$8, $Stylesheets_write_coderay_stylesheet$9, $Stylesheets_pygments_stylesheet_name$10, $Stylesheets_pygments_stylesheet_data$11, $Stylesheets_embed_pygments_stylesheet$12, $Stylesheets_write_pygments_stylesheet$13;

      self.$$prototype.primary_stylesheet_data = nil;
      
      Opal.const_set($nesting[0], 'DEFAULT_STYLESHEET_NAME', "asciidoctor.css");
      Opal.const_set($nesting[0], 'STYLESHEETS_DIR', $$$('::', 'File').$join($$($nesting, 'DATA_DIR'), "stylesheets"));
      self.__instance__ = self.$new();
      Opal.defs(self, '$instance', $Stylesheets_instance$1 = function $$instance() {
        var self = this;
        if (self.__instance__ == null) self.__instance__ = nil;

        return self.__instance__
      }, $Stylesheets_instance$1.$$arity = 0);
      
      Opal.def(self, '$primary_stylesheet_name', $Stylesheets_primary_stylesheet_name$2 = function $$primary_stylesheet_name() {
        var self = this;

        return $$($nesting, 'DEFAULT_STYLESHEET_NAME')
      }, $Stylesheets_primary_stylesheet_name$2.$$arity = 0);
      
      Opal.def(self, '$primary_stylesheet_data', $Stylesheets_primary_stylesheet_data$3 = function $$primary_stylesheet_data() {
        var $a, self = this;

        return (self.primary_stylesheet_data = ($truthy($a = self.primary_stylesheet_data) ? $a : $$$('::', 'File').$read($$$('::', 'File').$join($$($nesting, 'STYLESHEETS_DIR'), "asciidoctor-default.css"), $hash2(["mode"], {"mode": $$($nesting, 'FILE_READ_MODE')})).$rstrip()))
      }, $Stylesheets_primary_stylesheet_data$3.$$arity = 0);
      
      Opal.def(self, '$embed_primary_stylesheet', $Stylesheets_embed_primary_stylesheet$4 = function $$embed_primary_stylesheet() {
        var self = this;

        return "" + "<style>\n" + (self.$primary_stylesheet_data()) + "\n" + "</style>"
      }, $Stylesheets_embed_primary_stylesheet$4.$$arity = 0);
      
      Opal.def(self, '$write_primary_stylesheet', $Stylesheets_write_primary_stylesheet$5 = function $$write_primary_stylesheet(target_dir) {
        var self = this;

        
        
        if (target_dir == null) {
          target_dir = ".";
        };
        return $$$('::', 'File').$write($$$('::', 'File').$join(target_dir, self.$primary_stylesheet_name()), self.$primary_stylesheet_data(), $hash2(["mode"], {"mode": $$($nesting, 'FILE_WRITE_MODE')}));
      }, $Stylesheets_write_primary_stylesheet$5.$$arity = -1);
      
      Opal.def(self, '$coderay_stylesheet_name', $Stylesheets_coderay_stylesheet_name$6 = function $$coderay_stylesheet_name() {
        var self = this;

        return $$($nesting, 'SyntaxHighlighter').$for("coderay").$stylesheet_basename()
      }, $Stylesheets_coderay_stylesheet_name$6.$$arity = 0);
      
      Opal.def(self, '$coderay_stylesheet_data', $Stylesheets_coderay_stylesheet_data$7 = function $$coderay_stylesheet_data() {
        var self = this;

        return $$($nesting, 'SyntaxHighlighter').$for("coderay").$read_stylesheet()
      }, $Stylesheets_coderay_stylesheet_data$7.$$arity = 0);
      
      Opal.def(self, '$embed_coderay_stylesheet', $Stylesheets_embed_coderay_stylesheet$8 = function $$embed_coderay_stylesheet() {
        var self = this;

        return "" + "<style>\n" + (self.$coderay_stylesheet_data()) + "\n" + "</style>"
      }, $Stylesheets_embed_coderay_stylesheet$8.$$arity = 0);
      
      Opal.def(self, '$write_coderay_stylesheet', $Stylesheets_write_coderay_stylesheet$9 = function $$write_coderay_stylesheet(target_dir) {
        var self = this;

        
        
        if (target_dir == null) {
          target_dir = ".";
        };
        return $$$('::', 'File').$write($$$('::', 'File').$join(target_dir, self.$coderay_stylesheet_name()), self.$coderay_stylesheet_data(), $hash2(["mode"], {"mode": $$($nesting, 'FILE_WRITE_MODE')}));
      }, $Stylesheets_write_coderay_stylesheet$9.$$arity = -1);
      
      Opal.def(self, '$pygments_stylesheet_name', $Stylesheets_pygments_stylesheet_name$10 = function $$pygments_stylesheet_name(style) {
        var self = this;

        
        
        if (style == null) {
          style = nil;
        };
        return $$($nesting, 'SyntaxHighlighter').$for("pygments").$stylesheet_basename(style);
      }, $Stylesheets_pygments_stylesheet_name$10.$$arity = -1);
      
      Opal.def(self, '$pygments_stylesheet_data', $Stylesheets_pygments_stylesheet_data$11 = function $$pygments_stylesheet_data(style) {
        var self = this;

        
        
        if (style == null) {
          style = nil;
        };
        return $$($nesting, 'SyntaxHighlighter').$for("pygments").$read_stylesheet(style);
      }, $Stylesheets_pygments_stylesheet_data$11.$$arity = -1);
      
      Opal.def(self, '$embed_pygments_stylesheet', $Stylesheets_embed_pygments_stylesheet$12 = function $$embed_pygments_stylesheet(style) {
        var self = this;

        
        
        if (style == null) {
          style = nil;
        };
        return "" + "<style>\n" + (self.$pygments_stylesheet_data(style)) + "\n" + "</style>";
      }, $Stylesheets_embed_pygments_stylesheet$12.$$arity = -1);
      return (Opal.def(self, '$write_pygments_stylesheet', $Stylesheets_write_pygments_stylesheet$13 = function $$write_pygments_stylesheet(target_dir, style) {
        var self = this;

        
        
        if (target_dir == null) {
          target_dir = ".";
        };
        
        if (style == null) {
          style = nil;
        };
        return $$$('::', 'File').$write($$$('::', 'File').$join(target_dir, self.$pygments_stylesheet_name(style)), self.$pygments_stylesheet_data(style), $hash2(["mode"], {"mode": $$($nesting, 'FILE_WRITE_MODE')}));
      }, $Stylesheets_write_pygments_stylesheet$13.$$arity = -1), nil) && 'write_pygments_stylesheet';
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/table"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$attr_accessor', '$attr_reader', '$new', '$[]', '$>', '$to_i', '$<', '$==', '$[]=', '$-', '$attributes', '$truncate', '$*', '$/', '$to_f', '$empty?', '$body', '$each', '$<<', '$size', '$+', '$assign_column_widths', '$warn', '$logger', '$update_attributes', '$assign_width', '$round', '$map', '$shift', '$reinitialize', '$head=', '$nil?', '$unshift', '$pop', '$foot=', '$parent', '$sourcemap', '$dup', '$header_row?', '$table', '$style', '$merge', '$delete', '$===', '$start_with?', '$rstrip', '$slice', '$length', '$advance', '$lstrip', '$strip', '$split', '$include?', '$readlines', '$catalog_inline_anchor', '$=~', '$apply_subs', '$attr_writer', '$convert', '$text', '$!=', '$file', '$lineno', '$include', '$to_set', '$mark', '$key?', '$nested?', '$document', '$error', '$message_with_context', '$cursor_at_prev_line', '$nil_or_empty?', '$escape', '$columns', '$match', '$chop', '$end_with?', '$gsub', '$!', '$push_cellspec', '$cell_open?', '$close_cell', '$take_cellspec', '$squeeze', '$upto', '$times', '$cursor_before_mark', '$rowspan', '$activate_rowspan', '$colspan', '$end_of_row?', '$close_row', '$private', '$rows', '$effective_column_visits']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Table');

      var $nesting = [self].concat($parent_nesting), $Table_initialize$4, $Table_header_row$ques$5, $Table_create_columns$6, $Table_assign_column_widths$8, $Table_partition_header_footer$12;

      self.$$prototype.attributes = self.$$prototype.document = self.$$prototype.has_header_option = self.$$prototype.rows = self.$$prototype.columns = nil;
      
      Opal.const_set($nesting[0], 'DEFAULT_PRECISION', 4);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Rows');

        var $nesting = [self].concat($parent_nesting), $Rows_initialize$1, $Rows_by_section$2, $Rows_to_h$3;

        self.$$prototype.head = self.$$prototype.body = self.$$prototype.foot = nil;
        
        self.$attr_accessor("head", "foot", "body");
        
        Opal.def(self, '$initialize', $Rows_initialize$1 = function $$initialize(head, foot, body) {
          var self = this;

          
          
          if (head == null) {
            head = [];
          };
          
          if (foot == null) {
            foot = [];
          };
          
          if (body == null) {
            body = [];
          };
          self.head = head;
          self.foot = foot;
          return (self.body = body);
        }, $Rows_initialize$1.$$arity = -1);
        Opal.alias(self, "[]", "send");
        
        Opal.def(self, '$by_section', $Rows_by_section$2 = function $$by_section() {
          var self = this;

          return [["head", self.head], ["body", self.body], ["foot", self.foot]]
        }, $Rows_by_section$2.$$arity = 0);
        return (Opal.def(self, '$to_h', $Rows_to_h$3 = function $$to_h() {
          var self = this;

          return $hash2(["head", "body", "foot"], {"head": self.head, "body": self.body, "foot": self.foot})
        }, $Rows_to_h$3.$$arity = 0), nil) && 'to_h';
      })($nesting[0], null, $nesting);
      self.$attr_accessor("columns");
      self.$attr_accessor("rows");
      self.$attr_accessor("has_header_option");
      self.$attr_reader("caption");
      
      Opal.def(self, '$initialize', $Table_initialize$4 = function $$initialize(parent, attributes) {
        var $a, $b, $iter = $Table_initialize$4.$$p, $yield = $iter || nil, self = this, pcwidth = nil, pcwidth_intval = nil, $writer = nil, abswidth_val = nil;

        if ($iter) $Table_initialize$4.$$p = null;
        
        $send(self, Opal.find_super_dispatcher(self, 'initialize', $Table_initialize$4, false), [parent, "table"], null);
        self.rows = $$($nesting, 'Rows').$new();
        self.columns = [];
        self.has_header_option = false;
        if ($truthy((pcwidth = attributes['$[]']("width")))) {
          if ($truthy(($truthy($a = $rb_gt((pcwidth_intval = pcwidth.$to_i()), 100)) ? $a : $rb_lt(pcwidth_intval, 1)))) {
            if ($truthy((($a = pcwidth_intval['$=='](0)) ? ($truthy($b = pcwidth['$==']("0")) ? $b : pcwidth['$==']("0%")) : pcwidth_intval['$=='](0)))) {
            } else {
              pcwidth_intval = 100
            }}
        } else {
          pcwidth_intval = 100
        };
        
        $writer = ["tablepcwidth", pcwidth_intval];
        $send(self.attributes, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        if ($truthy(self.document.$attributes()['$[]']("pagewidth"))) {
          
          $writer = ["tableabswidth", (function() {if ((abswidth_val = $rb_times($rb_divide(pcwidth_intval, 100), self.document.$attributes()['$[]']("pagewidth").$to_f()).$truncate($$($nesting, 'DEFAULT_PRECISION')))['$=='](abswidth_val.$to_i())) {
            return abswidth_val.$to_i()
          } else {
            return abswidth_val
          }; return nil; })()];
          $send(self.attributes, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        if ($truthy(attributes['$[]']("rotate-option"))) {
          
          $writer = ["orientation", "landscape"];
          $send(self.attributes, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        } else {
          return nil
        };
      }, $Table_initialize$4.$$arity = 2);
      
      Opal.def(self, '$header_row?', $Table_header_row$ques$5 = function() {
        var $a, self = this, val = nil;

        if ($truthy(($truthy($a = (val = self.has_header_option)) ? self.rows.$body()['$empty?']() : $a))) {
          return val
        } else {
          return nil
        }
      }, $Table_header_row$ques$5.$$arity = 0);
      
      Opal.def(self, '$create_columns', $Table_create_columns$6 = function $$create_columns(colspecs) {
        var $$7, $a, self = this, cols = nil, autowidth_cols = nil, width_base = nil, num_cols = nil, $writer = nil;

        
        cols = [];
        autowidth_cols = nil;
        width_base = 0;
        $send(colspecs, 'each', [], ($$7 = function(colspec){var self = $$7.$$s || this, $a, colwidth = nil;

        
          
          if (colspec == null) {
            colspec = nil;
          };
          colwidth = colspec['$[]']("width");
          cols['$<<']($$($nesting, 'Column').$new(self, cols.$size(), colspec));
          if ($truthy($rb_lt(colwidth, 0))) {
            return (autowidth_cols = ($truthy($a = autowidth_cols) ? $a : []))['$<<'](cols['$[]'](-1))
          } else {
            return (width_base = $rb_plus(width_base, colwidth))
          };}, $$7.$$s = self, $$7.$$arity = 1, $$7));
        if ($truthy($rb_gt((num_cols = (self.columns = cols).$size()), 0))) {
          
          
          $writer = ["colcount", num_cols];
          $send(self.attributes, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          if ($truthy(($truthy($a = $rb_gt(width_base, 0)) ? $a : autowidth_cols))) {
          } else {
            width_base = nil
          };
          self.$assign_column_widths(width_base, autowidth_cols);};
        return nil;
      }, $Table_create_columns$6.$$arity = 1);
      
      Opal.def(self, '$assign_column_widths', $Table_assign_column_widths$8 = function $$assign_column_widths(width_base, autowidth_cols) {
        var $$9, $$10, $$11, self = this, precision = nil, total_width = nil, col_pcwidth = nil, autowidth = nil, autowidth_attrs = nil;

        
        
        if (width_base == null) {
          width_base = nil;
        };
        
        if (autowidth_cols == null) {
          autowidth_cols = nil;
        };
        precision = $$($nesting, 'DEFAULT_PRECISION');
        total_width = (col_pcwidth = 0);
        if ($truthy(width_base)) {
          
          if ($truthy(autowidth_cols)) {
            
            if ($truthy($rb_gt(width_base, 100))) {
              
              autowidth = 0;
              self.$logger().$warn("" + "total column width must not exceed 100% when using autowidth columns; got " + (width_base) + "%");
            } else {
              
              autowidth = $rb_divide($rb_minus(100, width_base), autowidth_cols.$size()).$truncate(precision);
              if (autowidth.$to_i()['$=='](autowidth)) {
                autowidth = autowidth.$to_i()};
              width_base = 100;
            };
            autowidth_attrs = $hash2(["width", "autowidth-option"], {"width": autowidth, "autowidth-option": ""});
            $send(autowidth_cols, 'each', [], ($$9 = function(col){var self = $$9.$$s || this;

            
              
              if (col == null) {
                col = nil;
              };
              return col.$update_attributes(autowidth_attrs);}, $$9.$$s = self, $$9.$$arity = 1, $$9));};
          $send(self.columns, 'each', [], ($$10 = function(col){var self = $$10.$$s || this;

          
            
            if (col == null) {
              col = nil;
            };
            return (total_width = $rb_plus(total_width, (col_pcwidth = col.$assign_width(nil, width_base, precision))));}, $$10.$$s = self, $$10.$$arity = 1, $$10));
        } else {
          
          col_pcwidth = $rb_divide(100, self.columns.$size()).$truncate(precision);
          if (col_pcwidth.$to_i()['$=='](col_pcwidth)) {
            col_pcwidth = col_pcwidth.$to_i()};
          $send(self.columns, 'each', [], ($$11 = function(col){var self = $$11.$$s || this;

          
            
            if (col == null) {
              col = nil;
            };
            return (total_width = $rb_plus(total_width, col.$assign_width(col_pcwidth, nil, precision)));}, $$11.$$s = self, $$11.$$arity = 1, $$11));
        };
        if (total_width['$=='](100)) {
        } else {
          self.columns['$[]'](-1).$assign_width($rb_plus($rb_minus(100, total_width), col_pcwidth).$round(precision), nil, precision)
        };
        return nil;
      }, $Table_assign_column_widths$8.$$arity = -1);
      return (Opal.def(self, '$partition_header_footer', $Table_partition_header_footer$12 = function $$partition_header_footer(attrs) {
        var $$13, $$14, $a, self = this, num_body_rows = nil, $writer = nil, body = nil;

        
        num_body_rows = (($writer = ["rowcount", (body = self.rows.$body()).$size()]), $send(self.attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]);
        if ($truthy($rb_gt(num_body_rows, 0))) {
          if ($truthy(self.has_header_option)) {
            
            
            $writer = [[$send(body.$shift(), 'map', [], ($$13 = function(cell){var self = $$13.$$s || this;

            
              
              if (cell == null) {
                cell = nil;
              };
              return cell.$reinitialize(true);}, $$13.$$s = self, $$13.$$arity = 1, $$13))]];
            $send(self.rows, 'head=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            num_body_rows = $rb_minus(num_body_rows, 1);
          } else if ($truthy(self.has_header_option['$nil?']())) {
            
            self.has_header_option = false;
            body.$unshift($send(body.$shift(), 'map', [], ($$14 = function(cell){var self = $$14.$$s || this;

            
              
              if (cell == null) {
                cell = nil;
              };
              return cell.$reinitialize(false);}, $$14.$$s = self, $$14.$$arity = 1, $$14)));}};
        if ($truthy(($truthy($a = $rb_gt(num_body_rows, 0)) ? attrs['$[]']("footer-option") : $a))) {
          
          $writer = [[body.$pop()]];
          $send(self.rows, 'foot=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        return nil;
      }, $Table_partition_header_footer$12.$$arity = 1), nil) && 'partition_header_footer';
    })($nesting[0], $$($nesting, 'AbstractBlock'), $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Column');

      var $nesting = [self].concat($parent_nesting), $Column_initialize$15, $Column_assign_width$16, $Column_block$ques$17, $Column_inline$ques$18;

      self.$$prototype.attributes = nil;
      
      self.$attr_accessor("style");
      
      Opal.def(self, '$initialize', $Column_initialize$15 = function $$initialize(table, index, attributes) {
        var $a, $iter = $Column_initialize$15.$$p, $yield = $iter || nil, self = this, $writer = nil;

        if ($iter) $Column_initialize$15.$$p = null;
        
        
        if (attributes == null) {
          attributes = $hash2([], {});
        };
        $send(self, Opal.find_super_dispatcher(self, 'initialize', $Column_initialize$15, false), [table, "table_column"], null);
        self.style = attributes['$[]']("style");
        
        $writer = ["colnumber", $rb_plus(index, 1)];
        $send(attributes, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        ($truthy($a = attributes['$[]']("width")) ? $a : (($writer = ["width", 1]), $send(attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        ($truthy($a = attributes['$[]']("halign")) ? $a : (($writer = ["halign", "left"]), $send(attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        ($truthy($a = attributes['$[]']("valign")) ? $a : (($writer = ["valign", "top"]), $send(attributes, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        return self.$update_attributes(attributes);
      }, $Column_initialize$15.$$arity = -3);
      Opal.alias(self, "table", "parent");
      
      Opal.def(self, '$assign_width', $Column_assign_width$16 = function $$assign_width(col_pcwidth, width_base, precision) {
        var self = this, $writer = nil, col_abswidth = nil;

        
        if ($truthy(width_base)) {
          
          col_pcwidth = $rb_divide($rb_times(self.attributes['$[]']("width").$to_f(), 100), width_base).$truncate(precision);
          if (col_pcwidth.$to_i()['$=='](col_pcwidth)) {
            col_pcwidth = col_pcwidth.$to_i()};};
        if ($truthy(self.$parent().$attributes()['$[]']("tableabswidth"))) {
          
          $writer = ["colabswidth", (function() {if ((col_abswidth = $rb_times($rb_divide(col_pcwidth, 100), self.$parent().$attributes()['$[]']("tableabswidth")).$truncate(precision))['$=='](col_abswidth.$to_i())) {
            return col_abswidth.$to_i()
          } else {
            return col_abswidth
          }; return nil; })()];
          $send(self.attributes, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        
        $writer = ["colpcwidth", col_pcwidth];
        $send(self.attributes, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];;
      }, $Column_assign_width$16.$$arity = 3);
      
      Opal.def(self, '$block?', $Column_block$ques$17 = function() {
        var self = this;

        return false
      }, $Column_block$ques$17.$$arity = 0);
      return (Opal.def(self, '$inline?', $Column_inline$ques$18 = function() {
        var self = this;

        return false
      }, $Column_inline$ques$18.$$arity = 0), nil) && 'inline?';
    })($$($nesting, 'Table'), $$($nesting, 'AbstractNode'), $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Cell');

      var $nesting = [self].concat($parent_nesting), $Cell_initialize$19, $Cell_reinitialize$20, $Cell_catalog_inline_anchor$21, $Cell_text$22, $Cell_content$23, $Cell_lines$25, $Cell_source$26, $Cell_file$27, $Cell_lineno$28, $Cell_to_s$29;

      self.$$prototype.document = self.$$prototype.reinitialize_args = self.$$prototype.attributes = self.$$prototype.cursor = self.$$prototype.text = self.$$prototype.subs = self.$$prototype.style = self.$$prototype.inner_document = self.$$prototype.source_location = self.$$prototype.colspan = self.$$prototype.rowspan = nil;
      
      Opal.const_set($nesting[0], 'DOUBLE_LF', $rb_times($$($nesting, 'LF'), 2));
      self.$attr_accessor("colspan");
      self.$attr_accessor("rowspan");
      Opal.alias(self, "column", "parent");
      self.$attr_reader("inner_document");
      
      Opal.def(self, '$initialize', $Cell_initialize$19 = function $$initialize(column, cell_text, attributes, opts) {
        var $a, $b, $c, $iter = $Cell_initialize$19.$$p, $yield = $iter || nil, self = this, in_header_row = nil, cell_style = nil, $case = nil, asciidoc = nil, inner_document_cursor = nil, lines_advanced = nil, literal = nil, normal_psv = nil, parent_doctitle = nil, inner_document_lines = nil, unprocessed_line1 = nil, preprocessed_lines = nil, $writer = nil;

        if ($iter) $Cell_initialize$19.$$p = null;
        
        
        if (attributes == null) {
          attributes = $hash2([], {});
        };
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        $send(self, Opal.find_super_dispatcher(self, 'initialize', $Cell_initialize$19, false), [column, "table_cell"], null);
        self.cursor = (self.reinitialize_args = nil);
        if ($truthy(self.document.$sourcemap())) {
          self.source_location = opts['$[]']("cursor").$dup()};
        if ($truthy(column)) {
          
          if ($truthy((in_header_row = column.$table()['$header_row?']()))) {
            if ($truthy((($a = in_header_row['$==']("implicit")) ? (cell_style = ($truthy($b = column.$style()) ? $b : ($truthy($c = attributes) ? attributes['$[]']("style") : $c))) : in_header_row['$==']("implicit")))) {
              
              if ($truthy(($truthy($a = cell_style['$==']("asciidoc")) ? $a : cell_style['$==']("literal")))) {
                self.reinitialize_args = [column, cell_text, ($truthy($a = attributes) ? attributes.$merge() : $a), opts]};
              cell_style = nil;}
          } else {
            cell_style = column.$style()
          };
          self.$update_attributes(column.$attributes());};
        if ($truthy(attributes)) {
          
          if ($truthy(attributes['$empty?']())) {
            self.colspan = (self.rowspan = nil)
          } else {
            
            $a = [attributes.$delete("colspan"), attributes.$delete("rowspan")], (self.colspan = $a[0]), (self.rowspan = $a[1]), $a;
            if ($truthy(in_header_row)) {
            } else {
              cell_style = ($truthy($a = attributes['$[]']("style")) ? $a : cell_style)
            };
            self.$update_attributes(attributes);
          };
          $case = cell_style;
          if ("asciidoc"['$===']($case)) {
          asciidoc = true;
          inner_document_cursor = opts['$[]']("cursor");
          if ($truthy((cell_text = cell_text.$rstrip())['$start_with?']($$($nesting, 'LF')))) {
            
            lines_advanced = 1;
            while ($truthy((cell_text = cell_text.$slice(1, cell_text.$length()))['$start_with?']($$($nesting, 'LF')))) {
              lines_advanced = $rb_plus(lines_advanced, 1)
            };
            inner_document_cursor.$advance(lines_advanced);
          } else {
            cell_text = cell_text.$lstrip()
          };}
          else if ("literal"['$===']($case)) {
          literal = true;
          cell_text = cell_text.$rstrip();
          while ($truthy(cell_text['$start_with?']($$($nesting, 'LF')))) {
            cell_text = cell_text.$slice(1, cell_text.$length())
          };}
          else {
          normal_psv = true;
          cell_text = (function() {if ($truthy(cell_text)) {
            return cell_text.$strip()
          } else {
            return ""
          }; return nil; })();};
        } else {
          
          self.colspan = (self.rowspan = nil);
          if (cell_style['$==']("asciidoc")) {
            
            asciidoc = true;
            inner_document_cursor = opts['$[]']("cursor");};
        };
        if ($truthy(asciidoc)) {
          
          parent_doctitle = self.document.$attributes().$delete("doctitle");
          inner_document_lines = cell_text.$split($$($nesting, 'LF'), -1);
          if ($truthy(inner_document_lines['$empty?']())) {
          } else if ($truthy((unprocessed_line1 = inner_document_lines['$[]'](0))['$include?']("::"))) {
            
            preprocessed_lines = $$($nesting, 'PreprocessorReader').$new(self.document, [unprocessed_line1]).$readlines();
            if ($truthy((($a = unprocessed_line1['$=='](preprocessed_lines['$[]'](0))) ? $rb_lt(preprocessed_lines.$size(), 2) : unprocessed_line1['$=='](preprocessed_lines['$[]'](0))))) {
            } else {
              
              inner_document_lines.$shift();
              if ($truthy(preprocessed_lines['$empty?']())) {
              } else {
                $send(inner_document_lines, 'unshift', Opal.to_a(preprocessed_lines))
              };
            };};
          self.inner_document = $$($nesting, 'Document').$new(inner_document_lines, $hash2(["standalone", "parent", "cursor"], {"standalone": false, "parent": self.document, "cursor": inner_document_cursor}));
          if ($truthy(parent_doctitle['$nil?']())) {
          } else {
            
            $writer = ["doctitle", parent_doctitle];
            $send(self.document.$attributes(), '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          };
          self.subs = nil;
        } else if ($truthy(literal)) {
          
          self.content_model = "verbatim";
          self.subs = $$($nesting, 'BASIC_SUBS');
        } else {
          
          if ($truthy(normal_psv)) {
            if ($truthy(in_header_row)) {
              self.cursor = opts['$[]']("cursor")
            } else {
              self.$catalog_inline_anchor(cell_text, opts['$[]']("cursor"))
            }};
          self.content_model = "simple";
          self.subs = $$($nesting, 'NORMAL_SUBS');
        };
        self.text = cell_text;
        return (self.style = cell_style);
      }, $Cell_initialize$19.$$arity = -3);
      
      Opal.def(self, '$reinitialize', $Cell_reinitialize$20 = function $$reinitialize(has_header) {
        var self = this;

        
        if ($truthy(has_header)) {
          self.reinitialize_args = nil
        } else if ($truthy(self.reinitialize_args)) {
          return $send($$$($$($nesting, 'Table'), 'Cell'), 'new', Opal.to_a(self.reinitialize_args))
        } else {
          self.style = self.attributes['$[]']("style")
        };
        if ($truthy(self.cursor)) {
          self.$catalog_inline_anchor()};
        return self;
      }, $Cell_reinitialize$20.$$arity = 1);
      
      Opal.def(self, '$catalog_inline_anchor', $Cell_catalog_inline_anchor$21 = function $$catalog_inline_anchor(cell_text, cursor) {
        var $a, self = this;

        
        
        if (cell_text == null) {
          cell_text = self.text;
        };
        
        if (cursor == null) {
          cursor = nil;
        };
        if ($truthy(cursor)) {
        } else {
          $a = [self.cursor, nil], (cursor = $a[0]), (self.cursor = $a[1]), $a
        };
        if ($truthy(($truthy($a = cell_text['$start_with?']("[[")) ? $$($nesting, 'LeadingInlineAnchorRx')['$=~'](cell_text) : $a))) {
          return $$($nesting, 'Parser').$catalog_inline_anchor((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), self, cursor, self.document)
        } else {
          return nil
        };
      }, $Cell_catalog_inline_anchor$21.$$arity = -1);
      
      Opal.def(self, '$text', $Cell_text$22 = function $$text() {
        var self = this;

        return self.$apply_subs(self.text, self.subs)
      }, $Cell_text$22.$$arity = 0);
      self.$attr_writer("text");
      
      Opal.def(self, '$content', $Cell_content$23 = function $$content() {
        var $$24, $a, self = this, cell_style = nil, subbed_text = nil;

        if ((cell_style = self.style)['$==']("asciidoc")) {
          return self.inner_document.$convert()
        } else if ($truthy(self.text['$include?']($$($nesting, 'DOUBLE_LF')))) {
          return $send(self.$text().$split($$($nesting, 'BlankLineRx')), 'map', [], ($$24 = function(para){var self = $$24.$$s || this, $a;

          
            
            if (para == null) {
              para = nil;
            };
            if ($truthy(($truthy($a = cell_style) ? cell_style['$!=']("header") : $a))) {
              return $$($nesting, 'Inline').$new(self.$parent(), "quoted", para, $hash2(["type"], {"type": cell_style})).$convert()
            } else {
              return para
            };}, $$24.$$s = self, $$24.$$arity = 1, $$24))
        } else if ($truthy((subbed_text = self.$text())['$empty?']())) {
          return []
        } else if ($truthy(($truthy($a = cell_style) ? cell_style['$!=']("header") : $a))) {
          return [$$($nesting, 'Inline').$new(self.$parent(), "quoted", subbed_text, $hash2(["type"], {"type": cell_style})).$convert()]
        } else {
          return [subbed_text]
        }
      }, $Cell_content$23.$$arity = 0);
      
      Opal.def(self, '$lines', $Cell_lines$25 = function $$lines() {
        var self = this;

        return self.text.$split($$($nesting, 'LF'))
      }, $Cell_lines$25.$$arity = 0);
      
      Opal.def(self, '$source', $Cell_source$26 = function $$source() {
        var self = this;

        return self.text
      }, $Cell_source$26.$$arity = 0);
      
      Opal.def(self, '$file', $Cell_file$27 = function $$file() {
        var $a, self = this;

        return ($truthy($a = self.source_location) ? self.source_location.$file() : $a)
      }, $Cell_file$27.$$arity = 0);
      
      Opal.def(self, '$lineno', $Cell_lineno$28 = function $$lineno() {
        var $a, self = this;

        return ($truthy($a = self.source_location) ? self.source_location.$lineno() : $a)
      }, $Cell_lineno$28.$$arity = 0);
      return (Opal.def(self, '$to_s', $Cell_to_s$29 = function $$to_s() {
        var $a, $iter = $Cell_to_s$29.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $Cell_to_s$29.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        return "" + ($send(self, Opal.find_super_dispatcher(self, 'to_s', $Cell_to_s$29, false), $zuper, $iter)) + " - [text: " + (self.text) + ", colspan: " + (($truthy($a = self.colspan) ? $a : 1)) + ", rowspan: " + (($truthy($a = self.rowspan) ? $a : 1)) + ", attributes: " + (self.attributes) + "]"
      }, $Cell_to_s$29.$$arity = 0), nil) && 'to_s';
    })($$($nesting, 'Table'), $$($nesting, 'AbstractBlock'), $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'ParserContext');

      var $nesting = [self].concat($parent_nesting), $ParserContext_initialize$30, $ParserContext_starts_with_delimiter$ques$31, $ParserContext_match_delimiter$32, $ParserContext_skip_past_delimiter$33, $ParserContext_skip_past_escaped_delimiter$34, $ParserContext_buffer_has_unclosed_quotes$ques$35, $ParserContext_take_cellspec$36, $ParserContext_push_cellspec$37, $ParserContext_keep_cell_open$38, $ParserContext_mark_cell_closed$39, $ParserContext_cell_open$ques$40, $ParserContext_cell_closed$ques$41, $ParserContext_close_open_cell$42, $ParserContext_close_cell$43, $ParserContext_close_row$46, $ParserContext_activate_rowspan$47, $ParserContext_end_of_row$ques$49, $ParserContext_effective_column_visits$50, $ParserContext_advance$51;

      self.$$prototype.delimiter = self.$$prototype.delimiter_rx = self.$$prototype.buffer = self.$$prototype.cellspecs = self.$$prototype.cell_open = self.$$prototype.format = self.$$prototype.start_cursor_data = self.$$prototype.reader = self.$$prototype.table = self.$$prototype.current_row = self.$$prototype.colcount = self.$$prototype.column_visits = self.$$prototype.active_rowspans = self.$$prototype.linenum = nil;
      
      self.$include($$($nesting, 'Logging'));
      Opal.const_set($nesting[0], 'FORMATS', ["psv", "csv", "dsv", "tsv"].$to_set());
      Opal.const_set($nesting[0], 'DELIMITERS', $hash2(["psv", "csv", "dsv", "tsv", "!sv"], {"psv": ["|", /\|/], "csv": [",", /,/], "dsv": [":", /:/], "tsv": ["\t", /\t/], "!sv": ["!", /!/]}));
      self.$attr_accessor("table");
      self.$attr_accessor("format");
      self.$attr_reader("colcount");
      self.$attr_accessor("buffer");
      self.$attr_reader("delimiter");
      self.$attr_reader("delimiter_re");
      
      Opal.def(self, '$initialize', $ParserContext_initialize$30 = function $$initialize(reader, table, attributes) {
        var $a, $b, self = this, xsv = nil, sep = nil;

        
        
        if (attributes == null) {
          attributes = $hash2([], {});
        };
        self.start_cursor_data = (self.reader = reader).$mark();
        self.table = table;
        if ($truthy(attributes['$key?']("format"))) {
          if ($truthy($$($nesting, 'FORMATS')['$include?']((xsv = attributes['$[]']("format"))))) {
            if (xsv['$==']("tsv")) {
              self.format = "csv"
            } else if ($truthy((($a = (self.format = xsv)['$==']("psv")) ? table.$document()['$nested?']() : (self.format = xsv)['$==']("psv")))) {
              xsv = "!sv"}
          } else {
            
            self.$logger().$error(self.$message_with_context("" + "illegal table format: " + (xsv), $hash2(["source_location"], {"source_location": reader.$cursor_at_prev_line()})));
            $a = ["psv", (function() {if ($truthy(table.$document()['$nested?']())) {
              return "!sv"
            } else {
              return "psv"
            }; return nil; })()], (self.format = $a[0]), (xsv = $a[1]), $a;
          }
        } else {
          $a = ["psv", (function() {if ($truthy(table.$document()['$nested?']())) {
            return "!sv"
          } else {
            return "psv"
          }; return nil; })()], (self.format = $a[0]), (xsv = $a[1]), $a
        };
        if ($truthy(attributes['$key?']("separator"))) {
          if ($truthy((sep = attributes['$[]']("separator"))['$nil_or_empty?']())) {
            $b = $$($nesting, 'DELIMITERS')['$[]'](xsv), $a = Opal.to_ary($b), (self.delimiter = ($a[0] == null ? nil : $a[0])), (self.delimiter_rx = ($a[1] == null ? nil : $a[1])), $b
          } else if (sep['$==']("\\t")) {
            $b = $$($nesting, 'DELIMITERS')['$[]']("tsv"), $a = Opal.to_ary($b), (self.delimiter = ($a[0] == null ? nil : $a[0])), (self.delimiter_rx = ($a[1] == null ? nil : $a[1])), $b
          } else {
            $a = [sep, new RegExp($$$('::', 'Regexp').$escape(sep))], (self.delimiter = $a[0]), (self.delimiter_rx = $a[1]), $a
          }
        } else {
          $b = $$($nesting, 'DELIMITERS')['$[]'](xsv), $a = Opal.to_ary($b), (self.delimiter = ($a[0] == null ? nil : $a[0])), (self.delimiter_rx = ($a[1] == null ? nil : $a[1])), $b
        };
        self.colcount = (function() {if ($truthy(table.$columns()['$empty?']())) {
          return -1
        } else {
          return table.$columns().$size()
        }; return nil; })();
        self.buffer = "";
        self.cellspecs = [];
        self.cell_open = false;
        self.active_rowspans = [0];
        self.column_visits = 0;
        self.current_row = [];
        return (self.linenum = -1);
      }, $ParserContext_initialize$30.$$arity = -3);
      
      Opal.def(self, '$starts_with_delimiter?', $ParserContext_starts_with_delimiter$ques$31 = function(line) {
        var self = this;

        return line['$start_with?'](self.delimiter)
      }, $ParserContext_starts_with_delimiter$ques$31.$$arity = 1);
      
      Opal.def(self, '$match_delimiter', $ParserContext_match_delimiter$32 = function $$match_delimiter(line) {
        var self = this;

        return self.delimiter_rx.$match(line)
      }, $ParserContext_match_delimiter$32.$$arity = 1);
      
      Opal.def(self, '$skip_past_delimiter', $ParserContext_skip_past_delimiter$33 = function $$skip_past_delimiter(pre) {
        var self = this;

        
        self.buffer = "" + (self.buffer) + (pre) + (self.delimiter);
        return nil;
      }, $ParserContext_skip_past_delimiter$33.$$arity = 1);
      
      Opal.def(self, '$skip_past_escaped_delimiter', $ParserContext_skip_past_escaped_delimiter$34 = function $$skip_past_escaped_delimiter(pre) {
        var self = this;

        
        self.buffer = "" + (self.buffer) + (pre.$chop()) + (self.delimiter);
        return nil;
      }, $ParserContext_skip_past_escaped_delimiter$34.$$arity = 1);
      
      Opal.def(self, '$buffer_has_unclosed_quotes?', $ParserContext_buffer_has_unclosed_quotes$ques$35 = function(append, q) {
        var $a, $b, self = this, record = nil, qq = nil, trailing_quote = nil;

        
        
        if (append == null) {
          append = nil;
        };
        
        if (q == null) {
          q = "\"";
        };
        if ((record = (function() {if ($truthy(append)) {
          return $rb_plus(self.buffer, append).$strip()
        } else {
          return self.buffer.$strip()
        }; return nil; })())['$=='](q)) {
          return true
        } else if ($truthy(record['$start_with?'](q))) {
          
          qq = $rb_plus(q, q);
          if ($truthy(($truthy($a = ($truthy($b = (trailing_quote = record['$end_with?'](q))) ? record['$end_with?'](qq) : $b)) ? $a : record['$start_with?'](qq)))) {
            return ($truthy($a = (record = record.$gsub(qq, ""))['$start_with?'](q)) ? record['$end_with?'](q)['$!']() : $a)
          } else {
            return trailing_quote['$!']()
          };
        } else {
          return false
        };
      }, $ParserContext_buffer_has_unclosed_quotes$ques$35.$$arity = -1);
      
      Opal.def(self, '$take_cellspec', $ParserContext_take_cellspec$36 = function $$take_cellspec() {
        var self = this;

        return self.cellspecs.$shift()
      }, $ParserContext_take_cellspec$36.$$arity = 0);
      
      Opal.def(self, '$push_cellspec', $ParserContext_push_cellspec$37 = function $$push_cellspec(cellspec) {
        var $a, self = this;

        
        
        if (cellspec == null) {
          cellspec = $hash2([], {});
        };
        self.cellspecs['$<<'](($truthy($a = cellspec) ? $a : $hash2([], {})));
        return nil;
      }, $ParserContext_push_cellspec$37.$$arity = -1);
      
      Opal.def(self, '$keep_cell_open', $ParserContext_keep_cell_open$38 = function $$keep_cell_open() {
        var self = this;

        
        self.cell_open = true;
        return nil;
      }, $ParserContext_keep_cell_open$38.$$arity = 0);
      
      Opal.def(self, '$mark_cell_closed', $ParserContext_mark_cell_closed$39 = function $$mark_cell_closed() {
        var self = this;

        
        self.cell_open = false;
        return nil;
      }, $ParserContext_mark_cell_closed$39.$$arity = 0);
      
      Opal.def(self, '$cell_open?', $ParserContext_cell_open$ques$40 = function() {
        var self = this;

        return self.cell_open
      }, $ParserContext_cell_open$ques$40.$$arity = 0);
      
      Opal.def(self, '$cell_closed?', $ParserContext_cell_closed$ques$41 = function() {
        var self = this;

        return self.cell_open['$!']()
      }, $ParserContext_cell_closed$ques$41.$$arity = 0);
      
      Opal.def(self, '$close_open_cell', $ParserContext_close_open_cell$42 = function $$close_open_cell(next_cellspec) {
        var self = this;

        
        
        if (next_cellspec == null) {
          next_cellspec = $hash2([], {});
        };
        self.$push_cellspec(next_cellspec);
        if ($truthy(self['$cell_open?']())) {
          self.$close_cell(true)};
        self.$advance();
        return nil;
      }, $ParserContext_close_open_cell$42.$$arity = -1);
      
      Opal.def(self, '$close_cell', $ParserContext_close_cell$43 = function $$close_cell(eol) {try {

        var $a, $b, $$44, self = this, cell_text = nil, cellspec = nil, repeat = nil, q = nil;

        
        
        if (eol == null) {
          eol = false;
        };
        if (self.format['$==']("psv")) {
          
          cell_text = self.buffer;
          self.buffer = "";
          if ($truthy((cellspec = self.$take_cellspec()))) {
            repeat = ($truthy($a = cellspec.$delete("repeatcol")) ? $a : 1)
          } else {
            
            self.$logger().$error(self.$message_with_context("table missing leading separator; recovering automatically", $hash2(["source_location"], {"source_location": $send($$$($$($nesting, 'Reader'), 'Cursor'), 'new', Opal.to_a(self.start_cursor_data))})));
            cellspec = $hash2([], {});
            repeat = 1;
          };
        } else {
          
          cell_text = self.buffer.$strip();
          self.buffer = "";
          cellspec = nil;
          repeat = 1;
          if ($truthy(($truthy($a = (($b = self.format['$==']("csv")) ? cell_text['$empty?']()['$!']() : self.format['$==']("csv"))) ? cell_text['$include?']((q = "\"")) : $a))) {
            if ($truthy(($truthy($a = cell_text['$start_with?'](q)) ? cell_text['$end_with?'](q) : $a))) {
              if ($truthy((cell_text = cell_text.$slice(1, $rb_minus(cell_text.$length(), 2))))) {
                cell_text = cell_text.$strip().$squeeze(q)
              } else {
                
                self.$logger().$error(self.$message_with_context("unclosed quote in CSV data; setting cell to empty", $hash2(["source_location"], {"source_location": self.reader.$cursor_at_prev_line()})));
                cell_text = "";
              }
            } else {
              cell_text = cell_text.$squeeze(q)
            }};
        };
        $send((1), 'upto', [repeat], ($$44 = function(i){var self = $$44.$$s || this, $c, $d, $$45, $e, column = nil, extra_cols = nil, offset = nil, cell = nil;
          if (self.colcount == null) self.colcount = nil;
          if (self.table == null) self.table = nil;
          if (self.current_row == null) self.current_row = nil;
          if (self.reader == null) self.reader = nil;
          if (self.column_visits == null) self.column_visits = nil;
          if (self.linenum == null) self.linenum = nil;

        
          
          if (i == null) {
            i = nil;
          };
          if (self.colcount['$=='](-1)) {
            
            self.table.$columns()['$<<']((column = $$$($$($nesting, 'Table'), 'Column').$new(self.table, $rb_minus($rb_plus(self.table.$columns().$size(), i), 1))));
            if ($truthy(($truthy($c = ($truthy($d = cellspec) ? cellspec['$key?']("colspan") : $d)) ? $rb_gt((extra_cols = $rb_minus(cellspec['$[]']("colspan").$to_i(), 1)), 0) : $c))) {
              
              offset = self.table.$columns().$size();
              $send(extra_cols, 'times', [], ($$45 = function(j){var self = $$45.$$s || this;
                if (self.table == null) self.table = nil;

              
                
                if (j == null) {
                  j = nil;
                };
                return self.table.$columns()['$<<']($$$($$($nesting, 'Table'), 'Column').$new(self.table, $rb_plus(offset, j)));}, $$45.$$s = self, $$45.$$arity = 1, $$45));};
          } else if ($truthy((column = self.table.$columns()['$[]'](self.current_row.$size())))) {
          } else {
            
            self.$logger().$error(self.$message_with_context("dropping cell because it exceeds specified number of columns", $hash2(["source_location"], {"source_location": self.reader.$cursor_before_mark()})));
            Opal.ret(nil);
          };
          cell = $$$($$($nesting, 'Table'), 'Cell').$new(column, cell_text, cellspec, $hash2(["cursor"], {"cursor": self.reader.$cursor_before_mark()}));
          self.reader.$mark();
          if ($truthy(($truthy($c = cell.$rowspan()['$!']()) ? $c : cell.$rowspan()['$=='](1)))) {
          } else {
            self.$activate_rowspan(cell.$rowspan(), ($truthy($c = cell.$colspan()) ? $c : 1))
          };
          self.column_visits = $rb_plus(self.column_visits, ($truthy($c = cell.$colspan()) ? $c : 1));
          self.current_row['$<<'](cell);
          if ($truthy(($truthy($c = self['$end_of_row?']()) ? ($truthy($d = ($truthy($e = self.colcount['$!='](-1)) ? $e : $rb_gt(self.linenum, 0))) ? $d : ($truthy($e = eol) ? i['$=='](repeat) : $e)) : $c))) {
            return self.$close_row()
          } else {
            return nil
          };}, $$44.$$s = self, $$44.$$arity = 1, $$44));
        self.cell_open = false;
        return nil;
        } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
      }, $ParserContext_close_cell$43.$$arity = -1);
      self.$private();
      
      Opal.def(self, '$close_row', $ParserContext_close_row$46 = function $$close_row() {
        var $a, self = this, $writer = nil;

        
        self.table.$rows().$body()['$<<'](self.current_row);
        if (self.colcount['$=='](-1)) {
          self.colcount = self.column_visits};
        self.column_visits = 0;
        self.current_row = [];
        self.active_rowspans.$shift();
        ($truthy($a = self.active_rowspans['$[]'](0)) ? $a : (($writer = [0, 0]), $send(self.active_rowspans, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        return nil;
      }, $ParserContext_close_row$46.$$arity = 0);
      
      Opal.def(self, '$activate_rowspan', $ParserContext_activate_rowspan$47 = function $$activate_rowspan(rowspan, colspan) {
        var $$48, self = this;

        
        $send((1), 'upto', [$rb_minus(rowspan, 1)], ($$48 = function(i){var self = $$48.$$s || this, $a, $writer = nil;
          if (self.active_rowspans == null) self.active_rowspans = nil;

        
          
          if (i == null) {
            i = nil;
          };
          $writer = [i, $rb_plus(($truthy($a = self.active_rowspans['$[]'](i)) ? $a : 0), colspan)];
          $send(self.active_rowspans, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$48.$$s = self, $$48.$$arity = 1, $$48));
        return nil;
      }, $ParserContext_activate_rowspan$47.$$arity = 2);
      
      Opal.def(self, '$end_of_row?', $ParserContext_end_of_row$ques$49 = function() {
        var $a, self = this;

        return ($truthy($a = self.colcount['$=='](-1)) ? $a : self.$effective_column_visits()['$=='](self.colcount))
      }, $ParserContext_end_of_row$ques$49.$$arity = 0);
      
      Opal.def(self, '$effective_column_visits', $ParserContext_effective_column_visits$50 = function $$effective_column_visits() {
        var self = this;

        return $rb_plus(self.column_visits, self.active_rowspans['$[]'](0))
      }, $ParserContext_effective_column_visits$50.$$arity = 0);
      return (Opal.def(self, '$advance', $ParserContext_advance$51 = function $$advance() {
        var self = this;

        return (self.linenum = $rb_plus(self.linenum, 1))
      }, $ParserContext_advance$51.$$arity = 0), nil) && 'advance';
    })($$($nesting, 'Table'), null, $nesting);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/writer"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$respond_to?', '$write', '$+', '$chomp', '$include']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $parent_nesting) {
      var self = $module($base, 'Writer');

      var $nesting = [self].concat($parent_nesting), $Writer_write$1;

      
      Opal.def(self, '$write', $Writer_write$1 = function $$write(output, target) {
        var self = this;

        
        if ($truthy(target['$respond_to?']("write"))) {
          target.$write($rb_plus(output.$chomp(), $$($nesting, 'LF')))
        } else {
          $$$('::', 'File').$write(target, output, $hash2(["mode"], {"mode": $$($nesting, 'FILE_WRITE_MODE')}))
        };
        return nil;
      }, $Writer_write$1.$$arity = 2)
    })($nesting[0], $nesting);
    (function($base, $parent_nesting) {
      var self = $module($base, 'VoidWriter');

      var $nesting = [self].concat($parent_nesting), $VoidWriter_write$2;

      
      self.$include($$($nesting, 'Writer'));
      
      Opal.def(self, '$write', $VoidWriter_write$2 = function $$write(output, target) {
        var self = this;

        return nil
      }, $VoidWriter_write$2.$$arity = 2);
    })($nesting[0], $nesting);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/load"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$merge', '$[]', '$start', '$key?', '$!=', '$logger', '$new', '$logger=', '$-', '$!', '$===', '$dup', '$tap', '$each', '$partition', '$[]=', '$split', '$gsub', '$+', '$respond_to?', '$keys', '$raise', '$join', '$ancestors', '$class', '$==', '$at', '$to_i', '$mtime', '$absolute_path', '$path', '$dirname', '$basename', '$extname', '$read', '$rewind', '$drop', '$record', '$parse', '$exception', '$message', '$set_backtrace', '$backtrace', '$stack_trace', '$stack_trace=', '$open', '$load']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $load$1, $load_file$8;

      
      
      Opal.def(self, '$load', $load$1 = function $$load(input, options) {
        var $a, $b, $c, $d, $$2, $$4, $$6, self = this, timings = nil, logger = nil, $writer = nil, attrs = nil, input_path = nil, source = nil, doc = nil, e = nil, context = nil, wrapped_e = nil;

        
        
        if (options == null) {
          options = $hash2([], {});
        };
        try {
          
          options = options.$merge();
          if ($truthy((timings = options['$[]']("timings")))) {
            timings.$start("read")};
          if ($truthy(($truthy($a = options['$key?']("logger")) ? (logger = options['$[]']("logger"))['$!=']($$($nesting, 'LoggerManager').$logger()) : $a))) {
            
            $writer = [($truthy($a = logger) ? $a : $$($nesting, 'NullLogger').$new())];
            $send($$($nesting, 'LoggerManager'), 'logger=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          if ($truthy((attrs = options['$[]']("attributes"))['$!']())) {
            attrs = $hash2([], {})
          } else if ($truthy($$$('::', 'Hash')['$==='](attrs))) {
            attrs = attrs.$merge()
          } else if ($truthy(($truthy($a = (($d = $$$('::', 'Java', 'skip_raise')) && ($c = $$$($d, 'JavaUtil', 'skip_raise')) && ($b = $$$($c, 'Map', 'skip_raise')) ? 'constant' : nil)) ? $$$($$$($$$('::', 'Java'), 'JavaUtil'), 'Map')['$==='](attrs) : $a))) {
            attrs = attrs.$dup()
          } else if ($truthy($$$('::', 'Array')['$==='](attrs))) {
            attrs = $send($hash2([], {}), 'tap', [], ($$2 = function(accum){var self = $$2.$$s || this, $$3;

            
              
              if (accum == null) {
                accum = nil;
              };
              return $send(attrs, 'each', [], ($$3 = function(entry){var self = $$3.$$s || this, $e, $f, k = nil, _ = nil, v = nil;

              
                
                if (entry == null) {
                  entry = nil;
                };
                $f = entry.$partition("="), $e = Opal.to_ary($f), (k = ($e[0] == null ? nil : $e[0])), (_ = ($e[1] == null ? nil : $e[1])), (v = ($e[2] == null ? nil : $e[2])), $f;
                
                $writer = [k, v];
                $send(accum, '[]=', Opal.to_a($writer));
                return $writer[$rb_minus($writer["length"], 1)];;}, $$3.$$s = self, $$3.$$arity = 1, $$3));}, $$2.$$s = self, $$2.$$arity = 1, $$2))
          } else if ($truthy($$$('::', 'String')['$==='](attrs))) {
            attrs = $send($hash2([], {}), 'tap', [], ($$4 = function(accum){var self = $$4.$$s || this, $$5;

            
              
              if (accum == null) {
                accum = nil;
              };
              return $send(attrs.$gsub($$($nesting, 'SpaceDelimiterRx'), $rb_plus("\\1", $$($nesting, 'NULL'))).$gsub($$($nesting, 'EscapedSpaceRx'), "\\1").$split($$($nesting, 'NULL')), 'each', [], ($$5 = function(entry){var self = $$5.$$s || this, $e, $f, k = nil, _ = nil, v = nil;

              
                
                if (entry == null) {
                  entry = nil;
                };
                $f = entry.$partition("="), $e = Opal.to_ary($f), (k = ($e[0] == null ? nil : $e[0])), (_ = ($e[1] == null ? nil : $e[1])), (v = ($e[2] == null ? nil : $e[2])), $f;
                
                $writer = [k, v];
                $send(accum, '[]=', Opal.to_a($writer));
                return $writer[$rb_minus($writer["length"], 1)];;}, $$5.$$s = self, $$5.$$arity = 1, $$5));}, $$4.$$s = self, $$4.$$arity = 1, $$4))
          } else if ($truthy(($truthy($a = attrs['$respond_to?']("keys")) ? attrs['$respond_to?']("[]") : $a))) {
            attrs = $send($hash2([], {}), 'tap', [], ($$6 = function(accum){var self = $$6.$$s || this, $$7;

            
              
              if (accum == null) {
                accum = nil;
              };
              return $send(attrs.$keys(), 'each', [], ($$7 = function(k){var self = $$7.$$s || this;

              
                
                if (k == null) {
                  k = nil;
                };
                $writer = [k, attrs['$[]'](k)];
                $send(accum, '[]=', Opal.to_a($writer));
                return $writer[$rb_minus($writer["length"], 1)];}, $$7.$$s = self, $$7.$$arity = 1, $$7));}, $$6.$$s = self, $$6.$$arity = 1, $$6))
          } else {
            self.$raise($$$('::', 'ArgumentError'), "" + "illegal type for attributes option: " + (attrs.$class().$ancestors().$join(" < ")))
          };
          if ($truthy($$$('::', 'File')['$==='](input))) {
            
            
            $writer = ["input_mtime", (function() {if ($$($nesting, 'RUBY_ENGINE')['$==']("jruby")) {
              
              return $$$('::', 'Time').$at(input.$mtime().$to_i());
            } else {
              return input.$mtime()
            }; return nil; })()];
            $send(options, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = ["docfile", (input_path = $$$('::', 'File').$absolute_path(input.$path()))];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = ["docdir", $$$('::', 'File').$dirname(input_path)];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            
            $writer = ["docname", $$($nesting, 'Helpers').$basename(input_path, (($writer = ["docfilesuffix", $$($nesting, 'Helpers').$extname(input_path)]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))];
            $send(attrs, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            source = input.$read();
          } else if ($truthy(input['$respond_to?']("read"))) {
            
            try {
              input.$rewind()
            } catch ($err) {
              if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
                try {
                  nil
                } finally { Opal.pop_exception() }
              } else { throw $err; }
            };
            source = input.$read();
          } else if ($truthy($$$('::', 'String')['$==='](input))) {
            source = input
          } else if ($truthy($$$('::', 'Array')['$==='](input))) {
            source = input.$drop(0)
          } else if ($truthy(input)) {
            self.$raise($$$('::', 'ArgumentError'), "" + "unsupported input type: " + (input.$class()))};
          if ($truthy(timings)) {
            
            timings.$record("read");
            timings.$start("parse");};
          
          $writer = ["attributes", attrs];
          $send(options, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          doc = (function() {if (options['$[]']("parse")['$=='](false)) {
            
            return $$($nesting, 'Document').$new(source, options);
          } else {
            return $$($nesting, 'Document').$new(source, options).$parse()
          }; return nil; })();
          if ($truthy(timings)) {
            timings.$record("parse")};
          return doc;
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {e = $err;
            try {
              
              
              try {
                
                context = "" + "asciidoctor: FAILED: " + (($truthy($a = attrs['$[]']("docfile")) ? $a : "<stdin>")) + ": Failed to load AsciiDoc document";
                if ($truthy(e['$respond_to?']("exception"))) {
                  
                  wrapped_e = e.$exception("" + (context) + " - " + (e.$message()));
                  wrapped_e.$set_backtrace(e.$backtrace());
                } else {
                  
                  wrapped_e = e.$class().$new(context, e);
                  
                  $writer = [e.$stack_trace()];
                  $send(wrapped_e, 'stack_trace=', Opal.to_a($writer));
                  $writer[$rb_minus($writer["length"], 1)];;
                };
              } catch ($err) {
                if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
                  try {
                    wrapped_e = e
                  } finally { Opal.pop_exception() }
                } else { throw $err; }
              };;
              return self.$raise(wrapped_e);
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };
      }, $load$1.$$arity = -2);
      return (Opal.def(self, '$load_file', $load_file$8 = function $$load_file(filename, options) {
        var $$9, self = this;

        
        
        if (options == null) {
          options = $hash2([], {});
        };
        return $send($$$('::', 'File'), 'open', [filename, $$($nesting, 'FILE_READ_MODE')], ($$9 = function(file){var self = $$9.$$s || this;

        
          
          if (file == null) {
            file = nil;
          };
          return self.$load(file, options);}, $$9.$$s = self, $$9.$$arity = 1, $$9));
      }, $load_file$8.$$arity = -2), nil) && 'load_file';
    })(Opal.get_singleton_class(self), $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/convert"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$delete', '$merge', '$===', '$absolute_path', '$path', '$load', '$respond_to?', '$[]=', '$-', '$key?', '$fetch', '$[]', '$dirname', '$expand_path', '$join', '$attributes', '$outfilesuffix', '$==', '$raise', '$pwd', '$>=', '$safe', '$normalize_system_path', '$mkdir_p', '$directory?', '$!', '$convert', '$write', '$<', '$attr?', '$basebackend?', '$attr', '$uriish?', '$include?', '$syntax_highlighter', '$write_stylesheet?', '$write_primary_stylesheet', '$instance', '$to_s', '$!=', '$read_asset', '$file?', '$write_stylesheet', '$open']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $convert$1, $convert_file$2;

      
      
      Opal.def(self, '$convert', $convert$1 = function $$convert(input, options) {
        var $a, $b, $c, $d, $e, self = this, to_dir = nil, mkdirs = nil, $case = nil, to_file = nil, write_to_target = nil, sibling_path = nil, stream_output = nil, $writer = nil, outdir = nil, doc = nil, outfile = nil, working_dir = nil, jail = nil, output = nil, stylesdir = nil, stylesheet = nil, copy_asciidoctor_stylesheet = nil, copy_user_stylesheet = nil, copy_syntax_hl_stylesheet = nil, syntax_hl = nil, stylesoutdir = nil, stylesheet_src = nil, stylesheet_dest = nil, stylesheet_data = nil, stylesheet_outdir = nil;

        
        
        if (options == null) {
          options = $hash2([], {});
        };
        (options = options.$merge()).$delete("parse");
        to_dir = options.$delete("to_dir");
        mkdirs = options.$delete("mkdirs");
        $case = (to_file = options.$delete("to_file"));
        if (true['$===']($case) || nil['$===']($case)) {
        if ($truthy((write_to_target = to_dir))) {
        } else if ($truthy($$$('::', 'File')['$==='](input))) {
          sibling_path = $$$('::', 'File').$absolute_path(input.$path())};
        to_file = nil;}
        else if (false['$===']($case)) {to_file = nil}
        else if ("/dev/null"['$===']($case)) {return self.$load(input, options)}
        else {if ($truthy((stream_output = to_file['$respond_to?']("write")))) {
        } else {
          
          $writer = ["to_file", (write_to_target = to_file)];
          $send(options, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        }};
        if ($truthy(options['$key?']("standalone"))) {
        } else if ($truthy(($truthy($a = sibling_path) ? $a : write_to_target))) {
          
          $writer = ["standalone", options.$fetch("header_footer", true)];
          $send(options, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        } else if ($truthy(options['$key?']("header_footer"))) {
          
          $writer = ["standalone", options['$[]']("header_footer")];
          $send(options, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
        if ($truthy(sibling_path)) {
          
          $writer = ["to_dir", (outdir = $$$('::', 'File').$dirname(sibling_path))];
          $send(options, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        } else if ($truthy(write_to_target)) {
          if ($truthy(to_dir)) {
            if ($truthy(to_file)) {
              
              $writer = ["to_dir", $$$('::', 'File').$dirname($$$('::', 'File').$expand_path(to_file, to_dir))];
              $send(options, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            } else {
              
              $writer = ["to_dir", $$$('::', 'File').$expand_path(to_dir)];
              $send(options, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            }
          } else if ($truthy(to_file)) {
            
            $writer = ["to_dir", $$$('::', 'File').$dirname($$$('::', 'File').$expand_path(to_file))];
            $send(options, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];}};
        doc = self.$load(input, options);
        if ($truthy(sibling_path)) {
          
          outfile = $$$('::', 'File').$join(outdir, "" + (doc.$attributes()['$[]']("docname")) + (doc.$outfilesuffix()));
          if (outfile['$=='](sibling_path)) {
            self.$raise($$$('::', 'IOError'), "" + "input file and output file cannot be the same: " + (outfile))};
        } else if ($truthy(write_to_target)) {
          
          working_dir = (function() {if ($truthy(options['$key?']("base_dir"))) {
            
            return $$$('::', 'File').$expand_path(options['$[]']("base_dir"));
          } else {
            return $$$('::', 'Dir').$pwd()
          }; return nil; })();
          jail = (function() {if ($truthy($rb_ge(doc.$safe(), $$$($$($nesting, 'SafeMode'), 'SAFE')))) {
            return working_dir
          } else {
            return nil
          }; return nil; })();
          if ($truthy(to_dir)) {
            
            outdir = doc.$normalize_system_path(to_dir, working_dir, jail, $hash2(["target_name", "recover"], {"target_name": "to_dir", "recover": false}));
            if ($truthy(to_file)) {
              
              outfile = doc.$normalize_system_path(to_file, outdir, nil, $hash2(["target_name", "recover"], {"target_name": "to_dir", "recover": false}));
              outdir = $$$('::', 'File').$dirname(outfile);
            } else {
              outfile = $$$('::', 'File').$join(outdir, "" + (doc.$attributes()['$[]']("docname")) + (doc.$outfilesuffix()))
            };
          } else if ($truthy(to_file)) {
            
            outfile = doc.$normalize_system_path(to_file, working_dir, jail, $hash2(["target_name", "recover"], {"target_name": "to_dir", "recover": false}));
            outdir = $$$('::', 'File').$dirname(outfile);};
          if ($truthy(($truthy($a = $$$('::', 'File')['$==='](input)) ? outfile['$==']($$$('::', 'File').$absolute_path(input.$path())) : $a))) {
            self.$raise($$$('::', 'IOError'), "" + "input file and output file cannot be the same: " + (outfile))};
          if ($truthy(mkdirs)) {
            $$($nesting, 'Helpers').$mkdir_p(outdir)
          } else if ($truthy($$$('::', 'File')['$directory?'](outdir))) {
          } else {
            self.$raise($$$('::', 'IOError'), "" + "target directory does not exist: " + (to_dir) + " (hint: set :mkdirs option)")
          };
        } else {
          
          outfile = to_file;
          outdir = nil;
        };
        if ($truthy(($truthy($a = outfile) ? stream_output['$!']() : $a))) {
          output = doc.$convert($hash2(["outfile", "outdir"], {"outfile": outfile, "outdir": outdir}))
        } else {
          output = doc.$convert()
        };
        if ($truthy(outfile)) {
          
          doc.$write(output, outfile);
          if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = ($truthy($d = ($truthy($e = stream_output['$!']()) ? $rb_lt(doc.$safe(), $$$($$($nesting, 'SafeMode'), 'SECURE')) : $e)) ? doc['$attr?']("linkcss") : $d)) ? doc['$attr?']("copycss") : $c)) ? doc['$basebackend?']("html") : $b)) ? ($truthy($b = (stylesdir = doc.$attr("stylesdir"))) ? $$($nesting, 'Helpers')['$uriish?'](stylesdir) : $b)['$!']() : $a))) {
            
            if ($truthy((stylesheet = doc.$attr("stylesheet")))) {
              if ($truthy($$($nesting, 'DEFAULT_STYLESHEET_KEYS')['$include?'](stylesheet))) {
                copy_asciidoctor_stylesheet = true
              } else if ($truthy($$($nesting, 'Helpers')['$uriish?'](stylesheet)['$!']())) {
                copy_user_stylesheet = true}};
            copy_syntax_hl_stylesheet = ($truthy($a = (syntax_hl = doc.$syntax_highlighter())) ? syntax_hl['$write_stylesheet?'](doc) : $a);
            if ($truthy(($truthy($a = ($truthy($b = copy_asciidoctor_stylesheet) ? $b : copy_user_stylesheet)) ? $a : copy_syntax_hl_stylesheet))) {
              
              stylesoutdir = doc.$normalize_system_path(stylesdir, outdir, (function() {if ($truthy($rb_ge(doc.$safe(), $$$($$($nesting, 'SafeMode'), 'SAFE')))) {
                return outdir
              } else {
                return nil
              }; return nil; })());
              if ($truthy(mkdirs)) {
                $$($nesting, 'Helpers').$mkdir_p(stylesoutdir)
              } else if ($truthy($$$('::', 'File')['$directory?'](stylesoutdir))) {
              } else {
                self.$raise($$$('::', 'IOError'), "" + "target stylesheet directory does not exist: " + (stylesoutdir) + " (hint: set :mkdirs option)")
              };
              if ($truthy(copy_asciidoctor_stylesheet)) {
                $$($nesting, 'Stylesheets').$instance().$write_primary_stylesheet(stylesoutdir)
              } else if ($truthy(copy_user_stylesheet)) {
                
                if ($truthy(($truthy($a = (stylesheet_src = doc.$attr("copycss"))['$==']("")) ? $a : stylesheet_src['$=='](true)))) {
                  stylesheet_src = doc.$normalize_system_path(stylesheet)
                } else {
                  stylesheet_src = doc.$normalize_system_path(stylesheet_src.$to_s())
                };
                stylesheet_dest = doc.$normalize_system_path(stylesheet, stylesoutdir, (function() {if ($truthy($rb_ge(doc.$safe(), $$$($$($nesting, 'SafeMode'), 'SAFE')))) {
                  return outdir
                } else {
                  return nil
                }; return nil; })());
                if ($truthy(($truthy($a = stylesheet_src['$!='](stylesheet_dest)) ? (stylesheet_data = doc.$read_asset(stylesheet_src, $hash2(["warn_on_failure", "label"], {"warn_on_failure": $$$('::', 'File')['$file?'](stylesheet_dest)['$!'](), "label": "stylesheet"}))) : $a))) {
                  
                  if ($truthy(($truthy($a = (stylesheet_outdir = $$$('::', 'File').$dirname(stylesheet_dest))['$!='](stylesoutdir)) ? $$$('::', 'File')['$directory?'](stylesheet_outdir)['$!']() : $a))) {
                    if ($truthy(mkdirs)) {
                      $$($nesting, 'Helpers').$mkdir_p(stylesheet_outdir)
                    } else {
                      self.$raise($$$('::', 'IOError'), "" + "target stylesheet directory does not exist: " + (stylesheet_outdir) + " (hint: set :mkdirs option)")
                    }};
                  $$$('::', 'File').$write(stylesheet_dest, stylesheet_data, $hash2(["mode"], {"mode": $$($nesting, 'FILE_WRITE_MODE')}));};};
              if ($truthy(copy_syntax_hl_stylesheet)) {
                syntax_hl.$write_stylesheet(doc, stylesoutdir)};};};
          return doc;
        } else {
          return output
        };
      }, $convert$1.$$arity = -2);
      
      Opal.def(self, '$convert_file', $convert_file$2 = function $$convert_file(filename, options) {
        var $$3, self = this;

        
        
        if (options == null) {
          options = $hash2([], {});
        };
        return $send($$$('::', 'File'), 'open', [filename, $$($nesting, 'FILE_READ_MODE')], ($$3 = function(file){var self = $$3.$$s || this;

        
          
          if (file == null) {
            file = nil;
          };
          return self.$convert(file, options);}, $$3.$$s = self, $$3.$$arity = 1, $$3));
      }, $convert_file$2.$$arity = -2);
      Opal.alias(self, "render", "convert");
      return Opal.alias(self, "render_file", "convert_file");
    })(Opal.get_singleton_class(self), $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/syntax_highlighter/highlightjs"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$register_for', '$merge', '$proc', '$[]=', '$-', '$attr', '$[]', '$==', '$attr?', '$join', '$map', '$split', '$lstrip']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HighlightJsAdapter');

      var $nesting = [self].concat($parent_nesting), $HighlightJsAdapter_initialize$1, $HighlightJsAdapter_format$2, $HighlightJsAdapter_docinfo$ques$4, $HighlightJsAdapter_docinfo$5;

      
      self.$register_for("highlightjs", "highlight.js");
      
      Opal.def(self, '$initialize', $HighlightJsAdapter_initialize$1 = function $$initialize($a) {
        var $post_args, args, $iter = $HighlightJsAdapter_initialize$1.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $HighlightJsAdapter_initialize$1.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        $send(self, Opal.find_super_dispatcher(self, 'initialize', $HighlightJsAdapter_initialize$1, false), $zuper, $iter);
        return (self.name = (self.pre_class = "highlightjs"));
      }, $HighlightJsAdapter_initialize$1.$$arity = -1);
      
      Opal.def(self, '$format', $HighlightJsAdapter_format$2 = function $$format(node, lang, opts) {
        var $$3, $iter = $HighlightJsAdapter_format$2.$$p, $yield = $iter || nil, self = this;

        if ($iter) $HighlightJsAdapter_format$2.$$p = null;
        return $send(self, Opal.find_super_dispatcher(self, 'format', $HighlightJsAdapter_format$2, false), [node, lang, opts.$merge($hash2(["transform"], {"transform": $send(self, 'proc', [], ($$3 = function(_, code){var self = $$3.$$s || this, $a, $writer = nil;

        
          
          if (_ == null) {
            _ = nil;
          };
          
          if (code == null) {
            code = nil;
          };
          $writer = ["class", "" + "language-" + (($truthy($a = lang) ? $a : "none")) + " hljs"];
          $send(code, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$3.$$s = self, $$3.$$arity = 2, $$3))}))], null)
      }, $HighlightJsAdapter_format$2.$$arity = 3);
      
      Opal.def(self, '$docinfo?', $HighlightJsAdapter_docinfo$ques$4 = function(location) {
        var self = this;

        return true
      }, $HighlightJsAdapter_docinfo$ques$4.$$arity = 1);
      return (Opal.def(self, '$docinfo', $HighlightJsAdapter_docinfo$5 = function $$docinfo(location, doc, opts) {
        var $$6, self = this, base_url = nil;

        
        base_url = doc.$attr("highlightjsdir", "" + (opts['$[]']("cdn_base_url")) + "/highlight.js/" + ($$($nesting, 'HIGHLIGHT_JS_VERSION')));
        if (location['$==']("head")) {
          return "" + "<link rel=\"stylesheet\" href=\"" + (base_url) + "/styles/" + (doc.$attr("highlightjs-theme", "github")) + ".min.css\"" + (opts['$[]']("self_closing_tag_slash")) + ">"
        } else {
          return "" + "<script src=\"" + (base_url) + "/highlight.min.js\"></script>\n" + ((function() {if ($truthy(doc['$attr?']("highlightjs-languages"))) {
            return $send(doc.$attr("highlightjs-languages").$split(","), 'map', [], ($$6 = function(lang){var self = $$6.$$s || this;

            
              
              if (lang == null) {
                lang = nil;
              };
              return "" + "<script src=\"" + (base_url) + "/languages/" + (lang.$lstrip()) + ".min.js\"></script>\n";}, $$6.$$s = self, $$6.$$arity = 1, $$6)).$join()
          } else {
            return ""
          }; return nil; })()) + "<script>\n" + "if (!hljs.initHighlighting.called) {\n" + "  hljs.initHighlighting.called = true\n" + "  ;[].slice.call(document.querySelectorAll('pre.highlight > code')).forEach(function (el) { hljs.highlightBlock(el) })\n" + "}\n" + "</script>"
        };
      }, $HighlightJsAdapter_docinfo$5.$$arity = 3), nil) && 'docinfo';
    })($$($nesting, 'SyntaxHighlighter'), $$$($$($nesting, 'SyntaxHighlighter'), 'Base'), $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/syntax_highlighter"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy, $klass = Opal.klass;

  Opal.add_stubs(['$attr_reader', '$raise', '$class', '$extend', '$private_class_method', '$register', '$map', '$to_s', '$each', '$[]=', '$registry', '$-', '$[]', '$for', '$===', '$new', '$name', '$private', '$include', '$==', '$delete', '$join', '$content']);
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'SyntaxHighlighter');

      var $nesting = [self].concat($parent_nesting), $SyntaxHighlighter_initialize$1, $SyntaxHighlighter_docinfo$ques$2, $SyntaxHighlighter_docinfo$3, $SyntaxHighlighter_highlight$ques$4, $SyntaxHighlighter_highlight$5, $SyntaxHighlighter_format$6, $SyntaxHighlighter_write_stylesheet$ques$7, $SyntaxHighlighter_write_stylesheet$8, $SyntaxHighlighter_included$9;

      
      self.$attr_reader("name");
      
      Opal.def(self, '$initialize', $SyntaxHighlighter_initialize$1 = function $$initialize(name, backend, opts) {
        var self = this;

        
        
        if (backend == null) {
          backend = "html5";
        };
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        return (self.name = (self.pre_class = name));
      }, $SyntaxHighlighter_initialize$1.$$arity = -2);
      
      Opal.def(self, '$docinfo?', $SyntaxHighlighter_docinfo$ques$2 = function(location) {
        var self = this;

        return nil
      }, $SyntaxHighlighter_docinfo$ques$2.$$arity = 1);
      
      Opal.def(self, '$docinfo', $SyntaxHighlighter_docinfo$3 = function $$docinfo(location, doc, opts) {
        var self = this;

        return self.$raise($$$('::', 'NotImplementedError'), "" + ($$($nesting, 'SyntaxHighlighter')) + " subclass " + (self.$class()) + " must implement the #" + ("docinfo") + " method since #docinfo? returns true")
      }, $SyntaxHighlighter_docinfo$3.$$arity = 3);
      
      Opal.def(self, '$highlight?', $SyntaxHighlighter_highlight$ques$4 = function() {
        var self = this;

        return nil
      }, $SyntaxHighlighter_highlight$ques$4.$$arity = 0);
      
      Opal.def(self, '$highlight', $SyntaxHighlighter_highlight$5 = function $$highlight(node, source, lang, opts) {
        var self = this;

        return self.$raise($$$('::', 'NotImplementedError'), "" + ($$($nesting, 'SyntaxHighlighter')) + " subclass " + (self.$class()) + " must implement the #" + ("highlight") + " method since #highlight? returns true")
      }, $SyntaxHighlighter_highlight$5.$$arity = 4);
      
      Opal.def(self, '$format', $SyntaxHighlighter_format$6 = function $$format(node, lang, opts) {
        var self = this;

        return self.$raise($$$('::', 'NotImplementedError'), "" + ($$($nesting, 'SyntaxHighlighter')) + " subclass " + (self.$class()) + " must implement the #" + ("format") + " method")
      }, $SyntaxHighlighter_format$6.$$arity = 3);
      
      Opal.def(self, '$write_stylesheet?', $SyntaxHighlighter_write_stylesheet$ques$7 = function(doc) {
        var self = this;

        return nil
      }, $SyntaxHighlighter_write_stylesheet$ques$7.$$arity = 1);
      
      Opal.def(self, '$write_stylesheet', $SyntaxHighlighter_write_stylesheet$8 = function $$write_stylesheet(doc, to_dir) {
        var self = this;

        return self.$raise($$$('::', 'NotImplementedError'), "" + ($$($nesting, 'SyntaxHighlighter')) + " subclass " + (self.$class()) + " must implement the #" + ("write_stylesheet") + " method since #write_stylesheet? returns true")
      }, $SyntaxHighlighter_write_stylesheet$8.$$arity = 2);
      Opal.defs(self, '$included', $SyntaxHighlighter_included$9 = function $$included(into) {
        var self = this;

        return into.$extend($$($nesting, 'Config'))
      }, $SyntaxHighlighter_included$9.$$arity = 1);
      self.$private_class_method("included");
      (function($base, $parent_nesting) {
        var self = $module($base, 'Config');

        var $nesting = [self].concat($parent_nesting), $Config_register_for$10;

        
        Opal.def(self, '$register_for', $Config_register_for$10 = function $$register_for($a) {
          var $post_args, names, $$11, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          names = $post_args;;
          return $send($$($nesting, 'SyntaxHighlighter'), 'register', [self].concat(Opal.to_a($send(names, 'map', [], ($$11 = function(name){var self = $$11.$$s || this;

          
            
            if (name == null) {
              name = nil;
            };
            return name.$to_s();}, $$11.$$s = self, $$11.$$arity = 1, $$11)))));
        }, $Config_register_for$10.$$arity = -1)
      })($nesting[0], $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'Factory');

        var $nesting = [self].concat($parent_nesting), $Factory_register$12, $Factory_for$14, $Factory_create$15, $Factory_registry$16;

        
        
        Opal.def(self, '$register', $Factory_register$12 = function $$register(syntax_highlighter, $a) {
          var $post_args, names, $$13, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          names = $post_args;;
          return $send(names, 'each', [], ($$13 = function(name){var self = $$13.$$s || this, $writer = nil;

          
            
            if (name == null) {
              name = nil;
            };
            $writer = [name, syntax_highlighter];
            $send(self.$registry(), '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, $$13.$$s = self, $$13.$$arity = 1, $$13));
        }, $Factory_register$12.$$arity = -2);
        
        Opal.def(self, '$for', $Factory_for$14 = function(name) {
          var self = this;

          return self.$registry()['$[]'](name)
        }, $Factory_for$14.$$arity = 1);
        
        Opal.def(self, '$create', $Factory_create$15 = function $$create(name, backend, opts) {
          var self = this, syntax_hl = nil;

          
          
          if (backend == null) {
            backend = "html5";
          };
          
          if (opts == null) {
            opts = $hash2([], {});
          };
          if ($truthy((syntax_hl = self.$for(name)))) {
            
            if ($truthy($$$('::', 'Class')['$==='](syntax_hl))) {
              syntax_hl = syntax_hl.$new(name, backend, opts)};
            if ($truthy(syntax_hl.$name())) {
            } else {
              self.$raise($$$('::', 'NameError'), "" + (syntax_hl.$class()) + " must specify a value for `name'")
            };
            return syntax_hl;
          } else {
            return nil
          };
        }, $Factory_create$15.$$arity = -2);
        self.$private();
        
        Opal.def(self, '$registry', $Factory_registry$16 = function $$registry() {
          var self = this;

          return self.$raise($$$('::', 'NotImplementedError'), "" + ($$($nesting, 'Factory')) + " subclass " + (self.$class()) + " must implement the #" + ("registry") + " method")
        }, $Factory_registry$16.$$arity = 0);
      })($nesting[0], $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'CustomFactory');

        var $nesting = [self].concat($parent_nesting), $CustomFactory_initialize$17;

        
        self.$include($$($nesting, 'Factory'));
        
        Opal.def(self, '$initialize', $CustomFactory_initialize$17 = function $$initialize(seed_registry) {
          var $a, self = this;

          
          
          if (seed_registry == null) {
            seed_registry = nil;
          };
          return (self.registry = ($truthy($a = seed_registry) ? $a : $hash2([], {})));
        }, $CustomFactory_initialize$17.$$arity = -1);
        self.$private();
        return self.$attr_reader("registry");
      })($nesting[0], null, $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'DefaultFactory');

        var $nesting = [self].concat($parent_nesting), $DefaultFactory_registry$18;

        
        self.$include($$($nesting, 'Factory'));
        (Opal.class_variable_set($nesting[0], '@@registry', $hash2([], {})));
        self.$private();
        
        Opal.def(self, '$registry', $DefaultFactory_registry$18 = function $$registry() {
          var $a, self = this;

          return (($a = $nesting[0].$$cvars['@@registry']) == null ? nil : $a)
        }, $DefaultFactory_registry$18.$$arity = 0);
        if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
        } else {
          nil
        };
      })($nesting[0], $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DefaultFactoryProxy');

        var $nesting = [self].concat($parent_nesting);

        
        self.$include($$($nesting, 'DefaultFactory'));
        if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
          return nil
        } else {
          return nil
        };
      })($nesting[0], $$($nesting, 'CustomFactory'), $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Base');

        var $nesting = [self].concat($parent_nesting), $Base_format$19;

        self.$$prototype.pre_class = nil;
        
        self.$include($$($nesting, 'SyntaxHighlighter'));
        return (Opal.def(self, '$format', $Base_format$19 = function $$format(node, lang, opts) {
          var $$20, $$21, self = this, class_attr_val = nil, transform = nil, pre = nil, code = nil, $writer = nil;

          
          class_attr_val = (function() {if ($truthy(opts['$[]']("nowrap"))) {
            return "" + (self.pre_class) + " highlight nowrap"
          } else {
            return "" + (self.pre_class) + " highlight"
          }; return nil; })();
          if ($truthy((transform = opts['$[]']("transform")))) {
            
            transform['$[]']((pre = $hash2(["class"], {"class": class_attr_val})), (code = (function() {if ($truthy(lang)) {
              return $hash2(["data-lang"], {"data-lang": lang})
            } else {
              return $hash2([], {})
            }; return nil; })()));
            if ($truthy((lang = code.$delete("data-lang")))) {
              
              $writer = ["data-lang", lang];
              $send(code, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
            return "" + "<pre" + ($send(pre, 'map', [], ($$20 = function(k, v){var self = $$20.$$s || this;

            
              
              if (k == null) {
                k = nil;
              };
              
              if (v == null) {
                v = nil;
              };
              return "" + " " + (k) + "=\"" + (v) + "\"";}, $$20.$$s = self, $$20.$$arity = 2, $$20)).$join()) + "><code" + ($send(code, 'map', [], ($$21 = function(k, v){var self = $$21.$$s || this;

            
              
              if (k == null) {
                k = nil;
              };
              
              if (v == null) {
                v = nil;
              };
              return "" + " " + (k) + "=\"" + (v) + "\"";}, $$21.$$s = self, $$21.$$arity = 2, $$21)).$join()) + ">" + (node.$content()) + "</code></pre>";
          } else {
            return "" + "<pre class=\"" + (class_attr_val) + "\"><code" + ((function() {if ($truthy(lang)) {
              return "" + " data-lang=\"" + (lang) + "\""
            } else {
              return ""
            }; return nil; })()) + ">" + (node.$content()) + "</code></pre>"
          };
        }, $Base_format$19.$$arity = 3), nil) && 'format';
      })($nesting[0], null, $nesting);
      self.$extend($$($nesting, 'DefaultFactory'));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
  self.$require("asciidoctor/syntax_highlighter.rb"+ '/../' + "syntax_highlighter/highlightjs");
  if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
    return nil
  } else {
    return nil
  };
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/timings"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$now', '$[]=', '$-', '$delete', '$reduce', '$+', '$[]', '$>', '$time', '$puts', '$sprintf', '$to_f', '$read_parse', '$convert', '$read_parse_convert', '$private', '$const_defined?', '$==', '$clock_gettime']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Timings');

      var $nesting = [self].concat($parent_nesting), $Timings_initialize$1, $Timings_start$2, $Timings_record$3, $Timings_time$4, $Timings_read$6, $Timings_parse$7, $Timings_read_parse$8, $Timings_convert$9, $Timings_read_parse_convert$10, $Timings_write$11, $Timings_total$12, $Timings_print_report$13, $a, $b, $c, $d, $e, $Timings_now$14, $Timings_now$15;

      self.$$prototype.timers = self.$$prototype.log = nil;
      
      
      Opal.def(self, '$initialize', $Timings_initialize$1 = function $$initialize() {
        var self = this;

        
        self.log = $hash2([], {});
        return (self.timers = $hash2([], {}));
      }, $Timings_initialize$1.$$arity = 0);
      
      Opal.def(self, '$start', $Timings_start$2 = function $$start(key) {
        var self = this, $writer = nil;

        
        $writer = [key, self.$now()];
        $send(self.timers, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];
      }, $Timings_start$2.$$arity = 1);
      
      Opal.def(self, '$record', $Timings_record$3 = function $$record(key) {
        var self = this, $writer = nil;

        
        $writer = [key, $rb_minus(self.$now(), self.timers.$delete(key))];
        $send(self.log, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];
      }, $Timings_record$3.$$arity = 1);
      
      Opal.def(self, '$time', $Timings_time$4 = function $$time($a) {
        var $post_args, keys, $$5, self = this, time = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        keys = $post_args;;
        time = $send(keys, 'reduce', [0], ($$5 = function(sum, key){var self = $$5.$$s || this, $b;
          if (self.log == null) self.log = nil;

        
          
          if (sum == null) {
            sum = nil;
          };
          
          if (key == null) {
            key = nil;
          };
          return $rb_plus(sum, ($truthy($b = self.log['$[]'](key)) ? $b : 0));}, $$5.$$s = self, $$5.$$arity = 2, $$5));
        if ($truthy($rb_gt(time, 0))) {
          return time
        } else {
          return nil
        };
      }, $Timings_time$4.$$arity = -1);
      
      Opal.def(self, '$read', $Timings_read$6 = function $$read() {
        var self = this;

        return self.$time("read")
      }, $Timings_read$6.$$arity = 0);
      
      Opal.def(self, '$parse', $Timings_parse$7 = function $$parse() {
        var self = this;

        return self.$time("parse")
      }, $Timings_parse$7.$$arity = 0);
      
      Opal.def(self, '$read_parse', $Timings_read_parse$8 = function $$read_parse() {
        var self = this;

        return self.$time("read", "parse")
      }, $Timings_read_parse$8.$$arity = 0);
      
      Opal.def(self, '$convert', $Timings_convert$9 = function $$convert() {
        var self = this;

        return self.$time("convert")
      }, $Timings_convert$9.$$arity = 0);
      
      Opal.def(self, '$read_parse_convert', $Timings_read_parse_convert$10 = function $$read_parse_convert() {
        var self = this;

        return self.$time("read", "parse", "convert")
      }, $Timings_read_parse_convert$10.$$arity = 0);
      
      Opal.def(self, '$write', $Timings_write$11 = function $$write() {
        var self = this;

        return self.$time("write")
      }, $Timings_write$11.$$arity = 0);
      
      Opal.def(self, '$total', $Timings_total$12 = function $$total() {
        var self = this;

        return self.$time("read", "parse", "convert", "write")
      }, $Timings_total$12.$$arity = 0);
      
      Opal.def(self, '$print_report', $Timings_print_report$13 = function $$print_report(to, subject) {
        var self = this;
        if ($gvars.stdout == null) $gvars.stdout = nil;

        
        
        if (to == null) {
          to = $gvars.stdout;
        };
        
        if (subject == null) {
          subject = nil;
        };
        if ($truthy(subject)) {
          to.$puts("" + "Input file: " + (subject))};
        to.$puts("" + "  Time to read and parse source: " + (self.$sprintf("%05.5f", self.$read_parse().$to_f())));
        to.$puts("" + "  Time to convert document: " + (self.$sprintf("%05.5f", self.$convert().$to_f())));
        return to.$puts("" + "  Total time (read, parse and convert): " + (self.$sprintf("%05.5f", self.$read_parse_convert().$to_f())));
      }, $Timings_print_report$13.$$arity = -1);
      self.$private();
      if ($truthy(($truthy($a = $$$('::', 'Process')['$const_defined?']("CLOCK_MONOTONIC", false)) ? ((($b = $$$('::', 'Process', 'skip_raise')) && ($c = $b, $c) && ($d = $c) && ((($e = $d.$clock_gettime) && !$e.$$stub) || $d['$respond_to_missing?']('clock_gettime'))) ? 'method' : nil)['$==']("method") : $a))) {
        
        Opal.const_set($nesting[0], 'CLOCK_ID', $$$($$$('::', 'Process'), 'CLOCK_MONOTONIC'));
        return (Opal.def(self, '$now', $Timings_now$14 = function $$now() {
          var self = this;

          return $$$('::', 'Process').$clock_gettime($$($nesting, 'CLOCK_ID'))
        }, $Timings_now$14.$$arity = 0), nil) && 'now';
      } else {
        return (Opal.def(self, '$now', $Timings_now$15 = function $$now() {
          var self = this;

          return $$$('::', 'Time').$now()
        }, $Timings_now$15.$$arity = 0), nil) && 'now'
      };
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/converter/composite"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_reader', '$each', '$respond_to?', '$composed', '$init_backend_traits', '$backend_traits', '$new', '$find_converter', '$[]=', '$-', '$convert', '$converter_for', '$node_name', '$[]', '$handles?', '$raise']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CompositeConverter');

      var $nesting = [self].concat($parent_nesting), $CompositeConverter_initialize$1, $CompositeConverter_convert$4, $CompositeConverter_converter_for$5, $CompositeConverter_find_converter$6;

      self.$$prototype.converter_cache = self.$$prototype.converters = nil;
      
      self.$attr_reader("converters");
      
      Opal.def(self, '$initialize', $CompositeConverter_initialize$1 = function $$initialize(backend, $a, $b) {
        var $post_args, $kwargs, converters, backend_traits_source, $$2, $$3, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 1, arguments.length);
        
        $kwargs = Opal.extract_kwargs($post_args);
        
        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new('expected kwargs');
        };
        
        converters = $post_args;;
        
        backend_traits_source = $kwargs.$$smap["backend_traits_source"];
        if (backend_traits_source == null) {
          backend_traits_source = nil
        };
        self.backend = backend;
        $send((self.converters = converters), 'each', [], ($$2 = function(converter){var self = $$2.$$s || this;

        
          
          if (converter == null) {
            converter = nil;
          };
          if ($truthy(converter['$respond_to?']("composed"))) {
            return converter.$composed(self)
          } else {
            return nil
          };}, $$2.$$s = self, $$2.$$arity = 1, $$2));
        if ($truthy(backend_traits_source)) {
          self.$init_backend_traits(backend_traits_source.$backend_traits())};
        return (self.converter_cache = $send($$$('::', 'Hash'), 'new', [], ($$3 = function(hash, key){var self = $$3.$$s || this, $writer = nil;

        
          
          if (hash == null) {
            hash = nil;
          };
          
          if (key == null) {
            key = nil;
          };
          $writer = [key, self.$find_converter(key)];
          $send(hash, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$3.$$s = self, $$3.$$arity = 2, $$3)));
      }, $CompositeConverter_initialize$1.$$arity = -2);
      
      Opal.def(self, '$convert', $CompositeConverter_convert$4 = function $$convert(node, transform, opts) {
        var $a, self = this;

        
        
        if (transform == null) {
          transform = nil;
        };
        
        if (opts == null) {
          opts = nil;
        };
        return self.$converter_for((transform = ($truthy($a = transform) ? $a : node.$node_name()))).$convert(node, transform, opts);
      }, $CompositeConverter_convert$4.$$arity = -2);
      
      Opal.def(self, '$converter_for', $CompositeConverter_converter_for$5 = function $$converter_for(transform) {
        var self = this;

        return self.converter_cache['$[]'](transform)
      }, $CompositeConverter_converter_for$5.$$arity = 1);
      return (Opal.def(self, '$find_converter', $CompositeConverter_find_converter$6 = function $$find_converter(transform) {try {

        var $$7, self = this;

        
        $send(self.converters, 'each', [], ($$7 = function(candidate){var self = $$7.$$s || this;

        
          
          if (candidate == null) {
            candidate = nil;
          };
          if ($truthy(candidate['$handles?'](transform))) {
            Opal.ret(candidate)
          } else {
            return nil
          };}, $$7.$$s = self, $$7.$$arity = 1, $$7));
        return self.$raise("" + "Could not find a converter to handle transform: " + (transform));
        } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
      }, $CompositeConverter_find_converter$6.$$arity = 1), nil) && 'find_converter';
    })($$($nesting, 'Converter'), $$$($$($nesting, 'Converter'), 'Base'), $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/converter/html5"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$register_for', '$default=', '$-', '$==', '$[]', '$init_backend_traits', '$node_name', '$===', '$convert_inline_quoted', '$convert_paragraph', '$convert_inline_anchor', '$convert_section', '$convert_listing', '$convert_literal', '$convert_ulist', '$convert_olist', '$convert_dlist', '$convert_admonition', '$convert_colist', '$convert_embedded', '$convert_example', '$convert_floating_title', '$convert_image', '$convert_inline_break', '$convert_inline_button', '$convert_inline_callout', '$convert_inline_footnote', '$convert_inline_image', '$convert_inline_indexterm', '$convert_inline_kbd', '$convert_inline_menu', '$convert_open', '$convert_page_break', '$convert_preamble', '$convert_quote', '$convert_sidebar', '$convert_stem', '$convert_table', '$convert_thematic_break', '$convert_verse', '$convert_video', '$convert_document', '$convert_toc', '$convert_pass', '$convert_audio', '$empty?', '$attr', '$attr?', '$<<', '$include?', '$sub_replacements', '$gsub', '$extname', '$slice', '$length', '$doctitle', '$normalize_web_path', '$primary_stylesheet_data', '$instance', '$read_contents', '$syntax_highlighter', '$size', '$docinfo', '$id', '$sections?', '$doctype', '$role?', '$role', '$join', '$noheader', '$convert', '$converter', '$generate_manname_section', '$header?', '$notitle', '$title', '$header', '$each', '$authors', '$>', '$name', '$email', '$sub_macros', '$+', '$downcase', '$concat', '$content', '$footnotes?', '$!', '$footnotes', '$index', '$text', '$nofooter', '$docinfo?', '$[]=', '$delete_at', '$inspect', '$!=', '$to_i', '$attributes', '$document', '$sections', '$level', '$caption', '$captioned_title', '$numbered', '$<=', '$<', '$sectname', '$sectnum', '$convert_outline', '$title?', '$icon_uri', '$compact', '$media_uri', '$option?', '$append_boolean_attribute', '$style', '$items', '$blocks?', '$text?', '$chomp', '$safe', '$read_svg_contents', '$alt', '$image_uri', '$encode_attribute_value', '$append_link_constraint_attrs', '$highlight?', '$to_sym', '$format', '$*', '$count', '$start_with?', '$end_with?', '$list_marker_keyword', '$parent', '$warn', '$logger', '$context', '$error', '$new', '$columns', '$to_h', '$rows', '$colspan', '$rowspan', '$unshift', '$shift', '$split', '$pop', '$nil_or_empty?', '$type', '$catalog', '$get_root_document', '$xreftext', '$target', '$reftext', '$chop', '$sub', '$match', '$private', '$upcase', '$nested?', '$parent_document', '$to_s', '$handles?', '$send']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Html5Converter');

      var $nesting = [self].concat($parent_nesting), $Html5Converter_initialize$1, $Html5Converter_convert$2, $Html5Converter_convert_document$3, $Html5Converter_convert_embedded$6, $Html5Converter_convert_outline$8, $Html5Converter_convert_section$10, $Html5Converter_convert_admonition$11, $Html5Converter_convert_audio$12, $Html5Converter_convert_colist$13, $Html5Converter_convert_dlist$16, $Html5Converter_convert_example$23, $Html5Converter_convert_floating_title$24, $Html5Converter_convert_image$25, $Html5Converter_convert_listing$26, $Html5Converter_convert_literal$27, $Html5Converter_convert_stem$28, $Html5Converter_convert_olist$30, $Html5Converter_convert_open$32, $Html5Converter_convert_page_break$33, $Html5Converter_convert_paragraph$34, $Html5Converter_convert_preamble$35, $Html5Converter_convert_quote$36, $Html5Converter_convert_thematic_break$37, $Html5Converter_convert_sidebar$38, $Html5Converter_convert_table$39, $Html5Converter_convert_toc$44, $Html5Converter_convert_ulist$45, $Html5Converter_convert_verse$47, $Html5Converter_convert_video$48, $Html5Converter_convert_inline_anchor$49, $Html5Converter_convert_inline_break$50, $Html5Converter_convert_inline_button$51, $Html5Converter_convert_inline_callout$52, $Html5Converter_convert_inline_footnote$53, $Html5Converter_convert_inline_image$54, $Html5Converter_convert_inline_indexterm$55, $Html5Converter_convert_inline_kbd$56, $Html5Converter_convert_inline_menu$57, $Html5Converter_convert_inline_quoted$58, $Html5Converter_read_svg_contents$59, $Html5Converter_append_boolean_attribute$61, $Html5Converter_append_link_constraint_attrs$62, $Html5Converter_encode_attribute_value$63, $Html5Converter_generate_manname_section$64, $Html5Converter_get_root_document$65, $Html5Converter_method_missing$66, $Html5Converter_respond_to_missing$ques$67, $writer = nil;

      self.$$prototype.void_element_slash = self.$$prototype.xml_mode = self.$$prototype.refs = self.$$prototype.resolving_xref = nil;
      
      self.$register_for("html5");
      
      $writer = [["", ""]];
      $send(Opal.const_set($nesting[0], 'QUOTE_TAGS', $hash2(["monospaced", "emphasis", "strong", "double", "single", "mark", "superscript", "subscript", "asciimath", "latexmath"], {"monospaced": ["<code>", "</code>", true], "emphasis": ["<em>", "</em>", true], "strong": ["<strong>", "</strong>", true], "double": ["&#8220;", "&#8221;"], "single": ["&#8216;", "&#8217;"], "mark": ["<mark>", "</mark>", true], "superscript": ["<sup>", "</sup>", true], "subscript": ["<sub>", "</sub>", true], "asciimath": ["\\$", "\\$"], "latexmath": ["\\(", "\\)"]})), 'default=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      Opal.const_set($nesting[0], 'DropAnchorRx', /<(?:a\b[^>]*|\/a)>/);
      Opal.const_set($nesting[0], 'StemBreakRx', / *\\\n(?:\\?\n)*|\n\n+/);
      if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
        
        Opal.const_set($nesting[0], 'SvgPreambleRx', new RegExp("" + "^" + ($$($nesting, 'CC_ALL')) + "*?(?=<svg[\\s>])"));
        Opal.const_set($nesting[0], 'SvgStartTagRx', /^<svg(?:\s[^>]*)?>/);
      } else {
        nil
      };
      Opal.const_set($nesting[0], 'DimensionAttributeRx', new RegExp("" + "\\s(?:width|height|style)=([\"'])" + ($$($nesting, 'CC_ANY')) + "*?\\1"));
      
      Opal.def(self, '$initialize', $Html5Converter_initialize$1 = function $$initialize(backend, opts) {
        var self = this, syntax = nil;

        
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        self.backend = backend;
        if (opts['$[]']("htmlsyntax")['$==']("xml")) {
          
          syntax = "xml";
          self.xml_mode = true;
          self.void_element_slash = "/";
        } else {
          
          syntax = "html";
          self.xml_mode = nil;
          self.void_element_slash = "";
        };
        return self.$init_backend_traits($hash2(["basebackend", "filetype", "htmlsyntax", "outfilesuffix", "supports_templates"], {"basebackend": "html", "filetype": "html", "htmlsyntax": syntax, "outfilesuffix": ".html", "supports_templates": true}));
      }, $Html5Converter_initialize$1.$$arity = -2);
      
      Opal.def(self, '$convert', $Html5Converter_convert$2 = function $$convert(node, transform, opts) {
        var $iter = $Html5Converter_convert$2.$$p, $yield = $iter || nil, self = this, $case = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $Html5Converter_convert$2.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        
        if (transform == null) {
          transform = node.$node_name();
        };
        
        if (opts == null) {
          opts = nil;
        };
        return (function() {$case = transform;
        if ("inline_quoted"['$===']($case)) {return self.$convert_inline_quoted(node)}
        else if ("paragraph"['$===']($case)) {return self.$convert_paragraph(node)}
        else if ("inline_anchor"['$===']($case)) {return self.$convert_inline_anchor(node)}
        else if ("section"['$===']($case)) {return self.$convert_section(node)}
        else if ("listing"['$===']($case)) {return self.$convert_listing(node)}
        else if ("literal"['$===']($case)) {return self.$convert_literal(node)}
        else if ("ulist"['$===']($case)) {return self.$convert_ulist(node)}
        else if ("olist"['$===']($case)) {return self.$convert_olist(node)}
        else if ("dlist"['$===']($case)) {return self.$convert_dlist(node)}
        else if ("admonition"['$===']($case)) {return self.$convert_admonition(node)}
        else if ("colist"['$===']($case)) {return self.$convert_colist(node)}
        else if ("embedded"['$===']($case)) {return self.$convert_embedded(node)}
        else if ("example"['$===']($case)) {return self.$convert_example(node)}
        else if ("floating_title"['$===']($case)) {return self.$convert_floating_title(node)}
        else if ("image"['$===']($case)) {return self.$convert_image(node)}
        else if ("inline_break"['$===']($case)) {return self.$convert_inline_break(node)}
        else if ("inline_button"['$===']($case)) {return self.$convert_inline_button(node)}
        else if ("inline_callout"['$===']($case)) {return self.$convert_inline_callout(node)}
        else if ("inline_footnote"['$===']($case)) {return self.$convert_inline_footnote(node)}
        else if ("inline_image"['$===']($case)) {return self.$convert_inline_image(node)}
        else if ("inline_indexterm"['$===']($case)) {return self.$convert_inline_indexterm(node)}
        else if ("inline_kbd"['$===']($case)) {return self.$convert_inline_kbd(node)}
        else if ("inline_menu"['$===']($case)) {return self.$convert_inline_menu(node)}
        else if ("open"['$===']($case)) {return self.$convert_open(node)}
        else if ("page_break"['$===']($case)) {return self.$convert_page_break(node)}
        else if ("preamble"['$===']($case)) {return self.$convert_preamble(node)}
        else if ("quote"['$===']($case)) {return self.$convert_quote(node)}
        else if ("sidebar"['$===']($case)) {return self.$convert_sidebar(node)}
        else if ("stem"['$===']($case)) {return self.$convert_stem(node)}
        else if ("table"['$===']($case)) {return self.$convert_table(node)}
        else if ("thematic_break"['$===']($case)) {return self.$convert_thematic_break(node)}
        else if ("verse"['$===']($case)) {return self.$convert_verse(node)}
        else if ("video"['$===']($case)) {return self.$convert_video(node)}
        else if ("document"['$===']($case)) {return self.$convert_document(node)}
        else if ("toc"['$===']($case)) {return self.$convert_toc(node)}
        else if ("pass"['$===']($case)) {return self.$convert_pass(node)}
        else if ("audio"['$===']($case)) {return self.$convert_audio(node)}
        else {return $send(self, Opal.find_super_dispatcher(self, 'convert', $Html5Converter_convert$2, false), $zuper, $iter)}})();
      }, $Html5Converter_convert$2.$$arity = -2);
      
      Opal.def(self, '$convert_document', $Html5Converter_convert_document$3 = function $$convert_document(node) {
        var $a, $b, $c, $$4, $$5, self = this, br = nil, slash = nil, asset_uri_scheme = nil, cdn_base_url = nil, linkcss = nil, max_width_attr = nil, result = nil, lang_attribute = nil, authors = nil, icon_href = nil, icon_type = nil, icon_ext = nil, webfonts = nil, iconfont_stylesheet = nil, syntax_hl = nil, syntax_hl_docinfo_head_idx = nil, docinfo_content = nil, id_attr = nil, sectioned = nil, classes = nil, details = nil, idx = nil, $writer = nil, eqnums_val = nil, eqnums_opt = nil;

        
        br = "" + "<br" + ((slash = self.void_element_slash)) + ">";
        if ($truthy((asset_uri_scheme = node.$attr("asset-uri-scheme", "https"))['$empty?']())) {
        } else {
          asset_uri_scheme = "" + (asset_uri_scheme) + ":"
        };
        cdn_base_url = "" + (asset_uri_scheme) + "//cdnjs.cloudflare.com/ajax/libs";
        linkcss = node['$attr?']("linkcss");
        max_width_attr = (function() {if ($truthy(node['$attr?']("max-width"))) {
          return "" + " style=\"max-width: " + (node.$attr("max-width")) + ";\""
        } else {
          return ""
        }; return nil; })();
        result = ["<!DOCTYPE html>"];
        lang_attribute = (function() {if ($truthy(node['$attr?']("nolang"))) {
          return ""
        } else {
          return "" + " lang=\"" + (node.$attr("lang", "en")) + "\""
        }; return nil; })();
        result['$<<']("" + "<html" + ((function() {if ($truthy(self.xml_mode)) {
          return " xmlns=\"http://www.w3.org/1999/xhtml\""
        } else {
          return ""
        }; return nil; })()) + (lang_attribute) + ">");
        result['$<<']("" + "<head>\n" + "<meta charset=\"" + (node.$attr("encoding", "UTF-8")) + "\"" + (slash) + ">\n" + "<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"" + (slash) + ">\n" + "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"" + (slash) + ">\n" + "<meta name=\"generator\" content=\"Asciidoctor " + (node.$attr("asciidoctor-version")) + "\"" + (slash) + ">");
        if ($truthy(node['$attr?']("app-name"))) {
          result['$<<']("" + "<meta name=\"application-name\" content=\"" + (node.$attr("app-name")) + "\"" + (slash) + ">")};
        if ($truthy(node['$attr?']("description"))) {
          result['$<<']("" + "<meta name=\"description\" content=\"" + (node.$attr("description")) + "\"" + (slash) + ">")};
        if ($truthy(node['$attr?']("keywords"))) {
          result['$<<']("" + "<meta name=\"keywords\" content=\"" + (node.$attr("keywords")) + "\"" + (slash) + ">")};
        if ($truthy(node['$attr?']("authors"))) {
          result['$<<']("" + "<meta name=\"author\" content=\"" + ((function() {if ($truthy((authors = node.$sub_replacements(node.$attr("authors")))['$include?']("<"))) {
            
            return authors.$gsub($$($nesting, 'XmlSanitizeRx'), "");
          } else {
            return authors
          }; return nil; })()) + "\"" + (slash) + ">")};
        if ($truthy(node['$attr?']("copyright"))) {
          result['$<<']("" + "<meta name=\"copyright\" content=\"" + (node.$attr("copyright")) + "\"" + (slash) + ">")};
        if ($truthy(node['$attr?']("favicon"))) {
          
          if ($truthy((icon_href = node.$attr("favicon"))['$empty?']())) {
            
            icon_href = "favicon.ico";
            icon_type = "image/x-icon";
          } else if ($truthy((icon_ext = $$($nesting, 'Helpers').$extname(icon_href, nil)))) {
            icon_type = (function() {if (icon_ext['$=='](".ico")) {
              return "image/x-icon"
            } else {
              return "" + "image/" + (icon_ext.$slice(1, icon_ext.$length()))
            }; return nil; })()
          } else {
            icon_type = "image/x-icon"
          };
          result['$<<']("" + "<link rel=\"icon\" type=\"" + (icon_type) + "\" href=\"" + (icon_href) + "\"" + (slash) + ">");};
        result['$<<']("" + "<title>" + (node.$doctitle($hash2(["sanitize", "use_fallback"], {"sanitize": true, "use_fallback": true}))) + "</title>");
        if ($truthy($$($nesting, 'DEFAULT_STYLESHEET_KEYS')['$include?'](node.$attr("stylesheet")))) {
          
          if ($truthy((webfonts = node.$attr("webfonts")))) {
            result['$<<']("" + "<link rel=\"stylesheet\" href=\"" + (asset_uri_scheme) + "//fonts.googleapis.com/css?family=" + ((function() {if ($truthy(webfonts['$empty?']())) {
              return "Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"
            } else {
              return webfonts
            }; return nil; })()) + "\"" + (slash) + ">")};
          if ($truthy(linkcss)) {
            result['$<<']("" + "<link rel=\"stylesheet\" href=\"" + (node.$normalize_web_path($$($nesting, 'DEFAULT_STYLESHEET_NAME'), node.$attr("stylesdir", ""), false)) + "\"" + (slash) + ">")
          } else {
            result['$<<']("" + "<style>\n" + ($$($nesting, 'Stylesheets').$instance().$primary_stylesheet_data()) + "\n" + "</style>")
          };
        } else if ($truthy(node['$attr?']("stylesheet"))) {
          if ($truthy(linkcss)) {
            result['$<<']("" + "<link rel=\"stylesheet\" href=\"" + (node.$normalize_web_path(node.$attr("stylesheet"), node.$attr("stylesdir", ""))) + "\"" + (slash) + ">")
          } else {
            result['$<<']("" + "<style>\n" + (node.$read_contents(node.$attr("stylesheet"), $hash2(["start", "warn_on_failure", "label"], {"start": node.$attr("stylesdir"), "warn_on_failure": true, "label": "stylesheet"}))) + "\n" + "</style>")
          }};
        if ($truthy(node['$attr?']("icons", "font"))) {
          if ($truthy(node['$attr?']("iconfont-remote"))) {
            result['$<<']("" + "<link rel=\"stylesheet\" href=\"" + (node.$attr("iconfont-cdn", "" + (cdn_base_url) + "/font-awesome/" + ($$($nesting, 'FONT_AWESOME_VERSION')) + "/css/font-awesome.min.css")) + "\"" + (slash) + ">")
          } else {
            
            iconfont_stylesheet = "" + (node.$attr("iconfont-name", "font-awesome")) + ".css";
            result['$<<']("" + "<link rel=\"stylesheet\" href=\"" + (node.$normalize_web_path(iconfont_stylesheet, node.$attr("stylesdir", ""), false)) + "\"" + (slash) + ">");
          }};
        if ($truthy((syntax_hl = node.$syntax_highlighter()))) {
          result['$<<']((syntax_hl_docinfo_head_idx = result.$size()))};
        if ($truthy((docinfo_content = node.$docinfo())['$empty?']())) {
        } else {
          result['$<<'](docinfo_content)
        };
        result['$<<']("</head>");
        id_attr = (function() {if ($truthy(node.$id())) {
          return "" + " id=\"" + (node.$id()) + "\""
        } else {
          return ""
        }; return nil; })();
        if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = (sectioned = node['$sections?']())) ? node['$attr?']("toc-class") : $c)) ? node['$attr?']("toc") : $b)) ? node['$attr?']("toc-placement", "auto") : $a))) {
          classes = [node.$doctype(), node.$attr("toc-class"), "" + "toc-" + (node.$attr("toc-position", "header"))]
        } else {
          classes = [node.$doctype()]
        };
        if ($truthy(node['$role?']())) {
          classes['$<<'](node.$role())};
        result['$<<']("" + "<body" + (id_attr) + " class=\"" + (classes.$join(" ")) + "\">");
        if ($truthy((docinfo_content = node.$docinfo("header"))['$empty?']())) {
        } else {
          result['$<<'](docinfo_content)
        };
        if ($truthy(node.$noheader())) {
        } else {
          
          result['$<<']("" + "<div id=\"header\"" + (max_width_attr) + ">");
          if (node.$doctype()['$==']("manpage")) {
            
            result['$<<']("" + "<h1>" + (node.$doctitle()) + " Manual Page</h1>");
            if ($truthy(($truthy($a = ($truthy($b = sectioned) ? node['$attr?']("toc") : $b)) ? node['$attr?']("toc-placement", "auto") : $a))) {
              result['$<<']("" + "<div id=\"toc\" class=\"" + (node.$attr("toc-class", "toc")) + "\">\n" + "<div id=\"toctitle\">" + (node.$attr("toc-title")) + "</div>\n" + (node.$converter().$convert(node, "outline")) + "\n" + "</div>")};
            if ($truthy(node['$attr?']("manpurpose"))) {
              result['$<<'](self.$generate_manname_section(node))};
          } else {
            
            if ($truthy(node['$header?']())) {
              
              if ($truthy(node.$notitle())) {
              } else {
                result['$<<']("" + "<h1>" + (node.$header().$title()) + "</h1>")
              };
              details = [];
              idx = 1;
              $send(node.$authors(), 'each', [], ($$4 = function(author){var self = $$4.$$s || this;

              
                
                if (author == null) {
                  author = nil;
                };
                details['$<<']("" + "<span id=\"author" + ((function() {if ($truthy($rb_gt(idx, 1))) {
                  return idx
                } else {
                  return ""
                }; return nil; })()) + "\" class=\"author\">" + (node.$sub_replacements(author.$name())) + "</span>" + (br));
                if ($truthy(author.$email())) {
                  details['$<<']("" + "<span id=\"email" + ((function() {if ($truthy($rb_gt(idx, 1))) {
                    return idx
                  } else {
                    return ""
                  }; return nil; })()) + "\" class=\"email\">" + (node.$sub_macros(author.$email())) + "</span>" + (br))};
                return (idx = $rb_plus(idx, 1));}, $$4.$$s = self, $$4.$$arity = 1, $$4));
              if ($truthy(node['$attr?']("revnumber"))) {
                details['$<<']("" + "<span id=\"revnumber\">" + (($truthy($a = node.$attr("version-label")) ? $a : "").$downcase()) + " " + (node.$attr("revnumber")) + ((function() {if ($truthy(node['$attr?']("revdate"))) {
                  return ","
                } else {
                  return ""
                }; return nil; })()) + "</span>")};
              if ($truthy(node['$attr?']("revdate"))) {
                details['$<<']("" + "<span id=\"revdate\">" + (node.$attr("revdate")) + "</span>")};
              if ($truthy(node['$attr?']("revremark"))) {
                details['$<<']("" + (br) + "<span id=\"revremark\">" + (node.$attr("revremark")) + "</span>")};
              if ($truthy(details['$empty?']())) {
              } else {
                
                result['$<<']("<div class=\"details\">");
                result.$concat(details);
                result['$<<']("</div>");
              };};
            if ($truthy(($truthy($a = ($truthy($b = sectioned) ? node['$attr?']("toc") : $b)) ? node['$attr?']("toc-placement", "auto") : $a))) {
              result['$<<']("" + "<div id=\"toc\" class=\"" + (node.$attr("toc-class", "toc")) + "\">\n" + "<div id=\"toctitle\">" + (node.$attr("toc-title")) + "</div>\n" + (node.$converter().$convert(node, "outline")) + "\n" + "</div>")};
          };
          result['$<<']("</div>");
        };
        result['$<<']("" + "<div id=\"content\"" + (max_width_attr) + ">\n" + (node.$content()) + "\n" + "</div>");
        if ($truthy(($truthy($a = node['$footnotes?']()) ? node['$attr?']("nofootnotes")['$!']() : $a))) {
          
          result['$<<']("" + "<div id=\"footnotes\"" + (max_width_attr) + ">\n" + "<hr" + (slash) + ">");
          $send(node.$footnotes(), 'each', [], ($$5 = function(footnote){var self = $$5.$$s || this;

          
            
            if (footnote == null) {
              footnote = nil;
            };
            return result['$<<']("" + "<div class=\"footnote\" id=\"_footnotedef_" + (footnote.$index()) + "\">\n" + "<a href=\"#_footnoteref_" + (footnote.$index()) + "\">" + (footnote.$index()) + "</a>. " + (footnote.$text()) + "\n" + "</div>");}, $$5.$$s = self, $$5.$$arity = 1, $$5));
          result['$<<']("</div>");};
        if ($truthy(node.$nofooter())) {
        } else {
          
          result['$<<']("" + "<div id=\"footer\"" + (max_width_attr) + ">");
          result['$<<']("<div id=\"footer-text\">");
          if ($truthy(node['$attr?']("revnumber"))) {
            result['$<<']("" + (node.$attr("version-label")) + " " + (node.$attr("revnumber")) + (br))};
          if ($truthy(($truthy($a = node['$attr?']("last-update-label")) ? node['$attr?']("reproducible")['$!']() : $a))) {
            result['$<<']("" + (node.$attr("last-update-label")) + " " + (node.$attr("docdatetime")))};
          result['$<<']("</div>");
          result['$<<']("</div>");
        };
        if ($truthy(syntax_hl)) {
          
          if ($truthy(syntax_hl['$docinfo?']("head"))) {
            
            $writer = [syntax_hl_docinfo_head_idx, syntax_hl.$docinfo("head", node, $hash2(["cdn_base_url", "linkcss", "self_closing_tag_slash"], {"cdn_base_url": cdn_base_url, "linkcss": linkcss, "self_closing_tag_slash": slash}))];
            $send(result, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          } else {
            result.$delete_at(syntax_hl_docinfo_head_idx)
          };
          if ($truthy(syntax_hl['$docinfo?']("footer"))) {
            result['$<<'](syntax_hl.$docinfo("footer", node, $hash2(["cdn_base_url", "linkcss", "self_closing_tag_slash"], {"cdn_base_url": cdn_base_url, "linkcss": linkcss, "self_closing_tag_slash": slash})))};};
        if ($truthy(node['$attr?']("stem"))) {
          
          eqnums_val = node.$attr("eqnums", "none");
          if ($truthy(eqnums_val['$empty?']())) {
            eqnums_val = "AMS"};
          eqnums_opt = "" + " equationNumbers: { autoNumber: \"" + (eqnums_val) + "\" } ";
          result['$<<']("" + "<script type=\"text/x-mathjax-config\">\n" + "MathJax.Hub.Config({\n" + "  messageStyle: \"none\",\n" + "  tex2jax: {\n" + "    inlineMath: [" + ($$($nesting, 'INLINE_MATH_DELIMITERS')['$[]']("latexmath").$inspect()) + "],\n" + "    displayMath: [" + ($$($nesting, 'BLOCK_MATH_DELIMITERS')['$[]']("latexmath").$inspect()) + "],\n" + "    ignoreClass: \"nostem|nolatexmath\"\n" + "  },\n" + "  asciimath2jax: {\n" + "    delimiters: [" + ($$($nesting, 'BLOCK_MATH_DELIMITERS')['$[]']("asciimath").$inspect()) + "],\n" + "    ignoreClass: \"nostem|noasciimath\"\n" + "  },\n" + "  TeX: {" + (eqnums_opt) + "}\n" + "})\n" + "MathJax.Hub.Register.StartupHook(\"AsciiMath Jax Ready\", function () {\n" + "  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {\n" + "    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains(\"stemblock\")) {\n" + "      data.math.root.display = \"block\"\n" + "    }\n" + "    return data\n" + "  })\n" + "})\n" + "</script>\n" + "<script src=\"" + (cdn_base_url) + "/mathjax/" + ($$($nesting, 'MATHJAX_VERSION')) + "/MathJax.js?config=TeX-MML-AM_HTMLorMML\"></script>");};
        if ($truthy((docinfo_content = node.$docinfo("footer"))['$empty?']())) {
        } else {
          result['$<<'](docinfo_content)
        };
        result['$<<']("</body>");
        result['$<<']("</html>");
        return result.$join($$($nesting, 'LF'));
      }, $Html5Converter_convert_document$3.$$arity = 1);
      
      Opal.def(self, '$convert_embedded', $Html5Converter_convert_embedded$6 = function $$convert_embedded(node) {
        var $a, $b, $c, $$7, self = this, result = nil, id_attr = nil, toc_p = nil;

        
        result = [];
        if (node.$doctype()['$==']("manpage")) {
          
          if ($truthy(node.$notitle())) {
          } else {
            
            id_attr = (function() {if ($truthy(node.$id())) {
              return "" + " id=\"" + (node.$id()) + "\""
            } else {
              return ""
            }; return nil; })();
            result['$<<']("" + "<h1" + (id_attr) + ">" + (node.$doctitle()) + " Manual Page</h1>");
          };
          if ($truthy(node['$attr?']("manpurpose"))) {
            result['$<<'](self.$generate_manname_section(node))};
        } else if ($truthy(($truthy($a = node['$header?']()) ? node.$notitle()['$!']() : $a))) {
          
          id_attr = (function() {if ($truthy(node.$id())) {
            return "" + " id=\"" + (node.$id()) + "\""
          } else {
            return ""
          }; return nil; })();
          result['$<<']("" + "<h1" + (id_attr) + ">" + (node.$header().$title()) + "</h1>");};
        if ($truthy(($truthy($a = ($truthy($b = ($truthy($c = node['$sections?']()) ? node['$attr?']("toc") : $c)) ? (toc_p = node.$attr("toc-placement"))['$!=']("macro") : $b)) ? toc_p['$!=']("preamble") : $a))) {
          result['$<<']("" + "<div id=\"toc\" class=\"toc\">\n" + "<div id=\"toctitle\">" + (node.$attr("toc-title")) + "</div>\n" + (node.$converter().$convert(node, "outline")) + "\n" + "</div>")};
        result['$<<'](node.$content());
        if ($truthy(($truthy($a = node['$footnotes?']()) ? node['$attr?']("nofootnotes")['$!']() : $a))) {
          
          result['$<<']("" + "<div id=\"footnotes\">\n" + "<hr" + (self.void_element_slash) + ">");
          $send(node.$footnotes(), 'each', [], ($$7 = function(footnote){var self = $$7.$$s || this;

          
            
            if (footnote == null) {
              footnote = nil;
            };
            return result['$<<']("" + "<div class=\"footnote\" id=\"_footnotedef_" + (footnote.$index()) + "\">\n" + "<a href=\"#_footnoteref_" + (footnote.$index()) + "\">" + (footnote.$index()) + "</a>. " + (footnote.$text()) + "\n" + "</div>");}, $$7.$$s = self, $$7.$$arity = 1, $$7));
          result['$<<']("</div>");};
        return result.$join($$($nesting, 'LF'));
      }, $Html5Converter_convert_embedded$6.$$arity = 1);
      
      Opal.def(self, '$convert_outline', $Html5Converter_convert_outline$8 = function $$convert_outline(node, opts) {
        var $a, $b, $$9, self = this, sectnumlevels = nil, toclevels = nil, sections = nil, result = nil;

        
        
        if (opts == null) {
          opts = $hash2([], {});
        };
        if ($truthy(node['$sections?']())) {
        } else {
          return nil
        };
        sectnumlevels = ($truthy($a = opts['$[]']("sectnumlevels")) ? $a : ($truthy($b = node.$document().$attributes()['$[]']("sectnumlevels")) ? $b : 3).$to_i());
        toclevels = ($truthy($a = opts['$[]']("toclevels")) ? $a : ($truthy($b = node.$document().$attributes()['$[]']("toclevels")) ? $b : 2).$to_i());
        sections = node.$sections();
        result = ["" + "<ul class=\"sectlevel" + (sections['$[]'](0).$level()) + "\">"];
        $send(sections, 'each', [], ($$9 = function(section){var self = $$9.$$s || this, $c, slevel = nil, stitle = nil, $case = nil, signifier = nil, child_toc_level = nil;

        
          
          if (section == null) {
            section = nil;
          };
          slevel = section.$level();
          if ($truthy(section.$caption())) {
            stitle = section.$captioned_title()
          } else if ($truthy(($truthy($c = section.$numbered()) ? $rb_le(slevel, sectnumlevels) : $c))) {
            if ($truthy(($truthy($c = $rb_lt(slevel, 2)) ? node.$document().$doctype()['$==']("book") : $c))) {
              $case = section.$sectname();
              if ("chapter"['$===']($case)) {stitle = "" + ((function() {if ($truthy((signifier = node.$document().$attributes()['$[]']("chapter-signifier")))) {
                return "" + (signifier) + " "
              } else {
                return ""
              }; return nil; })()) + (section.$sectnum()) + " " + (section.$title())}
              else if ("part"['$===']($case)) {stitle = "" + ((function() {if ($truthy((signifier = node.$document().$attributes()['$[]']("part-signifier")))) {
                return "" + (signifier) + " "
              } else {
                return ""
              }; return nil; })()) + (section.$sectnum(nil, ":")) + " " + (section.$title())}
              else {stitle = "" + (section.$sectnum()) + " " + (section.$title())}
            } else {
              stitle = "" + (section.$sectnum()) + " " + (section.$title())
            }
          } else {
            stitle = section.$title()
          };
          if ($truthy(stitle['$include?']("<a"))) {
            stitle = stitle.$gsub($$($nesting, 'DropAnchorRx'), "")};
          if ($truthy(($truthy($c = $rb_lt(slevel, toclevels)) ? (child_toc_level = self.$convert_outline(section, $hash2(["toclevels", "sectnumlevels"], {"toclevels": toclevels, "sectnumlevels": sectnumlevels}))) : $c))) {
            
            result['$<<']("" + "<li><a href=\"#" + (section.$id()) + "\">" + (stitle) + "</a>");
            result['$<<'](child_toc_level);
            return result['$<<']("</li>");
          } else {
            return result['$<<']("" + "<li><a href=\"#" + (section.$id()) + "\">" + (stitle) + "</a></li>")
          };}, $$9.$$s = self, $$9.$$arity = 1, $$9));
        result['$<<']("</ul>");
        return result.$join($$($nesting, 'LF'));
      }, $Html5Converter_convert_outline$8.$$arity = -2);
      
      Opal.def(self, '$convert_section', $Html5Converter_convert_section$10 = function $$convert_section(node) {
        var $a, $b, self = this, doc_attrs = nil, level = nil, title = nil, $case = nil, signifier = nil, id_attr = nil, id = nil, role = nil;

        
        doc_attrs = node.$document().$attributes();
        level = node.$level();
        if ($truthy(node.$caption())) {
          title = node.$captioned_title()
        } else if ($truthy(($truthy($a = node.$numbered()) ? $rb_le(level, ($truthy($b = doc_attrs['$[]']("sectnumlevels")) ? $b : 3).$to_i()) : $a))) {
          if ($truthy(($truthy($a = $rb_lt(level, 2)) ? node.$document().$doctype()['$==']("book") : $a))) {
            $case = node.$sectname();
            if ("chapter"['$===']($case)) {title = "" + ((function() {if ($truthy((signifier = doc_attrs['$[]']("chapter-signifier")))) {
              return "" + (signifier) + " "
            } else {
              return ""
            }; return nil; })()) + (node.$sectnum()) + " " + (node.$title())}
            else if ("part"['$===']($case)) {title = "" + ((function() {if ($truthy((signifier = doc_attrs['$[]']("part-signifier")))) {
              return "" + (signifier) + " "
            } else {
              return ""
            }; return nil; })()) + (node.$sectnum(nil, ":")) + " " + (node.$title())}
            else {title = "" + (node.$sectnum()) + " " + (node.$title())}
          } else {
            title = "" + (node.$sectnum()) + " " + (node.$title())
          }
        } else {
          title = node.$title()
        };
        if ($truthy(node.$id())) {
          
          id_attr = "" + " id=\"" + ((id = node.$id())) + "\"";
          if ($truthy(doc_attrs['$[]']("sectlinks"))) {
            title = "" + "<a class=\"link\" href=\"#" + (id) + "\">" + (title) + "</a>"};
          if ($truthy(doc_attrs['$[]']("sectanchors"))) {
            if (doc_attrs['$[]']("sectanchors")['$==']("after")) {
              title = "" + (title) + "<a class=\"anchor\" href=\"#" + (id) + "\"></a>"
            } else {
              title = "" + "<a class=\"anchor\" href=\"#" + (id) + "\"></a>" + (title)
            }};
        } else {
          id_attr = ""
        };
        if (level['$=='](0)) {
          return "" + "<h1" + (id_attr) + " class=\"sect0" + ((function() {if ($truthy((role = node.$role()))) {
            return "" + " " + (role)
          } else {
            return ""
          }; return nil; })()) + "\">" + (title) + "</h1>\n" + (node.$content())
        } else {
          return "" + "<div class=\"sect" + (level) + ((function() {if ($truthy((role = node.$role()))) {
            return "" + " " + (role)
          } else {
            return ""
          }; return nil; })()) + "\">\n" + "<h" + ($rb_plus(level, 1)) + (id_attr) + ">" + (title) + "</h" + ($rb_plus(level, 1)) + ">\n" + ((function() {if (level['$=='](1)) {
            return "" + "<div class=\"sectionbody\">\n" + (node.$content()) + "\n" + "</div>"
          } else {
            return node.$content()
          }; return nil; })()) + "\n" + "</div>"
        };
      }, $Html5Converter_convert_section$10.$$arity = 1);
      
      Opal.def(self, '$convert_admonition', $Html5Converter_convert_admonition$11 = function $$convert_admonition(node) {
        var $a, self = this, id_attr = nil, name = nil, title_element = nil, label = nil, role = nil;

        
        id_attr = (function() {if ($truthy(node.$id())) {
          return "" + " id=\"" + (node.$id()) + "\""
        } else {
          return ""
        }; return nil; })();
        name = node.$attr("name");
        title_element = (function() {if ($truthy(node['$title?']())) {
          return "" + "<div class=\"title\">" + (node.$title()) + "</div>\n"
        } else {
          return ""
        }; return nil; })();
        if ($truthy(node.$document()['$attr?']("icons"))) {
          if ($truthy(($truthy($a = node.$document()['$attr?']("icons", "font")) ? node['$attr?']("icon")['$!']() : $a))) {
            label = "" + "<i class=\"fa icon-" + (name) + "\" title=\"" + (node.$attr("textlabel")) + "\"></i>"
          } else {
            label = "" + "<img src=\"" + (node.$icon_uri(name)) + "\" alt=\"" + (node.$attr("textlabel")) + "\"" + (self.void_element_slash) + ">"
          }
        } else {
          label = "" + "<div class=\"title\">" + (node.$attr("textlabel")) + "</div>"
        };
        return "" + "<div" + (id_attr) + " class=\"admonitionblock " + (name) + ((function() {if ($truthy((role = node.$role()))) {
          return "" + " " + (role)
        } else {
          return ""
        }; return nil; })()) + "\">\n" + "<table>\n" + "<tr>\n" + "<td class=\"icon\">\n" + (label) + "\n" + "</td>\n" + "<td class=\"content\">\n" + (title_element) + (node.$content()) + "\n" + "</td>\n" + "</tr>\n" + "</table>\n" + "</div>";
      }, $Html5Converter_convert_admonition$11.$$arity = 1);
      
      Opal.def(self, '$convert_audio', $Html5Converter_convert_audio$12 = function $$convert_audio(node) {
        var $a, self = this, xml = nil, id_attribute = nil, classes = nil, class_attribute = nil, title_element = nil, start_t = nil, end_t = nil, time_anchor = nil;

        
        xml = self.xml_mode;
        id_attribute = (function() {if ($truthy(node.$id())) {
          return "" + " id=\"" + (node.$id()) + "\""
        } else {
          return ""
        }; return nil; })();
        classes = ["audioblock", node.$role()].$compact();
        class_attribute = "" + " class=\"" + (classes.$join(" ")) + "\"";
        title_element = (function() {if ($truthy(node['$title?']())) {
          return "" + "<div class=\"title\">" + (node.$title()) + "</div>\n"
        } else {
          return ""
        }; return nil; })();
        start_t = node.$attr("start");
        end_t = node.$attr("end");
        time_anchor = (function() {if ($truthy(($truthy($a = start_t) ? $a : end_t))) {
          return "" + "#t=" + (($truthy($a = start_t) ? $a : "")) + ((function() {if ($truthy(end_t)) {
            return "" + "," + (end_t)
          } else {
            return ""
          }; return nil; })())
        } else {
          return ""
        }; return nil; })();
        return "" + "<div" + (id_attribute) + (class_attribute) + ">\n" + (title_element) + "<div class=\"content\">\n" + "<audio src=\"" + (node.$media_uri(node.$attr("target"))) + (time_anchor) + "\"" + ((function() {if ($truthy(node['$option?']("autoplay"))) {
          
          return self.$append_boolean_attribute("autoplay", xml);
        } else {
          return ""
        }; return nil; })()) + ((function() {if ($truthy(node['$option?']("nocontrols"))) {
          return ""
        } else {
          
          return self.$append_boolean_attribute("controls", xml);
        }; return nil; })()) + ((function() {if ($truthy(node['$option?']("loop"))) {
          
          return self.$append_boolean_attribute("loop", xml);
        } else {
          return ""
        }; return nil; })()) + ">\n" + "Your browser does not support the audio tag.\n" + "</audio>\n" + "</div>\n" + "</div>";
      }, $Html5Converter_convert_audio$12.$$arity = 1);
      
      Opal.def(self, '$convert_colist', $Html5Converter_convert_colist$13 = function $$convert_colist(node) {
        var $a, $$14, $$15, self = this, result = nil, id_attribute = nil, classes = nil, class_attribute = nil, font_icons = nil, num = nil;

        
        result = [];
        id_attribute = (function() {if ($truthy(node.$id())) {
          return "" + " id=\"" + (node.$id()) + "\""
        } else {
          return ""
        }; return nil; })();
        classes = ["colist", node.$style(), node.$role()].$compact();
        class_attribute = "" + " class=\"" + (classes.$join(" ")) + "\"";
        result['$<<']("" + "<div" + (id_attribute) + (class_attribute) + ">");
        if ($truthy(node['$title?']())) {
          result['$<<']("" + "<div class=\"title\">" + (node.$title()) + "</div>")};
        if ($truthy(node.$document()['$attr?']("icons"))) {
          
          result['$<<']("<table>");
          $a = [node.$document()['$attr?']("icons", "font"), 0], (font_icons = $a[0]), (num = $a[1]), $a;
          $send(node.$items(), 'each', [], ($$14 = function(item){var self = $$14.$$s || this, num_label = nil;
            if (self.void_element_slash == null) self.void_element_slash = nil;

          
            
            if (item == null) {
              item = nil;
            };
            num = $rb_plus(num, 1);
            if ($truthy(font_icons)) {
              num_label = "" + "<i class=\"conum\" data-value=\"" + (num) + "\"></i><b>" + (num) + "</b>"
            } else {
              num_label = "" + "<img src=\"" + (node.$icon_uri("" + "callouts/" + (num))) + "\" alt=\"" + (num) + "\"" + (self.void_element_slash) + ">"
            };
            return result['$<<']("" + "<tr>\n" + "<td>" + (num_label) + "</td>\n" + "<td>" + (item.$text()) + ((function() {if ($truthy(item['$blocks?']())) {
              return $rb_plus($$($nesting, 'LF'), item.$content())
            } else {
              return ""
            }; return nil; })()) + "</td>\n" + "</tr>");}, $$14.$$s = self, $$14.$$arity = 1, $$14));
          result['$<<']("</table>");
        } else {
          
          result['$<<']("<ol>");
          $send(node.$items(), 'each', [], ($$15 = function(item){var self = $$15.$$s || this;

          
            
            if (item == null) {
              item = nil;
            };
            return result['$<<']("" + "<li>\n" + "<p>" + (item.$text()) + "</p>" + ((function() {if ($truthy(item['$blocks?']())) {
              return $rb_plus($$($nesting, 'LF'), item.$content())
            } else {
              return ""
            }; return nil; })()) + "\n" + "</li>");}, $$15.$$s = self, $$15.$$arity = 1, $$15));
          result['$<<']("</ol>");
        };
        result['$<<']("</div>");
        return result.$join($$($nesting, 'LF'));
      }, $Html5Converter_convert_colist$13.$$arity = 1);
      
      Opal.def(self, '$convert_dlist', $Html5Converter_convert_dlist$16 = function $$convert_dlist(node) {
        var $$17, $a, $$19, $$21, self = this, result = nil, id_attribute = nil, $case = nil, classes = nil, class_attribute = nil, slash = nil, col_style_attribute = nil, dt_style_attribute = nil;

        
        result = [];
        id_attribute = (function() {if ($truthy(node.$id())) {
          return "" + " id=\"" + (node.$id()) + "\""
        } else {
          return ""
        }; return nil; })();
        $case = node.$style();
        if ("qanda"['$===']($case)) {classes = ["qlist", "qanda", node.$role()]}
        else if ("horizontal"['$===']($case)) {classes = ["hdlist", node.$role()]}
        else {classes = ["dlist", node.$style(), node.$role()]};
        class_attribute = "" + " class=\"" + (classes.$compact().$join(" ")) + "\"";
        result['$<<']("" + "<div" + (id_attribute) + (class_attribute) + ">");
        if ($truthy(node['$title?']())) {
          result['$<<']("" + "<div class=\"title\">" + (node.$title()) + "</div>")};
        $case = node.$style();
        if ("qanda"['$===']($case)) {
        result['$<<']("<ol>");
        $send(node.$items(), 'each', [], ($$17 = function(terms, dd){var self = $$17.$$s || this, $$18;

        
          
          if (terms == null) {
            terms = nil;
          };
          
          if (dd == null) {
            dd = nil;
          };
          result['$<<']("<li>");
          $send(terms, 'each', [], ($$18 = function(dt){var self = $$18.$$s || this;

          
            
            if (dt == null) {
              dt = nil;
            };
            return result['$<<']("" + "<p><em>" + (dt.$text()) + "</em></p>");}, $$18.$$s = self, $$18.$$arity = 1, $$18));
          if ($truthy(dd)) {
            
            if ($truthy(dd['$text?']())) {
              result['$<<']("" + "<p>" + (dd.$text()) + "</p>")};
            if ($truthy(dd['$blocks?']())) {
              result['$<<'](dd.$content())};};
          return result['$<<']("</li>");}, $$17.$$s = self, $$17.$$arity = 2, $$17));
        result['$<<']("</ol>");}
        else if ("horizontal"['$===']($case)) {
        slash = self.void_element_slash;
        result['$<<']("<table>");
        if ($truthy(($truthy($a = node['$attr?']("labelwidth")) ? $a : node['$attr?']("itemwidth")))) {
          
          result['$<<']("<colgroup>");
          col_style_attribute = (function() {if ($truthy(node['$attr?']("labelwidth"))) {
            return "" + " style=\"width: " + (node.$attr("labelwidth").$chomp("%")) + "%;\""
          } else {
            return ""
          }; return nil; })();
          result['$<<']("" + "<col" + (col_style_attribute) + (slash) + ">");
          col_style_attribute = (function() {if ($truthy(node['$attr?']("itemwidth"))) {
            return "" + " style=\"width: " + (node.$attr("itemwidth").$chomp("%")) + "%;\""
          } else {
            return ""
          }; return nil; })();
          result['$<<']("" + "<col" + (col_style_attribute) + (slash) + ">");
          result['$<<']("</colgroup>");};
        $send(node.$items(), 'each', [], ($$19 = function(terms, dd){var self = $$19.$$s || this, $$20, first_term = nil;

        
          
          if (terms == null) {
            terms = nil;
          };
          
          if (dd == null) {
            dd = nil;
          };
          result['$<<']("<tr>");
          result['$<<']("" + "<td class=\"hdlist1" + ((function() {if ($truthy(node['$option?']("strong"))) {
            return " strong"
          } else {
            return ""
          }; return nil; })()) + "\">");
          first_term = true;
          $send(terms, 'each', [], ($$20 = function(dt){var self = $$20.$$s || this;

          
            
            if (dt == null) {
              dt = nil;
            };
            if ($truthy(first_term)) {
            } else {
              result['$<<']("" + "<br" + (slash) + ">")
            };
            result['$<<'](dt.$text());
            return (first_term = nil);}, $$20.$$s = self, $$20.$$arity = 1, $$20));
          result['$<<']("</td>");
          result['$<<']("<td class=\"hdlist2\">");
          if ($truthy(dd)) {
            
            if ($truthy(dd['$text?']())) {
              result['$<<']("" + "<p>" + (dd.$text()) + "</p>")};
            if ($truthy(dd['$blocks?']())) {
              result['$<<'](dd.$content())};};
          result['$<<']("</td>");
          return result['$<<']("</tr>");}, $$19.$$s = self, $$19.$$arity = 2, $$19));
        result['$<<']("</table>");}
        else {
        result['$<<']("<dl>");
        dt_style_attribute = (function() {if ($truthy(node.$style())) {
          return ""
        } else {
          return " class=\"hdlist1\""
        }; return nil; })();
        $send(node.$items(), 'each', [], ($$21 = function(terms, dd){var self = $$21.$$s || this, $$22;

        
          
          if (terms == null) {
            terms = nil;
          };
          
          if (dd == null) {
            dd = nil;
          };
          $send(terms, 'each', [], ($$22 = function(dt){var self = $$22.$$s || this;

          
            
            if (dt == null) {
              dt = nil;
            };
            return result['$<<']("" + "<dt" + (dt_style_attribute) + ">" + (dt.$text()) + "</dt>");}, $$22.$$s = self, $$22.$$arity = 1, $$22));
          if ($truthy(dd)) {
          } else {
            return nil;
          };
          result['$<<']("<dd>");
          if ($truthy(dd['$text?']())) {
            result['$<<']("" + "<p>" + (dd.$text()) + "</p>")};
          if ($truthy(dd['$blocks?']())) {
            result['$<<'](dd.$content())};
          return result['$<<']("</dd>");}, $$21.$$s = self, $$21.$$arity = 2, $$21));
        result['$<<']("</dl>");};
        result['$<<']("</div>");
        return result.$join($$($nesting, 'LF'));
      }, $Html5Converter_convert_dlist$16.$$arity = 1);
      
      Opal.def(self, '$convert_example', $Html5Converter_convert_example$23 = function $$convert_example(node) {
        var self = this, id_attribute = nil, class_attribute = nil, summary_element = nil, title_element = nil, role = nil;

        
        id_attribute = (function() {if ($truthy(node.$id())) {
          return "" + " id=\"" + (node.$id()) + "\""
        } else {
          return ""
        }; return nil; })();
        if ($truthy(node['$option?']("collapsible"))) {
          
          class_attribute = (function() {if ($truthy(node.$role())) {
            return "" + " class=\"" + (node.$role()) + "\""
          } else {
            return ""
          }; return nil; })();
          summary_element = (function() {if ($truthy(node['$title?']())) {
            return "" + "<summary class=\"title\">" + (node.$title()) + "</summary>"
          } else {
            return "<summary class=\"title\">Details</summary>"
          }; return nil; })();
          return "" + "<details" + (id_attribute) + (class_attribute) + ((function() {if ($truthy(node['$option?']("open"))) {
            return " open"
          } else {
            return ""
          }; return nil; })()) + ">\n" + (summary_element) + "\n" + "<div class=\"content\">\n" + (node.$content()) + "\n" + "</div>\n" + "</details>";
        } else {
          
          title_element = (function() {if ($truthy(node['$title?']())) {
            return "" + "<div class=\"title\">" + (node.$captioned_title()) + "</div>\n"
          } else {
            return ""
          }; return nil; })();
          return "" + "<div" + (id_attribute) + " class=\"exampleblock" + ((function() {if ($truthy((role = node.$role()))) {
            return "" + " " + (role)
          } else {
            return ""
          }; return nil; })()) + "\">\n" + (title_element) + "<div class=\"content\">\n" + (node.$content()) + "\n" + "</div>\n" + "</div>";
        };
      }, $Html5Converter_convert_example$23.$$arity = 1);
      
      Opal.def(self, '$convert_floating_title', $Html5Converter_convert_floating_title$24 = function $$convert_floating_title(node) {
        var self = this, tag_name = nil, id_attribute = nil, classes = nil;

        
        tag_name = "" + "h" + ($rb_plus(node.$level(), 1));
        id_attribute = (function() {if ($truthy(node.$id())) {
          return "" + " id=\"" + (node.$id()) + "\""
        } else {
          return ""
        }; return nil; })();
        classes = [node.$style(), node.$role()].$compact();
        return "" + "<" + (tag_name) + (id_attribute) + " class=\"" + (classes.$join(" ")) + "\">" + (node.$title()) + "</" + (tag_name) + ">";
      }, $Html5Converter_convert_floating_title$24.$$arity = 1);
      
      Opal.def(self, '$convert_image', $Html5Converter_convert_image$25 = function $$convert_image(node) {
        var $a, $b, self = this, target = nil, width_attr = nil, height_attr = nil, img = nil, fallback = nil, id_attr = nil, classes = nil, class_attr = nil, title_el = nil;

        
        target = node.$attr("target");
        width_attr = (function() {if ($truthy(node['$attr?']("width"))) {
          return "" + " width=\"" + (node.$attr("width")) + "\""
        } else {
          return ""
        }; return nil; })();
        height_attr = (function() {if ($truthy(node['$attr?']("height"))) {
          return "" + " height=\"" + (node.$attr("height")) + "\""
        } else {
          return ""
        }; return nil; })();
        if ($truthy(($truthy($a = ($truthy($b = node['$attr?']("format", "svg")) ? $b : target['$include?'](".svg"))) ? $rb_lt(node.$document().$safe(), $$$($$($nesting, 'SafeMode'), 'SECURE')) : $a))) {
          if ($truthy(node['$option?']("inline"))) {
            img = ($truthy($a = self.$read_svg_contents(node, target)) ? $a : "" + "<span class=\"alt\">" + (node.$alt()) + "</span>")
          } else if ($truthy(node['$option?']("interactive"))) {
            
            fallback = (function() {if ($truthy(node['$attr?']("fallback"))) {
              return "" + "<img src=\"" + (node.$image_uri(node.$attr("fallback"))) + "\" alt=\"" + (self.$encode_attribute_value(node.$alt())) + "\"" + (width_attr) + (height_attr) + (self.void_element_slash) + ">"
            } else {
              return "" + "<span class=\"alt\">" + (node.$alt()) + "</span>"
            }; return nil; })();
            img = "" + "<object type=\"image/svg+xml\" data=\"" + (node.$image_uri(target)) + "\"" + (width_attr) + (height_attr) + ">" + (fallback) + "</object>";
          } else {
            img = "" + "<img src=\"" + (node.$image_uri(target)) + "\" alt=\"" + (self.$encode_attribute_value(node.$alt())) + "\"" + (width_attr) + (height_attr) + (self.void_element_slash) + ">"
          }
        } else {
          img = "" + "<img src=\"" + (node.$image_uri(target)) + "\" alt=\"" + (self.$encode_attribute_value(node.$alt())) + "\"" + (width_attr) + (height_attr) + (self.void_element_slash) + ">"
        };
        if ($truthy(node['$attr?']("link"))) {
          img = "" + "<a class=\"image\" href=\"" + (node.$attr("link")) + "\"" + (self.$append_link_constraint_attrs(node).$join()) + ">" + (img) + "</a>"};
        id_attr = (function() {if ($truthy(node.$id())) {
          return "" + " id=\"" + (node.$id()) + "\""
        } else {
          return ""
        }; return nil; })();
        classes = ["imageblock"];
        if ($truthy(node['$attr?']("float"))) {
          classes['$<<'](node.$attr("float"))};
        if ($truthy(node['$attr?']("align"))) {
          classes['$<<']("" + "text-" + (node.$attr("align")))};
        if ($truthy(node.$role())) {
          classes['$<<'](node.$role())};
        class_attr = "" + " class=\"" + (classes.$join(" ")) + "\"";
        title_el = (function() {if ($truthy(node['$title?']())) {
          return "" + "\n<div class=\"title\">" + (node.$captioned_title()) + "</div>"
        } else {
          return ""
        }; return nil; })();
        return "" + "<div" + (id_attr) + (class_attr) + ">\n" + "<div class=\"content\">\n" + (img) + "\n" + "</div>" + (title_el) + "\n" + "</div>";
      }, $Html5Converter_convert_image$25.$$arity = 1);
      
      Opal.def(self, '$convert_listing', $Html5Converter_convert_listing$26 = function $$convert_listing(node) {
        var $a, self = this, nowrap = nil, lang = nil, syntax_hl = nil, opts = nil, doc_attrs = nil, $writer = nil, pre_open = nil, pre_close = nil, id_attribute = nil, title_element = nil, role = nil;

        
        nowrap = ($truthy($a = node['$option?']("nowrap")) ? $a : node.$document()['$attr?']("prewrap")['$!']());
        if (node.$style()['$==']("source")) {
          
          lang = node.$attr("language");
          if ($truthy((syntax_hl = node.$document().$syntax_highlighter()))) {
            
            opts = (function() {if ($truthy(syntax_hl['$highlight?']())) {
              return $hash2(["css_mode", "style"], {"css_mode": ($truthy($a = (doc_attrs = node.$document().$attributes())['$[]']("" + (syntax_hl.$name()) + "-css")) ? $a : "class").$to_sym(), "style": doc_attrs['$[]']("" + (syntax_hl.$name()) + "-style")})
            } else {
              return $hash2([], {})
            }; return nil; })();
            
            $writer = ["nowrap", nowrap];
            $send(opts, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
          } else {
            
            pre_open = "" + "<pre class=\"highlight" + ((function() {if ($truthy(nowrap)) {
              return " nowrap"
            } else {
              return ""
            }; return nil; })()) + "\"><code" + ((function() {if ($truthy(lang)) {
              return "" + " class=\"language-" + (lang) + "\" data-lang=\"" + (lang) + "\""
            } else {
              return ""
            }; return nil; })()) + ">";
            pre_close = "</code></pre>";
          };
        } else {
          
          pre_open = "" + "<pre" + ((function() {if ($truthy(nowrap)) {
            return " class=\"nowrap\""
          } else {
            return ""
          }; return nil; })()) + ">";
          pre_close = "</pre>";
        };
        id_attribute = (function() {if ($truthy(node.$id())) {
          return "" + " id=\"" + (node.$id()) + "\""
        } else {
          return ""
        }; return nil; })();
        title_element = (function() {if ($truthy(node['$title?']())) {
          return "" + "<div class=\"title\">" + (node.$captioned_title()) + "</div>\n"
        } else {
          return ""
        }; return nil; })();
        return "" + "<div" + (id_attribute) + " class=\"listingblock" + ((function() {if ($truthy((role = node.$role()))) {
          return "" + " " + (role)
        } else {
          return ""
        }; return nil; })()) + "\">\n" + (title_element) + "<div class=\"content\">\n" + ((function() {if ($truthy(syntax_hl)) {
          
          return syntax_hl.$format(node, lang, opts);
        } else {
          return $rb_plus($rb_plus(pre_open, ($truthy($a = node.$content()) ? $a : "")), pre_close)
        }; return nil; })()) + "\n" + "</div>\n" + "</div>";
      }, $Html5Converter_convert_listing$26.$$arity = 1);
      
      Opal.def(self, '$convert_literal', $Html5Converter_convert_literal$27 = function $$convert_literal(node) {
        var $a, self = this, id_attribute = nil, title_element = nil, nowrap = nil, role = nil;

        
        id_attribute = (function() {if ($truthy(node.$id())) {
          return "" + " id=\"" + (node.$id()) + "\""
        } else {
          return ""
        }; return nil; })();
        title_element = (function() {if ($truthy(node['$title?']())) {
          return "" + "<div class=\"title\">" + (node.$title()) + "</div>\n"
        } else {
          return ""
        }; return nil; })();
        nowrap = ($truthy($a = node.$document()['$attr?']("prewrap")['$!']()) ? $a : node['$option?']("nowrap"));
        return "" + "<div" + (id_attribute) + " class=\"literalblock" + ((function() {if ($truthy((role = node.$role()))) {
          return "" + " " + (role)
        } else {
          return ""
        }; return nil; })()) + "\">\n" + (title_element) + "<div class=\"content\">\n" + "<pre" + ((function() {if ($truthy(nowrap)) {
          return " class=\"nowrap\""
        } else {
          return ""
        }; return nil; })()) + ">" + (node.$content()) + "</pre>\n" + "</div>\n" + "</div>";
      }, $Html5Converter_convert_literal$27.$$arity = 1);
      
      Opal.def(self, '$convert_stem', $Html5Converter_convert_stem$28 = function $$convert_stem(node) {
        var $a, $b, $$29, self = this, id_attribute = nil, title_element = nil, style = nil, open = nil, close = nil, equation = nil, br = nil, role = nil;

        
        id_attribute = (function() {if ($truthy(node.$id())) {
          return "" + " id=\"" + (node.$id()) + "\""
        } else {
          return ""
        }; return nil; })();
        title_element = (function() {if ($truthy(node['$title?']())) {
          return "" + "<div class=\"title\">" + (node.$title()) + "</div>\n"
        } else {
          return ""
        }; return nil; })();
        $b = $$($nesting, 'BLOCK_MATH_DELIMITERS')['$[]']((style = node.$style().$to_sym())), $a = Opal.to_ary($b), (open = ($a[0] == null ? nil : $a[0])), (close = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy((equation = node.$content()))) {
          
          if ($truthy((($a = style['$==']("asciimath")) ? equation['$include?']($$($nesting, 'LF')) : style['$==']("asciimath")))) {
            
            br = "" + ($$($nesting, 'LF')) + "<br" + (self.void_element_slash) + ">";
            equation = $send(equation, 'gsub', [$$($nesting, 'StemBreakRx')], ($$29 = function(){var self = $$29.$$s || this, $c;

            return "" + (close) + ($rb_times(br, $rb_minus((($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$count($$($nesting, 'LF')), 1))) + ($$($nesting, 'LF')) + (open)}, $$29.$$s = self, $$29.$$arity = 0, $$29));};
          if ($truthy(($truthy($a = equation['$start_with?'](open)) ? equation['$end_with?'](close) : $a))) {
          } else {
            equation = "" + (open) + (equation) + (close)
          };
        } else {
          equation = ""
        };
        return "" + "<div" + (id_attribute) + " class=\"stemblock" + ((function() {if ($truthy((role = node.$role()))) {
          return "" + " " + (role)
        } else {
          return ""
        }; return nil; })()) + "\">\n" + (title_element) + "<div class=\"content\">\n" + (equation) + "\n" + "</div>\n" + "</div>";
      }, $Html5Converter_convert_stem$28.$$arity = 1);
      
      Opal.def(self, '$convert_olist', $Html5Converter_convert_olist$30 = function $$convert_olist(node) {
        var $$31, self = this, result = nil, id_attribute = nil, classes = nil, class_attribute = nil, type_attribute = nil, keyword = nil, start_attribute = nil, reversed_attribute = nil;

        
        result = [];
        id_attribute = (function() {if ($truthy(node.$id())) {
          return "" + " id=\"" + (node.$id()) + "\""
        } else {
          return ""
        }; return nil; })();
        classes = ["olist", node.$style(), node.$role()].$compact();
        class_attribute = "" + " class=\"" + (classes.$join(" ")) + "\"";
        result['$<<']("" + "<div" + (id_attribute) + (class_attribute) + ">");
        if ($truthy(node['$title?']())) {
          result['$<<']("" + "<div class=\"title\">" + (node.$title()) + "</div>")};
        type_attribute = (function() {if ($truthy((keyword = node.$list_marker_keyword()))) {
          return "" + " type=\"" + (keyword) + "\""
        } else {
          return ""
        }; return nil; })();
        start_attribute = (function() {if ($truthy(node['$attr?']("start"))) {
          return "" + " start=\"" + (node.$attr("start")) + "\""
        } else {
          return ""
        }; return nil; })();
        reversed_attribute = (function() {if ($truthy(node['$option?']("reversed"))) {
          
          return self.$append_boolean_attribute("reversed", self.xml_mode);
        } else {
          return ""
        }; return nil; })();
        result['$<<']("" + "<ol class=\"" + (node.$style()) + "\"" + (type_attribute) + (start_attribute) + (reversed_attribute) + ">");
        $send(node.$items(), 'each', [], ($$31 = function(item){var self = $$31.$$s || this;

        
          
          if (item == null) {
            item = nil;
          };
          if ($truthy(item.$id())) {
            result['$<<']("" + "<li id=\"" + (item.$id()) + "\"" + ((function() {if ($truthy(item.$role())) {
              return "" + " class=\"" + (item.$role()) + "\""
            } else {
              return ""
            }; return nil; })()) + ">")
          } else if ($truthy(item.$role())) {
            result['$<<']("" + "<li class=\"" + (item.$role()) + "\">")
          } else {
            result['$<<']("<li>")
          };
          result['$<<']("" + "<p>" + (item.$text()) + "</p>");
          if ($truthy(item['$blocks?']())) {
            result['$<<'](item.$content())};
          return result['$<<']("</li>");}, $$31.$$s = self, $$31.$$arity = 1, $$31));
        result['$<<']("</ol>");
        result['$<<']("</div>");
        return result.$join($$($nesting, 'LF'));
      }, $Html5Converter_convert_olist$30.$$arity = 1);
      
      Opal.def(self, '$convert_open', $Html5Converter_convert_open$32 = function $$convert_open(node) {
        var $a, $b, $c, self = this, style = nil, id_attr = nil, title_el = nil, role = nil;

        if ((style = node.$style())['$==']("abstract")) {
          if ($truthy((($a = node.$parent()['$=='](node.$document())) ? node.$document().$doctype()['$==']("book") : node.$parent()['$=='](node.$document())))) {
            
            self.$logger().$warn("abstract block cannot be used in a document without a title when doctype is book. Excluding block content.");
            return "";
          } else {
            
            id_attr = (function() {if ($truthy(node.$id())) {
              return "" + " id=\"" + (node.$id()) + "\""
            } else {
              return ""
            }; return nil; })();
            title_el = (function() {if ($truthy(node['$title?']())) {
              return "" + "<div class=\"title\">" + (node.$title()) + "</div>\n"
            } else {
              return ""
            }; return nil; })();
            return "" + "<div" + (id_attr) + " class=\"quoteblock abstract" + ((function() {if ($truthy((role = node.$role()))) {
              return "" + " " + (role)
            } else {
              return ""
            }; return nil; })()) + "\">\n" + (title_el) + "<blockquote>\n" + (node.$content()) + "\n" + "</blockquote>\n" + "</div>";
          }
        } else if ($truthy((($a = style['$==']("partintro")) ? ($truthy($b = ($truthy($c = $rb_gt(node.$level(), 0)) ? $c : node.$parent().$context()['$!=']("section"))) ? $b : node.$document().$doctype()['$!=']("book")) : style['$==']("partintro")))) {
          
          self.$logger().$error("partintro block can only be used when doctype is book and must be a child of a book part. Excluding block content.");
          return "";
        } else {
          
          id_attr = (function() {if ($truthy(node.$id())) {
            return "" + " id=\"" + (node.$id()) + "\""
          } else {
            return ""
          }; return nil; })();
          title_el = (function() {if ($truthy(node['$title?']())) {
            return "" + "<div class=\"title\">" + (node.$title()) + "</div>\n"
          } else {
            return ""
          }; return nil; })();
          return "" + "<div" + (id_attr) + " class=\"openblock" + ((function() {if ($truthy(($truthy($a = style) ? style['$!=']("open") : $a))) {
            return "" + " " + (style)
          } else {
            return ""
          }; return nil; })()) + ((function() {if ($truthy((role = node.$role()))) {
            return "" + " " + (role)
          } else {
            return ""
          }; return nil; })()) + "\">\n" + (title_el) + "<div class=\"content\">\n" + (node.$content()) + "\n" + "</div>\n" + "</div>";
        }
      }, $Html5Converter_convert_open$32.$$arity = 1);
      
      Opal.def(self, '$convert_page_break', $Html5Converter_convert_page_break$33 = function $$convert_page_break(node) {
        var self = this;

        return "<div style=\"page-break-after: always;\"></div>"
      }, $Html5Converter_convert_page_break$33.$$arity = 1);
      
      Opal.def(self, '$convert_paragraph', $Html5Converter_convert_paragraph$34 = function $$convert_paragraph(node) {
        var self = this, attributes = nil;

        
        if ($truthy(node.$role())) {
          attributes = "" + ((function() {if ($truthy(node.$id())) {
            return "" + " id=\"" + (node.$id()) + "\""
          } else {
            return ""
          }; return nil; })()) + " class=\"paragraph " + (node.$role()) + "\""
        } else if ($truthy(node.$id())) {
          attributes = "" + " id=\"" + (node.$id()) + "\" class=\"paragraph\""
        } else {
          attributes = " class=\"paragraph\""
        };
        if ($truthy(node['$title?']())) {
          return "" + "<div" + (attributes) + ">\n" + "<div class=\"title\">" + (node.$title()) + "</div>\n" + "<p>" + (node.$content()) + "</p>\n" + "</div>"
        } else {
          return "" + "<div" + (attributes) + ">\n" + "<p>" + (node.$content()) + "</p>\n" + "</div>"
        };
      }, $Html5Converter_convert_paragraph$34.$$arity = 1);
      Opal.alias(self, "convert_pass", "content_only");
      
      Opal.def(self, '$convert_preamble', $Html5Converter_convert_preamble$35 = function $$convert_preamble(node) {
        var $a, $b, self = this, doc = nil, toc = nil;

        
        if ($truthy(($truthy($a = ($truthy($b = (doc = node.$document())['$attr?']("toc-placement", "preamble")) ? doc['$sections?']() : $b)) ? doc['$attr?']("toc") : $a))) {
          toc = "" + "\n" + "<div id=\"toc\" class=\"" + (doc.$attr("toc-class", "toc")) + "\">\n" + "<div id=\"toctitle\">" + (doc.$attr("toc-title")) + "</div>\n" + (doc.$converter().$convert(doc, "outline")) + "\n" + "</div>"
        } else {
          toc = ""
        };
        return "" + "<div id=\"preamble\">\n" + "<div class=\"sectionbody\">\n" + (node.$content()) + "\n" + "</div>" + (toc) + "\n" + "</div>";
      }, $Html5Converter_convert_preamble$35.$$arity = 1);
      
      Opal.def(self, '$convert_quote', $Html5Converter_convert_quote$36 = function $$convert_quote(node) {
        var $a, self = this, id_attribute = nil, classes = nil, class_attribute = nil, title_element = nil, attribution = nil, citetitle = nil, cite_element = nil, attribution_text = nil, attribution_element = nil;

        
        id_attribute = (function() {if ($truthy(node.$id())) {
          return "" + " id=\"" + (node.$id()) + "\""
        } else {
          return ""
        }; return nil; })();
        classes = ["quoteblock", node.$role()].$compact();
        class_attribute = "" + " class=\"" + (classes.$join(" ")) + "\"";
        title_element = (function() {if ($truthy(node['$title?']())) {
          return "" + "\n<div class=\"title\">" + (node.$title()) + "</div>"
        } else {
          return ""
        }; return nil; })();
        attribution = (function() {if ($truthy(node['$attr?']("attribution"))) {
          
          return node.$attr("attribution");
        } else {
          return nil
        }; return nil; })();
        citetitle = (function() {if ($truthy(node['$attr?']("citetitle"))) {
          
          return node.$attr("citetitle");
        } else {
          return nil
        }; return nil; })();
        if ($truthy(($truthy($a = attribution) ? $a : citetitle))) {
          
          cite_element = (function() {if ($truthy(citetitle)) {
            return "" + "<cite>" + (citetitle) + "</cite>"
          } else {
            return ""
          }; return nil; })();
          attribution_text = (function() {if ($truthy(attribution)) {
            return "" + "&#8212; " + (attribution) + ((function() {if ($truthy(citetitle)) {
              return "" + "<br" + (self.void_element_slash) + ">\n"
            } else {
              return ""
            }; return nil; })())
          } else {
            return ""
          }; return nil; })();
          attribution_element = "" + "\n<div class=\"attribution\">\n" + (attribution_text) + (cite_element) + "\n</div>";
        } else {
          attribution_element = ""
        };
        return "" + "<div" + (id_attribute) + (class_attribute) + ">" + (title_element) + "\n" + "<blockquote>\n" + (node.$content()) + "\n" + "</blockquote>" + (attribution_element) + "\n" + "</div>";
      }, $Html5Converter_convert_quote$36.$$arity = 1);
      
      Opal.def(self, '$convert_thematic_break', $Html5Converter_convert_thematic_break$37 = function $$convert_thematic_break(node) {
        var self = this;

        return "" + "<hr" + (self.void_element_slash) + ">"
      }, $Html5Converter_convert_thematic_break$37.$$arity = 1);
      
      Opal.def(self, '$convert_sidebar', $Html5Converter_convert_sidebar$38 = function $$convert_sidebar(node) {
        var self = this, id_attribute = nil, title_element = nil, role = nil;

        
        id_attribute = (function() {if ($truthy(node.$id())) {
          return "" + " id=\"" + (node.$id()) + "\""
        } else {
          return ""
        }; return nil; })();
        title_element = (function() {if ($truthy(node['$title?']())) {
          return "" + "<div class=\"title\">" + (node.$title()) + "</div>\n"
        } else {
          return ""
        }; return nil; })();
        return "" + "<div" + (id_attribute) + " class=\"sidebarblock" + ((function() {if ($truthy((role = node.$role()))) {
          return "" + " " + (role)
        } else {
          return ""
        }; return nil; })()) + "\">\n" + "<div class=\"content\">\n" + (title_element) + (node.$content()) + "\n" + "</div>\n" + "</div>";
      }, $Html5Converter_convert_sidebar$38.$$arity = 1);
      
      Opal.def(self, '$convert_table', $Html5Converter_convert_table$39 = function $$convert_table(node) {
        var $a, $$40, $$41, self = this, result = nil, id_attribute = nil, frame = nil, classes = nil, stripes = nil, style_attribute = nil, autowidth = nil, tablewidth = nil, role = nil, class_attribute = nil, slash = nil;

        
        result = [];
        id_attribute = (function() {if ($truthy(node.$id())) {
          return "" + " id=\"" + (node.$id()) + "\""
        } else {
          return ""
        }; return nil; })();
        if ((frame = node.$attr("frame", "all", "table-frame"))['$==']("topbot")) {
          frame = "ends"};
        classes = ["tableblock", "" + "frame-" + (frame), "" + "grid-" + (node.$attr("grid", "all", "table-grid"))];
        if ($truthy((stripes = node.$attr("stripes", nil, "table-stripes")))) {
          classes['$<<']("" + "stripes-" + (stripes))};
        style_attribute = "";
        if ($truthy(($truthy($a = (autowidth = node['$option?']("autowidth"))) ? node['$attr?']("width")['$!']() : $a))) {
          classes['$<<']("fit-content")
        } else if ((tablewidth = node.$attr("tablepcwidth"))['$=='](100)) {
          classes['$<<']("stretch")
        } else {
          style_attribute = "" + " style=\"width: " + (tablewidth) + "%;\""
        };
        if ($truthy(node['$attr?']("float"))) {
          classes['$<<'](node.$attr("float"))};
        if ($truthy((role = node.$role()))) {
          classes['$<<'](role)};
        class_attribute = "" + " class=\"" + (classes.$join(" ")) + "\"";
        result['$<<']("" + "<table" + (id_attribute) + (class_attribute) + (style_attribute) + ">");
        if ($truthy(node['$title?']())) {
          result['$<<']("" + "<caption class=\"title\">" + (node.$captioned_title()) + "</caption>")};
        if ($truthy($rb_gt(node.$attr("rowcount"), 0))) {
          
          slash = self.void_element_slash;
          result['$<<']("<colgroup>");
          if ($truthy(autowidth)) {
            result = $rb_plus(result, $$($nesting, 'Array').$new(node.$columns().$size(), "" + "<col" + (slash) + ">"))
          } else {
            $send(node.$columns(), 'each', [], ($$40 = function(col){var self = $$40.$$s || this;

            
              
              if (col == null) {
                col = nil;
              };
              return result['$<<']((function() {if ($truthy(col['$option?']("autowidth"))) {
                return "" + "<col" + (slash) + ">"
              } else {
                return "" + "<col style=\"width: " + (col.$attr("colpcwidth")) + "%;\"" + (slash) + ">"
              }; return nil; })());}, $$40.$$s = self, $$40.$$arity = 1, $$40))
          };
          result['$<<']("</colgroup>");
          $send(node.$rows().$to_h(), 'each', [], ($$41 = function(tsec, rows){var self = $$41.$$s || this, $$42;

          
            
            if (tsec == null) {
              tsec = nil;
            };
            
            if (rows == null) {
              rows = nil;
            };
            if ($truthy(rows['$empty?']())) {
              return nil;};
            result['$<<']("" + "<t" + (tsec) + ">");
            $send(rows, 'each', [], ($$42 = function(row){var self = $$42.$$s || this, $$43;

            
              
              if (row == null) {
                row = nil;
              };
              result['$<<']("<tr>");
              $send(row, 'each', [], ($$43 = function(cell){var self = $$43.$$s || this, $b, cell_content = nil, $case = nil, cell_tag_name = nil, cell_class_attribute = nil, cell_colspan_attribute = nil, cell_rowspan_attribute = nil, cell_style_attribute = nil;

              
                
                if (cell == null) {
                  cell = nil;
                };
                if (tsec['$==']("head")) {
                  cell_content = cell.$text()
                } else {
                  $case = cell.$style();
                  if ("asciidoc"['$===']($case)) {cell_content = "" + "<div class=\"content\">" + (cell.$content()) + "</div>"}
                  else if ("literal"['$===']($case)) {cell_content = "" + "<div class=\"literal\"><pre>" + (cell.$text()) + "</pre></div>"}
                  else {cell_content = (function() {if ($truthy((cell_content = cell.$content())['$empty?']())) {
                    return ""
                  } else {
                    return "" + "<p class=\"tableblock\">" + (cell_content.$join("" + "</p>\n" + "<p class=\"tableblock\">")) + "</p>"
                  }; return nil; })()}
                };
                cell_tag_name = (function() {if ($truthy(($truthy($b = tsec['$==']("head")) ? $b : cell.$style()['$==']("header")))) {
                  return "th"
                } else {
                  return "td"
                }; return nil; })();
                cell_class_attribute = "" + " class=\"tableblock halign-" + (cell.$attr("halign")) + " valign-" + (cell.$attr("valign")) + "\"";
                cell_colspan_attribute = (function() {if ($truthy(cell.$colspan())) {
                  return "" + " colspan=\"" + (cell.$colspan()) + "\""
                } else {
                  return ""
                }; return nil; })();
                cell_rowspan_attribute = (function() {if ($truthy(cell.$rowspan())) {
                  return "" + " rowspan=\"" + (cell.$rowspan()) + "\""
                } else {
                  return ""
                }; return nil; })();
                cell_style_attribute = (function() {if ($truthy(node.$document()['$attr?']("cellbgcolor"))) {
                  return "" + " style=\"background-color: " + (node.$document().$attr("cellbgcolor")) + ";\""
                } else {
                  return ""
                }; return nil; })();
                return result['$<<']("" + "<" + (cell_tag_name) + (cell_class_attribute) + (cell_colspan_attribute) + (cell_rowspan_attribute) + (cell_style_attribute) + ">" + (cell_content) + "</" + (cell_tag_name) + ">");}, $$43.$$s = self, $$43.$$arity = 1, $$43));
              return result['$<<']("</tr>");}, $$42.$$s = self, $$42.$$arity = 1, $$42));
            return result['$<<']("" + "</t" + (tsec) + ">");}, $$41.$$s = self, $$41.$$arity = 2, $$41));};
        result['$<<']("</table>");
        return result.$join($$($nesting, 'LF'));
      }, $Html5Converter_convert_table$39.$$arity = 1);
      
      Opal.def(self, '$convert_toc', $Html5Converter_convert_toc$44 = function $$convert_toc(node) {
        var $a, $b, self = this, doc = nil, id_attr = nil, title_id_attr = nil, title = nil, levels = nil, role = nil;

        
        if ($truthy(($truthy($a = ($truthy($b = (doc = node.$document())['$attr?']("toc-placement", "macro")) ? doc['$sections?']() : $b)) ? doc['$attr?']("toc") : $a))) {
        } else {
          return "<!-- toc disabled -->"
        };
        if ($truthy(node.$id())) {
          
          id_attr = "" + " id=\"" + (node.$id()) + "\"";
          title_id_attr = "" + " id=\"" + (node.$id()) + "title\"";
        } else {
          
          id_attr = " id=\"toc\"";
          title_id_attr = " id=\"toctitle\"";
        };
        title = (function() {if ($truthy(node['$title?']())) {
          return node.$title()
        } else {
          
          return doc.$attr("toc-title");
        }; return nil; })();
        levels = (function() {if ($truthy(node['$attr?']("levels"))) {
          return node.$attr("levels").$to_i()
        } else {
          return nil
        }; return nil; })();
        role = (function() {if ($truthy(node['$role?']())) {
          return node.$role()
        } else {
          
          return doc.$attr("toc-class", "toc");
        }; return nil; })();
        return "" + "<div" + (id_attr) + " class=\"" + (role) + "\">\n" + "<div" + (title_id_attr) + " class=\"title\">" + (title) + "</div>\n" + (doc.$converter().$convert(doc, "outline", $hash2(["toclevels"], {"toclevels": levels}))) + "\n" + "</div>";
      }, $Html5Converter_convert_toc$44.$$arity = 1);
      
      Opal.def(self, '$convert_ulist', $Html5Converter_convert_ulist$45 = function $$convert_ulist(node) {
        var $$46, self = this, result = nil, id_attribute = nil, div_classes = nil, marker_checked = nil, marker_unchecked = nil, checklist = nil, ul_class_attribute = nil;

        
        result = [];
        id_attribute = (function() {if ($truthy(node.$id())) {
          return "" + " id=\"" + (node.$id()) + "\""
        } else {
          return ""
        }; return nil; })();
        div_classes = ["ulist", node.$style(), node.$role()].$compact();
        marker_checked = (marker_unchecked = "");
        if ($truthy((checklist = node['$option?']("checklist")))) {
          
          div_classes.$unshift(div_classes.$shift(), "checklist");
          ul_class_attribute = " class=\"checklist\"";
          if ($truthy(node['$option?']("interactive"))) {
            if ($truthy(self.xml_mode)) {
              
              marker_checked = "<input type=\"checkbox\" data-item-complete=\"1\" checked=\"checked\"/> ";
              marker_unchecked = "<input type=\"checkbox\" data-item-complete=\"0\"/> ";
            } else {
              
              marker_checked = "<input type=\"checkbox\" data-item-complete=\"1\" checked> ";
              marker_unchecked = "<input type=\"checkbox\" data-item-complete=\"0\"> ";
            }
          } else if ($truthy(node.$document()['$attr?']("icons", "font"))) {
            
            marker_checked = "<i class=\"fa fa-check-square-o\"></i> ";
            marker_unchecked = "<i class=\"fa fa-square-o\"></i> ";
          } else {
            
            marker_checked = "&#10003; ";
            marker_unchecked = "&#10063; ";
          };
        } else {
          ul_class_attribute = (function() {if ($truthy(node.$style())) {
            return "" + " class=\"" + (node.$style()) + "\""
          } else {
            return ""
          }; return nil; })()
        };
        result['$<<']("" + "<div" + (id_attribute) + " class=\"" + (div_classes.$join(" ")) + "\">");
        if ($truthy(node['$title?']())) {
          result['$<<']("" + "<div class=\"title\">" + (node.$title()) + "</div>")};
        result['$<<']("" + "<ul" + (ul_class_attribute) + ">");
        $send(node.$items(), 'each', [], ($$46 = function(item){var self = $$46.$$s || this, $a;

        
          
          if (item == null) {
            item = nil;
          };
          if ($truthy(item.$id())) {
            result['$<<']("" + "<li id=\"" + (item.$id()) + "\"" + ((function() {if ($truthy(item.$role())) {
              return "" + " class=\"" + (item.$role()) + "\""
            } else {
              return ""
            }; return nil; })()) + ">")
          } else if ($truthy(item.$role())) {
            result['$<<']("" + "<li class=\"" + (item.$role()) + "\">")
          } else {
            result['$<<']("<li>")
          };
          if ($truthy(($truthy($a = checklist) ? item['$attr?']("checkbox") : $a))) {
            result['$<<']("" + "<p>" + ((function() {if ($truthy(item['$attr?']("checked"))) {
              return marker_checked
            } else {
              return marker_unchecked
            }; return nil; })()) + (item.$text()) + "</p>")
          } else {
            result['$<<']("" + "<p>" + (item.$text()) + "</p>")
          };
          if ($truthy(item['$blocks?']())) {
            result['$<<'](item.$content())};
          return result['$<<']("</li>");}, $$46.$$s = self, $$46.$$arity = 1, $$46));
        result['$<<']("</ul>");
        result['$<<']("</div>");
        return result.$join($$($nesting, 'LF'));
      }, $Html5Converter_convert_ulist$45.$$arity = 1);
      
      Opal.def(self, '$convert_verse', $Html5Converter_convert_verse$47 = function $$convert_verse(node) {
        var $a, self = this, id_attribute = nil, classes = nil, class_attribute = nil, title_element = nil, attribution = nil, citetitle = nil, cite_element = nil, attribution_text = nil, attribution_element = nil;

        
        id_attribute = (function() {if ($truthy(node.$id())) {
          return "" + " id=\"" + (node.$id()) + "\""
        } else {
          return ""
        }; return nil; })();
        classes = ["verseblock", node.$role()].$compact();
        class_attribute = "" + " class=\"" + (classes.$join(" ")) + "\"";
        title_element = (function() {if ($truthy(node['$title?']())) {
          return "" + "\n<div class=\"title\">" + (node.$title()) + "</div>"
        } else {
          return ""
        }; return nil; })();
        attribution = (function() {if ($truthy(node['$attr?']("attribution"))) {
          
          return node.$attr("attribution");
        } else {
          return nil
        }; return nil; })();
        citetitle = (function() {if ($truthy(node['$attr?']("citetitle"))) {
          
          return node.$attr("citetitle");
        } else {
          return nil
        }; return nil; })();
        if ($truthy(($truthy($a = attribution) ? $a : citetitle))) {
          
          cite_element = (function() {if ($truthy(citetitle)) {
            return "" + "<cite>" + (citetitle) + "</cite>"
          } else {
            return ""
          }; return nil; })();
          attribution_text = (function() {if ($truthy(attribution)) {
            return "" + "&#8212; " + (attribution) + ((function() {if ($truthy(citetitle)) {
              return "" + "<br" + (self.void_element_slash) + ">\n"
            } else {
              return ""
            }; return nil; })())
          } else {
            return ""
          }; return nil; })();
          attribution_element = "" + "\n<div class=\"attribution\">\n" + (attribution_text) + (cite_element) + "\n</div>";
        } else {
          attribution_element = ""
        };
        return "" + "<div" + (id_attribute) + (class_attribute) + ">" + (title_element) + "\n" + "<pre class=\"content\">" + (node.$content()) + "</pre>" + (attribution_element) + "\n" + "</div>";
      }, $Html5Converter_convert_verse$47.$$arity = 1);
      
      Opal.def(self, '$convert_video', $Html5Converter_convert_video$48 = function $$convert_video(node) {
        var $a, $b, self = this, xml = nil, id_attribute = nil, classes = nil, class_attribute = nil, title_element = nil, width_attribute = nil, height_attribute = nil, $case = nil, asset_uri_scheme = nil, start_anchor = nil, delimiter = nil, target = nil, hash = nil, hash_param = nil, autoplay_param = nil, loop_param = nil, muted_param = nil, rel_param_val = nil, start_param = nil, end_param = nil, has_loop_param = nil, mute_param = nil, controls_param = nil, fs_param = nil, fs_attribute = nil, modest_param = nil, theme_param = nil, hl_param = nil, list = nil, list_param = nil, playlist = nil, poster_attribute = nil, val = nil, preload_attribute = nil, start_t = nil, end_t = nil, time_anchor = nil;

        
        xml = self.xml_mode;
        id_attribute = (function() {if ($truthy(node.$id())) {
          return "" + " id=\"" + (node.$id()) + "\""
        } else {
          return ""
        }; return nil; })();
        classes = ["videoblock"];
        if ($truthy(node['$attr?']("float"))) {
          classes['$<<'](node.$attr("float"))};
        if ($truthy(node['$attr?']("align"))) {
          classes['$<<']("" + "text-" + (node.$attr("align")))};
        if ($truthy(node.$role())) {
          classes['$<<'](node.$role())};
        class_attribute = "" + " class=\"" + (classes.$join(" ")) + "\"";
        title_element = (function() {if ($truthy(node['$title?']())) {
          return "" + "\n<div class=\"title\">" + (node.$title()) + "</div>"
        } else {
          return ""
        }; return nil; })();
        width_attribute = (function() {if ($truthy(node['$attr?']("width"))) {
          return "" + " width=\"" + (node.$attr("width")) + "\""
        } else {
          return ""
        }; return nil; })();
        height_attribute = (function() {if ($truthy(node['$attr?']("height"))) {
          return "" + " height=\"" + (node.$attr("height")) + "\""
        } else {
          return ""
        }; return nil; })();
        return (function() {$case = node.$attr("poster");
        if ("vimeo"['$===']($case)) {
        if ($truthy((asset_uri_scheme = node.$document().$attr("asset-uri-scheme", "https"))['$empty?']())) {
        } else {
          asset_uri_scheme = "" + (asset_uri_scheme) + ":"
        };
        start_anchor = (function() {if ($truthy(node['$attr?']("start"))) {
          return "" + "#at=" + (node.$attr("start"))
        } else {
          return ""
        }; return nil; })();
        delimiter = ["?"];
        $b = node.$attr("target").$split("/", 2), $a = Opal.to_ary($b), (target = ($a[0] == null ? nil : $a[0])), (hash = ($a[1] == null ? nil : $a[1])), $b;
        hash_param = (function() {if ($truthy((hash = ($truthy($a = hash) ? $a : node.$attr("hash"))))) {
          return "" + (($truthy($a = delimiter.$pop()) ? $a : "&amp;")) + "h=" + (hash)
        } else {
          return ""
        }; return nil; })();
        autoplay_param = (function() {if ($truthy(node['$option?']("autoplay"))) {
          return "" + (($truthy($a = delimiter.$pop()) ? $a : "&amp;")) + "autoplay=1"
        } else {
          return ""
        }; return nil; })();
        loop_param = (function() {if ($truthy(node['$option?']("loop"))) {
          return "" + (($truthy($a = delimiter.$pop()) ? $a : "&amp;")) + "loop=1"
        } else {
          return ""
        }; return nil; })();
        muted_param = (function() {if ($truthy(node['$option?']("muted"))) {
          return "" + (($truthy($a = delimiter.$pop()) ? $a : "&amp;")) + "muted=1"
        } else {
          return ""
        }; return nil; })();
        return "" + "<div" + (id_attribute) + (class_attribute) + ">" + (title_element) + "\n" + "<div class=\"content\">\n" + "<iframe" + (width_attribute) + (height_attribute) + " src=\"" + (asset_uri_scheme) + "//player.vimeo.com/video/" + (target) + (hash_param) + (autoplay_param) + (loop_param) + (muted_param) + (start_anchor) + "\" frameborder=\"0\"" + ((function() {if ($truthy(node['$option?']("nofullscreen"))) {
          return ""
        } else {
          
          return self.$append_boolean_attribute("allowfullscreen", xml);
        }; return nil; })()) + "></iframe>\n" + "</div>\n" + "</div>";}
        else if ("youtube"['$===']($case)) {
        if ($truthy((asset_uri_scheme = node.$document().$attr("asset-uri-scheme", "https"))['$empty?']())) {
        } else {
          asset_uri_scheme = "" + (asset_uri_scheme) + ":"
        };
        rel_param_val = (function() {if ($truthy(node['$option?']("related"))) {
          return 1
        } else {
          return 0
        }; return nil; })();
        start_param = (function() {if ($truthy(node['$attr?']("start"))) {
          return "" + "&amp;start=" + (node.$attr("start"))
        } else {
          return ""
        }; return nil; })();
        end_param = (function() {if ($truthy(node['$attr?']("end"))) {
          return "" + "&amp;end=" + (node.$attr("end"))
        } else {
          return ""
        }; return nil; })();
        autoplay_param = (function() {if ($truthy(node['$option?']("autoplay"))) {
          return "&amp;autoplay=1"
        } else {
          return ""
        }; return nil; })();
        loop_param = (function() {if ($truthy((has_loop_param = node['$option?']("loop")))) {
          return "&amp;loop=1"
        } else {
          return ""
        }; return nil; })();
        mute_param = (function() {if ($truthy(node['$option?']("muted"))) {
          return "&amp;mute=1"
        } else {
          return ""
        }; return nil; })();
        controls_param = (function() {if ($truthy(node['$option?']("nocontrols"))) {
          return "&amp;controls=0"
        } else {
          return ""
        }; return nil; })();
        if ($truthy(node['$option?']("nofullscreen"))) {
          
          fs_param = "&amp;fs=0";
          fs_attribute = "";
        } else {
          
          fs_param = "";
          fs_attribute = self.$append_boolean_attribute("allowfullscreen", xml);
        };
        modest_param = (function() {if ($truthy(node['$option?']("modest"))) {
          return "&amp;modestbranding=1"
        } else {
          return ""
        }; return nil; })();
        theme_param = (function() {if ($truthy(node['$attr?']("theme"))) {
          return "" + "&amp;theme=" + (node.$attr("theme"))
        } else {
          return ""
        }; return nil; })();
        hl_param = (function() {if ($truthy(node['$attr?']("lang"))) {
          return "" + "&amp;hl=" + (node.$attr("lang"))
        } else {
          return ""
        }; return nil; })();
        $b = node.$attr("target").$split("/", 2), $a = Opal.to_ary($b), (target = ($a[0] == null ? nil : $a[0])), (list = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy((list = ($truthy($a = list) ? $a : node.$attr("list"))))) {
          list_param = "" + "&amp;list=" + (list)
        } else {
          
          $b = target.$split(",", 2), $a = Opal.to_ary($b), (target = ($a[0] == null ? nil : $a[0])), (playlist = ($a[1] == null ? nil : $a[1])), $b;
          if ($truthy((playlist = ($truthy($a = playlist) ? $a : node.$attr("playlist"))))) {
            list_param = "" + "&amp;playlist=" + (target) + "," + (playlist)
          } else {
            list_param = (function() {if ($truthy(has_loop_param)) {
              return "" + "&amp;playlist=" + (target)
            } else {
              return ""
            }; return nil; })()
          };
        };
        return "" + "<div" + (id_attribute) + (class_attribute) + ">" + (title_element) + "\n" + "<div class=\"content\">\n" + "<iframe" + (width_attribute) + (height_attribute) + " src=\"" + (asset_uri_scheme) + "//www.youtube.com/embed/" + (target) + "?rel=" + (rel_param_val) + (start_param) + (end_param) + (autoplay_param) + (loop_param) + (mute_param) + (controls_param) + (list_param) + (fs_param) + (modest_param) + (theme_param) + (hl_param) + "\" frameborder=\"0\"" + (fs_attribute) + "></iframe>\n" + "</div>\n" + "</div>";}
        else {
        poster_attribute = (function() {if ($truthy((val = node.$attr("poster"))['$nil_or_empty?']())) {
          return ""
        } else {
          return "" + " poster=\"" + (node.$media_uri(val)) + "\""
        }; return nil; })();
        preload_attribute = (function() {if ($truthy((val = node.$attr("preload"))['$nil_or_empty?']())) {
          return ""
        } else {
          return "" + " preload=\"" + (val) + "\""
        }; return nil; })();
        start_t = node.$attr("start");
        end_t = node.$attr("end");
        time_anchor = (function() {if ($truthy(($truthy($a = start_t) ? $a : end_t))) {
          return "" + "#t=" + (($truthy($a = start_t) ? $a : "")) + ((function() {if ($truthy(end_t)) {
            return "" + "," + (end_t)
          } else {
            return ""
          }; return nil; })())
        } else {
          return ""
        }; return nil; })();
        return "" + "<div" + (id_attribute) + (class_attribute) + ">" + (title_element) + "\n" + "<div class=\"content\">\n" + "<video src=\"" + (node.$media_uri(node.$attr("target"))) + (time_anchor) + "\"" + (width_attribute) + (height_attribute) + (poster_attribute) + ((function() {if ($truthy(node['$option?']("autoplay"))) {
          
          return self.$append_boolean_attribute("autoplay", xml);
        } else {
          return ""
        }; return nil; })()) + ((function() {if ($truthy(node['$option?']("muted"))) {
          
          return self.$append_boolean_attribute("muted", xml);
        } else {
          return ""
        }; return nil; })()) + ((function() {if ($truthy(node['$option?']("nocontrols"))) {
          return ""
        } else {
          
          return self.$append_boolean_attribute("controls", xml);
        }; return nil; })()) + ((function() {if ($truthy(node['$option?']("loop"))) {
          
          return self.$append_boolean_attribute("loop", xml);
        } else {
          return ""
        }; return nil; })()) + (preload_attribute) + ">\n" + "Your browser does not support the video tag.\n" + "</video>\n" + "</div>\n" + "</div>";}})();
      }, $Html5Converter_convert_video$48.$$arity = 1);
      
      Opal.def(self, '$convert_inline_anchor', $Html5Converter_convert_inline_anchor$49 = function $$convert_inline_anchor(node) {
        var $a, $b, self = this, $case = nil, path = nil, attrs = nil, text = nil, ref = nil, refid = nil, top = nil, outer = nil;

        return (function() {$case = node.$type();
        if ("xref"['$===']($case)) {
        if ($truthy((path = node.$attributes()['$[]']("path")))) {
          
          attrs = self.$append_link_constraint_attrs(node, (function() {if ($truthy(node.$role())) {
            return ["" + " class=\"" + (node.$role()) + "\""]
          } else {
            return []
          }; return nil; })()).$join();
          text = ($truthy($a = node.$text()) ? $a : path);
        } else {
          
          attrs = (function() {if ($truthy(node.$role())) {
            return "" + " class=\"" + (node.$role()) + "\""
          } else {
            return ""
          }; return nil; })();
          if ($truthy((text = node.$text()))) {
          } else if ($truthy($$($nesting, 'AbstractNode')['$===']((ref = ($truthy($a = (self.refs = ($truthy($b = self.refs) ? $b : node.$document().$catalog()['$[]']("refs")))['$[]']((refid = node.$attributes()['$[]']("refid")))) ? $a : (function() {if ($truthy(refid['$nil_or_empty?']())) {
            
            return (top = self.$get_root_document(node));
          } else {
            return nil
          }; return nil; })()))))) {
            if ($truthy(($truthy($a = (self.resolving_xref = ($truthy($b = self.resolving_xref) ? $b : (outer = true)))) ? outer : $a))) {
              
              if ($truthy((text = ref.$xreftext(node.$attr("xrefstyle", nil, true))))) {
                if ($truthy(text['$include?']("<a"))) {
                  text = text.$gsub($$($nesting, 'DropAnchorRx'), "")}
              } else {
                text = (function() {if ($truthy(top)) {
                  return "[^top]"
                } else {
                  return "" + "[" + (refid) + "]"
                }; return nil; })()
              };
              self.resolving_xref = nil;
            } else {
              text = (function() {if ($truthy(top)) {
                return "[^top]"
              } else {
                return "" + "[" + (refid) + "]"
              }; return nil; })()
            }
          } else {
            text = "" + "[" + (refid) + "]"
          };
        };
        return "" + "<a href=\"" + (node.$target()) + "\"" + (attrs) + ">" + (text) + "</a>";}
        else if ("ref"['$===']($case)) {return "" + "<a id=\"" + (node.$id()) + "\"></a>"}
        else if ("link"['$===']($case)) {
        attrs = (function() {if ($truthy(node.$id())) {
          return ["" + " id=\"" + (node.$id()) + "\""]
        } else {
          return []
        }; return nil; })();
        if ($truthy(node.$role())) {
          attrs['$<<']("" + " class=\"" + (node.$role()) + "\"")};
        if ($truthy(node['$attr?']("title"))) {
          attrs['$<<']("" + " title=\"" + (node.$attr("title")) + "\"")};
        return "" + "<a href=\"" + (node.$target()) + "\"" + (self.$append_link_constraint_attrs(node, attrs).$join()) + ">" + (node.$text()) + "</a>";}
        else if ("bibref"['$===']($case)) {return "" + "<a id=\"" + (node.$id()) + "\"></a>[" + (($truthy($a = node.$reftext()) ? $a : node.$id())) + "]"}
        else {
        self.$logger().$warn("" + "unknown anchor type: " + (node.$type().$inspect()));
        return nil;}})()
      }, $Html5Converter_convert_inline_anchor$49.$$arity = 1);
      
      Opal.def(self, '$convert_inline_break', $Html5Converter_convert_inline_break$50 = function $$convert_inline_break(node) {
        var self = this;

        return "" + (node.$text()) + "<br" + (self.void_element_slash) + ">"
      }, $Html5Converter_convert_inline_break$50.$$arity = 1);
      
      Opal.def(self, '$convert_inline_button', $Html5Converter_convert_inline_button$51 = function $$convert_inline_button(node) {
        var self = this;

        return "" + "<b class=\"button\">" + (node.$text()) + "</b>"
      }, $Html5Converter_convert_inline_button$51.$$arity = 1);
      
      Opal.def(self, '$convert_inline_callout', $Html5Converter_convert_inline_callout$52 = function $$convert_inline_callout(node) {
        var self = this, src = nil, guard = nil;

        if ($truthy(node.$document()['$attr?']("icons", "font"))) {
          return "" + "<i class=\"conum\" data-value=\"" + (node.$text()) + "\"></i><b>(" + (node.$text()) + ")</b>"
        } else if ($truthy(node.$document()['$attr?']("icons"))) {
          
          src = node.$icon_uri("" + "callouts/" + (node.$text()));
          return "" + "<img src=\"" + (src) + "\" alt=\"" + (node.$text()) + "\"" + (self.void_element_slash) + ">";
        } else if ($truthy($$$('::', 'Array')['$===']((guard = node.$attributes()['$[]']("guard"))))) {
          return "" + "&lt;!--<b class=\"conum\">(" + (node.$text()) + ")</b>--&gt;"
        } else {
          return "" + (guard) + "<b class=\"conum\">(" + (node.$text()) + ")</b>"
        }
      }, $Html5Converter_convert_inline_callout$52.$$arity = 1);
      
      Opal.def(self, '$convert_inline_footnote', $Html5Converter_convert_inline_footnote$53 = function $$convert_inline_footnote(node) {
        var self = this, index = nil, id_attr = nil;

        if ($truthy((index = node.$attr("index")))) {
          if (node.$type()['$==']("xref")) {
            return "" + "<sup class=\"footnoteref\">[<a class=\"footnote\" href=\"#_footnotedef_" + (index) + "\" title=\"View footnote.\">" + (index) + "</a>]</sup>"
          } else {
            
            id_attr = (function() {if ($truthy(node.$id())) {
              return "" + " id=\"_footnote_" + (node.$id()) + "\""
            } else {
              return ""
            }; return nil; })();
            return "" + "<sup class=\"footnote\"" + (id_attr) + ">[<a id=\"_footnoteref_" + (index) + "\" class=\"footnote\" href=\"#_footnotedef_" + (index) + "\" title=\"View footnote.\">" + (index) + "</a>]</sup>";
          }
        } else if (node.$type()['$==']("xref")) {
          return "" + "<sup class=\"footnoteref red\" title=\"Unresolved footnote reference.\">[" + (node.$text()) + "]</sup>"
        } else {
          return nil
        }
      }, $Html5Converter_convert_inline_footnote$53.$$arity = 1);
      
      Opal.def(self, '$convert_inline_image', $Html5Converter_convert_inline_image$54 = function $$convert_inline_image(node) {
        var $a, $b, self = this, target = nil, type = nil, icons = nil, i_class_attr_val = nil, attrs = nil, img = nil, fallback = nil, class_attr_val = nil, role = nil;

        
        target = node.$target();
        if ((type = ($truthy($a = node.$type()) ? $a : "image"))['$==']("icon")) {
          if ((icons = node.$document().$attr("icons"))['$==']("font")) {
            
            i_class_attr_val = "" + "fa fa-" + (target);
            if ($truthy(node['$attr?']("size"))) {
              i_class_attr_val = "" + (i_class_attr_val) + " fa-" + (node.$attr("size"))};
            if ($truthy(node['$attr?']("flip"))) {
              i_class_attr_val = "" + (i_class_attr_val) + " fa-flip-" + (node.$attr("flip"))
            } else if ($truthy(node['$attr?']("rotate"))) {
              i_class_attr_val = "" + (i_class_attr_val) + " fa-rotate-" + (node.$attr("rotate"))};
            attrs = (function() {if ($truthy(node['$attr?']("title"))) {
              return "" + " title=\"" + (node.$attr("title")) + "\""
            } else {
              return ""
            }; return nil; })();
            img = "" + "<i class=\"" + (i_class_attr_val) + "\"" + (attrs) + "></i>";
          } else if ($truthy(icons)) {
            
            attrs = (function() {if ($truthy(node['$attr?']("width"))) {
              return "" + " width=\"" + (node.$attr("width")) + "\""
            } else {
              return ""
            }; return nil; })();
            if ($truthy(node['$attr?']("height"))) {
              attrs = "" + (attrs) + " height=\"" + (node.$attr("height")) + "\""};
            if ($truthy(node['$attr?']("title"))) {
              attrs = "" + (attrs) + " title=\"" + (node.$attr("title")) + "\""};
            img = "" + "<img src=\"" + (node.$icon_uri(target)) + "\" alt=\"" + (self.$encode_attribute_value(node.$alt())) + "\"" + (attrs) + (self.void_element_slash) + ">";
          } else {
            img = "" + "[" + (node.$alt()) + "&#93;"
          }
        } else {
          
          attrs = (function() {if ($truthy(node['$attr?']("width"))) {
            return "" + " width=\"" + (node.$attr("width")) + "\""
          } else {
            return ""
          }; return nil; })();
          if ($truthy(node['$attr?']("height"))) {
            attrs = "" + (attrs) + " height=\"" + (node.$attr("height")) + "\""};
          if ($truthy(node['$attr?']("title"))) {
            attrs = "" + (attrs) + " title=\"" + (node.$attr("title")) + "\""};
          if ($truthy(($truthy($a = ($truthy($b = node['$attr?']("format", "svg")) ? $b : target['$include?'](".svg"))) ? $rb_lt(node.$document().$safe(), $$$($$($nesting, 'SafeMode'), 'SECURE')) : $a))) {
            if ($truthy(node['$option?']("inline"))) {
              img = ($truthy($a = self.$read_svg_contents(node, target)) ? $a : "" + "<span class=\"alt\">" + (node.$alt()) + "</span>")
            } else if ($truthy(node['$option?']("interactive"))) {
              
              fallback = (function() {if ($truthy(node['$attr?']("fallback"))) {
                return "" + "<img src=\"" + (node.$image_uri(node.$attr("fallback"))) + "\" alt=\"" + (self.$encode_attribute_value(node.$alt())) + "\"" + (attrs) + (self.void_element_slash) + ">"
              } else {
                return "" + "<span class=\"alt\">" + (node.$alt()) + "</span>"
              }; return nil; })();
              img = "" + "<object type=\"image/svg+xml\" data=\"" + (node.$image_uri(target)) + "\"" + (attrs) + ">" + (fallback) + "</object>";
            } else {
              img = "" + "<img src=\"" + (node.$image_uri(target)) + "\" alt=\"" + (self.$encode_attribute_value(node.$alt())) + "\"" + (attrs) + (self.void_element_slash) + ">"
            }
          } else {
            img = "" + "<img src=\"" + (node.$image_uri(target)) + "\" alt=\"" + (self.$encode_attribute_value(node.$alt())) + "\"" + (attrs) + (self.void_element_slash) + ">"
          };
        };
        if ($truthy(node['$attr?']("link"))) {
          img = "" + "<a class=\"image\" href=\"" + (node.$attr("link")) + "\"" + (self.$append_link_constraint_attrs(node).$join()) + ">" + (img) + "</a>"};
        class_attr_val = type;
        if ($truthy((role = node.$role()))) {
          class_attr_val = (function() {if ($truthy(node['$attr?']("float"))) {
            return "" + (class_attr_val) + " " + (node.$attr("float")) + " " + (role)
          } else {
            return "" + (class_attr_val) + " " + (role)
          }; return nil; })()
        } else if ($truthy(node['$attr?']("float"))) {
          class_attr_val = "" + (class_attr_val) + " " + (node.$attr("float"))};
        return "" + "<span class=\"" + (class_attr_val) + "\">" + (img) + "</span>";
      }, $Html5Converter_convert_inline_image$54.$$arity = 1);
      
      Opal.def(self, '$convert_inline_indexterm', $Html5Converter_convert_inline_indexterm$55 = function $$convert_inline_indexterm(node) {
        var self = this;

        if (node.$type()['$==']("visible")) {
          return node.$text()
        } else {
          return ""
        }
      }, $Html5Converter_convert_inline_indexterm$55.$$arity = 1);
      
      Opal.def(self, '$convert_inline_kbd', $Html5Converter_convert_inline_kbd$56 = function $$convert_inline_kbd(node) {
        var self = this, keys = nil;

        if ((keys = node.$attr("keys")).$size()['$=='](1)) {
          return "" + "<kbd>" + (keys['$[]'](0)) + "</kbd>"
        } else {
          return "" + "<span class=\"keyseq\"><kbd>" + (keys.$join("</kbd>+<kbd>")) + "</kbd></span>"
        }
      }, $Html5Converter_convert_inline_kbd$56.$$arity = 1);
      
      Opal.def(self, '$convert_inline_menu', $Html5Converter_convert_inline_menu$57 = function $$convert_inline_menu(node) {
        var self = this, caret = nil, submenu_joiner = nil, menu = nil, submenus = nil, menuitem = nil;

        
        caret = (function() {if ($truthy(node.$document()['$attr?']("icons", "font"))) {
          return "&#160;<i class=\"fa fa-angle-right caret\"></i> "
        } else {
          return "&#160;<b class=\"caret\">&#8250;</b> "
        }; return nil; })();
        submenu_joiner = "" + "</b>" + (caret) + "<b class=\"submenu\">";
        menu = node.$attr("menu");
        if ($truthy((submenus = node.$attr("submenus"))['$empty?']())) {
          if ($truthy((menuitem = node.$attr("menuitem")))) {
            return "" + "<span class=\"menuseq\"><b class=\"menu\">" + (menu) + "</b>" + (caret) + "<b class=\"menuitem\">" + (menuitem) + "</b></span>"
          } else {
            return "" + "<b class=\"menuref\">" + (menu) + "</b>"
          }
        } else {
          return "" + "<span class=\"menuseq\"><b class=\"menu\">" + (menu) + "</b>" + (caret) + "<b class=\"submenu\">" + (submenus.$join(submenu_joiner)) + "</b>" + (caret) + "<b class=\"menuitem\">" + (node.$attr("menuitem")) + "</b></span>"
        };
      }, $Html5Converter_convert_inline_menu$57.$$arity = 1);
      
      Opal.def(self, '$convert_inline_quoted', $Html5Converter_convert_inline_quoted$58 = function $$convert_inline_quoted(node) {
        var $a, $b, self = this, open = nil, close = nil, tag = nil, class_attr = nil;

        
        $b = $$($nesting, 'QUOTE_TAGS')['$[]'](node.$type()), $a = Opal.to_ary($b), (open = ($a[0] == null ? nil : $a[0])), (close = ($a[1] == null ? nil : $a[1])), (tag = ($a[2] == null ? nil : $a[2])), $b;
        if ($truthy(node.$id())) {
          
          class_attr = (function() {if ($truthy(node.$role())) {
            return "" + " class=\"" + (node.$role()) + "\""
          } else {
            return ""
          }; return nil; })();
          if ($truthy(tag)) {
            return "" + (open.$chop()) + " id=\"" + (node.$id()) + "\"" + (class_attr) + ">" + (node.$text()) + (close)
          } else {
            return "" + "<span id=\"" + (node.$id()) + "\"" + (class_attr) + ">" + (open) + (node.$text()) + (close) + "</span>"
          };
        } else if ($truthy(node.$role())) {
          if ($truthy(tag)) {
            return "" + (open.$chop()) + " class=\"" + (node.$role()) + "\">" + (node.$text()) + (close)
          } else {
            return "" + "<span class=\"" + (node.$role()) + "\">" + (open) + (node.$text()) + (close) + "</span>"
          }
        } else {
          return "" + (open) + (node.$text()) + (close)
        };
      }, $Html5Converter_convert_inline_quoted$58.$$arity = 1);
      
      Opal.def(self, '$read_svg_contents', $Html5Converter_read_svg_contents$59 = function $$read_svg_contents(node, target) {
        var $$60, self = this, svg = nil, old_start_tag = nil, new_start_tag = nil, start_tag_match = nil;

        
        if ($truthy((svg = node.$read_contents(target, $hash2(["start", "normalize", "label", "warn_if_empty"], {"start": node.$document().$attr("imagesdir"), "normalize": true, "label": "SVG", "warn_if_empty": true}))))) {
          
          if ($truthy(svg['$empty?']())) {
            return nil};
          if ($truthy(svg['$start_with?']("<svg"))) {
          } else {
            svg = svg.$sub($$($nesting, 'SvgPreambleRx'), "")
          };
          old_start_tag = (new_start_tag = (start_tag_match = nil));
          $send(["width", "height"], 'each', [], ($$60 = function(dim){var self = $$60.$$s || this, $a, $b;

          
            
            if (dim == null) {
              dim = nil;
            };
            if ($truthy(node['$attr?'](dim))) {
            } else {
              return nil;
            };
            if ($truthy(new_start_tag)) {
            } else {
              
              if ((start_tag_match = ($truthy($a = start_tag_match) ? $a : ($truthy($b = svg.$match($$($nesting, 'SvgStartTagRx'))) ? $b : "no_match")))['$==']("no_match")) {
                return nil;};
              new_start_tag = (old_start_tag = start_tag_match['$[]'](0)).$gsub($$($nesting, 'DimensionAttributeRx'), "");
            };
            return (new_start_tag = "" + (new_start_tag.$chop()) + " " + (dim) + "=\"" + (node.$attr(dim)) + "\">");}, $$60.$$s = self, $$60.$$arity = 1, $$60));
          if ($truthy(new_start_tag)) {
            svg = "" + (new_start_tag) + (svg['$[]'](Opal.Range.$new(old_start_tag.$length(), -1, false)))};};
        return svg;
      }, $Html5Converter_read_svg_contents$59.$$arity = 2);
      self.$private();
      
      Opal.def(self, '$append_boolean_attribute', $Html5Converter_append_boolean_attribute$61 = function $$append_boolean_attribute(name, xml) {
        var self = this;

        if ($truthy(xml)) {
          return "" + " " + (name) + "=\"" + (name) + "\""
        } else {
          return "" + " " + (name)
        }
      }, $Html5Converter_append_boolean_attribute$61.$$arity = 2);
      
      Opal.def(self, '$append_link_constraint_attrs', $Html5Converter_append_link_constraint_attrs$62 = function $$append_link_constraint_attrs(node, attrs) {
        var $a, self = this, rel = nil, window = nil;

        
        
        if (attrs == null) {
          attrs = [];
        };
        if ($truthy(node['$option?']("nofollow"))) {
          rel = "nofollow"};
        if ($truthy((window = node.$attributes()['$[]']("window")))) {
          
          attrs['$<<']("" + " target=\"" + (window) + "\"");
          if ($truthy(($truthy($a = window['$==']("_blank")) ? $a : node['$option?']("noopener")))) {
            attrs['$<<']((function() {if ($truthy(rel)) {
              return "" + " rel=\"" + (rel) + " noopener\""
            } else {
              return " rel=\"noopener\""
            }; return nil; })())};
        } else if ($truthy(rel)) {
          attrs['$<<']("" + " rel=\"" + (rel) + "\"")};
        return attrs;
      }, $Html5Converter_append_link_constraint_attrs$62.$$arity = -2);
      
      Opal.def(self, '$encode_attribute_value', $Html5Converter_encode_attribute_value$63 = function $$encode_attribute_value(val) {
        var self = this;

        if ($truthy(val['$include?']("\""))) {
          
          return val.$gsub("\"", "&quot;");
        } else {
          return val
        }
      }, $Html5Converter_encode_attribute_value$63.$$arity = 1);
      
      Opal.def(self, '$generate_manname_section', $Html5Converter_generate_manname_section$64 = function $$generate_manname_section(node) {
        var $a, self = this, manname_title = nil, next_section = nil, next_section_title = nil, manname_id_attr = nil, manname_id = nil;

        
        manname_title = node.$attr("manname-title", "Name");
        if ($truthy(($truthy($a = (next_section = node.$sections()['$[]'](0))) ? (next_section_title = next_section.$title())['$=='](next_section_title.$upcase()) : $a))) {
          manname_title = manname_title.$upcase()};
        manname_id_attr = (function() {if ($truthy((manname_id = node.$attr("manname-id")))) {
          return "" + " id=\"" + (manname_id) + "\""
        } else {
          return ""
        }; return nil; })();
        return "" + "<h2" + (manname_id_attr) + ">" + (manname_title) + "</h2>\n" + "<div class=\"sectionbody\">\n" + "<p>" + (node.$attr("mannames").$join(", ")) + " - " + (node.$attr("manpurpose")) + "</p>\n" + "</div>";
      }, $Html5Converter_generate_manname_section$64.$$arity = 1);
      
      Opal.def(self, '$get_root_document', $Html5Converter_get_root_document$65 = function $$get_root_document(node) {
        var $a, self = this;

        
        while ($truthy((node = node.$document())['$nested?']())) {
          node = node.$parent_document()
        };
        return node;
      }, $Html5Converter_get_root_document$65.$$arity = 1);
      
      Opal.def(self, '$method_missing', $Html5Converter_method_missing$66 = function $$method_missing(id, $a) {
        var $post_args, args, $b, $iter = $Html5Converter_method_missing$66.$$p, $yield = $iter || nil, self = this, name = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $Html5Converter_method_missing$66.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        
        $post_args = Opal.slice.call(arguments, 1, arguments.length);
        
        args = $post_args;;
        if ($truthy(($truthy($b = (name = id.$to_s())['$start_with?']("convert_")['$!']()) ? self['$handles?'](name) : $b))) {
          
          return $send(self, 'send', ["" + "convert_" + (name)].concat(Opal.to_a(args)));
        } else {
          return $send(self, Opal.find_super_dispatcher(self, 'method_missing', $Html5Converter_method_missing$66, false), $zuper, $iter)
        };
      }, $Html5Converter_method_missing$66.$$arity = -2);
      return (Opal.def(self, '$respond_to_missing?', $Html5Converter_respond_to_missing$ques$67 = function(id, $a) {
        var $post_args, options, $b, self = this, name = nil;

        
        
        $post_args = Opal.slice.call(arguments, 1, arguments.length);
        
        options = $post_args;;
        return ($truthy($b = (name = id.$to_s())['$start_with?']("convert_")['$!']()) ? self['$handles?'](name) : $b);
      }, $Html5Converter_respond_to_missing$ques$67.$$arity = -2), nil) && 'respond_to_missing?';
    })($$($nesting, 'Converter'), $$$($$($nesting, 'Converter'), 'Base'), $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/extensions"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send, $hash = Opal.hash;

  Opal.add_stubs(['$==', '$[]=', '$config', '$-', '$const_defined?', '$singleton_class?', '$include', '$const_get', '$extend', '$attr_reader', '$merge', '$class', '$update', '$raise', '$document', '$doctype', '$[]', '$+', '$level', '$delete', '$>', '$casecmp', '$new', '$title=', '$sectname=', '$special=', '$fetch', '$numbered=', '$!', '$key?', '$attr?', '$special', '$numbered', '$generate_id', '$title', '$id=', '$update_attributes', '$tr', '$basename', '$create_block', '$assign_caption', '$===', '$parse_blocks', '$empty?', '$include?', '$sub_attributes', '$parse', '$each', '$define_method', '$unshift', '$shift', '$send', '$size', '$binding', '$receiver', '$define_singleton_method', '$instance_exec', '$to_proc', '$call', '$option', '$flatten', '$respond_to?', '$to_s', '$partition', '$to_i', '$<<', '$compact', '$inspect', '$attr_accessor', '$to_set', '$match?', '$resolve_regexp', '$method', '$register', '$values', '$groups', '$arity', '$activate', '$add_document_processor', '$any?', '$select', '$add_syntax_processor', '$to_sym', '$instance_variable_get', '$kind', '$private', '$join', '$map', '$split', '$capitalize', '$instance_variable_set', '$resolve_args', '$enable_dsl', '$singleton_class', '$process_block_given?', '$source_location', '$freeze', '$resolve_class', '$<', '$update_config', '$as_symbol', '$name', '$name=', '$pop', '$-@', '$next_auto_id', '$generate_name']);
  
  if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
  } else {
    nil
  };
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Extensions');

      var $nesting = [self].concat($parent_nesting);

      
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Processor');

        var $nesting = [self].concat($parent_nesting), $Processor_initialize$4, $Processor_update_config$5, $Processor_process$6, $Processor_create_section$7, $Processor_create_block$8, $Processor_create_list$9, $Processor_create_list_item$10, $Processor_create_image_block$11, $Processor_create_inline$12, $Processor_parse_content$13, $Processor_parse_attributes$14, $Processor$15;

        self.$$prototype.config = nil;
        
        (function(self, $parent_nesting) {
          var $nesting = [self].concat($parent_nesting), $config$1, $option$2, $enable_dsl$3;

          
          
          Opal.def(self, '$config', $config$1 = function $$config() {
            var $a, self = this;
            if (self.config == null) self.config = nil;

            return (self.config = ($truthy($a = self.config) ? $a : $hash2([], {})))
          }, $config$1.$$arity = 0);
          
          Opal.def(self, '$option', $option$2 = function $$option(key, default_value) {
            var self = this, $writer = nil;

            
            $writer = [key, default_value];
            $send(self.$config(), '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          }, $option$2.$$arity = 2);
          
          Opal.def(self, '$enable_dsl', $enable_dsl$3 = function $$enable_dsl() {
            var self = this;

            if ($truthy(self['$const_defined?']("DSL"))) {
              if ($truthy(self['$singleton_class?']())) {
                return self.$include(self.$const_get("DSL"))
              } else {
                return self.$extend(self.$const_get("DSL"))
              }
            } else {
              return nil
            }
          }, $enable_dsl$3.$$arity = 0);
          return Opal.alias(self, "use_dsl", "enable_dsl");
        })(Opal.get_singleton_class(self), $nesting);
        self.$attr_reader("config");
        
        Opal.def(self, '$initialize', $Processor_initialize$4 = function $$initialize(config) {
          var self = this;

          
          
          if (config == null) {
            config = $hash2([], {});
          };
          return (self.config = self.$class().$config().$merge(config));
        }, $Processor_initialize$4.$$arity = -1);
        
        Opal.def(self, '$update_config', $Processor_update_config$5 = function $$update_config(config) {
          var self = this;

          return self.config.$update(config)
        }, $Processor_update_config$5.$$arity = 1);
        
        Opal.def(self, '$process', $Processor_process$6 = function $$process($a) {
          var $post_args, args, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return self.$raise($$$('::', 'NotImplementedError'), "" + ($$($nesting, 'Processor')) + " subclass " + (self.$class()) + " must implement the #" + ("process") + " method");
        }, $Processor_process$6.$$arity = -1);
        
        Opal.def(self, '$create_section', $Processor_create_section$7 = function $$create_section(parent, title, attrs, opts) {
          var $a, self = this, doc = nil, book = nil, doctype = nil, level = nil, style = nil, sectname = nil, special = nil, sect = nil, $writer = nil, id = nil;

          
          
          if (opts == null) {
            opts = $hash2([], {});
          };
          doc = parent.$document();
          book = (doctype = doc.$doctype())['$==']("book");
          level = ($truthy($a = opts['$[]']("level")) ? $a : $rb_plus(parent.$level(), 1));
          if ($truthy((style = attrs.$delete("style")))) {
            if ($truthy(($truthy($a = book) ? style['$==']("abstract") : $a))) {
              $a = ["chapter", 1], (sectname = $a[0]), (level = $a[1]), $a
            } else {
              
              $a = [style, true], (sectname = $a[0]), (special = $a[1]), $a;
              if (level['$=='](0)) {
                level = 1};
            }
          } else if ($truthy(book)) {
            sectname = (function() {if (level['$=='](0)) {
              return "part"
            } else {
              
              if ($truthy($rb_gt(level, 1))) {
                return "section"
              } else {
                return "chapter"
              };
            }; return nil; })()
          } else if ($truthy((($a = doctype['$==']("manpage")) ? title.$casecmp("synopsis")['$=='](0) : doctype['$==']("manpage")))) {
            $a = ["synopsis", true], (sectname = $a[0]), (special = $a[1]), $a
          } else {
            sectname = "section"
          };
          sect = $$($nesting, 'Section').$new(parent, level);
          $a = [title, sectname], sect['$title=']($a[0]), sect['$sectname=']($a[1]), $a;
          if ($truthy(special)) {
            
            
            $writer = [true];
            $send(sect, 'special=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            if ($truthy(opts.$fetch("numbered", style['$==']("appendix")))) {
              
              $writer = [true];
              $send(sect, 'numbered=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            } else if ($truthy(($truthy($a = opts['$key?']("numbered")['$!']()) ? doc['$attr?']("sectnums", "all") : $a))) {
              
              $writer = [(function() {if ($truthy(($truthy($a = book) ? level['$=='](1) : $a))) {
                return "chapter"
              } else {
                return true
              }; return nil; })()];
              $send(sect, 'numbered=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];};
          } else if ($truthy($rb_gt(level, 0))) {
            if ($truthy(opts.$fetch("numbered", doc['$attr?']("sectnums")))) {
              
              $writer = [(function() {if ($truthy(sect.$special())) {
                return ($truthy($a = parent.$numbered()) ? true : $a)
              } else {
                return true
              }; return nil; })()];
              $send(sect, 'numbered=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];}
          } else if ($truthy(opts.$fetch("numbered", ($truthy($a = book) ? doc['$attr?']("partnums") : $a)))) {
            
            $writer = [true];
            $send(sect, 'numbered=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];};
          if ((id = attrs['$[]']("id"))['$=='](false)) {
            attrs.$delete("id")
          } else {
            
            $writer = [(($writer = ["id", ($truthy($a = id) ? $a : (function() {if ($truthy(doc['$attr?']("sectids"))) {
              
              return $$($nesting, 'Section').$generate_id(sect.$title(), doc);
            } else {
              return nil
            }; return nil; })())]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])];
            $send(sect, 'id=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];
          };
          sect.$update_attributes(attrs);
          return sect;
        }, $Processor_create_section$7.$$arity = -4);
        
        Opal.def(self, '$create_block', $Processor_create_block$8 = function $$create_block(parent, context, source, attrs, opts) {
          var self = this;

          
          
          if (opts == null) {
            opts = $hash2([], {});
          };
          return $$($nesting, 'Block').$new(parent, context, $hash2(["source", "attributes"], {"source": source, "attributes": attrs}).$merge(opts));
        }, $Processor_create_block$8.$$arity = -5);
        
        Opal.def(self, '$create_list', $Processor_create_list$9 = function $$create_list(parent, context, attrs) {
          var self = this, list = nil;

          
          
          if (attrs == null) {
            attrs = nil;
          };
          list = $$($nesting, 'List').$new(parent, context);
          if ($truthy(attrs)) {
            list.$update_attributes(attrs)};
          return list;
        }, $Processor_create_list$9.$$arity = -3);
        
        Opal.def(self, '$create_list_item', $Processor_create_list_item$10 = function $$create_list_item(parent, text) {
          var self = this;

          
          
          if (text == null) {
            text = nil;
          };
          return $$($nesting, 'ListItem').$new(parent, text);
        }, $Processor_create_list_item$10.$$arity = -2);
        
        Opal.def(self, '$create_image_block', $Processor_create_image_block$11 = function $$create_image_block(parent, attrs, opts) {
          var $a, self = this, target = nil, $writer = nil, title = nil, block = nil;

          
          
          if (opts == null) {
            opts = $hash2([], {});
          };
          if ($truthy((target = attrs['$[]']("target")))) {
          } else {
            self.$raise($$$('::', 'ArgumentError'), "Unable to create an image block, target attribute is required")
          };
          ($truthy($a = attrs['$[]']("alt")) ? $a : (($writer = ["alt", (($writer = ["default-alt", $$($nesting, 'Helpers').$basename(target, true).$tr("_-", " ")]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])]), $send(attrs, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
          title = (function() {if ($truthy(attrs['$key?']("title"))) {
            
            return attrs.$delete("title");
          } else {
            return nil
          }; return nil; })();
          block = self.$create_block(parent, "image", nil, attrs, opts);
          if ($truthy(title)) {
            
            
            $writer = [title];
            $send(block, 'title=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            block.$assign_caption(attrs.$delete("caption"), "figure");};
          return block;
        }, $Processor_create_image_block$11.$$arity = -3);
        
        Opal.def(self, '$create_inline', $Processor_create_inline$12 = function $$create_inline(parent, context, text, opts) {
          var self = this;

          
          
          if (opts == null) {
            opts = $hash2([], {});
          };
          return $$($nesting, 'Inline').$new(parent, context, text, (function() {if (context['$==']("quoted")) {
            
            return $hash2(["type"], {"type": "unquoted"}).$merge(opts);
          } else {
            return opts
          }; return nil; })());
        }, $Processor_create_inline$12.$$arity = -4);
        
        Opal.def(self, '$parse_content', $Processor_parse_content$13 = function $$parse_content(parent, content, attributes) {
          var self = this, reader = nil;

          
          
          if (attributes == null) {
            attributes = nil;
          };
          reader = (function() {if ($truthy($$($nesting, 'Reader')['$==='](content))) {
            return content
          } else {
            
            return $$($nesting, 'Reader').$new(content);
          }; return nil; })();
          $$($nesting, 'Parser').$parse_blocks(reader, parent, attributes);
          return parent;
        }, $Processor_parse_content$13.$$arity = -3);
        
        Opal.def(self, '$parse_attributes', $Processor_parse_attributes$14 = function $$parse_attributes(block, attrlist, opts) {
          var $a, self = this;

          
          
          if (opts == null) {
            opts = $hash2([], {});
          };
          if ($truthy((function() {if ($truthy(attrlist)) {
            return attrlist['$empty?']()
          } else {
            return true
          }; return nil; })())) {
            return $hash2([], {})};
          if ($truthy(($truthy($a = opts['$[]']("sub_attributes")) ? attrlist['$include?']($$($nesting, 'ATTR_REF_HEAD')) : $a))) {
            attrlist = block.$sub_attributes(attrlist)};
          return $$($nesting, 'AttributeList').$new(attrlist).$parse(($truthy($a = opts['$[]']("positional_attributes")) ? $a : []));
        }, $Processor_parse_attributes$14.$$arity = -3);
        return $send([["create_paragraph", "create_block", "paragraph"], ["create_open_block", "create_block", "open"], ["create_example_block", "create_block", "example"], ["create_pass_block", "create_block", "pass"], ["create_listing_block", "create_block", "listing"], ["create_literal_block", "create_block", "literal"], ["create_anchor", "create_inline", "anchor"], ["create_inline_pass", "create_inline", "quoted"]], 'each', [], ($Processor$15 = function(method_name, delegate_method_name, context){var self = $Processor$15.$$s || this, $$16;

        
          
          if (method_name == null) {
            method_name = nil;
          };
          
          if (delegate_method_name == null) {
            delegate_method_name = nil;
          };
          
          if (context == null) {
            context = nil;
          };
          return $send(self, 'define_method', [method_name], ($$16 = function($a){var self = $$16.$$s || this, $post_args, args;

          
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            args.$unshift(args.$shift(), context);
            return $send(self, 'send', [delegate_method_name].concat(Opal.to_a(args)));}, $$16.$$s = self, $$16.$$arity = -1, $$16));}, $Processor$15.$$s = self, $Processor$15.$$arity = 3, $Processor$15));
      })($nesting[0], null, $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'ProcessorDsl');

        var $nesting = [self].concat($parent_nesting), $ProcessorDsl_option$17, $ProcessorDsl_process$18, $ProcessorDsl_process_block_given$ques$20;

        
        
        Opal.def(self, '$option', $ProcessorDsl_option$17 = function $$option(key, value) {
          var self = this, $writer = nil;

          
          $writer = [key, value];
          $send(self.$config(), '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        }, $ProcessorDsl_option$17.$$arity = 2);
        
        Opal.def(self, '$process', $ProcessorDsl_process$18 = function $$process($a) {
          var $iter = $ProcessorDsl_process$18.$$p, block = $iter || nil, $post_args, args, $b, $$19, self = this, context = nil;
          if (self.process_block == null) self.process_block = nil;

          if ($iter) $ProcessorDsl_process$18.$$p = null;
          
          
          if ($iter) $ProcessorDsl_process$18.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          if ((block !== nil)) {
            
            if ($truthy(args['$empty?']())) {
            } else {
              self.$raise($$$('::', 'ArgumentError'), "" + "wrong number of arguments (given " + (args.$size()) + ", expected 0)")
            };
            if ($truthy(($truthy($b = block.$binding()) ? self['$=='](block.$binding().$receiver()) : $b))) {
            } else {
              
              context = self;
              $send(block, 'define_singleton_method', ["call"], ($$19 = function($c){var self = $$19.$$s || this, $post_args, m_args;

              
                
                $post_args = Opal.slice.call(arguments, 0, arguments.length);
                
                m_args = $post_args;;
                return $send(context, 'instance_exec', Opal.to_a(m_args), block.$to_proc());}, $$19.$$s = self, $$19.$$arity = -1, $$19));
            };
            return (self.process_block = block);
          } else if ($truthy((($b = self['process_block'], $b != null && $b !== nil) ? 'instance-variable' : nil))) {
            return $send(self.process_block, 'call', Opal.to_a(args))
          } else {
            return self.$raise($$$('::', 'NotImplementedError'), "" + (self.$class()) + " #" + ("process") + " method called before being registered")
          };
        }, $ProcessorDsl_process$18.$$arity = -1);
        
        Opal.def(self, '$process_block_given?', $ProcessorDsl_process_block_given$ques$20 = function() {
          var $a, self = this;

          return (($a = self['process_block'], $a != null && $a !== nil) ? 'instance-variable' : nil)
        }, $ProcessorDsl_process_block_given$ques$20.$$arity = 0);
      })($nesting[0], $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'DocumentProcessorDsl');

        var $nesting = [self].concat($parent_nesting), $DocumentProcessorDsl_prefer$21;

        
        self.$include($$($nesting, 'ProcessorDsl'));
        
        Opal.def(self, '$prefer', $DocumentProcessorDsl_prefer$21 = function $$prefer() {
          var self = this;

          return self.$option("position", ">>")
        }, $DocumentProcessorDsl_prefer$21.$$arity = 0);
      })($nesting[0], $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'SyntaxProcessorDsl');

        var $nesting = [self].concat($parent_nesting), $SyntaxProcessorDsl_named$22, $SyntaxProcessorDsl_content_model$23, $SyntaxProcessorDsl_positional_attributes$24, $SyntaxProcessorDsl_default_attributes$25, $SyntaxProcessorDsl_resolve_attributes$26;

        
        self.$include($$($nesting, 'ProcessorDsl'));
        
        Opal.def(self, '$named', $SyntaxProcessorDsl_named$22 = function $$named(value) {
          var self = this;

          if ($truthy($$($nesting, 'Processor')['$==='](self))) {
            return (self.name = value)
          } else {
            return self.$option("name", value)
          }
        }, $SyntaxProcessorDsl_named$22.$$arity = 1);
        
        Opal.def(self, '$content_model', $SyntaxProcessorDsl_content_model$23 = function $$content_model(value) {
          var self = this;

          return self.$option("content_model", value)
        }, $SyntaxProcessorDsl_content_model$23.$$arity = 1);
        Opal.alias(self, "parse_content_as", "content_model");
        
        Opal.def(self, '$positional_attributes', $SyntaxProcessorDsl_positional_attributes$24 = function $$positional_attributes($a) {
          var $post_args, value, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          return self.$option("positional_attrs", value.$flatten());
        }, $SyntaxProcessorDsl_positional_attributes$24.$$arity = -1);
        Opal.alias(self, "name_positional_attributes", "positional_attributes");
        Opal.alias(self, "positional_attrs", "positional_attributes");
        
        Opal.def(self, '$default_attributes', $SyntaxProcessorDsl_default_attributes$25 = function $$default_attributes(value) {
          var self = this;

          return self.$option("default_attrs", value)
        }, $SyntaxProcessorDsl_default_attributes$25.$$arity = 1);
        Opal.alias(self, "default_attrs", "default_attributes");
        
        Opal.def(self, '$resolve_attributes', $SyntaxProcessorDsl_resolve_attributes$26 = function $$resolve_attributes($a) {
          var $post_args, args, $b, $$27, $$28, self = this, $case = nil, names = nil, defaults = nil;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          if ($truthy($rb_gt(args.$size(), 1))) {
          } else if ($truthy((args = args.$fetch(0, true))['$respond_to?']("to_sym"))) {
            args = [args]};
          return (function() {$case = args;
          if (true['$===']($case)) {
          self.$option("positional_attrs", []);
          return self.$option("default_attrs", $hash2([], {}));}
          else if ($$$('::', 'Array')['$===']($case)) {
          $b = [[], $hash2([], {})], (names = $b[0]), (defaults = $b[1]), $b;
          $send(args, 'each', [], ($$27 = function(arg){var self = $$27.$$s || this, $c, $d, name = nil, _ = nil, value = nil, idx = nil, $writer = nil;

          
            
            if (arg == null) {
              arg = nil;
            };
            if ($truthy((arg = arg.$to_s())['$include?']("="))) {
              
              $d = arg.$partition("="), $c = Opal.to_ary($d), (name = ($c[0] == null ? nil : $c[0])), (_ = ($c[1] == null ? nil : $c[1])), (value = ($c[2] == null ? nil : $c[2])), $d;
              if ($truthy(name['$include?'](":"))) {
                
                $d = name.$partition(":"), $c = Opal.to_ary($d), (idx = ($c[0] == null ? nil : $c[0])), (_ = ($c[1] == null ? nil : $c[1])), (name = ($c[2] == null ? nil : $c[2])), $d;
                idx = (function() {if (idx['$==']("@")) {
                  return names.$size()
                } else {
                  return idx.$to_i()
                }; return nil; })();
                
                $writer = [idx, name];
                $send(names, '[]=', Opal.to_a($writer));
                $writer[$rb_minus($writer["length"], 1)];;};
              
              $writer = [name, value];
              $send(defaults, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];;
            } else if ($truthy(arg['$include?'](":"))) {
              
              $d = arg.$partition(":"), $c = Opal.to_ary($d), (idx = ($c[0] == null ? nil : $c[0])), (_ = ($c[1] == null ? nil : $c[1])), (name = ($c[2] == null ? nil : $c[2])), $d;
              idx = (function() {if (idx['$==']("@")) {
                return names.$size()
              } else {
                return idx.$to_i()
              }; return nil; })();
              
              $writer = [idx, name];
              $send(names, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];;
            } else {
              return names['$<<'](arg)
            };}, $$27.$$s = self, $$27.$$arity = 1, $$27));
          self.$option("positional_attrs", names.$compact());
          return self.$option("default_attrs", defaults);}
          else if ($$$('::', 'Hash')['$===']($case)) {
          $b = [[], $hash2([], {})], (names = $b[0]), (defaults = $b[1]), $b;
          $send(args, 'each', [], ($$28 = function(key, val){var self = $$28.$$s || this, $c, $d, name = nil, idx = nil, _ = nil, $writer = nil;

          
            
            if (key == null) {
              key = nil;
            };
            
            if (val == null) {
              val = nil;
            };
            if ($truthy((name = key.$to_s())['$include?'](":"))) {
              
              $d = name.$partition(":"), $c = Opal.to_ary($d), (idx = ($c[0] == null ? nil : $c[0])), (_ = ($c[1] == null ? nil : $c[1])), (name = ($c[2] == null ? nil : $c[2])), $d;
              idx = (function() {if (idx['$==']("@")) {
                return names.$size()
              } else {
                return idx.$to_i()
              }; return nil; })();
              
              $writer = [idx, name];
              $send(names, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];;};
            if ($truthy(val)) {
              
              $writer = [name, val];
              $send(defaults, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];
            } else {
              return nil
            };}, $$28.$$s = self, $$28.$$arity = 2, $$28));
          self.$option("positional_attrs", names.$compact());
          return self.$option("default_attrs", defaults);}
          else {return self.$raise($$$('::', 'ArgumentError'), "" + "unsupported attributes specification for macro: " + (args.$inspect()))}})();
        }, $SyntaxProcessorDsl_resolve_attributes$26.$$arity = -1);
        Opal.alias(self, "resolves_attributes", "resolve_attributes");
      })($nesting[0], $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Preprocessor');

        var $nesting = [self].concat($parent_nesting), $Preprocessor_process$29;

        return (Opal.def(self, '$process', $Preprocessor_process$29 = function $$process(document, reader) {
          var self = this;

          return self.$raise($$$('::', 'NotImplementedError'), "" + ($$($nesting, 'Preprocessor')) + " subclass " + (self.$class()) + " must implement the #" + ("process") + " method")
        }, $Preprocessor_process$29.$$arity = 2), nil) && 'process'
      })($nesting[0], $$($nesting, 'Processor'), $nesting);
      Opal.const_set($$($nesting, 'Preprocessor'), 'DSL', $$($nesting, 'DocumentProcessorDsl'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'TreeProcessor');

        var $nesting = [self].concat($parent_nesting), $TreeProcessor_process$30;

        return (Opal.def(self, '$process', $TreeProcessor_process$30 = function $$process(document) {
          var self = this;

          return self.$raise($$$('::', 'NotImplementedError'), "" + ($$($nesting, 'TreeProcessor')) + " subclass " + (self.$class()) + " must implement the #" + ("process") + " method")
        }, $TreeProcessor_process$30.$$arity = 1), nil) && 'process'
      })($nesting[0], $$($nesting, 'Processor'), $nesting);
      Opal.const_set($$($nesting, 'TreeProcessor'), 'DSL', $$($nesting, 'DocumentProcessorDsl'));
      Opal.const_set($nesting[0], 'Treeprocessor', $$($nesting, 'TreeProcessor'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Postprocessor');

        var $nesting = [self].concat($parent_nesting), $Postprocessor_process$31;

        return (Opal.def(self, '$process', $Postprocessor_process$31 = function $$process(document, output) {
          var self = this;

          return self.$raise($$$('::', 'NotImplementedError'), "" + ($$($nesting, 'Postprocessor')) + " subclass " + (self.$class()) + " must implement the #" + ("process") + " method")
        }, $Postprocessor_process$31.$$arity = 2), nil) && 'process'
      })($nesting[0], $$($nesting, 'Processor'), $nesting);
      Opal.const_set($$($nesting, 'Postprocessor'), 'DSL', $$($nesting, 'DocumentProcessorDsl'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'IncludeProcessor');

        var $nesting = [self].concat($parent_nesting), $IncludeProcessor_process$32, $IncludeProcessor_handles$ques$33;

        
        
        Opal.def(self, '$process', $IncludeProcessor_process$32 = function $$process(document, reader, target, attributes) {
          var self = this;

          return self.$raise($$$('::', 'NotImplementedError'), "" + ($$($nesting, 'IncludeProcessor')) + " subclass " + (self.$class()) + " must implement the #" + ("process") + " method")
        }, $IncludeProcessor_process$32.$$arity = 4);
        return (Opal.def(self, '$handles?', $IncludeProcessor_handles$ques$33 = function(target) {
          var self = this;

          return true
        }, $IncludeProcessor_handles$ques$33.$$arity = 1), nil) && 'handles?';
      })($nesting[0], $$($nesting, 'Processor'), $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'IncludeProcessorDsl');

        var $nesting = [self].concat($parent_nesting), $IncludeProcessorDsl_handles$ques$34;

        
        self.$include($$($nesting, 'DocumentProcessorDsl'));
        
        Opal.def(self, '$handles?', $IncludeProcessorDsl_handles$ques$34 = function($a) {
          var $iter = $IncludeProcessorDsl_handles$ques$34.$$p, block = $iter || nil, $post_args, args, $b, self = this;
          if (self.handles_block == null) self.handles_block = nil;

          if ($iter) $IncludeProcessorDsl_handles$ques$34.$$p = null;
          
          
          if ($iter) $IncludeProcessorDsl_handles$ques$34.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          if ((block !== nil)) {
            
            if ($truthy(args['$empty?']())) {
            } else {
              self.$raise($$$('::', 'ArgumentError'), "" + "wrong number of arguments (given " + (args.$size()) + ", expected 0)")
            };
            return (self.handles_block = block);
          } else if ($truthy((($b = self['handles_block'], $b != null && $b !== nil) ? 'instance-variable' : nil))) {
            return self.handles_block.$call(args['$[]'](0))
          } else {
            return true
          };
        }, $IncludeProcessorDsl_handles$ques$34.$$arity = -1);
      })($nesting[0], $nesting);
      Opal.const_set($$($nesting, 'IncludeProcessor'), 'DSL', $$($nesting, 'IncludeProcessorDsl'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DocinfoProcessor');

        var $nesting = [self].concat($parent_nesting), $DocinfoProcessor_initialize$35, $DocinfoProcessor_process$36;

        self.$$prototype.config = nil;
        
        
        Opal.def(self, '$initialize', $DocinfoProcessor_initialize$35 = function $$initialize(config) {
          var $a, $iter = $DocinfoProcessor_initialize$35.$$p, $yield = $iter || nil, self = this, $writer = nil;

          if ($iter) $DocinfoProcessor_initialize$35.$$p = null;
          
          
          if (config == null) {
            config = $hash2([], {});
          };
          $send(self, Opal.find_super_dispatcher(self, 'initialize', $DocinfoProcessor_initialize$35, false), [config], null);
          return ($truthy($a = self.config['$[]']("location")) ? $a : (($writer = ["location", "head"]), $send(self.config, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        }, $DocinfoProcessor_initialize$35.$$arity = -1);
        return (Opal.def(self, '$process', $DocinfoProcessor_process$36 = function $$process(document) {
          var self = this;

          return self.$raise($$$('::', 'NotImplementedError'), "" + ($$($nesting, 'DocinfoProcessor')) + " subclass " + (self.$class()) + " must implement the #" + ("process") + " method")
        }, $DocinfoProcessor_process$36.$$arity = 1), nil) && 'process';
      })($nesting[0], $$($nesting, 'Processor'), $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'DocinfoProcessorDsl');

        var $nesting = [self].concat($parent_nesting), $DocinfoProcessorDsl_at_location$37;

        
        self.$include($$($nesting, 'DocumentProcessorDsl'));
        
        Opal.def(self, '$at_location', $DocinfoProcessorDsl_at_location$37 = function $$at_location(value) {
          var self = this;

          return self.$option("location", value)
        }, $DocinfoProcessorDsl_at_location$37.$$arity = 1);
      })($nesting[0], $nesting);
      Opal.const_set($$($nesting, 'DocinfoProcessor'), 'DSL', $$($nesting, 'DocinfoProcessorDsl'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'BlockProcessor');

        var $nesting = [self].concat($parent_nesting), $BlockProcessor_initialize$38, $BlockProcessor_process$39;

        self.$$prototype.config = nil;
        
        self.$attr_accessor("name");
        
        Opal.def(self, '$initialize', $BlockProcessor_initialize$38 = function $$initialize(name, config) {
          var $a, $iter = $BlockProcessor_initialize$38.$$p, $yield = $iter || nil, self = this, $case = nil, $writer = nil;

          if ($iter) $BlockProcessor_initialize$38.$$p = null;
          
          
          if (name == null) {
            name = nil;
          };
          
          if (config == null) {
            config = $hash2([], {});
          };
          $send(self, Opal.find_super_dispatcher(self, 'initialize', $BlockProcessor_initialize$38, false), [config], null);
          self.name = ($truthy($a = name) ? $a : self.config['$[]']("name"));
          $case = self.config['$[]']("contexts");
          if ($$$('::', 'NilClass')['$===']($case)) {($truthy($a = self.config['$[]']("contexts")) ? $a : (($writer = ["contexts", ["open", "paragraph"].$to_set()]), $send(self.config, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))}
          else if ($$$('::', 'Symbol')['$===']($case)) {
          $writer = ["contexts", [self.config['$[]']("contexts")].$to_set()];
          $send(self.config, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];}
          else {
          $writer = ["contexts", self.config['$[]']("contexts").$to_set()];
          $send(self.config, '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];};
          return ($truthy($a = self.config['$[]']("content_model")) ? $a : (($writer = ["content_model", "compound"]), $send(self.config, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        }, $BlockProcessor_initialize$38.$$arity = -1);
        return (Opal.def(self, '$process', $BlockProcessor_process$39 = function $$process(parent, reader, attributes) {
          var self = this;

          return self.$raise($$$('::', 'NotImplementedError'), "" + ($$($nesting, 'BlockProcessor')) + " subclass " + (self.$class()) + " must implement the #" + ("process") + " method")
        }, $BlockProcessor_process$39.$$arity = 3), nil) && 'process';
      })($nesting[0], $$($nesting, 'Processor'), $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'BlockProcessorDsl');

        var $nesting = [self].concat($parent_nesting), $BlockProcessorDsl_contexts$40;

        
        self.$include($$($nesting, 'SyntaxProcessorDsl'));
        
        Opal.def(self, '$contexts', $BlockProcessorDsl_contexts$40 = function $$contexts($a) {
          var $post_args, value, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          return self.$option("contexts", value.$flatten().$to_set());
        }, $BlockProcessorDsl_contexts$40.$$arity = -1);
        Opal.alias(self, "on_contexts", "contexts");
        Opal.alias(self, "on_context", "contexts");
        Opal.alias(self, "bind_to", "contexts");
      })($nesting[0], $nesting);
      Opal.const_set($$($nesting, 'BlockProcessor'), 'DSL', $$($nesting, 'BlockProcessorDsl'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'MacroProcessor');

        var $nesting = [self].concat($parent_nesting), $MacroProcessor_initialize$41, $MacroProcessor_process$42;

        self.$$prototype.config = nil;
        
        self.$attr_accessor("name");
        
        Opal.def(self, '$initialize', $MacroProcessor_initialize$41 = function $$initialize(name, config) {
          var $a, $iter = $MacroProcessor_initialize$41.$$p, $yield = $iter || nil, self = this, $writer = nil;

          if ($iter) $MacroProcessor_initialize$41.$$p = null;
          
          
          if (name == null) {
            name = nil;
          };
          
          if (config == null) {
            config = $hash2([], {});
          };
          $send(self, Opal.find_super_dispatcher(self, 'initialize', $MacroProcessor_initialize$41, false), [config], null);
          self.name = ($truthy($a = name) ? $a : self.config['$[]']("name"));
          return ($truthy($a = self.config['$[]']("content_model")) ? $a : (($writer = ["content_model", "attributes"]), $send(self.config, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        }, $MacroProcessor_initialize$41.$$arity = -1);
        return (Opal.def(self, '$process', $MacroProcessor_process$42 = function $$process(parent, target, attributes) {
          var self = this;

          return self.$raise($$$('::', 'NotImplementedError'), "" + ($$($nesting, 'MacroProcessor')) + " subclass " + (self.$class()) + " must implement the #" + ("process") + " method")
        }, $MacroProcessor_process$42.$$arity = 3), nil) && 'process';
      })($nesting[0], $$($nesting, 'Processor'), $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'MacroProcessorDsl');

        var $nesting = [self].concat($parent_nesting), $MacroProcessorDsl_resolve_attributes$43;

        
        self.$include($$($nesting, 'SyntaxProcessorDsl'));
        
        Opal.def(self, '$resolve_attributes', $MacroProcessorDsl_resolve_attributes$43 = function $$resolve_attributes($a) {
          var $post_args, args, $b, $iter = $MacroProcessorDsl_resolve_attributes$43.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

          if ($iter) $MacroProcessorDsl_resolve_attributes$43.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          if ($truthy((($b = args.$size()['$=='](1)) ? args['$[]'](0)['$!']() : args.$size()['$=='](1)))) {
            return self.$option("content_model", "text")
          } else {
            
            $send(self, Opal.find_super_dispatcher(self, 'resolve_attributes', $MacroProcessorDsl_resolve_attributes$43, false), $zuper, $iter);
            return self.$option("content_model", "attributes");
          };
        }, $MacroProcessorDsl_resolve_attributes$43.$$arity = -1);
        Opal.alias(self, "resolves_attributes", "resolve_attributes");
      })($nesting[0], $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'BlockMacroProcessor');

        var $nesting = [self].concat($parent_nesting), $BlockMacroProcessor_name$44;

        self.$$prototype.name = nil;
        return (Opal.def(self, '$name', $BlockMacroProcessor_name$44 = function $$name() {
          var self = this;

          
          if ($truthy($$($nesting, 'MacroNameRx')['$match?'](self.name.$to_s()))) {
          } else {
            self.$raise($$$('::', 'ArgumentError'), "" + "invalid name for block macro: " + (self.name))
          };
          return self.name;
        }, $BlockMacroProcessor_name$44.$$arity = 0), nil) && 'name'
      })($nesting[0], $$($nesting, 'MacroProcessor'), $nesting);
      Opal.const_set($$($nesting, 'BlockMacroProcessor'), 'DSL', $$($nesting, 'MacroProcessorDsl'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'InlineMacroProcessor');

        var $nesting = [self].concat($parent_nesting), $InlineMacroProcessor_regexp$45, $InlineMacroProcessor_resolve_regexp$46;

        self.$$prototype.config = self.$$prototype.name = nil;
        
        (Opal.class_variable_set($nesting[0], '@@rx_cache', $hash2([], {})));
        
        Opal.def(self, '$regexp', $InlineMacroProcessor_regexp$45 = function $$regexp() {
          var $a, self = this, $writer = nil;

          return ($truthy($a = self.config['$[]']("regexp")) ? $a : (($writer = ["regexp", self.$resolve_regexp(self.name.$to_s(), self.config['$[]']("format"))]), $send(self.config, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))
        }, $InlineMacroProcessor_regexp$45.$$arity = 0);
        return (Opal.def(self, '$resolve_regexp', $InlineMacroProcessor_resolve_regexp$46 = function $$resolve_regexp(name, format) {
          var $a, $b, self = this, $writer = nil;

          
          if ($truthy($$($nesting, 'MacroNameRx')['$match?'](name))) {
          } else {
            self.$raise($$$('::', 'ArgumentError'), "" + "invalid name for inline macro: " + (name))
          };
          return ($truthy($a = (($b = $nesting[0].$$cvars['@@rx_cache']) == null ? nil : $b)['$[]']([name, format])) ? $a : (($writer = [[name, format], new RegExp("" + "\\\\?" + (name) + ":" + ((function() {if (format['$==']("short")) {
            return "(){0}"
          } else {
            return "(\\S+?)"
          }; return nil; })()) + "\\[(|" + ($$($nesting, 'CC_ANY')) + "*?[^\\\\])\\]")]), $send((($b = $nesting[0].$$cvars['@@rx_cache']) == null ? nil : $b), '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
        }, $InlineMacroProcessor_resolve_regexp$46.$$arity = 2), nil) && 'resolve_regexp';
      })($nesting[0], $$($nesting, 'MacroProcessor'), $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'InlineMacroProcessorDsl');

        var $nesting = [self].concat($parent_nesting), $InlineMacroProcessorDsl_format$47, $InlineMacroProcessorDsl_match$48;

        
        self.$include($$($nesting, 'MacroProcessorDsl'));
        
        Opal.def(self, '$format', $InlineMacroProcessorDsl_format$47 = function $$format(value) {
          var self = this;

          return self.$option("format", value)
        }, $InlineMacroProcessorDsl_format$47.$$arity = 1);
        Opal.alias(self, "match_format", "format");
        Opal.alias(self, "using_format", "format");
        
        Opal.def(self, '$match', $InlineMacroProcessorDsl_match$48 = function $$match(value) {
          var self = this;

          return self.$option("regexp", value)
        }, $InlineMacroProcessorDsl_match$48.$$arity = 1);
      })($nesting[0], $nesting);
      Opal.const_set($$($nesting, 'InlineMacroProcessor'), 'DSL', $$($nesting, 'InlineMacroProcessorDsl'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Extension');

        var $nesting = [self].concat($parent_nesting), $Extension_initialize$49;

        
        self.$attr_reader("kind");
        self.$attr_reader("config");
        self.$attr_reader("instance");
        return (Opal.def(self, '$initialize', $Extension_initialize$49 = function $$initialize(kind, instance, config) {
          var self = this;

          
          self.kind = kind;
          self.instance = instance;
          return (self.config = config);
        }, $Extension_initialize$49.$$arity = 3), nil) && 'initialize';
      })($nesting[0], null, $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'ProcessorExtension');

        var $nesting = [self].concat($parent_nesting), $ProcessorExtension_initialize$50;

        
        self.$attr_reader("process_method");
        return (Opal.def(self, '$initialize', $ProcessorExtension_initialize$50 = function $$initialize(kind, instance, process_method) {
          var $a, $iter = $ProcessorExtension_initialize$50.$$p, $yield = $iter || nil, self = this;

          if ($iter) $ProcessorExtension_initialize$50.$$p = null;
          
          
          if (process_method == null) {
            process_method = nil;
          };
          $send(self, Opal.find_super_dispatcher(self, 'initialize', $ProcessorExtension_initialize$50, false), [kind, instance, instance.$config()], null);
          return (self.process_method = ($truthy($a = process_method) ? $a : instance.$method("process")));
        }, $ProcessorExtension_initialize$50.$$arity = -3), nil) && 'initialize';
      })($nesting[0], $$($nesting, 'Extension'), $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Group');

        var $nesting = [self].concat($parent_nesting), $Group_activate$52;

        
        (function(self, $parent_nesting) {
          var $nesting = [self].concat($parent_nesting), $register$51;

          return (Opal.def(self, '$register', $register$51 = function $$register(name) {
            var self = this;

            
            
            if (name == null) {
              name = nil;
            };
            return $$($nesting, 'Extensions').$register(name, self);
          }, $register$51.$$arity = -1), nil) && 'register'
        })(Opal.get_singleton_class(self), $nesting);
        return (Opal.def(self, '$activate', $Group_activate$52 = function $$activate(registry) {
          var self = this;

          return self.$raise($$$('::', 'NotImplementedError'))
        }, $Group_activate$52.$$arity = 1), nil) && 'activate';
      })($nesting[0], null, $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Registry');

        var $nesting = [self].concat($parent_nesting), $Registry_initialize$53, $Registry_activate$54, $Registry_preprocessor$56, $Registry_preprocessors$ques$57, $Registry_preprocessors$58, $Registry_tree_processor$59, $Registry_tree_processors$ques$60, $Registry_tree_processors$61, $Registry_postprocessor$62, $Registry_postprocessors$ques$63, $Registry_postprocessors$64, $Registry_include_processor$65, $Registry_include_processors$ques$66, $Registry_include_processors$67, $Registry_docinfo_processor$68, $Registry_docinfo_processors$ques$69, $Registry_docinfo_processors$71, $Registry_block$73, $Registry_blocks$ques$74, $Registry_registered_for_block$ques$75, $Registry_find_block_extension$76, $Registry_block_macro$77, $Registry_block_macros$ques$78, $Registry_registered_for_block_macro$ques$79, $Registry_find_block_macro_extension$80, $Registry_inline_macro$81, $Registry_inline_macros$ques$82, $Registry_registered_for_inline_macro$ques$83, $Registry_find_inline_macro_extension$84, $Registry_inline_macros$85, $Registry_prefer$86, $Registry_add_document_processor$87, $Registry_add_syntax_processor$89, $Registry_resolve_args$91, $Registry_as_symbol$92;

        self.$$prototype.groups = self.$$prototype.preprocessor_extensions = self.$$prototype.tree_processor_extensions = self.$$prototype.postprocessor_extensions = self.$$prototype.include_processor_extensions = self.$$prototype.docinfo_processor_extensions = self.$$prototype.block_extensions = self.$$prototype.block_macro_extensions = self.$$prototype.inline_macro_extensions = nil;
        
        self.$attr_reader("document");
        self.$attr_reader("groups");
        
        Opal.def(self, '$initialize', $Registry_initialize$53 = function $$initialize(groups) {
          var self = this;

          
          
          if (groups == null) {
            groups = $hash2([], {});
          };
          self.groups = groups;
          self.preprocessor_extensions = (self.tree_processor_extensions = (self.postprocessor_extensions = (self.include_processor_extensions = (self.docinfo_processor_extensions = (self.block_extensions = (self.block_macro_extensions = (self.inline_macro_extensions = nil)))))));
          return (self.document = nil);
        }, $Registry_initialize$53.$$arity = -1);
        
        Opal.def(self, '$activate', $Registry_activate$54 = function $$activate(document) {
          var $$55, self = this, ext_groups = nil;

          
          self.document = document;
          if ($truthy((ext_groups = $rb_plus($$($nesting, 'Extensions').$groups().$values(), self.groups.$values()))['$empty?']())) {
          } else {
            $send(ext_groups, 'each', [], ($$55 = function(group){var self = $$55.$$s || this, $case = nil;

            
              
              if (group == null) {
                group = nil;
              };
              return (function() {$case = group;
              if ($$$('::', 'Proc')['$===']($case)) {return (function() {$case = group.$arity();
              if ((0)['$===']($case) || (-1)['$===']($case)) {return $send(self, 'instance_exec', [], group.$to_proc())}
              else if ((1)['$===']($case)) {return group.$call(self)}
              else { return nil }})()}
              else if ($$$('::', 'Class')['$===']($case)) {return group.$new().$activate(self)}
              else {return group.$activate(self)}})();}, $$55.$$s = self, $$55.$$arity = 1, $$55))
          };
          return self;
        }, $Registry_activate$54.$$arity = 1);
        
        Opal.def(self, '$preprocessor', $Registry_preprocessor$56 = function $$preprocessor($a) {
          var $iter = $Registry_preprocessor$56.$$p, block = $iter || nil, $post_args, args, self = this;

          if ($iter) $Registry_preprocessor$56.$$p = null;
          
          
          if ($iter) $Registry_preprocessor$56.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $send(self, 'add_document_processor', ["preprocessor", args], block.$to_proc());
        }, $Registry_preprocessor$56.$$arity = -1);
        
        Opal.def(self, '$preprocessors?', $Registry_preprocessors$ques$57 = function() {
          var self = this;

          return self.preprocessor_extensions['$!']()['$!']()
        }, $Registry_preprocessors$ques$57.$$arity = 0);
        
        Opal.def(self, '$preprocessors', $Registry_preprocessors$58 = function $$preprocessors() {
          var self = this;

          return self.preprocessor_extensions
        }, $Registry_preprocessors$58.$$arity = 0);
        
        Opal.def(self, '$tree_processor', $Registry_tree_processor$59 = function $$tree_processor($a) {
          var $iter = $Registry_tree_processor$59.$$p, block = $iter || nil, $post_args, args, self = this;

          if ($iter) $Registry_tree_processor$59.$$p = null;
          
          
          if ($iter) $Registry_tree_processor$59.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $send(self, 'add_document_processor', ["tree_processor", args], block.$to_proc());
        }, $Registry_tree_processor$59.$$arity = -1);
        
        Opal.def(self, '$tree_processors?', $Registry_tree_processors$ques$60 = function() {
          var self = this;

          return self.tree_processor_extensions['$!']()['$!']()
        }, $Registry_tree_processors$ques$60.$$arity = 0);
        
        Opal.def(self, '$tree_processors', $Registry_tree_processors$61 = function $$tree_processors() {
          var self = this;

          return self.tree_processor_extensions
        }, $Registry_tree_processors$61.$$arity = 0);
        Opal.alias(self, "treeprocessor", "tree_processor");
        Opal.alias(self, "treeprocessors?", "tree_processors?");
        Opal.alias(self, "treeprocessors", "tree_processors");
        
        Opal.def(self, '$postprocessor', $Registry_postprocessor$62 = function $$postprocessor($a) {
          var $iter = $Registry_postprocessor$62.$$p, block = $iter || nil, $post_args, args, self = this;

          if ($iter) $Registry_postprocessor$62.$$p = null;
          
          
          if ($iter) $Registry_postprocessor$62.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $send(self, 'add_document_processor', ["postprocessor", args], block.$to_proc());
        }, $Registry_postprocessor$62.$$arity = -1);
        
        Opal.def(self, '$postprocessors?', $Registry_postprocessors$ques$63 = function() {
          var self = this;

          return self.postprocessor_extensions['$!']()['$!']()
        }, $Registry_postprocessors$ques$63.$$arity = 0);
        
        Opal.def(self, '$postprocessors', $Registry_postprocessors$64 = function $$postprocessors() {
          var self = this;

          return self.postprocessor_extensions
        }, $Registry_postprocessors$64.$$arity = 0);
        
        Opal.def(self, '$include_processor', $Registry_include_processor$65 = function $$include_processor($a) {
          var $iter = $Registry_include_processor$65.$$p, block = $iter || nil, $post_args, args, self = this;

          if ($iter) $Registry_include_processor$65.$$p = null;
          
          
          if ($iter) $Registry_include_processor$65.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $send(self, 'add_document_processor', ["include_processor", args], block.$to_proc());
        }, $Registry_include_processor$65.$$arity = -1);
        
        Opal.def(self, '$include_processors?', $Registry_include_processors$ques$66 = function() {
          var self = this;

          return self.include_processor_extensions['$!']()['$!']()
        }, $Registry_include_processors$ques$66.$$arity = 0);
        
        Opal.def(self, '$include_processors', $Registry_include_processors$67 = function $$include_processors() {
          var self = this;

          return self.include_processor_extensions
        }, $Registry_include_processors$67.$$arity = 0);
        
        Opal.def(self, '$docinfo_processor', $Registry_docinfo_processor$68 = function $$docinfo_processor($a) {
          var $iter = $Registry_docinfo_processor$68.$$p, block = $iter || nil, $post_args, args, self = this;

          if ($iter) $Registry_docinfo_processor$68.$$p = null;
          
          
          if ($iter) $Registry_docinfo_processor$68.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $send(self, 'add_document_processor', ["docinfo_processor", args], block.$to_proc());
        }, $Registry_docinfo_processor$68.$$arity = -1);
        
        Opal.def(self, '$docinfo_processors?', $Registry_docinfo_processors$ques$69 = function(location) {
          var $$70, self = this;

          
          
          if (location == null) {
            location = nil;
          };
          if ($truthy(self.docinfo_processor_extensions)) {
            if ($truthy(location)) {
              return $send(self.docinfo_processor_extensions, 'any?', [], ($$70 = function(ext){var self = $$70.$$s || this;

              
                
                if (ext == null) {
                  ext = nil;
                };
                return ext.$config()['$[]']("location")['$=='](location);}, $$70.$$s = self, $$70.$$arity = 1, $$70))
            } else {
              return true
            }
          } else {
            return false
          };
        }, $Registry_docinfo_processors$ques$69.$$arity = -1);
        
        Opal.def(self, '$docinfo_processors', $Registry_docinfo_processors$71 = function $$docinfo_processors(location) {
          var $$72, self = this;

          
          
          if (location == null) {
            location = nil;
          };
          if ($truthy(self.docinfo_processor_extensions)) {
            if ($truthy(location)) {
              return $send(self.docinfo_processor_extensions, 'select', [], ($$72 = function(ext){var self = $$72.$$s || this;

              
                
                if (ext == null) {
                  ext = nil;
                };
                return ext.$config()['$[]']("location")['$=='](location);}, $$72.$$s = self, $$72.$$arity = 1, $$72))
            } else {
              return self.docinfo_processor_extensions
            }
          } else {
            return nil
          };
        }, $Registry_docinfo_processors$71.$$arity = -1);
        
        Opal.def(self, '$block', $Registry_block$73 = function $$block($a) {
          var $iter = $Registry_block$73.$$p, block = $iter || nil, $post_args, args, self = this;

          if ($iter) $Registry_block$73.$$p = null;
          
          
          if ($iter) $Registry_block$73.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $send(self, 'add_syntax_processor', ["block", args], block.$to_proc());
        }, $Registry_block$73.$$arity = -1);
        
        Opal.def(self, '$blocks?', $Registry_blocks$ques$74 = function() {
          var self = this;

          return self.block_extensions['$!']()['$!']()
        }, $Registry_blocks$ques$74.$$arity = 0);
        
        Opal.def(self, '$registered_for_block?', $Registry_registered_for_block$ques$75 = function(name, context) {
          var self = this, ext = nil;

          if ($truthy((ext = self.block_extensions['$[]'](name.$to_sym())))) {
            if ($truthy(ext.$config()['$[]']("contexts")['$include?'](context))) {
              return ext
            } else {
              return false
            }
          } else {
            return false
          }
        }, $Registry_registered_for_block$ques$75.$$arity = 2);
        
        Opal.def(self, '$find_block_extension', $Registry_find_block_extension$76 = function $$find_block_extension(name) {
          var self = this;

          return self.block_extensions['$[]'](name.$to_sym())
        }, $Registry_find_block_extension$76.$$arity = 1);
        
        Opal.def(self, '$block_macro', $Registry_block_macro$77 = function $$block_macro($a) {
          var $iter = $Registry_block_macro$77.$$p, block = $iter || nil, $post_args, args, self = this;

          if ($iter) $Registry_block_macro$77.$$p = null;
          
          
          if ($iter) $Registry_block_macro$77.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $send(self, 'add_syntax_processor', ["block_macro", args], block.$to_proc());
        }, $Registry_block_macro$77.$$arity = -1);
        
        Opal.def(self, '$block_macros?', $Registry_block_macros$ques$78 = function() {
          var self = this;

          return self.block_macro_extensions['$!']()['$!']()
        }, $Registry_block_macros$ques$78.$$arity = 0);
        
        Opal.def(self, '$registered_for_block_macro?', $Registry_registered_for_block_macro$ques$79 = function(name) {
          var self = this, ext = nil;

          if ($truthy((ext = self.block_macro_extensions['$[]'](name.$to_sym())))) {
            return ext
          } else {
            return false
          }
        }, $Registry_registered_for_block_macro$ques$79.$$arity = 1);
        
        Opal.def(self, '$find_block_macro_extension', $Registry_find_block_macro_extension$80 = function $$find_block_macro_extension(name) {
          var self = this;

          return self.block_macro_extensions['$[]'](name.$to_sym())
        }, $Registry_find_block_macro_extension$80.$$arity = 1);
        
        Opal.def(self, '$inline_macro', $Registry_inline_macro$81 = function $$inline_macro($a) {
          var $iter = $Registry_inline_macro$81.$$p, block = $iter || nil, $post_args, args, self = this;

          if ($iter) $Registry_inline_macro$81.$$p = null;
          
          
          if ($iter) $Registry_inline_macro$81.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $send(self, 'add_syntax_processor', ["inline_macro", args], block.$to_proc());
        }, $Registry_inline_macro$81.$$arity = -1);
        
        Opal.def(self, '$inline_macros?', $Registry_inline_macros$ques$82 = function() {
          var self = this;

          return self.inline_macro_extensions['$!']()['$!']()
        }, $Registry_inline_macros$ques$82.$$arity = 0);
        
        Opal.def(self, '$registered_for_inline_macro?', $Registry_registered_for_inline_macro$ques$83 = function(name) {
          var self = this, ext = nil;

          if ($truthy((ext = self.inline_macro_extensions['$[]'](name.$to_sym())))) {
            return ext
          } else {
            return false
          }
        }, $Registry_registered_for_inline_macro$ques$83.$$arity = 1);
        
        Opal.def(self, '$find_inline_macro_extension', $Registry_find_inline_macro_extension$84 = function $$find_inline_macro_extension(name) {
          var self = this;

          return self.inline_macro_extensions['$[]'](name.$to_sym())
        }, $Registry_find_inline_macro_extension$84.$$arity = 1);
        
        Opal.def(self, '$inline_macros', $Registry_inline_macros$85 = function $$inline_macros() {
          var self = this;

          return self.inline_macro_extensions.$values()
        }, $Registry_inline_macros$85.$$arity = 0);
        
        Opal.def(self, '$prefer', $Registry_prefer$86 = function $$prefer($a) {
          var $iter = $Registry_prefer$86.$$p, block = $iter || nil, $post_args, args, self = this, extension = nil, arg0 = nil, extensions_store = nil;

          if ($iter) $Registry_prefer$86.$$p = null;
          
          
          if ($iter) $Registry_prefer$86.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          extension = (function() {if ($truthy($$($nesting, 'ProcessorExtension')['$===']((arg0 = args.$shift())))) {
            return arg0
          } else {
            
            return $send(self, 'send', [arg0].concat(Opal.to_a(args)), block.$to_proc());
          }; return nil; })();
          extensions_store = self.$instance_variable_get(((("" + "@") + (extension.$kind())) + "_extensions").$to_sym());
          extensions_store.$unshift(extensions_store.$delete(extension));
          return extension;
        }, $Registry_prefer$86.$$arity = -1);
        self.$private();
        
        Opal.def(self, '$add_document_processor', $Registry_add_document_processor$87 = function $$add_document_processor(kind, args) {
          var $iter = $Registry_add_document_processor$87.$$p, block = $iter || nil, $$88, $a, $b, $c, self = this, kind_name = nil, kind_class_symbol = nil, kind_class = nil, kind_java_class = nil, kind_store = nil, config = nil, processor = nil, extension = nil, processor_class = nil, processor_instance = nil;

          if ($iter) $Registry_add_document_processor$87.$$p = null;
          
          
          if ($iter) $Registry_add_document_processor$87.$$p = null;;
          kind_name = kind.$to_s().$tr("_", " ");
          kind_class_symbol = $send(kind_name.$split(), 'map', [], ($$88 = function(it){var self = $$88.$$s || this;

          
            
            if (it == null) {
              it = nil;
            };
            return it.$capitalize();}, $$88.$$s = self, $$88.$$arity = 1, $$88)).$join().$to_sym();
          kind_class = $$($nesting, 'Extensions').$const_get(kind_class_symbol, false);
          kind_java_class = (function() {if ($truthy((($a = $$$('::', 'AsciidoctorJ', 'skip_raise')) ? 'constant' : nil))) {
            
            return $$$($$$('::', 'AsciidoctorJ'), 'Extensions').$const_get(kind_class_symbol, false);
          } else {
            return nil
          }; return nil; })();
          kind_store = ($truthy($b = self.$instance_variable_get(((("" + "@") + (kind)) + "_extensions").$to_sym())) ? $b : self.$instance_variable_set(((("" + "@") + (kind)) + "_extensions").$to_sym(), []));
          if ((block !== nil)) {
            
            config = self.$resolve_args(args, 1);
            (processor = kind_class.$new(config)).$singleton_class().$enable_dsl();
            if (block.$arity()['$=='](0)) {
              $send(processor, 'instance_exec', [], block.$to_proc())
            } else {
              Opal.yield1(block, processor)
            };
            if ($truthy(processor['$process_block_given?']())) {
            } else {
              self.$raise($$$('::', 'ArgumentError'), "" + "No block specified to process " + (kind_name) + " extension at " + (block.$source_location()))
            };
            processor.$freeze();
            extension = $$($nesting, 'ProcessorExtension').$new(kind, processor);
          } else {
            
            $c = self.$resolve_args(args, 2), $b = Opal.to_ary($c), (processor = ($b[0] == null ? nil : $b[0])), (config = ($b[1] == null ? nil : $b[1])), $c;
            if ($truthy((processor_class = $$($nesting, 'Helpers').$resolve_class(processor)))) {
              
              if ($truthy(($truthy($b = $rb_lt(processor_class, kind_class)) ? $b : ($truthy($c = kind_java_class) ? $rb_lt(processor_class, kind_java_class) : $c)))) {
              } else {
                self.$raise($$$('::', 'ArgumentError'), "" + "Invalid type for " + (kind_name) + " extension: " + (processor))
              };
              processor_instance = processor_class.$new(config);
              processor_instance.$freeze();
              extension = $$($nesting, 'ProcessorExtension').$new(kind, processor_instance);
            } else if ($truthy(($truthy($b = kind_class['$==='](processor)) ? $b : ($truthy($c = kind_java_class) ? kind_java_class['$==='](processor) : $c)))) {
              
              processor.$update_config(config);
              processor.$freeze();
              extension = $$($nesting, 'ProcessorExtension').$new(kind, processor);
            } else {
              self.$raise($$$('::', 'ArgumentError'), "" + "Invalid arguments specified for registering " + (kind_name) + " extension: " + (args))
            };
          };
          if (extension.$config()['$[]']("position")['$=='](">>")) {
            
            kind_store.$unshift(extension);
          } else {
            
            kind_store['$<<'](extension);
          };
          return extension;
        }, $Registry_add_document_processor$87.$$arity = 2);
        
        Opal.def(self, '$add_syntax_processor', $Registry_add_syntax_processor$89 = function $$add_syntax_processor(kind, args) {
          var $iter = $Registry_add_syntax_processor$89.$$p, block = $iter || nil, $$90, $a, $b, $c, self = this, kind_name = nil, kind_class_symbol = nil, kind_class = nil, kind_java_class = nil, kind_store = nil, name = nil, config = nil, processor = nil, $writer = nil, processor_class = nil, processor_instance = nil;

          if ($iter) $Registry_add_syntax_processor$89.$$p = null;
          
          
          if ($iter) $Registry_add_syntax_processor$89.$$p = null;;
          kind_name = kind.$to_s().$tr("_", " ");
          kind_class_symbol = $send(kind_name.$split(), 'map', [], ($$90 = function(it){var self = $$90.$$s || this;

          
            
            if (it == null) {
              it = nil;
            };
            return it.$capitalize();}, $$90.$$s = self, $$90.$$arity = 1, $$90))['$<<']("Processor").$join().$to_sym();
          kind_class = $$($nesting, 'Extensions').$const_get(kind_class_symbol, false);
          kind_java_class = (function() {if ($truthy((($a = $$$('::', 'AsciidoctorJ', 'skip_raise')) ? 'constant' : nil))) {
            
            return $$$($$$('::', 'AsciidoctorJ'), 'Extensions').$const_get(kind_class_symbol, false);
          } else {
            return nil
          }; return nil; })();
          kind_store = ($truthy($b = self.$instance_variable_get(((("" + "@") + (kind)) + "_extensions").$to_sym())) ? $b : self.$instance_variable_set(((("" + "@") + (kind)) + "_extensions").$to_sym(), $hash2([], {})));
          if ((block !== nil)) {
            
            $c = self.$resolve_args(args, 2), $b = Opal.to_ary($c), (name = ($b[0] == null ? nil : $b[0])), (config = ($b[1] == null ? nil : $b[1])), $c;
            (processor = kind_class.$new(self.$as_symbol(name), config)).$singleton_class().$enable_dsl();
            if (block.$arity()['$=='](0)) {
              $send(processor, 'instance_exec', [], block.$to_proc())
            } else {
              Opal.yield1(block, processor)
            };
            if ($truthy((name = self.$as_symbol(processor.$name())))) {
            } else {
              self.$raise($$$('::', 'ArgumentError'), "" + "No name specified for " + (kind_name) + " extension at " + (block.$source_location()))
            };
            if ($truthy(processor['$process_block_given?']())) {
            } else {
              self.$raise($$$('::', 'NoMethodError'), "" + "No block specified to process " + (kind_name) + " extension at " + (block.$source_location()))
            };
            processor.$freeze();
            
            $writer = [name, $$($nesting, 'ProcessorExtension').$new(kind, processor)];
            $send(kind_store, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];;
          } else {
            
            $c = self.$resolve_args(args, 3), $b = Opal.to_ary($c), (processor = ($b[0] == null ? nil : $b[0])), (name = ($b[1] == null ? nil : $b[1])), (config = ($b[2] == null ? nil : $b[2])), $c;
            if ($truthy((processor_class = $$($nesting, 'Helpers').$resolve_class(processor)))) {
              
              if ($truthy(($truthy($b = $rb_lt(processor_class, kind_class)) ? $b : ($truthy($c = kind_java_class) ? $rb_lt(processor_class, kind_java_class) : $c)))) {
              } else {
                self.$raise($$$('::', 'ArgumentError'), "" + "Class specified for " + (kind_name) + " extension does not inherit from " + (kind_class) + ": " + (processor))
              };
              processor_instance = processor_class.$new(self.$as_symbol(name), config);
              if ($truthy((name = self.$as_symbol(processor_instance.$name())))) {
              } else {
                self.$raise($$$('::', 'ArgumentError'), "" + "No name specified for " + (kind_name) + " extension: " + (processor))
              };
              processor_instance.$freeze();
              
              $writer = [name, $$($nesting, 'ProcessorExtension').$new(kind, processor_instance)];
              $send(kind_store, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];;
            } else if ($truthy(($truthy($b = kind_class['$==='](processor)) ? $b : ($truthy($c = kind_java_class) ? kind_java_class['$==='](processor) : $c)))) {
              
              processor.$update_config(config);
              if ($truthy((name = (function() {if ($truthy(name)) {
                
                
                $writer = [self.$as_symbol(name)];
                $send(processor, 'name=', Opal.to_a($writer));
                return $writer[$rb_minus($writer["length"], 1)];;
              } else {
                
                return self.$as_symbol(processor.$name());
              }; return nil; })()))) {
              } else {
                self.$raise($$$('::', 'ArgumentError'), "" + "No name specified for " + (kind_name) + " extension: " + (processor))
              };
              processor.$freeze();
              
              $writer = [name, $$($nesting, 'ProcessorExtension').$new(kind, processor)];
              $send(kind_store, '[]=', Opal.to_a($writer));
              return $writer[$rb_minus($writer["length"], 1)];;
            } else {
              return self.$raise($$$('::', 'ArgumentError'), "" + "Invalid arguments specified for registering " + (kind_name) + " extension: " + (args))
            };
          };
        }, $Registry_add_syntax_processor$89.$$arity = 2);
        
        Opal.def(self, '$resolve_args', $Registry_resolve_args$91 = function $$resolve_args(args, expect) {
          var self = this, opts = nil, missing = nil;

          
          opts = (function() {if ($truthy($$$('::', 'Hash')['$==='](args['$[]'](-1)))) {
            return args.$pop()
          } else {
            return $hash2([], {})
          }; return nil; })();
          if (expect['$=='](1)) {
            return opts};
          if ($truthy($rb_gt((missing = $rb_minus($rb_minus(expect, 1), args.$size())), 0))) {
            args = $rb_plus(args, $$$('::', 'Array').$new(missing))
          } else if ($truthy($rb_lt(missing, 0))) {
            args.$pop(missing['$-@']())};
          args['$<<'](opts);
          return args;
        }, $Registry_resolve_args$91.$$arity = 2);
        return (Opal.def(self, '$as_symbol', $Registry_as_symbol$92 = function $$as_symbol(name) {
          var self = this;

          if ($truthy(name)) {
            return name.$to_sym()
          } else {
            return nil
          }
        }, $Registry_as_symbol$92.$$arity = 1), nil) && 'as_symbol';
      })($nesting[0], null, $nesting);
      (function(self, $parent_nesting) {
        var $nesting = [self].concat($parent_nesting), $generate_name$93, $next_auto_id$94, $groups$95, $create$96, $register$97, $unregister_all$98, $unregister$99;

        
        
        Opal.def(self, '$generate_name', $generate_name$93 = function $$generate_name() {
          var self = this;

          return "" + "extgrp" + (self.$next_auto_id())
        }, $generate_name$93.$$arity = 0);
        
        Opal.def(self, '$next_auto_id', $next_auto_id$94 = function $$next_auto_id() {
          var $a, self = this;
          if (self.auto_id == null) self.auto_id = nil;

          
          self.auto_id = ($truthy($a = self.auto_id) ? $a : -1);
          return (self.auto_id = $rb_plus(self.auto_id, 1));
        }, $next_auto_id$94.$$arity = 0);
        
        Opal.def(self, '$groups', $groups$95 = function $$groups() {
          var $a, self = this;
          if (self.groups == null) self.groups = nil;

          return (self.groups = ($truthy($a = self.groups) ? $a : $hash2([], {})))
        }, $groups$95.$$arity = 0);
        
        Opal.def(self, '$create', $create$96 = function $$create(name) {
          var $iter = $create$96.$$p, block = $iter || nil, $a, self = this;

          if ($iter) $create$96.$$p = null;
          
          
          if ($iter) $create$96.$$p = null;;
          
          if (name == null) {
            name = nil;
          };
          if ((block !== nil)) {
            return $$($nesting, 'Registry').$new($hash(($truthy($a = name) ? $a : self.$generate_name()), block))
          } else {
            return $$($nesting, 'Registry').$new()
          };
        }, $create$96.$$arity = -1);
        
        Opal.def(self, '$register', $register$97 = function $$register($a) {
          var $iter = $register$97.$$p, block = $iter || nil, $post_args, args, $b, self = this, argc = nil, resolved_group = nil, group = nil, name = nil, $writer = nil;

          if ($iter) $register$97.$$p = null;
          
          
          if ($iter) $register$97.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          argc = args.$size();
          if ((block !== nil)) {
            resolved_group = block
          } else if ($truthy((group = args.$pop()))) {
            resolved_group = ($truthy($b = $$($nesting, 'Helpers').$resolve_class(group)) ? $b : group)
          } else {
            self.$raise($$$('::', 'ArgumentError'), "Extension group to register not specified")
          };
          name = ($truthy($b = args.$pop()) ? $b : self.$generate_name());
          if ($truthy(args['$empty?']())) {
          } else {
            self.$raise($$$('::', 'ArgumentError'), "" + "Wrong number of arguments (" + (argc) + " for 1..2)")
          };
          
          $writer = [name.$to_sym(), resolved_group];
          $send(self.$groups(), '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];;
        }, $register$97.$$arity = -1);
        
        Opal.def(self, '$unregister_all', $unregister_all$98 = function $$unregister_all() {
          var self = this;

          
          self.groups = $hash2([], {});
          return nil;
        }, $unregister_all$98.$$arity = 0);
        return (Opal.def(self, '$unregister', $unregister$99 = function $$unregister($a) {
          var $post_args, names, $$100, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          names = $post_args;;
          $send(names, 'each', [], ($$100 = function(group){var self = $$100.$$s || this;
            if (self.groups == null) self.groups = nil;

          
            
            if (group == null) {
              group = nil;
            };
            return self.groups.$delete(group.$to_sym());}, $$100.$$s = self, $$100.$$arity = 1, $$100));
          return nil;
        }, $unregister$99.$$arity = -1), nil) && 'unregister';
      })(Opal.get_singleton_class(self), $nesting);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/asciidoctor_ext/stylesheet"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$rstrip', '$read', '$join']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Stylesheets');

      var $nesting = [self].concat($parent_nesting), $Stylesheets_primary_stylesheet_data$1;

      self.$$prototype.primary_stylesheet_data = nil;
      return (Opal.def(self, '$primary_stylesheet_data', $Stylesheets_primary_stylesheet_data$1 = function $$primary_stylesheet_data() {
        var $a, self = this;

        return (self.primary_stylesheet_data = ($truthy($a = self.primary_stylesheet_data) ? $a : $$$('::', 'IO').$read($$$('::', 'File').$join("css", "asciidoctor.css")).$rstrip()))
      }, $Stylesheets_primary_stylesheet_data$1.$$arity = 0), nil) && 'primary_stylesheet_data'
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/asciidoctor_ext/document"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Document');

      var $nesting = [self].concat($parent_nesting), $Document_fill_datetime_attributes$1;

      return (Opal.def(self, '$fill_datetime_attributes', $Document_fill_datetime_attributes$1 = function $$fill_datetime_attributes(attrs, input_mtime) {
        var self = this;

        
      var $truthy = Opal.truthy
      var $falsy = Opal.falsy
      var nil = Opal.nil
      var utc_offset
      var source_date_epoch
      var localdate
      var localyear
      var localtime
      var localdatetime
      var docdate
      var doctime

      var getYear = function (time, utc_offset) {
        return utc_offset === 0 ? time.getUTCFullYear() : time.getFullYear()
      }
      var getMonth = function (time, utc_offset) {
        return utc_offset === 0 ? time.getUTCMonth() : time.getMonth()
      }
      var getDay = function (time, utc_offset) {
        return utc_offset === 0 ? time.getUTCDate() : time.getDate()
      }
      var getHours = function (time, utc_offset) {
        return utc_offset === 0 ? time.getUTCHours() : time.getHours()
      }

      var now = new Date()
      // See https://reproducible-builds.org/specs/source-date-epoch/
      if (Opal.const_get_qualified('::', 'ENV')['$key?']('SOURCE_DATE_EPOCH')) {
        now.setTime(parseInt(Opal.const_get_qualified('::', 'ENV')['$[]']('SOURCE_DATE_EPOCH')) * 1000)
        source_date_epoch = now
        utc_offset = 0  // utc
      } else {
        utc_offset = -now.getTimezoneOffset() / 60 // local date
      }
      // localdate and localyear
      if ($truthy((localdate = attrs['$[]']('localdate')))) {
        if ($falsy(localyear = attrs['$[]']('localyear'))) {
          localyear = localdate.indexOf('-') === 4 ? localdate.substring(0, 4) : nil
          attrs['$[]=']('localyear', localyear)
        }
      } else {
        var now_year = getYear(now, utc_offset).toString()
        var now_month = ('0' + (getMonth(now, utc_offset) + 1)).slice(-2)
        var now_day = ('0' + getDay(now, utc_offset)).slice(-2)
        localdate = now_year + '-' + now_month + '-' + now_day
        attrs['$[]=']('localdate', localdate)
        localyear = now_year
        attrs['$[]=']('localyear', now_year)
      }
      // localtime
      if ($falsy((localtime = attrs['$[]']('localtime')))) {
        var hours = ('0' + (getHours(now, utc_offset))).slice(-2)
        var minutes = ('0' + (now.getMinutes())).slice(-2)
        var seconds = ('0' + (now.getSeconds())).slice(-2)
        var utc_offset_format
        if (utc_offset === 0) {
          utc_offset_format = 'UTC'
        } else if (utc_offset > 0) {
          utc_offset_format = ('+0' + (utc_offset * 100)).slice(-5)
        } else {
          utc_offset_format = ('-0' + (-utc_offset * 100)).slice(-5)
        }
        localtime = hours + ':' + minutes + ':' + seconds + ' ' + utc_offset_format
        attrs['$[]=']('localtime', localtime)
      }
      // localdatetime
      if ($falsy((localdatetime = attrs['$[]']('localdatetime')))) {
        localdatetime = localdate + ' ' + localtime
        attrs['$[]=']('localdatetime', localdatetime)
      }

      // docdate, doctime and docdatetime should default to localdate, localtime and localdatetime if not otherwise set
      if ($truthy(source_date_epoch)) {
        input_mtime = source_date_epoch
      } else if ($truthy(input_mtime)) {
        utc_offset = -input_mtime.getTimezoneOffset() / 60
      } else {
        input_mtime = now
      }

      // docdate and docyear
      if ($truthy(docdate = attrs['$[]']('docdate'))) {
        attrs['$[]=']('docyear', docdate.indexOf('-') === 4 ? docdate.substring(0, 4) : nil)
      } else {
        var mtime_year = getYear(input_mtime, utc_offset).toString()
        var mtime_month = ('0' + (getMonth(input_mtime, utc_offset) + 1)).slice(-2)
        var mtime_day = ('0' + (getDay(input_mtime, utc_offset))).slice(-2)
        docdate = mtime_year + '-' + mtime_month + '-' + mtime_day
        attrs['$[]=']('docdate', docdate)
        if ($falsy(attrs['$[]']('docyear'))) {
          attrs['$[]=']('docyear', mtime_year)
        }
      }
      // doctime
      if ($falsy(doctime = attrs['$[]']('doctime'))) {
        var mtime_hours = ('0' + (getHours(input_mtime, utc_offset))).slice(-2)
        var mtime_minutes = ('0' + (input_mtime.getMinutes())).slice(-2)
        var mtime_seconds = ('0' + (input_mtime.getSeconds())).slice(-2)
        var utc_offset_format
        if (utc_offset === 0) {
          utc_offset_format = 'UTC'
        } else if (utc_offset > 0) {
          utc_offset_format = ('+0' + (utc_offset * 100)).slice(-5)
        } else {
          utc_offset_format = ('-0' + (-utc_offset * 100)).slice(-5)
        }
        doctime = mtime_hours + ':' + mtime_minutes + ':' + mtime_seconds + ' ' + utc_offset_format
        attrs['$[]=']('doctime', doctime)
      }
      // docdatetime
      if ($falsy(attrs['$[]']('docdatetime'))) {
        attrs['$[]=']('docdatetime', docdate + ' ' + doctime)
      }
      return nil
    
      }, $Document_fill_datetime_attributes$1.$$arity = 2), nil) && 'fill_datetime_attributes'
    })($nesting[0], $$($nesting, 'AbstractBlock'), $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/asciidoctor_ext/substitutors"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Substitutors');

      var $nesting = [self].concat($parent_nesting), $Substitutors_sub_placeholder$1;

      
      Opal.def(self, '$sub_placeholder', $Substitutors_sub_placeholder$1 = function $$sub_placeholder(format_string, replacement) {
        var self = this;

        return format_string.replace('%s', replacement);
      }, $Substitutors_sub_placeholder$1.$$arity = 2)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/asciidoctor_ext/parser"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Parser');

      var $nesting = [self].concat($parent_nesting), $Parser_uniform$ques$1, $Parser_uniform$ques$2;

      if ($truthy(String.prototype.repeat)) {
        return (Opal.defs(self, '$uniform?', $Parser_uniform$ques$1 = function(str, chr, len) {
          var self = this;

          return chr.repeat(len) === str;
        }, $Parser_uniform$ques$1.$$arity = 3), nil) && 'uniform?'
      } else {
        return (Opal.defs(self, '$uniform?', $Parser_uniform$ques$2 = function(str, chr, len) {
          var self = this;

          return Array.apply(null, { length: len }).map(function () { return chr }).join('') === str;
        }, $Parser_uniform$ques$2.$$arity = 3), nil) && 'uniform?'
      }
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/asciidoctor_ext/syntax_highlighter"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$key?', '$registry', '$[]', '$include?', '$include', '$empty?', '$debug', '$logger', '$join', '$keys']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'SyntaxHighlighter');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $parent_nesting) {
        var self = $module($base, 'Factory');

        var $nesting = [self].concat($parent_nesting), $Factory_for$1;

        
        Opal.def(self, '$for', $Factory_for$1 = function(name) {
          var self = this;

          if ($truthy(self.$registry()['$key?'](name))) {
            return self.$registry()['$[]'](name)
          } else {
            
            if ($truthy(self['$include?']($$($nesting, 'Logging')))) {
            } else {
              self.$include($$($nesting, 'Logging'))
            };
            if ($truthy(self.$registry()['$empty?']())) {
              self.$logger().$debug("no syntax highlighter available, functionality disabled.")
            } else {
              self.$logger().$debug("" + "syntax highlighter named '" + (name) + "' is not available, must be one of: '" + (self.$registry().$keys().$join("', '")) + "'.")
            };
            return nil;
          }
        }, $Factory_for$1.$$arity = 1)
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/asciidoctor_ext"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$require']);
  
  self.$require("asciidoctor/js/asciidoctor_ext/stylesheet");
  self.$require("asciidoctor/js/asciidoctor_ext/document");
  self.$require("asciidoctor/js/asciidoctor_ext/substitutors");
  self.$require("asciidoctor/js/asciidoctor_ext/parser");
  self.$require("asciidoctor/js/asciidoctor_ext/syntax_highlighter");
  
// Load specific runtime
self.$require("asciidoctor/js/asciidoctor_ext/node");
;
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/opal_ext/logger"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$chr', '$rjust', '$message_as_string', '$<', '$write', '$call', '$[]']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Logger');

    var $nesting = [self].concat($parent_nesting), $Logger_add$2;

    self.$$prototype.level = self.$$prototype.progname = self.$$prototype.pipe = self.$$prototype.formatter = nil;
    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Formatter');

      var $nesting = [self].concat($parent_nesting), $Formatter_call$1;

      return (Opal.def(self, '$call', $Formatter_call$1 = function $$call(severity, time, progname, msg) {
        var self = this, time_format = nil;

        
        time_format = time.getFullYear() + '-' + ('0'+(time.getMonth()+1)).slice(-2) + '-' + ('0'+time.getDate()).slice(-2) + 'T' + ('0'+time.getHours()).slice(-2) + ':' + ('0'+time.getMinutes()).slice(-2) + ':' + ('0'+time.getSeconds()).slice(-2) + '.' + ('00' + new Date().getMilliseconds() * 1000).slice(-6);
        return "" + (severity.$chr()) + ", [" + (time_format) + "] " + (severity.$rjust(5)) + " -- " + (progname) + ": " + (self.$message_as_string(msg));
      }, $Formatter_call$1.$$arity = 4), nil) && 'call'
    })($nesting[0], null, $nesting);
    return (Opal.def(self, '$add', $Logger_add$2 = function $$add(severity, message, progname) {
      var $iter = $Logger_add$2.$$p, block = $iter || nil, $a, self = this;

      if ($iter) $Logger_add$2.$$p = null;
      
      
      if ($iter) $Logger_add$2.$$p = null;;
      
      if (message == null) {
        message = nil;
      };
      
      if (progname == null) {
        progname = nil;
      };
      if ($truthy($rb_lt((severity = ($truthy($a = severity) ? $a : $$($nesting, 'UNKNOWN'))), self.level))) {
        return true};
      progname = ($truthy($a = progname) ? $a : self.progname);
      if ($truthy(message)) {
      } else if ((block !== nil)) {
        message = Opal.yieldX(block, [])
      } else {
        
        message = progname;
        progname = self.progname;
      };
      self.pipe.$write(self.formatter.$call(($truthy($a = $$($nesting, 'SEVERITY_LABELS')['$[]'](severity)) ? $a : "ANY"), new Date(), progname, message));
      return true;
    }, $Logger_add$2.$$arity = -2), nil) && 'add';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["asciidoctor/js/postscript"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$require']);
  
  self.$require("asciidoctor/converter/composite");
  self.$require("asciidoctor/converter/html5");
  self.$require("asciidoctor/extensions");
  self.$require("asciidoctor/js/asciidoctor_ext");
  return self.$require("asciidoctor/js/opal_ext/logger");
};

/* Generated by Opal 0.11.99.dev */
(function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$==', '$to_h', '$sort', '$map', '$constants', '$const_get', '$downcase', '$to_s', '$<=>', '$upcase', '$[]', '$values', '$new', '$attr_reader', '$instance_variable_set', '$send', '$singleton_class', '$<<', '$define', '$dirname', '$absolute_path', '$__dir__', '$join', '$home', '$pwd', '$to_set', '$tap', '$each', '$chr', '$each_key', '$slice', '$[]=', '$-', '$length', '$merge', '$default=', '$drop', '$insert']);
  
  self.$require("set");
  if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
    self.$require("asciidoctor/js")
  } else {
    nil
  };
  (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting), $a, $b, $Asciidoctor$7, $Asciidoctor$9, $Asciidoctor$11, $Asciidoctor$13, $writer = nil;

    
    Opal.const_set($nesting[0], 'RUBY_ENGINE_OPAL', Opal.const_set($nesting[0], 'RUBY_ENGINE', $$$('::', 'RUBY_ENGINE'))['$==']("opal"));
    (function($base, $parent_nesting) {
      var self = $module($base, 'SafeMode');

      var $nesting = [self].concat($parent_nesting), $SafeMode$1, $SafeMode$2, $SafeMode_value_for_name$3, $SafeMode_name_for_value$4, $SafeMode_names$5;

      
      Opal.const_set($nesting[0], 'UNSAFE', 0);
      Opal.const_set($nesting[0], 'SAFE', 1);
      Opal.const_set($nesting[0], 'SERVER', 10);
      Opal.const_set($nesting[0], 'SECURE', 20);
      self.names_by_value = $send($send(self.$constants(false), 'map', [], ($SafeMode$1 = function(sym){var self = $SafeMode$1.$$s || this;

      
        
        if (sym == null) {
          sym = nil;
        };
        return [self.$const_get(sym), sym.$to_s().$downcase()];}, $SafeMode$1.$$s = self, $SafeMode$1.$$arity = 1, $SafeMode$1)), 'sort', [], ($SafeMode$2 = function($mlhs_tmp1, $mlhs_tmp2){var self = $SafeMode$2.$$s || this, $a, $b, a = nil, b = nil;

      
        
        if ($mlhs_tmp1 == null) {
          $mlhs_tmp1 = nil;
        };
        
        if ($mlhs_tmp2 == null) {
          $mlhs_tmp2 = nil;
        };
        $b = $mlhs_tmp1, $a = Opal.to_ary($b), (a = ($a[0] == null ? nil : $a[0])), $b;
        $b = $mlhs_tmp2, $a = Opal.to_ary($b), (b = ($a[0] == null ? nil : $a[0])), $b;
        return a['$<=>'](b);}, $SafeMode$2.$$s = self, $SafeMode$2.$$arity = 2, $SafeMode$2.$$has_top_level_mlhs_arg = true, $SafeMode$2)).$to_h();
      Opal.defs(self, '$value_for_name', $SafeMode_value_for_name$3 = function $$value_for_name(name) {
        var self = this;

        return self.$const_get(name.$upcase(), false)
      }, $SafeMode_value_for_name$3.$$arity = 1);
      Opal.defs(self, '$name_for_value', $SafeMode_name_for_value$4 = function $$name_for_value(value) {
        var self = this;
        if (self.names_by_value == null) self.names_by_value = nil;

        return self.names_by_value['$[]'](value)
      }, $SafeMode_name_for_value$4.$$arity = 1);
      Opal.defs(self, '$names', $SafeMode_names$5 = function $$names() {
        var self = this;
        if (self.names_by_value == null) self.names_by_value = nil;

        return self.names_by_value.$values()
      }, $SafeMode_names$5.$$arity = 0);
    })($nesting[0], $nesting);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Compliance');

      var $nesting = [self].concat($parent_nesting);

      
      self.keys = $$$('::', 'Set').$new();
      (function(self, $parent_nesting) {
        var $nesting = [self].concat($parent_nesting), $define$6;

        
        self.$attr_reader("keys");
        return (Opal.def(self, '$define', $define$6 = function $$define(key, value) {
          var self = this;
          if (self.keys == null) self.keys = nil;

          
          self.$instance_variable_set("" + "@" + (key), value);
          self.$singleton_class().$send("attr_accessor", key);
          self.keys['$<<'](key);
          return nil;
        }, $define$6.$$arity = 2), nil) && 'define';
      })(Opal.get_singleton_class(self), $nesting);
      self.$define("block_terminates_paragraph", true);
      self.$define("strict_verbatim_paragraphs", true);
      self.$define("underline_style_section_titles", true);
      self.$define("unwrap_standalone_preamble", true);
      self.$define("attribute_missing", "skip");
      self.$define("attribute_undefined", "drop-line");
      self.$define("shorthand_property_syntax", true);
      self.$define("natural_xrefs", true);
      self.$define("unique_id_start_index", 2);
      self.$define("markdown_syntax", true);
    })($nesting[0], $nesting);
    if ($truthy((($a = $$($nesting, 'ROOT_DIR', 'skip_raise')) ? 'constant' : nil))) {
    } else {
      Opal.const_set($nesting[0], 'ROOT_DIR', $$$('::', 'File').$dirname($$$('::', 'File').$absolute_path(self.$__dir__())))
    };
    Opal.const_set($nesting[0], 'LIB_DIR', $$$('::', 'File').$join($$($nesting, 'ROOT_DIR'), "lib"));
    Opal.const_set($nesting[0], 'DATA_DIR', $$$('::', 'File').$join($$($nesting, 'ROOT_DIR'), "data"));
    Opal.const_set($nesting[0], 'USER_HOME', (function() { try {
      return $$$('::', 'Dir').$home()
    } catch ($err) {
      if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
        try {
          
          return ($truthy($b = $$$('::', 'ENV')['$[]']("HOME")) ? $b : $$$('::', 'Dir').$pwd());
        } finally { Opal.pop_exception() }
      } else { throw $err; }
    }})());
    Opal.const_set($nesting[0], 'LF', "\n");
    Opal.const_set($nesting[0], 'NULL', "\u0000");
    Opal.const_set($nesting[0], 'TAB', "\t");
    Opal.const_set($nesting[0], 'MAX_INT', 9007199254740991);
    Opal.const_set($nesting[0], 'UTF_8', $$$($$$('::', 'Encoding'), 'UTF_8'));
    Opal.const_set($nesting[0], 'BOM_BYTES_UTF_8', [239, 187, 191]);
    Opal.const_set($nesting[0], 'BOM_BYTES_UTF_16LE', [255, 254]);
    Opal.const_set($nesting[0], 'BOM_BYTES_UTF_16BE', [254, 255]);
    Opal.const_set($nesting[0], 'FILE_READ_MODE', (function() {if ($truthy($$($nesting, 'RUBY_ENGINE_OPAL'))) {
      return "r"
    } else {
      return "rb:utf-8:utf-8"
    }; return nil; })());
    Opal.const_set($nesting[0], 'URI_READ_MODE', $$($nesting, 'FILE_READ_MODE'));
    Opal.const_set($nesting[0], 'FILE_WRITE_MODE', (function() {if ($truthy($$($nesting, 'RUBY_ENGINE_OPAL'))) {
      return "w"
    } else {
      return "w:utf-8"
    }; return nil; })());
    Opal.const_set($nesting[0], 'DEFAULT_DOCTYPE', "article");
    Opal.const_set($nesting[0], 'DEFAULT_BACKEND', "html5");
    Opal.const_set($nesting[0], 'DEFAULT_STYLESHEET_KEYS', ["", "DEFAULT"].$to_set());
    Opal.const_set($nesting[0], 'DEFAULT_STYLESHEET_NAME', "asciidoctor.css");
    Opal.const_set($nesting[0], 'BACKEND_ALIASES', $hash2(["html", "docbook"], {"html": "html5", "docbook": "docbook5"}));
    Opal.const_set($nesting[0], 'DEFAULT_PAGE_WIDTHS', $hash2(["docbook"], {"docbook": 425}));
    Opal.const_set($nesting[0], 'DEFAULT_EXTENSIONS', $hash2(["html", "docbook", "pdf", "epub", "manpage", "asciidoc"], {"html": ".html", "docbook": ".xml", "pdf": ".pdf", "epub": ".epub", "manpage": ".man", "asciidoc": ".adoc"}));
    Opal.const_set($nesting[0], 'ASCIIDOC_EXTENSIONS', $hash2([".adoc", ".asciidoc", ".asc", ".ad", ".txt"], {".adoc": true, ".asciidoc": true, ".asc": true, ".ad": true, ".txt": true}));
    Opal.const_set($nesting[0], 'SETEXT_SECTION_LEVELS', $hash2(["=", "-", "~", "^", "+"], {"=": 0, "-": 1, "~": 2, "^": 3, "+": 4}));
    Opal.const_set($nesting[0], 'ADMONITION_STYLES', ["NOTE", "TIP", "IMPORTANT", "WARNING", "CAUTION"].$to_set());
    Opal.const_set($nesting[0], 'ADMONITION_STYLE_HEADS', $send($$$('::', 'Set').$new(), 'tap', [], ($Asciidoctor$7 = function(accum){var self = $Asciidoctor$7.$$s || this, $$8;

    
      
      if (accum == null) {
        accum = nil;
      };
      return $send($$($nesting, 'ADMONITION_STYLES'), 'each', [], ($$8 = function(s){var self = $$8.$$s || this;

      
        
        if (s == null) {
          s = nil;
        };
        return accum['$<<'](s.$chr());}, $$8.$$s = self, $$8.$$arity = 1, $$8));}, $Asciidoctor$7.$$s = self, $Asciidoctor$7.$$arity = 1, $Asciidoctor$7)));
    Opal.const_set($nesting[0], 'PARAGRAPH_STYLES', ["comment", "example", "literal", "listing", "normal", "open", "pass", "quote", "sidebar", "source", "verse", "abstract", "partintro"].$to_set());
    Opal.const_set($nesting[0], 'VERBATIM_STYLES', ["literal", "listing", "source", "verse"].$to_set());
    Opal.const_set($nesting[0], 'DELIMITED_BLOCKS', $hash2(["--", "----", "....", "====", "****", "____", "++++", "|===", ",===", ":===", "!===", "////", "```"], {"--": ["open", ["comment", "example", "literal", "listing", "pass", "quote", "sidebar", "source", "verse", "admonition", "abstract", "partintro"].$to_set()], "----": ["listing", ["literal", "source"].$to_set()], "....": ["literal", ["listing", "source"].$to_set()], "====": ["example", ["admonition"].$to_set()], "****": ["sidebar", $$$('::', 'Set').$new()], "____": ["quote", ["verse"].$to_set()], "++++": ["pass", ["stem", "latexmath", "asciimath"].$to_set()], "|===": ["table", $$$('::', 'Set').$new()], ",===": ["table", $$$('::', 'Set').$new()], ":===": ["table", $$$('::', 'Set').$new()], "!===": ["table", $$$('::', 'Set').$new()], "////": ["comment", $$$('::', 'Set').$new()], "```": ["fenced_code", $$$('::', 'Set').$new()]}));
    Opal.const_set($nesting[0], 'DELIMITED_BLOCK_HEADS', $send($hash2([], {}), 'tap', [], ($Asciidoctor$9 = function(accum){var self = $Asciidoctor$9.$$s || this, $$10;

    
      
      if (accum == null) {
        accum = nil;
      };
      return $send($$($nesting, 'DELIMITED_BLOCKS'), 'each_key', [], ($$10 = function(k){var self = $$10.$$s || this, $writer = nil;

      
        
        if (k == null) {
          k = nil;
        };
        $writer = [k.$slice(0, 2), true];
        $send(accum, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];}, $$10.$$s = self, $$10.$$arity = 1, $$10));}, $Asciidoctor$9.$$s = self, $Asciidoctor$9.$$arity = 1, $Asciidoctor$9)));
    Opal.const_set($nesting[0], 'DELIMITED_BLOCK_TAILS', $send($hash2([], {}), 'tap', [], ($Asciidoctor$11 = function(accum){var self = $Asciidoctor$11.$$s || this, $$12;

    
      
      if (accum == null) {
        accum = nil;
      };
      return $send($$($nesting, 'DELIMITED_BLOCKS'), 'each_key', [], ($$12 = function(k){var self = $$12.$$s || this, $writer = nil;

      
        
        if (k == null) {
          k = nil;
        };
        if (k.$length()['$=='](4)) {
          
          $writer = [k, k['$[]']($rb_minus(k.$length(), 1))];
          $send(accum, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        } else {
          return nil
        };}, $$12.$$s = self, $$12.$$arity = 1, $$12));}, $Asciidoctor$11.$$s = self, $Asciidoctor$11.$$arity = 1, $Asciidoctor$11)));
    Opal.const_set($nesting[0], 'CAPTION_ATTRIBUTE_NAMES', $hash2(["example", "figure", "listing", "table"], {"example": "example-caption", "figure": "figure-caption", "listing": "listing-caption", "table": "table-caption"}));
    Opal.const_set($nesting[0], 'LAYOUT_BREAK_CHARS', $hash2(["'", "<"], {"'": "thematic_break", "<": "page_break"}));
    Opal.const_set($nesting[0], 'MARKDOWN_THEMATIC_BREAK_CHARS', $hash2(["-", "*", "_"], {"-": "thematic_break", "*": "thematic_break", "_": "thematic_break"}));
    Opal.const_set($nesting[0], 'HYBRID_LAYOUT_BREAK_CHARS', $$($nesting, 'LAYOUT_BREAK_CHARS').$merge($$($nesting, 'MARKDOWN_THEMATIC_BREAK_CHARS')));
    Opal.const_set($nesting[0], 'NESTABLE_LIST_CONTEXTS', ["ulist", "olist", "dlist"]);
    Opal.const_set($nesting[0], 'ORDERED_LIST_STYLES', ["arabic", "loweralpha", "lowerroman", "upperalpha", "upperroman"]);
    Opal.const_set($nesting[0], 'ORDERED_LIST_KEYWORDS', $hash2(["loweralpha", "lowerroman", "upperalpha", "upperroman"], {"loweralpha": "a", "lowerroman": "i", "upperalpha": "A", "upperroman": "I"}));
    Opal.const_set($nesting[0], 'ATTR_REF_HEAD', "{");
    Opal.const_set($nesting[0], 'LIST_CONTINUATION', "+");
    Opal.const_set($nesting[0], 'HARD_LINE_BREAK', " +");
    Opal.const_set($nesting[0], 'LINE_CONTINUATION', " \\");
    Opal.const_set($nesting[0], 'LINE_CONTINUATION_LEGACY', " +");
    Opal.const_set($nesting[0], 'BLOCK_MATH_DELIMITERS', $hash2(["asciimath", "latexmath"], {"asciimath": ["\\$", "\\$"], "latexmath": ["\\[", "\\]"]}));
    Opal.const_set($nesting[0], 'INLINE_MATH_DELIMITERS', $hash2(["asciimath", "latexmath"], {"asciimath": ["\\$", "\\$"], "latexmath": ["\\(", "\\)"]}));
    
    $writer = ["asciimath"];
    $send(Opal.const_set($nesting[0], 'STEM_TYPE_ALIASES', $hash2(["latexmath", "latex", "tex"], {"latexmath": "latexmath", "latex": "latexmath", "tex": "latexmath"})), 'default=', Opal.to_a($writer));
    $writer[$rb_minus($writer["length"], 1)];;
    Opal.const_set($nesting[0], 'FONT_AWESOME_VERSION', "4.7.0");
    Opal.const_set($nesting[0], 'HIGHLIGHT_JS_VERSION', "9.18.3");
    Opal.const_set($nesting[0], 'MATHJAX_VERSION', "2.7.9");
    Opal.const_set($nesting[0], 'DEFAULT_ATTRIBUTES', $hash2(["appendix-caption", "appendix-refsig", "caution-caption", "chapter-refsig", "example-caption", "figure-caption", "important-caption", "last-update-label", "note-caption", "part-refsig", "prewrap", "sectids", "section-refsig", "table-caption", "tip-caption", "toc-placement", "toc-title", "untitled-label", "version-label", "warning-caption"], {"appendix-caption": "Appendix", "appendix-refsig": "Appendix", "caution-caption": "Caution", "chapter-refsig": "Chapter", "example-caption": "Example", "figure-caption": "Figure", "important-caption": "Important", "last-update-label": "Last updated", "note-caption": "Note", "part-refsig": "Part", "prewrap": "", "sectids": "", "section-refsig": "Section", "table-caption": "Table", "tip-caption": "Tip", "toc-placement": "auto", "toc-title": "Table of Contents", "untitled-label": "Untitled", "version-label": "Version", "warning-caption": "Warning"}));
    Opal.const_set($nesting[0], 'FLEXIBLE_ATTRIBUTES', ["sectnums"]);
    Opal.const_set($nesting[0], 'INTRINSIC_ATTRIBUTES', $hash2(["startsb", "endsb", "vbar", "caret", "asterisk", "tilde", "plus", "backslash", "backtick", "blank", "empty", "sp", "two-colons", "two-semicolons", "nbsp", "deg", "zwsp", "quot", "apos", "lsquo", "rsquo", "ldquo", "rdquo", "wj", "brvbar", "pp", "cpp", "amp", "lt", "gt"], {"startsb": "[", "endsb": "]", "vbar": "|", "caret": "^", "asterisk": "*", "tilde": "~", "plus": "&#43;", "backslash": "\\", "backtick": "`", "blank": "", "empty": "", "sp": " ", "two-colons": "::", "two-semicolons": ";;", "nbsp": "&#160;", "deg": "&#176;", "zwsp": "&#8203;", "quot": "&#34;", "apos": "&#39;", "lsquo": "&#8216;", "rsquo": "&#8217;", "ldquo": "&#8220;", "rdquo": "&#8221;", "wj": "&#8288;", "brvbar": "&#166;", "pp": "&#43;&#43;", "cpp": "C&#43;&#43;", "amp": "&", "lt": "<", "gt": ">"}));
    if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
    } else {
      nil
    };
    Opal.const_set($nesting[0], 'QUOTE_SUBS', $send($hash2([], {}), 'tap', [], ($Asciidoctor$13 = function(accum){var self = $Asciidoctor$13.$$s || this, normal = nil, compat = nil;

    
      
      if (accum == null) {
        accum = nil;
      };
      
      $writer = [false, (normal = [["strong", "unconstrained", new RegExp("" + "\\\\?(?:\\[([^\\]]+)\\])?\\*\\*(" + ($$($nesting, 'CC_ALL')) + "+?)\\*\\*", 'm')], ["strong", "constrained", new RegExp("" + "(^|[^" + ($$($nesting, 'CC_WORD')) + ";:}])(?:\\[([^\\]]+)\\])?\\*(\\S|\\S" + ($$($nesting, 'CC_ALL')) + "*?\\S)\\*(?!" + ($$($nesting, 'CG_WORD')) + ")", 'm')], ["double", "constrained", new RegExp("" + "(^|[^" + ($$($nesting, 'CC_WORD')) + ";:}])(?:\\[([^\\]]+)\\])?\"`(\\S|\\S" + ($$($nesting, 'CC_ALL')) + "*?\\S)`\"(?!" + ($$($nesting, 'CG_WORD')) + ")", 'm')], ["single", "constrained", new RegExp("" + "(^|[^" + ($$($nesting, 'CC_WORD')) + ";:`}])(?:\\[([^\\]]+)\\])?'`(\\S|\\S" + ($$($nesting, 'CC_ALL')) + "*?\\S)`'(?!" + ($$($nesting, 'CG_WORD')) + ")", 'm')], ["monospaced", "unconstrained", new RegExp("" + "\\\\?(?:\\[([^\\]]+)\\])?``(" + ($$($nesting, 'CC_ALL')) + "+?)``", 'm')], ["monospaced", "constrained", new RegExp("" + "(^|[^" + ($$($nesting, 'CC_WORD')) + ";:\"'`}])(?:\\[([^\\]]+)\\])?`(\\S|\\S" + ($$($nesting, 'CC_ALL')) + "*?\\S)`(?![" + ($$($nesting, 'CC_WORD')) + "\"'`])", 'm')], ["emphasis", "unconstrained", new RegExp("" + "\\\\?(?:\\[([^\\]]+)\\])?__(" + ($$($nesting, 'CC_ALL')) + "+?)__", 'm')], ["emphasis", "constrained", new RegExp("" + "(^|[^" + ($$($nesting, 'CC_WORD')) + ";:}])(?:\\[([^\\]]+)\\])?_(\\S|\\S" + ($$($nesting, 'CC_ALL')) + "*?\\S)_(?!" + ($$($nesting, 'CG_WORD')) + ")", 'm')], ["mark", "unconstrained", new RegExp("" + "\\\\?(?:\\[([^\\]]+)\\])?##(" + ($$($nesting, 'CC_ALL')) + "+?)##", 'm')], ["mark", "constrained", new RegExp("" + "(^|[^" + ($$($nesting, 'CC_WORD')) + "&;:}])(?:\\[([^\\]]+)\\])?#(\\S|\\S" + ($$($nesting, 'CC_ALL')) + "*?\\S)#(?!" + ($$($nesting, 'CG_WORD')) + ")", 'm')], ["superscript", "unconstrained", /\\?(?:\[([^\]]+)\])?\^(\S+?)\^/], ["subscript", "unconstrained", /\\?(?:\[([^\]]+)\])?~(\S+?)~/]])];
      $send(accum, '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      
      $writer = [true, (compat = normal.$drop(0))];
      $send(accum, '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      
      $writer = [2, ["double", "constrained", new RegExp("" + "(^|[^" + ($$($nesting, 'CC_WORD')) + ";:}])(?:\\[([^\\]]+)\\])?``(\\S|\\S" + ($$($nesting, 'CC_ALL')) + "*?\\S)''(?!" + ($$($nesting, 'CG_WORD')) + ")", 'm')]];
      $send(compat, '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      
      $writer = [3, ["single", "constrained", new RegExp("" + "(^|[^" + ($$($nesting, 'CC_WORD')) + ";:}])(?:\\[([^\\]]+)\\])?`(\\S|\\S" + ($$($nesting, 'CC_ALL')) + "*?\\S)'(?!" + ($$($nesting, 'CG_WORD')) + ")", 'm')]];
      $send(compat, '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      
      $writer = [4, ["monospaced", "unconstrained", new RegExp("" + "\\\\?(?:\\[([^\\]]+)\\])?\\+\\+(" + ($$($nesting, 'CC_ALL')) + "+?)\\+\\+", 'm')]];
      $send(compat, '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      
      $writer = [5, ["monospaced", "constrained", new RegExp("" + "(^|[^" + ($$($nesting, 'CC_WORD')) + ";:}])(?:\\[([^\\]]+)\\])?\\+(\\S|\\S" + ($$($nesting, 'CC_ALL')) + "*?\\S)\\+(?!" + ($$($nesting, 'CG_WORD')) + ")", 'm')]];
      $send(compat, '[]=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      return compat.$insert(3, ["emphasis", "constrained", new RegExp("" + "(^|[^" + ($$($nesting, 'CC_WORD')) + ";:}])(?:\\[([^\\]]+)\\])?'(\\S|\\S" + ($$($nesting, 'CC_ALL')) + "*?\\S)'(?!" + ($$($nesting, 'CG_WORD')) + ")", 'm')]);}, $Asciidoctor$13.$$s = self, $Asciidoctor$13.$$arity = 1, $Asciidoctor$13)));
    Opal.const_set($nesting[0], 'REPLACEMENTS', [[/\\?\(C\)/, "&#169;", "none"], [/\\?\(R\)/, "&#174;", "none"], [/\\?\(TM\)/, "&#8482;", "none"], [/(?: |\n|^|\\)--(?: |\n|$)/, "&#8201;&#8212;&#8201;", "none"], [new RegExp("" + "(" + ($$($nesting, 'CG_WORD')) + ")\\\\?--(?=" + ($$($nesting, 'CG_WORD')) + ")"), "&#8212;&#8203;", "leading"], [/\\?\.\.\./, "&#8230;&#8203;", "none"], [/\\?`'/, "&#8217;", "none"], [new RegExp("" + "(" + ($$($nesting, 'CG_ALNUM')) + ")\\\\?'(?=" + ($$($nesting, 'CG_ALPHA')) + ")"), "&#8217;", "leading"], [/\\?-&gt;/, "&#8594;", "none"], [/\\?=&gt;/, "&#8658;", "none"], [/\\?&lt;-/, "&#8592;", "none"], [/\\?&lt;=/, "&#8656;", "none"], [/\\?(&)amp;((?:[a-zA-Z][a-zA-Z]+\d{0,2}|#\d\d\d{0,4}|#x[\da-fA-F][\da-fA-F][\da-fA-F]{0,3});)/, "", "bounding"]]);
    if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
    } else {
      nil
    };
    if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
    } else {
      nil
    };
  })($nesting[0], $nesting);
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/core_ext");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/helpers");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/logging");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/rx");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/substitutors");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/version");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/abstract_node");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/abstract_block");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/attribute_list");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/block");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/callouts");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/converter");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/document");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/inline");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/list");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/parser");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/path_resolver");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/reader");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/section");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/stylesheets");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/table");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/writer");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/load");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/convert");
  if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
    
    self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/syntax_highlighter");
    self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/timings");
    return self.$require("asciidoctor/js/postscript");
  } else {
    return nil
  };
})(Opal);


/* global Opal */

/**
 * Convert a JSON to an (Opal) Hash.
 * @private
 */
var toHash = function (object) {
  return object && !object.$$is_hash ? Opal.hash2(Object.keys(object), object) : object
}

/**
 * Convert an (Opal) Hash to JSON.
 * @private
 */
var fromHash = function (hash) {
  var object = {}
  if (hash) {
    var stringMap = hash.$$smap
    for (var stringMapKey in stringMap) {
      var stringMapValue = stringMap[stringMapKey]
      object[stringMapKey] = stringMapValue === Opal.nil ? undefined : stringMapValue
    }
    var numericMap = hash.$$map
    if (numericMap) {
      var positional = []
      for (var numericMapKey in numericMap) {
        var entry = numericMap[numericMapKey]
        var numericMapValue = entry.value
        var index = entry.key - 1
        positional[index] = numericMapValue === Opal.nil ? undefined : numericMapValue
      }
      if (positional.length > 0) {
        object.$positional = positional
      }
    }
  }
  return object
}

var fromHashKeys = function (hash) {
  var object = {}
  if (hash) {
    var data = hash.$$keys
    for (var key in data) {
      var value = data[key].value
      object[key.toString()] = value === Opal.nil ? undefined : value
    }
  }
  return object
}

/**
 * @private
 */
var prepareOptions = function (options) {
  options = toHash(options)
  if (options) {
    var attrs = options['$[]']('attributes')
    if (attrs && typeof attrs === 'object' && attrs.constructor.name === 'Object') {
      options = options.$dup()
      options['$[]=']('attributes', toHash(attrs))
    }
  }
  return options
}

function initializeClass (superClass, className, functions, defaultFunctions, argProxyFunctions) {
  var scope = Opal.klass(Opal.Object, superClass, className, function () { })
  var postConstructFunction
  var initializeFunction
  var constructorFunction
  var defaultFunctionsOverridden = {}
  for (var functionName in functions) {
    if (Object.prototype.hasOwnProperty.call(functions, functionName)) {
      (function (functionName) {
        var userFunction = functions[functionName]
        if (functionName === 'postConstruct') {
          postConstructFunction = userFunction
        } else if (functionName === 'initialize') {
          initializeFunction = userFunction
        } else if (functionName === 'constructor') {
          constructorFunction = userFunction
        } else {
          if (defaultFunctions && Object.prototype.hasOwnProperty.call(defaultFunctions, functionName)) {
            defaultFunctionsOverridden[functionName] = true
          }
          Opal.def(scope, '$' + functionName, function () {
            var args
            if (argProxyFunctions && Object.prototype.hasOwnProperty.call(argProxyFunctions, functionName)) {
              args = argProxyFunctions[functionName](arguments)
            } else {
              args = arguments
            }
            return userFunction.apply(this, args)
          })
        }
      }(functionName))
    }
  }
  var initialize
  if (typeof constructorFunction === 'function') {
    initialize = function () {
      var args = Array.from(arguments)
      for (var i = 0; i < args.length; i++) {
        // convert all (Opal) Hash arguments to JSON.
        if (typeof args[i] === 'object' && '$$smap' in args[i]) {
          args[i] = fromHash(args[i])
        }
      }
      args.unshift(null)
      var result = new (Function.prototype.bind.apply(constructorFunction, args)) // eslint-disable-line
      Object.assign(this, result)
      if (typeof postConstructFunction === 'function') {
        postConstructFunction.bind(this)()
      }
    }
  } else if (typeof initializeFunction === 'function') {
    initialize = function () {
      var args = Array.from(arguments)
      for (var i = 0; i < args.length; i++) {
        // convert all (Opal) Hash arguments to JSON.
        if (typeof args[i] === 'object' && '$$smap' in args[i]) {
          args[i] = fromHash(args[i])
        }
      }
      initializeFunction.apply(this, args)
      if (typeof postConstructFunction === 'function') {
        postConstructFunction.bind(this)()
      }
    }
  } else {
    initialize = function () {
      Opal.send(this, Opal.find_super_dispatcher(this, 'initialize', initialize))
      if (typeof postConstructFunction === 'function') {
        postConstructFunction.bind(this)()
      }
    }
  }
  Opal.def(scope, '$initialize', initialize)
  Opal.def(scope, 'super', function (func) {
    if (typeof func === 'function') {
      Opal.send(this, Opal.find_super_dispatcher(this, func.name, func))
    } else {
      // Bind the initialize function to super();
      var argumentsList = Array.from(arguments)
      for (var i = 0; i < argumentsList.length; i++) {
        // convert all (Opal) Hash arguments to JSON.
        if (typeof argumentsList[i] === 'object') {
          argumentsList[i] = toHash(argumentsList[i])
        }
      }
      Opal.send(this, Opal.find_super_dispatcher(this, 'initialize', initialize), argumentsList)
    }
  })
  if (defaultFunctions) {
    for (var defaultFunctionName in defaultFunctions) {
      if (Object.prototype.hasOwnProperty.call(defaultFunctions, defaultFunctionName) && !Object.prototype.hasOwnProperty.call(defaultFunctionsOverridden, defaultFunctionName)) {
        (function (defaultFunctionName) {
          var defaultFunction = defaultFunctions[defaultFunctionName]
          Opal.def(scope, '$' + defaultFunctionName, function () {
            return defaultFunction.apply(this, arguments)
          })
        }(defaultFunctionName))
      }
    }
  }
  return scope
}

// Asciidoctor API

/**
 * @namespace
 * @description
 * The main application interface (API) for Asciidoctor.
 * This API provides methods to parse AsciiDoc content and convert it to various output formats using built-in or third-party converters.
 *
 * An AsciiDoc document can be as simple as a single line of content,
 * though it more commonly starts with a document header that declares the document title and document attribute definitions.
 * The document header is then followed by zero or more section titles, optionally nested, to organize the paragraphs, blocks, lists, etc. of the document.
 *
 * By default, the processor converts the AsciiDoc document to HTML 5 using a built-in converter.
 * However, this behavior can be changed by specifying a different backend (e.g., +docbook+).
 * A backend is a keyword for an output format (e.g., DocBook).
 * That keyword, in turn, is used to select a converter, which carries out the request to convert the document to that format.
 *
 * @example
 * asciidoctor.convertFile('document.adoc', { 'safe': 'safe' }) // Convert an AsciiDoc file
 *
 * asciidoctor.convert("I'm using *Asciidoctor* version {asciidoctor-version}.", { 'safe': 'safe' }) // Convert an AsciiDoc string
 *
 * const doc = asciidoctor.loadFile('document.adoc', { 'safe': 'safe' }) // Parse an AsciiDoc file into a document object
 *
 * const doc = asciidoctor.load("= Document Title\n\nfirst paragraph\n\nsecond paragraph", { 'safe': 'safe' }) // Parse an AsciiDoc string into a document object
 */
var Asciidoctor = Opal.Asciidoctor.$$class

/**
 * Get Asciidoctor core version number.
 *
 * @returns {string} - the version number of Asciidoctor core.
 * @memberof Asciidoctor
 */
Asciidoctor.prototype.getCoreVersion = function () {
  return this.$$const.VERSION
}

/**
 * Get Asciidoctor.js runtime environment information.
 *
 * @returns {Object} - the runtime environment including the ioModule, the platform, the engine and the framework.
 * @memberof Asciidoctor
 */
Asciidoctor.prototype.getRuntime = function () {
  return {
    ioModule: Opal.const_get_qualified('::', 'JAVASCRIPT_IO_MODULE'),
    platform: Opal.const_get_qualified('::', 'JAVASCRIPT_PLATFORM'),
    engine: Opal.const_get_qualified('::', 'JAVASCRIPT_ENGINE'),
    framework: Opal.const_get_qualified('::', 'JAVASCRIPT_FRAMEWORK')
  }
}

/**
 * Parse the AsciiDoc source input into an {@link Document} and convert it to the specified backend format.
 *
 * Accepts input as a Buffer or String.
 *
 * @param {string|Buffer} input - AsciiDoc input as String or Buffer
 * @param {Object} options - a JSON of options to control processing (default: {})
 * @returns {string|Document} - the {@link Document} object if the converted String is written to a file,
 * otherwise the converted String
 * @example
 * var input = '= Hello, AsciiDoc!\n' +
 *   'Guillaume Grossetie <ggrossetie@example.com>\n\n' +
 *   'An introduction to http://asciidoc.org[AsciiDoc].\n\n' +
 *   '== First Section\n\n' +
 *   '* item 1\n' +
 *   '* item 2\n';
 *
 * var html = asciidoctor.convert(input);
 * @memberof Asciidoctor
 */
Asciidoctor.prototype.convert = function (input, options) {
  if (typeof input === 'object' && input.constructor.name === 'Buffer') {
    input = input.toString('utf8')
  }
  var result = this.$convert(input, prepareOptions(options))
  return result === Opal.nil ? '' : result
}

/**
 * Parse the AsciiDoc source input into an {@link Document} and convert it to the specified backend format.
 *
 * @param {string} filename - source filename
 * @param {Object} options - a JSON of options to control processing (default: {})
 * @returns {string|Document} - the {@link Document} object if the converted String is written to a file,
 * otherwise the converted String
 * @example
 * var html = asciidoctor.convertFile('./document.adoc');
 * @memberof Asciidoctor
 */
Asciidoctor.prototype.convertFile = function (filename, options) {
  return this.$convert_file(filename, prepareOptions(options))
}

/**
 * Parse the AsciiDoc source input into an {@link Document}
 *
 * Accepts input as a Buffer or String.
 *
 * @param {string|Buffer} input - AsciiDoc input as String or Buffer
 * @param {Object} options - a JSON of options to control processing (default: {})
 * @returns {Document} - the {@link Document} object
 * @memberof Asciidoctor
 */
Asciidoctor.prototype.load = function (input, options) {
  if (typeof input === 'object' && input.constructor.name === 'Buffer') {
    input = input.toString('utf8')
  }
  return this.$load(input, prepareOptions(options))
}

/**
 * Parse the contents of the AsciiDoc source file into an {@link Document}
 *
 * @param {string} filename - source filename
 * @param {Object} options - a JSON of options to control processing (default: {})
 * @returns {Document} - the {@link Document} object
 * @memberof Asciidoctor
 */
Asciidoctor.prototype.loadFile = function (filename, options) {
  return this.$load_file(filename, prepareOptions(options))
}

// AbstractBlock API

/**
 * @namespace
 * @extends AbstractNode
 */
var AbstractBlock = Opal.Asciidoctor.AbstractBlock

/**
 * Append a block to this block's list of child blocks.
 * @param {AbstractBlock} block - the block to append
 * @returns {AbstractBlock} - the parent block to which this block was appended.
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.append = function (block) {
  this.$append(block)
  return this
}

/**
 * Get the String title of this Block with title substitions applied
 *
 * The following substitutions are applied to block and section titles:
 *
 * <code>specialcharacters</code>, <code>quotes</code>, <code>replacements</code>, <code>macros</code>, <code>attributes</code> and <code>post_replacements</code>
 *
 * @returns {string} - the converted String title for this Block, or undefined if the title is not set.
 * @example
 * block.title // "Foo 3^ # {two-colons} Bar(1)"
 * block.getTitle(); // "Foo 3^ # :: Bar(1)"
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getTitle = function () {
  var title = this.$title()
  return title === Opal.nil ? undefined : title
}

/**
 * Set the String block title.
 *
 * @param {string} title - The block title
 * @returns {string} - the new String title assigned to this Block.
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.setTitle = function (title) {
  title = typeof title === 'undefined' ? Opal.nil : title
  return this['$title='](title)
}

/**
 * Generate and assign caption to block if not already assigned.
 *
 * If the block has a title and a caption prefix is available for this block,
 * then build a caption from this information, assign it a number and store it
 * to the caption attribute on the block.
 *
 * If a caption has already been assigned to this block, do nothing.
 *
 * The parts of a complete caption are: `<prefix> <number>. <title>`
 * This partial caption represents the part the precedes the title.
 *
 * @param {string} value - the String caption to assign to this block or nil to use document attribute.
 * @param {string} captionContext - the String context to use when resolving caption-related attributes.
 * If not provided, the name of the context for this block is used. Only certain contexts allow the caption to be looked up.
 *
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.assignCaption = function (value, captionContext) {
  value = typeof value === 'undefined' ? Opal.nil : value
  captionContext = typeof captionContext === 'undefined' ? null : captionContext
  this.$assign_caption(value, captionContext)
}

/**
 * Convenience method that returns the interpreted title of the Block
 * with the caption prepended.
 * Concatenates the value of this Block's caption instance variable and the
 * return value of this Block's title method. No space is added between the
 * two values. If the Block does not have a caption, the interpreted title is
 * returned.
 *
 * @returns {string} - the converted String title prefixed with the caption, or just the converted String title if no caption is set
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getCaptionedTitle = function () {
  return this.$captioned_title()
}

/**
 * Get the style (block type qualifier) for this block.
 *
 * @returns {string} - the style for this block
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getStyle = function () {
  var style = this.style
  return style === Opal.nil ? undefined : style
}

/**
 * Set the style for this block.
 *
 * @param {string} style - Style
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.setStyle = function (style) {
  this.style = style
}

/**
 * Get the location in the AsciiDoc source where this block begins.
 *
 * @returns {string} - the style for this block
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getSourceLocation = function () {
  var sourceLocation = this.source_location
  if (sourceLocation === Opal.nil) {
    return undefined
  }
  sourceLocation.getFile = function () {
    var file = this.file
    return file === Opal.nil ? undefined : file
  }
  sourceLocation.getDirectory = function () {
    var dir = this.dir
    return dir === Opal.nil ? undefined : dir
  }
  sourceLocation.getPath = function () {
    var path = this.path
    return path === Opal.nil ? undefined : path
  }
  sourceLocation.getLineNumber = function () {
    var lineno = this.lineno
    return lineno === Opal.nil ? undefined : lineno
  }
  return sourceLocation
}

/**
 * Get the caption for this block.
 *
 * @returns {string} - the caption for this block
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getCaption = function () {
  var caption = this.$caption()
  return caption === Opal.nil ? undefined : caption
}

/**
 * Set the caption for this block.
 *
 * @param {string} caption - Caption
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.setCaption = function (caption) {
  this.caption = typeof caption === 'undefined' ? Opal.nil : caption
}

/**
 * Get the level of this section or the section level in which this block resides.
 *
 * @returns {number} - the level (Integer) of this section
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getLevel = function () {
  var level = this.level
  return level === Opal.nil ? undefined : level
}

/**
 * Get the substitution keywords to be applied to the contents of this block.
 *
 * @returns {Array<string>} - the list of {string} substitution keywords associated with this block.
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getSubstitutions = function () {
  return this.subs
}

/**
 * Check whether a given substitution keyword is present in the substitutions for this block.
 *
 * @returns {boolean} - whether the substitution is present on this block.
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.hasSubstitution = function (substitution) {
  return this['$sub?'](substitution)
}

/**
 * Remove the specified substitution keyword from the list of substitutions for this block.
 *
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.removeSubstitution = function (substitution) {
  this.$remove_sub(substitution)
}

/**
 * Checks if the {@link AbstractBlock} contains any child blocks.
 *
 * @returns {boolean} - whether the {@link AbstractBlock} has child blocks.
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.hasBlocks = function () {
  return this.blocks.length > 0
}

/**
 * Get the list of {@link AbstractBlock} sub-blocks for this block.
 *
 * @returns {Array<AbstractBlock>} - a list of {@link AbstractBlock} sub-blocks
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getBlocks = function () {
  return this.blocks
}

/**
 * Get the converted result of the child blocks by converting the children appropriate to content model that this block supports.
 *
 * @returns {string} - the converted result of the child blocks
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getContent = function () {
  return this.$content()
}

/**
 * Get the converted content for this block.
 * If the block has child blocks, the content method should cause them to be converted
 * and returned as content that can be included in the parent block's template.
 *
 * @returns {string} - the converted String content for this block
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.convert = function () {
  return this.$convert()
}

/**
 * Query for all descendant block-level nodes in the document tree
 * that match the specified selector (context, style, id, and/or role).
 * If a function block is given, it's used as an additional filter.
 * If no selector or function block is supplied, all block-level nodes in the tree are returned.
 * @param {Object} [selector]
 * @param {function} [block]
 * @example
 * doc.findBy({'context': 'section'});
 * // => { level: 0, title: "Hello, AsciiDoc!", blocks: 0 }
 * // => { level: 1, title: "First Section", blocks: 1 }
 *
 * doc.findBy({'context': 'section'}, function (section) { return section.getLevel() === 1; });
 * // => { level: 1, title: "First Section", blocks: 1 }
 *
 * doc.findBy({'context': 'listing', 'style': 'source'});
 * // => { context: :listing, content_model: :verbatim, style: "source", lines: 1 }
 *
 * @returns {Array<AbstractBlock>} - a list of block-level nodes that match the filter or an empty list if no matches are found
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.findBy = function (selector, block) {
  if (typeof block === 'undefined' && typeof selector === 'function') {
    return Opal.send(this, 'find_by', null, selector)
  } else if (typeof block === 'function') {
    return Opal.send(this, 'find_by', [toHash(selector)], block)
  } else {
    return this.$find_by(toHash(selector))
  }
}

/**
 * Get the source line number where this block started.
 * @returns {number} - the source line number where this block started
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getLineNumber = function () {
  var lineno = this.$lineno()
  return lineno === Opal.nil ? undefined : lineno
}

/**
 * Check whether this block has any child Section objects.
 * Only applies to Document and Section instances.
 * @returns {boolean} - true if this block has child Section objects, otherwise false
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.hasSections = function () {
  // REMIND: call directly the underlying method "$sections?"
  // once https://github.com/asciidoctor/asciidoctor/pull/3591 is merged and a new version is released.
  // return this['$sections?']()
  return this.next_section_index !== Opal.nil && this.next_section_index > 0
}

/**
 * Get the Array of child Section objects.
 * Only applies to Document and Section instances.
 * @memberof AbstractBlock
 * @returns {Array<Section>} - an {Array} of {@link Section} objects
 */
AbstractBlock.prototype.getSections = function () {
  return this.$sections()
}

/**
 * Get the numeral of this block (if section, relative to parent, otherwise absolute).
 * Only assigned to section if automatic section numbering is enabled.
 * Only assigned to formal block (block with title) if corresponding caption attribute is present.
 * If the section is an appendix, the numeral is a letter (starting with A).
 * @returns {string} - the numeral
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getNumeral = function () {
  return this.$numeral()
}

/**
 * Set the numeral of this block.
 * @param {string} value - The numeral value
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.setNumeral = function (value) {
  this['$numeral='](value)
}

/**
 * A convenience method that checks whether the title of this block is defined.
 *
 * @returns {boolean} - a {boolean} indicating whether this block has a title.
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.hasTitle = function () {
  return this['$title?']()
}

/**
 * Returns the converted alt text for this block image.
 * @returns {string} - the {string} value of the alt attribute with XML special character and replacement substitutions applied.
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getAlt = function () {
  return this.$alt()
}

// Section API

/**
 * @description
 * Methods for managing sections of AsciiDoc content in a document.
 *
 * @example
 * <pre>
 *   section = asciidoctor.Section.create()
 *   section.setTitle('Section 1')
 *   section.setId('sect1')
 *   section.getBlocks().length // 0
 *   section.getId() // "sect1"
 *   section.append(newBlock)
 *   section.getBlocks().length // 1
 * </pre>
 * @namespace
 * @extends AbstractBlock
 */
var Section = Opal.Asciidoctor.Section

/**
 * Create a {Section} object.
 * @param {AbstractBlock} [parent] - The parent AbstractBlock. If set, must be a Document or Section object (default: undefined)
 * @param {number} [level] - The Integer level of this section (default: 1 more than parent level or 1 if parent not defined)
 * @param {boolean} [numbered] - A Boolean indicating whether numbering is enabled for this Section (default: false)
 * @param {Object} [opts] - An optional JSON of options (default: {})
 * @returns {Section} - a new {Section} object
 * @memberof Section
 */
Section.create = function (parent, level, numbered, opts) {
  if (opts && opts.attributes) {
    opts.attributes = toHash(opts.attributes)
  }
  return this.$new(parent, level, numbered, toHash(opts))
}

/**
 * Set the level of this section or the section level in which this block resides.
 * @param {number} level - Level (Integer)
 * @memberof AbstractBlock
 */
Section.prototype.setLevel = function (level) {
  this.level = level
}

/**
 * Get the 0-based index order of this section within the parent block.
 * @returns {number}
 * @memberof Section
 */
Section.prototype.getIndex = function () {
  return this.index
}

/**
 * Set the 0-based index order of this section within the parent block.
 * @param {string} index - The index order of this section
 * @memberof Section
 */
Section.prototype.setIndex = function (index) {
  this.index = index
}

/**
 * Get the section name of this section.
 * @returns {string|undefined}
 * @memberof Section
 */
Section.prototype.getSectionName = function () {
  var sectname = this.sectname
  return sectname === Opal.nil ? undefined : sectname
}

/**
 * Set the section name of this section.
 * @param {string} value - The section name
 * @memberof Section
 */
Section.prototype.setSectionName = function (value) {
  this.sectname = value
}

/**
 * Get the flag to indicate whether this is a special section or a child of one.
 * @returns {boolean}
 * @memberof Section
 */
Section.prototype.isSpecial = function () {
  return this.special
}

/**
 * Set the flag to indicate whether this is a special section or a child of one.
 * @param {boolean} value - A flag to indicated if this is a special section
 * @memberof Section
 */
Section.prototype.setSpecial = function (value) {
  this.special = value
}

/**
 * Get the state of the numbered attribute at this section (need to preserve for creating TOC).
 * @returns {boolean}
 * @memberof Section
 */
Section.prototype.isNumbered = function () {
  return this.numbered
}

/**
 * Get the caption for this section (only relevant for appendices).
 * @returns {string}
 * @memberof Section
 */
Section.prototype.getCaption = function () {
  var value = this.caption
  return value === Opal.nil ? undefined : value
}

/**
 * Get the name of the Section (title)
 * @returns {string}
 * @see {@link AbstractBlock#getTitle}
 * @memberof Section
 */
Section.prototype.getName = function () {
  return this.getTitle()
}

/**
 * @description
 * Methods for managing AsciiDoc content blocks.
 *
 * @example
 * block = asciidoctor.Block.create(parent, 'paragraph', {source: '_This_ is a <test>'})
 * block.getContent()
 * // "<em>This</em> is a &lt;test&gt;"
 *
 * @namespace
 * @extends AbstractBlock
 */
var Block = Opal.Asciidoctor.Block

/**
 * Create a {Block} object.
 * @param {AbstractBlock} parent - The parent {AbstractBlock} with a compound content model to which this {Block} will be appended.
 * @param {string} context - The context name for the type of content (e.g., "paragraph").
 * @param {Object} [opts] - a JSON of options to customize block initialization: (default: {})
 * @param {string} opts.content_model - indicates whether blocks can be nested in this {Block} ("compound"),
 * otherwise how the lines should be processed ("simple", "verbatim", "raw", "empty"). (default: "simple")
 * @param {Object} opts.attributes - a JSON of attributes (key/value pairs) to assign to this {Block}. (default: {})
 * @param {string|Array<string>} opts.source - a String or {Array} of raw source for this {Block}. (default: undefined)
 *
 * IMPORTANT: If you don't specify the `subs` option, you must explicitly call the `commit_subs` method to resolve and assign the substitutions
 * to this block (which are resolved from the `subs` attribute, if specified, or the default substitutions based on this block's context).
 * If you want to use the default subs for a block, pass the option `subs: "default"`.
 * You can override the default subs using the `default_subs` option.
 *
 * @returns {Block} - a new {Block} object
 * @memberof Block
 */
Block.create = function (parent, context, opts) {
  if (opts && opts.attributes) {
    opts.attributes = toHash(opts.attributes)
  }
  return this.$new(parent, context, toHash(opts))
}

/**
 * Get the source of this block.
 * @returns {string} - the String source of this block.
 * @memberof Block
 */
Block.prototype.getSource = function () {
  return this.$source()
}

/**
 * Get the source lines of this block.
 * @returns {Array<string>} - the String {Array} of source lines for this block.
 * @memberof Block
 */
Block.prototype.getSourceLines = function () {
  return this.lines
}

// AbstractNode API

/**
 * @namespace
 * @description
 * An abstract base class that provides state and methods for managing a node of AsciiDoc content.
 * The state and methods on this class are common to all content segments in an AsciiDoc document.
 */
var AbstractNode = Opal.Asciidoctor.AbstractNode

/**
 * Apply the specified substitutions to the text.
 * If no substitutions are specified, the following substitutions are applied:
 * <code>specialcharacters</code>, <code>quotes</code>, <code>attributes</code>, <code>replacements</code>, <code>macros</code>, and <code>post_replacements</code>.
 *
 * @param {string|Array<string>} text - The String or String Array of text to process; must not be undefined.
 * @param {Array<string>} [subs] - The substitutions to perform; must be an Array or undefined.
 * @returns {string|Array<string>} - a String or String Array to match the type of the text argument with substitutions applied.
 * @memberof AbstractNode
 */
AbstractNode.prototype.applySubstitutions = function (text, subs) {
  return this.$apply_subs(text, subs)
}

/**
 * Resolve the list of comma-delimited subs against the possible options.
 *
 * @param {string} subs - The comma-delimited String of substitution names or aliases.
 * @param {string} [type] - A String representing the context for which the subs are being resolved (default: 'block').
 * @param {Array<string>} [defaults] - An Array of substitutions to start with when computing incremental substitutions (default: undefined).
 * @param {string} [subject] - The String to use in log messages to communicate the subject for which subs are being resolved (default: undefined)
 *
 * @returns {Array<string>} - An Array of Strings representing the substitution operation or nothing if no subs are found.
 * @memberof AbstractNode
 */
AbstractNode.prototype.resolveSubstitutions = function (subs, type, defaults, subject) {
  if (typeof type === 'undefined') {
    type = 'block'
  }
  if (typeof defaults === 'undefined') {
    defaults = Opal.nil
  }
  if (typeof subject === 'undefined') {
    subject = Opal.nil
  }
  const value = this.$resolve_subs(subs, type, defaults, subject)
  return value === Opal.nil ? undefined : value
}

/**
 * Call {@link AbstractNode#resolveSubstitutions} for the 'block' type.
 *
 * @see {@link AbstractNode#resolveSubstitutions}
 */
AbstractNode.prototype.resolveBlockSubstitutions = function (subs, defaults, subject) {
  return this.resolveSubstitutions(subs, 'block', defaults, subject)
}

/**
 * Call {@link AbstractNode#resolveSubstitutions} for the 'inline' type with the subject set as passthrough macro.
 *
 * @see {@link AbstractNode#resolveSubstitutions}
 */
AbstractNode.prototype.resolvePassSubstitutions = function (subs) {
  return this.resolveSubstitutions(subs, 'inline', undefined, 'passthrough macro')
}

/**
 * @returns {string} - the String name of this node
 * @memberof AbstractNode
 */
AbstractNode.prototype.getNodeName = function () {
  return this.node_name
}

/**
 * @returns {Object} - the JSON of attributes for this node
 * @memberof AbstractNode
 */
AbstractNode.prototype.getAttributes = function () {
  return fromHash(this.attributes)
}

/**
 * Get the value of the specified attribute.
 * If the attribute is not found on this node, fallback_name is set, and this node is not the Document node, get the value of the specified attribute from the Document node.
 *
 * Look for the specified attribute in the attributes on this node and return the value of the attribute, if found.
 * Otherwise, if fallback_name is set (default: same as name) and this node is not the Document node, look for that attribute on the Document node and return its value, if found.
 * Otherwise, return the default value (default: undefined).
 *
 * @param {string} name - The String of the attribute to resolve.
 * @param {*} [defaultValue] - The {Object} value to return if the attribute is not found (default: undefined).
 * @param {string} [fallbackName] - The String of the attribute to resolve on the Document if the attribute is not found on this node (default: same as name).
 *
 * @returns {*} - the {Object} value (typically a String) of the attribute or defaultValue if the attribute is not found.
 * @memberof AbstractNode
 */
AbstractNode.prototype.getAttribute = function (name, defaultValue, fallbackName) {
  var value = this.$attr(name, defaultValue, fallbackName)
  return value === Opal.nil ? undefined : value
}

/**
 * Check whether the specified attribute is present on this node.
 *
 * @param {string} name - The String of the attribute to resolve.
 * @returns {boolean} - true if the attribute is present, otherwise false
 * @memberof AbstractNode
 */
AbstractNode.prototype.hasAttribute = function (name) {
  return name in this.attributes.$$smap
}

/**
 * Check if the specified attribute is defined using the same logic as {AbstractNode#getAttribute}, optionally performing acomparison with the expected value if specified.
 *
 * Look for the specified attribute in the attributes on this node.
 * If not found, fallback_name is specified (default: same as name), and this node is not the Document node, look for that attribute on the Document node.
 * In either case, if the attribute is found, and the comparison value is truthy, return whether the two values match.
 * Otherwise, return whether the attribute was found.
 *
 * @param {string} name - The String name of the attribute to resolve.
 * @param {*} [expectedValue] - The expected Object value of the attribute (default: undefined).
 * @param {string} fallbackName - The String of the attribute to resolve on the Document if the attribute is not found on this node (default: same as name).
 *
 * @returns {boolean} - a Boolean indicating whether the attribute exists and, if a truthy comparison value is specified, whether the value of the attribute matches the comparison value.
 * @memberof AbstractNode
 */
AbstractNode.prototype.isAttribute = function (name, expectedValue, fallbackName) {
  var result = this['$attr?'](name, expectedValue, fallbackName)
  return result === Opal.nil ? false : result
}

/**
 * Assign the value to the attribute name for the current node.
 *
 * @param {string} name - The String attribute name to assign
 * @param {*} value - The Object value to assign to the attribute (default: '')
 * @param {boolean} overwrite - A Boolean indicating whether to assign the attribute if currently present in the attributes JSON (default: true)
 *
 * @returns {boolean} - a Boolean indicating whether the assignment was performed
 * @memberof AbstractNode
 */
AbstractNode.prototype.setAttribute = function (name, value, overwrite) {
  if (typeof overwrite === 'undefined') overwrite = true
  return this.$set_attr(name, value, overwrite)
}

/**
 * Remove the attribute from the current node.
 * @param {string} name - The String attribute name to remove
 * @returns {string} - the previous {string} value, or undefined if the attribute was not present.
 * @memberof AbstractNode
 */
AbstractNode.prototype.removeAttribute = function (name) {
  var value = this.$remove_attr(name)
  return value === Opal.nil ? undefined : value
}

/**
 * Get the {@link Document} to which this node belongs.
 *
 * @returns {Document} - the {@link Document} object to which this node belongs.
 * @memberof AbstractNode
 */
AbstractNode.prototype.getDocument = function () {
  return this.document
}

/**
 * Get the {@link AbstractNode} to which this node is attached.
 *
 * @memberof AbstractNode
 * @returns {AbstractNode} - the {@link AbstractNode} object to which this node is attached,
 * or undefined if this node has no parent.
 */
AbstractNode.prototype.getParent = function () {
  var parent = this.parent
  return parent === Opal.nil ? undefined : parent
}

/**
 * @returns {boolean} - true if this {AbstractNode} is an instance of {Inline}
 * @memberof AbstractNode
 */
AbstractNode.prototype.isInline = function () {
  return this['$inline?']()
}

/**
 * @returns {boolean} - true if this {AbstractNode} is an instance of {Block}
 * @memberof AbstractNode
 */
AbstractNode.prototype.isBlock = function () {
  return this['$block?']()
}

/**
 * Checks if the role attribute is set on this node and, if an expected value is given, whether the space-separated role matches that value.
 *
 * @param {string} expectedValue - The expected String value of the role (optional, default: undefined)
 *
 * @returns {boolean} - a Boolean indicating whether the role attribute is set on this node and, if an expected value is given, whether the space-separated role matches that value.
 * @memberof AbstractNode
 */
AbstractNode.prototype.isRole = function (expectedValue) {
  return this['$role?'](expectedValue)
}

/**
 * Retrieves the space-separated String role for this node.
 *
 * @returns {string} - the role as a space-separated String.
 * @memberof AbstractNode
 */
AbstractNode.prototype.getRole = function () {
  return this.$role()
}

/**
 * Checks if the specified role is present in the list of roles for this node.
 *
 * @param {string} name - The String name of the role to find.
 *
 * @returns {boolean} - a Boolean indicating whether this node has the specified role.
 * @memberof AbstractNode
 */
AbstractNode.prototype.hasRole = function (name) {
  return this['$has_role?'](name)
}

/**
 * Retrieves the String role names for this node as an Array.
 *
 * @returns {Array<string>} - the role names as a String {Array}, which is empty if the role attribute is absent on this node.
 * @memberof AbstractNode
 */
AbstractNode.prototype.getRoles = function () {
  return this.$roles()
}

/**
 * Adds the given role directly to this node.
 *
 * @param {string} name - The name of the role to add
 *
 * @returns {boolean} - a Boolean indicating whether the role was added.
 * @memberof AbstractNode
 */
AbstractNode.prototype.addRole = function (name) {
  return this.$add_role(name)
}

/**
 * Public: Removes the given role directly from this node.
 *
 * @param {string} name - The name of the role to remove
 *
 * @returns {boolean} - a Boolean indicating whether the role was removed.
 * @memberof AbstractNode
 */
AbstractNode.prototype.removeRole = function (name) {
  return this.$remove_role(name)
}

/**
 * A convenience method that checks if the reftext attribute is defined.
 * @returns {boolean} - A Boolean indicating whether the reftext attribute is defined
 * @memberof AbstractNode
 */
AbstractNode.prototype.isReftext = function () {
  return this['$reftext?']()
}

/**
 * A convenience method that returns the value of the reftext attribute with substitutions applied.
 * @returns {string|undefined} - the value of the reftext attribute with substitutions applied.
 * @memberof AbstractNode
 */
AbstractNode.prototype.getReftext = function () {
  var reftext = this.$reftext()
  return reftext === Opal.nil ? undefined : reftext
}

/**
 * @returns {string} - Get the context name for this node
 * @memberof AbstractNode
 */
AbstractNode.prototype.getContext = function () {
  var context = this.context
  // Automatically convert Opal pseudo-symbol to String
  return typeof context === 'string' ? context : context.toString()
}

/**
 * @returns {string} - the String id of this node
 * @memberof AbstractNode
 */
AbstractNode.prototype.getId = function () {
  var id = this.id
  return id === Opal.nil ? undefined : id
}

/**
 * @param {string} id - the String id of this node
 * @memberof AbstractNode
 */
AbstractNode.prototype.setId = function (id) {
  this.id = id
}

/**
 * A convenience method to check if the specified option attribute is enabled on the current node.
 * Check if the option is enabled. This method simply checks to see if the <name>-option attribute is defined on the current node.
 *
 * @param {string} name - the String name of the option
 *
 * @return {boolean} - a Boolean indicating whether the option has been specified
 * @memberof AbstractNode
 */
AbstractNode.prototype.isOption = function (name) {
  return this['$option?'](name)
}

/**
 * Set the specified option on this node.
 * This method sets the specified option on this node by setting the <name>-option attribute.
 *
 * @param {string} name - the String name of the option
 *
 * @memberof AbstractNode
 */
AbstractNode.prototype.setOption = function (name) {
  return this.$set_option(name)
}

/**
 * @memberof AbstractNode
 */
AbstractNode.prototype.getIconUri = function (name) {
  return this.$icon_uri(name)
}

/**
 * @memberof AbstractNode
 */
AbstractNode.prototype.getMediaUri = function (target, assetDirKey) {
  return this.$media_uri(target, assetDirKey)
}

/**
 * @memberof AbstractNode
 */
AbstractNode.prototype.getImageUri = function (targetImage, assetDirKey) {
  return this.$image_uri(targetImage, assetDirKey)
}

/**
 * Get the {Converter} instance being used to convert the current {Document}.
 * @returns {Object}
 * @memberof AbstractNode
 */
AbstractNode.prototype.getConverter = function () {
  return this.$converter()
}

/**
 * @memberof AbstractNode
 */
AbstractNode.prototype.readContents = function (target, options) {
  return this.$read_contents(target, toHash(options))
}

/**
 * Read the contents of the file at the specified path.
 * This method assumes that the path is safe to read.
 * It checks that the file is readable before attempting to read it.
 *
 * @param path - the {string} path from which to read the contents
 * @param {Object} options - a JSON {Object} of options to control processing (default: {})
 * @param {boolean} options.warn_on_failure - a {boolean} that controls whether a warning is issued if the file cannot be read (default: false)
 * @param {boolean} options.normalize - a {boolean} that controls whether the lines are normalized and coerced to UTF-8 (default: false)
 *
 * @returns {string} - the String content of the file at the specified path, or undefined if the file does not exist.
 * @memberof AbstractNode
 */
AbstractNode.prototype.readAsset = function (path, options) {
  var result = this.$read_asset(path, toHash(options))
  return result === Opal.nil ? undefined : result
}

/**
 * @memberof AbstractNode
 */
AbstractNode.prototype.normalizeWebPath = function (target, start, preserveTargetUri) {
  return this.$normalize_web_path(target, start, preserveTargetUri)
}

/**
 * @memberof AbstractNode
 */
AbstractNode.prototype.normalizeSystemPath = function (target, start, jail, options) {
  return this.$normalize_system_path(target, start, jail, toHash(options))
}

/**
 * @memberof AbstractNode
 */
AbstractNode.prototype.normalizeAssetPath = function (assetRef, assetName, autoCorrect) {
  return this.$normalize_asset_path(assetRef, assetName, autoCorrect)
}

// Document API

/**
 * The {@link Document} class represents a parsed AsciiDoc document.
 *
 * Document is the root node of a parsed AsciiDoc document.<br/>
 * It provides an abstract syntax tree (AST) that represents the structure of the AsciiDoc document
 * from which the Document object was parsed.
 *
 * Although the constructor can be used to create an empty document object,
 * more commonly, you'll load the document object from AsciiDoc source
 * using the primary API methods on {@link Asciidoctor}.
 * When using one of these APIs, you almost always want to set the safe mode to 'safe' (or 'unsafe')
 * to enable all of Asciidoctor's features.
 *
 * <pre>
 *   var doc = Asciidoctor.load('= Hello, AsciiDoc!', { 'safe': 'safe' })
 *   // => Asciidoctor::Document { doctype: "article", doctitle: "Hello, AsciiDoc!", blocks: 0 }
 * </pre>
 *
 * Instances of this class can be used to extract information from the document or alter its structure.
 * As such, the Document object is most often used in extensions and by integrations.
 *
 * The most basic usage of the Document object is to retrieve the document's title.
 *
 * <pre>
 *  var source = '= Document Title'
 *  var doc = asciidoctor.load(source, { 'safe': 'safe' })
 *  console.log(doc.getTitle()) // 'Document Title'
 * </pre>
 *
 * You can also use the Document object to access document attributes defined in the header, such as the author and doctype.
 * @namespace
 * @extends AbstractBlock
 */
var Document = Opal.Asciidoctor.Document

/**
 * Returns a JSON {Object} of references captured by the processor.
 *
 * @returns {Object} - a JSON {Object} of {AbstractNode} in the document.
 * @memberof Document
 */
Document.prototype.getRefs = function () {
  return fromHash(this.catalog.$$smap.refs)
}

/**
 * Returns an {Array} of {Document/ImageReference} captured by the processor.
 *
 * @returns {Array<ImageReference>} - an {Array} of {Document/ImageReference} in the document.
 * Will return an empty array if the option "catalog_assets: true" was not defined on the processor.
 * @memberof Document
 */
Document.prototype.getImages = function () {
  return this.catalog.$$smap.images
}

/**
 * Returns an {Array} of links captured by the processor.
 *
 * @returns {Array<string>} - an {Array} of links in the document.
 * Will return an empty array if:
 * - the function was called before the document was converted
 * - the option "catalog_assets: true" was not defined on the processor
 * @memberof Document
 */
Document.prototype.getLinks = function () {
  return this.catalog.$$smap.links
}

/**
 * @returns {boolean} - true if the document has footnotes otherwise false
 * @memberof Document
 */
Document.prototype.hasFootnotes = function () {
  return this['$footnotes?']()
}

/**
 * Returns an {Array} of {Document/Footnote} captured by the processor.
 *
 * @returns {Array<Footnote>} - an {Array} of {Document/Footnote} in the document.
 * Will return an empty array if the function was called before the document was converted.
 * @memberof Document
 */
Document.prototype.getFootnotes = function () {
  return this.$footnotes()
}

/**
 * Returns the level-0 {Section} (i.e. the document title).
 * Only stores the title, not the header attributes.
 *
 * @returns {string} - the level-0 {Section}.
 * @memberof Document
 */
Document.prototype.getHeader = function () {
  return this.header
}

/**
 * @memberof Document
 */
Document.prototype.setAttribute = function (name, value) {
  return this.$set_attribute(name, value)
}

/**

 * @memberof Document
 */
Document.prototype.removeAttribute = function (name) {
  this.attributes.$delete(name)
  this.attribute_overrides.$delete(name)
}

/**
 * Convert the AsciiDoc document using the templates loaded by the Converter.
 * If a "template_dir" is not specified, or a template is missing, the converter will fall back to using the appropriate built-in template.
 *
 * @param {Object} [options] - a JSON of options to control processing (default: {})
 *
 * @returns {string}
 * @memberof Document
 */
Document.prototype.convert = function (options) {
  var result = this.$convert(toHash(options))
  return result === Opal.nil ? '' : result
}

/**
 * Write the output to the specified file.
 *
 * If the converter responds to "write", delegate the work of writing the file to that method.
 * Otherwise, write the output the specified file.
 *
 * @param {string} output
 * @param {string} target
 *
 * @memberof Document
 */
Document.prototype.write = function (output, target) {
  return this.$write(output, target)
}

/**
 * @returns {string} - the full name of the author as a String
 * @memberof Document
 */
Document.prototype.getAuthor = function () {
  return this.$author()
}

/**
 * @returns {string}
 * @memberof Document
 */
Document.prototype.getSource = function () {
  return this.$source()
}

/**
 * @returns {Array<string>}
 * @memberof Document
 */
Document.prototype.getSourceLines = function () {
  return this.$source_lines()
}

/**
 * @returns {boolean}
 * @memberof Document
 */
Document.prototype.isNested = function () {
  return this['$nested?']()
}

/**
 * @returns {boolean}
 * @memberof Document
 */
Document.prototype.isEmbedded = function () {
  return this['$embedded?']()
}

/**
 * @returns {boolean}
 * @memberof Document
 */
Document.prototype.hasExtensions = function () {
  return this['$extensions?']()
}

/**
 * Get the value of the doctype attribute for this document.
 * @returns {string}
 * @memberof Document
 */
Document.prototype.getDoctype = function () {
  return this.doctype
}

/**
 * Get the value of the backend attribute for this document.
 * @returns {string}
 * @memberof Document
 */
Document.prototype.getBackend = function () {
  return this.backend
}

/**
 * @returns {boolean}
 * @memberof Document
 */
Document.prototype.isBasebackend = function (base) {
  return this['$basebackend?'](base)
}

/**
 * Get the title explicitly defined in the document attributes.
 * @returns {string}
 * @see {@link AbstractNode#getAttributes}
 * @memberof Document
 */
Document.prototype.getTitle = function () {
  var title = this.$title()
  return title === Opal.nil ? undefined : title
}

/**
 * Set the title on the document header
 *
 * Set the title of the document header to the specified value.
 * If the header does not exist, it is first created.
 *
 * @param {string} title - the String title to assign as the title of the document header
 *
 * @returns {string} - the new String title assigned to the document header
 * @memberof Document
 */
Document.prototype.setTitle = function (title) {
  return this['$title='](title)
}

/**
 * @returns {Document/Title} - a {@link Document/Title}
 * @memberof Document
 */
Document.prototype.getDocumentTitle = function (options) {
  var doctitle = this.$doctitle(toHash(options))
  return doctitle === Opal.nil ? undefined : doctitle
}

/**
 * @see {@link Document#getDocumentTitle}
 * @memberof Document
 */
Document.prototype.getDoctitle = Document.prototype.getDocumentTitle

/**
 * Get the document catalog JSON object.
 * @returns {Object}
 * @memberof Document
 */
Document.prototype.getCatalog = function () {
  return fromHash(this.catalog)
}

/**
 *
 * @returns {Object}
 * @see Document#getCatalog
 * @memberof Document
 */
Document.prototype.getReferences = Document.prototype.getCatalog

/**
 * Get the document revision date from document header (document attribute <code>revdate</code>).
 * @returns {string}
 * @memberof Document
 */
Document.prototype.getRevisionDate = function () {
  return this.getAttribute('revdate')
}

/**
 * @see Document#getRevisionDate
 * @returns {string}
 * @memberof Document
 */
Document.prototype.getRevdate = function () {
  return this.getRevisionDate()
}

/**
 * Get the document revision number from document header (document attribute <code>revnumber</code>).
 * @returns {string}
 * @memberof Document
 */
Document.prototype.getRevisionNumber = function () {
  return this.getAttribute('revnumber')
}

/**
 * Get the document revision remark from document header (document attribute <code>revremark</code>).
 * @returns {string}
 * @memberof Document
 */
Document.prototype.getRevisionRemark = function () {
  return this.getAttribute('revremark')
}

/**
 *  Assign a value to the specified attribute in the document header.
 *
 *  The assignment will be visible when the header attributes are restored,
 *  typically between processor phases (e.g., between parse and convert).
 *
 * @param {string} name - The {string} attribute name to assign
 * @param {Object} value - The {Object} value to assign to the attribute (default: '')
 * @param {boolean} overwrite - A {boolean} indicating whether to assign the attribute
 * if already present in the attributes Hash (default: true)
 *
 * @returns {boolean} - true if the assignment was performed otherwise false
 * @memberof Document
 */
Document.prototype.setHeaderAttribute = function (name, value, overwrite) {
  if (typeof overwrite === 'undefined') overwrite = true
  if (typeof value === 'undefined') value = ''
  return this.$set_header_attribute(name, value, overwrite)
}

/**
 * Convenience method to retrieve the authors of this document as an {Array} of {Document/Author} objects.
 *
 * This method is backed by the author-related attributes on the document.
 *
 * @returns {Array<Author>} - an {Array} of {Document/Author} objects.
 * @memberof Document
 */
Document.prototype.getAuthors = function () {
  return this.$authors()
}

// Document.Footnote API

/**
 * @namespace
 * @module Document/Footnote
 */
var Footnote = Document.Footnote

/**
 * @returns {number} - the footnote's index
 * @memberof Document/Footnote
 */
Footnote.prototype.getIndex = function () {
  var index = this.$$data.index
  return index === Opal.nil ? undefined : index
}

/**
 * @returns {number} - the footnote's id
 * @memberof Document/Footnote
 */
Footnote.prototype.getId = function () {
  var id = this.$$data.id
  return id === Opal.nil ? undefined : id
}

/**
 * @returns {string} - the footnote's text
 * @memberof Document/Footnote
 */
Footnote.prototype.getText = function () {
  var text = this.$$data.text
  return text === Opal.nil ? undefined : text
}

// Document.ImageReference API

/**
 * @class
 * @module Document/ImageReference
 */
var ImageReference = Document.ImageReference

/**
 * @returns {string} - the image's target
 * @memberof Document/ImageReference
 */
ImageReference.prototype.getTarget = function () {
  return this.$$data.target
}

/**
 * @returns {string} - the image's directory (imagesdir attribute)
 * @memberof Document/ImageReference
 */
ImageReference.prototype.getImagesDirectory = function () {
  var value = this.$$data.imagesdir
  return value === Opal.nil ? undefined : value
}

// Document.Author API

/**
 * The Author class represents information about an author extracted from document attributes.
 * @namespace
 * @module Document/Author
 */
var Author = Document.Author

/**
 * @returns {string} - the author's full name
 * @memberof Document/Author
 */
Author.prototype.getName = function () {
  var name = this.$$data.name
  return name === Opal.nil ? undefined : name
}

/**
 * @returns {string} - the author's first name
 * @memberof Document/Author
 */
Author.prototype.getFirstName = function () {
  var firstName = this.$$data.firstname
  return firstName === Opal.nil ? undefined : firstName
}

/**
 * @returns {string} - the author's middle name (or undefined if the author has no middle name)
 * @memberof Document/Author
 */
Author.prototype.getMiddleName = function () {
  var middleName = this.$$data.middlename
  return middleName === Opal.nil ? undefined : middleName
}

/**
 * @returns {string} - the author's last name
 * @memberof Document/Author
 */
Author.prototype.getLastName = function () {
  var lastName = this.$$data.lastname
  return lastName === Opal.nil ? undefined : lastName
}

/**
 * @returns {string} - the author's initials (by default based on the author's name)
 * @memberof Document/Author
 */
Author.prototype.getInitials = function () {
  var initials = this.$$data.initials
  return initials === Opal.nil ? undefined : initials
}

/**
 * @returns {string} - the author's email
 * @memberof Document/Author
 */
Author.prototype.getEmail = function () {
  var email = this.$$data.email
  return email === Opal.nil ? undefined : email
}

// private constructor
Document.RevisionInfo = function (date, number, remark) {
  this.date = date
  this.number = number
  this.remark = remark
}

/**
 * @class
 * @namespace
 * @module Document/RevisionInfo
 */
var RevisionInfo = Document.RevisionInfo

/**
 * Get the document revision date from document header (document attribute <code>revdate</code>).
 * @returns {string}
 * @memberof Document/RevisionInfo
 */
RevisionInfo.prototype.getDate = function () {
  return this.date
}

/**
 * Get the document revision number from document header (document attribute <code>revnumber</code>).
 * @returns {string}
 * @memberof Document/RevisionInfo
 */
RevisionInfo.prototype.getNumber = function () {
  return this.number
}

/**
 * Get the document revision remark from document header (document attribute <code>revremark</code>).
 * A short summary of changes in this document revision.
 * @returns {string}
 * @memberof Document/RevisionInfo
 */
RevisionInfo.prototype.getRemark = function () {
  return this.remark
}

/**
 * @returns {boolean} - true if the revision info is empty (ie. not defined), otherwise false
 * @memberof Document/RevisionInfo
 */
RevisionInfo.prototype.isEmpty = function () {
  return this.date === undefined && this.number === undefined && this.remark === undefined
}

// SafeMode API

/**
 * @namespace
 */
var SafeMode = Opal.Asciidoctor.SafeMode

/**
 * @param {string} name - the name of the security level
 * @returns {number} - the integer value of the corresponding security level
 */
SafeMode.getValueForName = function (name) {
  return this.$value_for_name(name)
}

/**
 * @param {number} value - the integer value of the security level
 * @returns {string} - the name of the corresponding security level
 */
SafeMode.getNameForValue = function (value) {
  var name = this.$name_for_value(value)
  return name === Opal.nil ? undefined : name
}

/**
 * @returns {Array<string>} - the String {Array} of security levels
 */
SafeMode.getNames = function () {
  return this.$names()
}

// Callouts API

/**
 * Maintains a catalog of callouts and their associations.
 * @namespace
 */
var Callouts = Opal.Asciidoctor.Callouts

/**
 * Create a new Callouts.
 * @returns {Callouts} - a new Callouts
 * @memberof Callouts
 */
Callouts.create = function () {
  return this.$new()
}

/**
 * Register a new callout for the given list item ordinal.
 * Generates a unique id for this callout based on the index of the next callout list in the document and the index of this callout since the end of the last callout list.
 *
 * @param {number} ordinal - the Integer ordinal (1-based) of the list item to which this callout is to be associated
 * @returns {string} - The unique String id of this callout
 * @example
 *  callouts = asciidoctor.Callouts.create()
 *  callouts.register(1)
 *  // => "CO1-1"
 *  callouts.nextList()
 *  callouts.register(2)
 *  // => "CO2-1"
 * @memberof Callouts
 */

Callouts.prototype.register = function (ordinal) {
  return this.$register(ordinal)
}
/**
 * Get the next callout index in the document.
 *
 * Reads the next callout index in the document and advances the pointer.
 * This method is used during conversion to retrieve the unique id of the callout that was generated during parsing.
 *
 * @returns {string} - The unique String id of the next callout in the document
 * @memberof Callouts
 */
Callouts.prototype.readNextId = function () {
  return this.$read_next_id()
}

/**
 * et a space-separated list of callout ids for the specified list item.
 * @param {number} ordinal - the Integer ordinal (1-based) of the list item for which to retrieve the callouts
 * @returns {string} - a space-separated String of callout ids associated with the specified list item
 * @memberof Callouts
 */
Callouts.prototype.getCalloutIds = function (ordinal) {
  return this.$callout_ids(ordinal)
}

/**
 * @memberof Callouts
 */
Callouts.prototype.getLists = function () {
  var lists = this.lists
  if (lists && lists.length > 0) {
    for (var i = 0; i < lists.length; i++) {
      var list = lists[i]
      if (list && list.length > 0) {
        for (var j = 0; j < list.length; j++) {
          if (typeof list[j] === 'object' && '$$smap' in list[j]) {
            list[j] = fromHash(list[j])
          }
        }
      }
    }
  }
  return lists
}

/**
 * @memberof Callouts
 */
Callouts.prototype.getListIndex = function () {
  return this.list_index
}

/**
 * The current list for which callouts are being collected.
 * @returns {Array} - The Array of callouts at the position of the list index pointer
 * @memberof Callouts
 */
Callouts.prototype.getCurrentList = function () {
  var currentList = this.$current_list()
  if (currentList && currentList.length > 0) {
    for (var i = 0; i < currentList.length; i++) {
      if (typeof currentList[i] === 'object' && '$$smap' in currentList[i]) {
        currentList[i] = fromHash(currentList[i])
      }
    }
  }
  return currentList
}

/**
 * Advance to the next callout list in the document.
 * @memberof Callouts
 */
Callouts.prototype.nextList = function () {
  return this.$nextList()
}

/**
 * Rewind the list index pointer, intended to be used when switching from the parsing to conversion phase.
 * @memberof Callouts
 */
Callouts.prototype.rewind = function () {
  return this.$rewind()
}

/**
 * @returns {Document/RevisionInfo} - a {@link Document/RevisionInfo}
 * @memberof Document
 */
Document.prototype.getRevisionInfo = function () {
  return new Document.RevisionInfo(this.getRevisionDate(), this.getRevisionNumber(), this.getRevisionRemark())
}

/**
 * @returns {boolean} - true if the document contains revision info, otherwise false
 * @memberof Document
 */
Document.prototype.hasRevisionInfo = function () {
  var revisionInfo = this.getRevisionInfo()
  return !revisionInfo.isEmpty()
}

/**
 * @returns {boolean}
 * @memberof Document
 */
Document.prototype.getNotitle = function () {
  return this.$notitle()
}

/**
 * @returns {boolean}
 * @memberof Document
 */
Document.prototype.getNoheader = function () {
  return this.$noheader()
}

/**
 * @returns {boolean}
 * @memberof Document
 */
Document.prototype.getNofooter = function () {
  return this.$nofooter()
}

/**
 * @returns {boolean}
 * @memberof Document
 */
Document.prototype.hasHeader = function () {
  return this['$header?']()
}

/**
 * Replay attribute assignments at the block level.
 *
 * <i>This method belongs to an internal API that deals with how attributes are managed by the processor.</i>
 * If you understand why this group of methods are necessary, and what they do, feel free to use them.
 * <strong>However, keep in mind they are subject to change at any time.</strong>
 *
 * @param {Object} blockAttributes - A JSON of attributes
 * @memberof Document
 */
Document.prototype.playbackAttributes = function (blockAttributes) {
  blockAttributes = toHash(blockAttributes)
  if (blockAttributes) {
    var attrEntries = blockAttributes['$[]']('attribute_entries')
    if (attrEntries && Array.isArray(attrEntries)) {
      var result = []
      for (var i = 0; i < attrEntries.length; i++) {
        var attrEntryObject = attrEntries[i]
        if (attrEntryObject && typeof attrEntryObject === 'object' && attrEntryObject.constructor.name === 'Object') {
          attrEntryObject.$name = function () {
            return this.name
          }
          attrEntryObject.$value = function () {
            return this.value
          }
          attrEntryObject.$negate = function () {
            return this.negate
          }
        }
        result.push(attrEntryObject)
      }
      blockAttributes['$[]=']('attribute_entries', result)
    }
  }
  this.$playback_attributes(blockAttributes)
}

/**
 * Delete the specified attribute from the document if the name is not locked.
 * If the attribute is locked, false is returned.
 * Otherwise, the attribute is deleted.
 *
 * @param {string} name - the String attribute name
 *
 * @returns {boolean} - true if the attribute was deleted, false if it was not because it's locked
 * @memberof Document
 */
Document.prototype.deleteAttribute = function (name) {
  return this.$delete_attribute(name)
}

/**
 * Determine if the attribute has been locked by being assigned in document options.
 *
 * @param {string} key - The attribute key to check
 *
 * @returns {boolean} - true if the attribute is locked, false otherwise
 * @memberof Document
 */
Document.prototype.isAttributeLocked = function (key) {
  return this['$attribute_locked?'](key)
}

/**
 * Restore the attributes to the previously saved state (attributes in header).
 *
 * @memberof Document
 */
Document.prototype.restoreAttributes = function () {
  return this.$restore_attributes()
}

/**
 * Parse the AsciiDoc source stored in the {Reader} into an abstract syntax tree.
 *
 * If the data parameter is not nil, create a new {PreprocessorReader} and assigned it to the reader property of this object.
 * Otherwise, continue with the reader that was created when the {Document} was instantiated.
 * Pass the reader to {Parser.parse} to parse the source data into an abstract syntax tree.
 *
 * If parsing has already been performed, this method returns without performing any processing.
 *
 * @param {string|Array<string>} [data] - The optional replacement AsciiDoc source data as a String or String Array. (default: undefined)
 *
 * @returns {Document} - this {Document}
 * @memberof Document
 */
Document.prototype.parse = function (data) {
  return this.$parse(data)
}

/**
 * @memberof Document
 */
Document.prototype.getDocinfo = function (docinfoLocation, suffix) {
  return this.$docinfo(docinfoLocation, suffix)
}

/**
 * @param {string} [docinfoLocation] - A {string} for checking docinfo extensions at a given location (head or footer) (default: head)
 * @returns {boolean}
 * @memberof Document
 */
Document.prototype.hasDocinfoProcessors = function (docinfoLocation) {
  return this['$docinfo_processors?'](docinfoLocation)
}

/**
 * Increment the specified counter and store it in the block's attributes.
 *
 * @param {string} counterName - the String name of the counter attribute
 * @param {Block} block - the {Block} on which to save the counter
 *
 * @returns {number} - the next number in the sequence for the specified counter
 * @memberof Document
 */
Document.prototype.incrementAndStoreCounter = function (counterName, block) {
  return this.$increment_and_store_counter(counterName, block)
}

/**
 * @deprecated Please use {Document#incrementAndStoreCounter} method.
 * @memberof Document
 */
Document.prototype.counterIncrement = Document.prototype.incrementAndStoreCounter

/**
 * Get the named counter and take the next number in the sequence.
 *
 * @param {string} name - the String name of the counter
 * @param {string|number} seed - the initial value as a String or Integer
 *
 * @returns {number} the next number in the sequence for the specified counter
 * @memberof Document
 */
Document.prototype.counter = function (name, seed) {
  return this.$counter(name, seed)
}

/**
 * A read-only integer value indicating the level of security that should be enforced while processing this document.
 * The value must be set in the Document constructor using the "safe" option.
 *
 * A value of 0 (UNSAFE) disables any of the security features enforced by Asciidoctor.
 *
 * A value of 1 (SAFE) closely parallels safe mode in AsciiDoc.
 * In particular, it prevents access to files which reside outside of the parent directory of the source file and disables any macro other than the include directive.
 *
 * A value of 10 (SERVER) disallows the document from setting attributes that would affect the conversion of the document,
 * in addition to all the security features of SafeMode.SAFE.
 * For instance, this level forbids changing the backend or source-highlighter using an attribute defined in the source document header.
 * This is the most fundamental level of security for server deployments (hence the name).
 *
 * A value of 20 (SECURE) disallows the document from attempting to read files from the file system and including the contents of them into the document,
 * in addition to all the security features of SafeMode.SECURE.
 * In particular, it disallows use of the include::[] directive and the embedding of binary content (data uri), stylesheets and JavaScripts referenced by the document.
 * (Asciidoctor and trusted extensions may still be allowed to embed trusted content into the document).
 *
 * Since Asciidoctor is aiming for wide adoption, 20 (SECURE) is the default value and is recommended for server deployments.
 *
 * A value of 100 (PARANOID) is planned to disallow the use of passthrough macros and prevents the document from setting any known attributes,
 * in addition to all the security features of SafeMode.SECURE.
 * Please note that this level is not currently implemented (and therefore not enforced)!
 *
 * @returns {number} - An integer value indicating the level of security
 * @memberof Document
 */
Document.prototype.getSafe = function () {
  return this.safe
}

/**
 * Get the Boolean AsciiDoc compatibility mode.
 * Enabling this attribute activates the following syntax changes:
 *
 *   * single quotes as constrained emphasis formatting marks
 *   * single backticks parsed as inline literal, formatted as monospace
 *   * single plus parsed as constrained, monospaced inline formatting
 *   * double plus parsed as constrained, monospaced inline formatting
 *
 * @returns {boolean}
 * @memberof Document
 */
Document.prototype.getCompatMode = function () {
  return this.compat_mode
}

/**
 * Get the Boolean flag that indicates whether source map information should be tracked by the parser.
 * @returns {boolean}
 * @memberof Document
 */
Document.prototype.getSourcemap = function () {
  var sourcemap = this.sourcemap
  return sourcemap === Opal.nil ? false : sourcemap
}

/**
 * Set the Boolean flag that indicates whether source map information should be tracked by the parser.
 * @param {boolean} value
 * @memberof Document
 */
Document.prototype.setSourcemap = function (value) {
  this.sourcemap = value
}

/**
 * Get the JSON of document counters.
 * @returns {Object}
 * @memberof Document
 */
Document.prototype.getCounters = function () {
  return fromHash(this.counters)
}

/**
 * @returns {Object}
 * @memberof Document
 */
Document.prototype.getCallouts = function () {
  return this.$callouts()
}

/**
 * Get the String base directory for converting this document.
 *
 * Defaults to directory of the source file.
 * If the source is a string, defaults to the current directory.
 * @returns {string}
 * @memberof Document
 */
Document.prototype.getBaseDir = function () {
  return this.base_dir
}

/**
 * Get the JSON of resolved options used to initialize this {Document}.
 * @returns {Object}
 * @memberof Document
 */
Document.prototype.getOptions = function () {
  return fromHash(this.options)
}

/**
 * Get the outfilesuffix defined at the end of the header.
 * @returns {string}
 * @memberof Document
 */
Document.prototype.getOutfilesuffix = function () {
  return this.outfilesuffix
}

/**
 * Get a reference to the parent Document of this nested document.
 * @returns {Document|undefined}
 * @memberof Document
 */
Document.prototype.getParentDocument = function () {
  var parentDocument = this.parent_document
  return parentDocument === Opal.nil ? undefined : parentDocument
}

/**
 * Get the {Reader} associated with this document.
 * @returns {Object}
 * @memberof Document
 */
Document.prototype.getReader = function () {
  return this.reader
}

/**
 * Get the {Converter} instance being used to convert the current {Document}.
 * @returns {Object}
 * @memberof Document
 */
Document.prototype.getConverter = function () {
  return this.converter
}

/**
 * Get the activated {Extensions.Registry} associated with this document.
 * @returns {Extensions/Registry}
 * @memberof Document
 */
Document.prototype.getExtensions = function () {
  var extensions = this.extensions
  return extensions === Opal.nil ? undefined : extensions
}

// Document.Title API

/**
 * A partitioned title (i.e., title & subtitle).
 * @namespace
 * @module Document/Title
 */
var Title = Document.Title

/**
 * @returns {string}
 * @memberof Document/Title
 */
Title.prototype.getMain = function () {
  return this.main
}

/**
 * @returns {string}
 * @memberof Document/Title
 */
Title.prototype.getCombined = function () {
  return this.combined
}

/**
 * @returns {string}
 * @memberof Document/Title
 */
Title.prototype.getSubtitle = function () {
  var subtitle = this.subtitle
  return subtitle === Opal.nil ? undefined : subtitle
}

/**
 * @returns {boolean}
 * @memberof Document/Title
 */
Title.prototype.isSanitized = function () {
  var sanitized = this['$sanitized?']()
  return sanitized === Opal.nil ? false : sanitized
}

/**
 * @returns {boolean}
 * @memberof Document/Title
 */
Title.prototype.hasSubtitle = function () {
  return this['$subtitle?']()
}

// Inline API

/**
 * Methods for managing inline elements in AsciiDoc block.
 * @namespace
 * @extends AbstractNode
 */
var Inline = Opal.Asciidoctor.Inline

/**
 * Create a new Inline element.
 * @param {AbstractBlock} parent
 * @param {string} context
 * @param {string|undefined} text
 * @param {Object|undefined} opts
 * @returns {Inline} - a new Inline element
 * @memberof Inline
 */
Inline.create = function (parent, context, text, opts) {
  return this.$new(parent, context, text, prepareOptions(opts))
}

/**
 * Get the converted content for this inline node.
 *
 * @returns {string} - the converted String content for this inline node
 * @memberof Inline
 */
Inline.prototype.convert = function () {
  return this.$convert()
}

/**
 * Get the converted String text of this Inline node, if applicable.
 *
 * @returns {string|undefined} - the converted String text for this Inline node, or undefined if not applicable for this node.
 * @memberof Inline
 */
Inline.prototype.getText = function () {
  var text = this.$text()
  return text === Opal.nil ? undefined : text
}

/**
 * Get the String sub-type (aka qualifier) of this Inline node.
 *
 * This value is used to distinguish different variations of the same node
 * category, such as different types of anchors.
 *
 * @returns {string} - the string sub-type of this Inline node.
 * @memberof Inline
 */
Inline.prototype.getType = function () {
  return this.$type()
}

/**
 * Get the primary String target of this Inline node.
 *
 * @returns {string|undefined} - the string target of this Inline node.
 * @memberof Inline
 */
Inline.prototype.getTarget = function () {
  var target = this.$target()
  return target === Opal.nil ? undefined : target
}

/**
 * Returns the converted alt text for this inline image.
 *
 * @returns {string} - the String value of the alt attribute.
 * @memberof Inline
 */
Inline.prototype.getAlt = function () {
  return this.$alt()
}

// List API

/**
 * Methods for managing AsciiDoc lists (ordered, unordered and description lists).
 * @namespace
 * @extends AbstractBlock
 */
var List = Opal.Asciidoctor.List

/**
 * Checks if the {@link List} contains any child {@link ListItem}.
 *
 * @memberof List
 * @returns {boolean} - whether the {@link List} has child {@link ListItem}.
 */
List.prototype.hasItems = function () {
  return this['$items?']()
}

/**
 * Get the Array of {@link ListItem} nodes for this {@link List}.
 *
 * @returns {Array<ListItem>} - an Array of {@link ListItem} nodes.
 * @memberof List
 */
List.prototype.getItems = function () {
  return this.blocks
}

// ListItem API

/**
 * Methods for managing items for AsciiDoc olists, ulist, and dlists.
 *
 * In a description list (dlist), each item is a tuple that consists of a 2-item Array of ListItem terms and a ListItem description (i.e., [[term, term, ...], desc].
 * If a description is not set, then the second entry in the tuple is nil.
 * @namespace
 * @extends AbstractBlock
 */
var ListItem = Opal.Asciidoctor.ListItem

/**
 * Get the converted String text of this {@link ListItem} node.
 *
 * @returns {string} - the converted String text for this {@link ListItem} node.
 * @memberof ListItem
 */
ListItem.prototype.getText = function () {
  return this.$text()
}

/**
 * Set the String source text of this {@link ListItem} node.
 *
 * @returns {string} - the new String text assigned to this {@link ListItem}
 * @memberof ListItem
 */
ListItem.prototype.setText = function (text) {
  return this['$text='](text)
}

/**
 * A convenience method that checks whether the text of this {@link ListItem} is not blank (i.e. not undefined or empty string).
 *
 * @returns {boolean} - whether the text is not blank
 * @memberof ListItem
 */
ListItem.prototype.hasText = function () {
  return this['$text?']()
}

/**
 * Get the {string} used to mark this {@link ListItem}.
 *
 * @returns {string}
 * @memberof ListItem
 */
ListItem.prototype.getMarker = function () {
  return this.marker
}

/**
 * Set the {string} used to mark this {@link ListItem}.
 *
 * @param {string} marker - the {string} used to mark this {@link ListItem}
 * @memberof ListItem
 */
ListItem.prototype.setMarker = function (marker) {
  this.marker = marker
}

/**
 * Get the {@link List} to which this {@link ListItem} is attached.
 *
 * @returns {List} - the {@link List} object to which this {@link ListItem} is attached,
 * or undefined if this node has no parent.
 * @memberof ListItem
 */
ListItem.prototype.getList = function () {
  return this.$list()
}

/**
 * @see {@link ListItem#getList}
 * @memberof ListItem
 */
ListItem.prototype.getParent = ListItem.prototype.getList

// Reader API

/** @namespace */
var Reader = Opal.Asciidoctor.Reader

/**
 * Push source onto the front of the reader and switch the context based on the file, document-relative path and line information given.
 *
 * This method is typically used in an IncludeProcessor to add source read from the target specified.
 *
 * @param {string} data
 * @param {string|undefined} file
 * @param {string|undefined} path
 * @param {number} lineno - The line number
 * @param {Object} attributes - a JSON of attributes
 * @returns {Reader} - this {Reader} object.
 * @memberof Reader
 */
Reader.prototype.pushInclude = function (data, file, path, lineno, attributes) {
  return this.$push_include(data, file, path, lineno, toHash(attributes))
}

/**
 * Get the current location of the reader's cursor, which encapsulates the file, dir, path, and lineno of the file being read.
 *
 * @returns {Cursor}
 * @memberof Reader
 */
Reader.prototype.getCursor = function () {
  return this.$cursor()
}

/**
 * Get the remaining unprocessed lines, without consuming them, as an {Array} of {string}.
 *
 * Lines will not be consumed from the Reader (ie. you will be able to read these lines again).
 *
 * @returns {Array<string>} - the remaining unprocessed lines as an {Array} of {string}.
 * @memberof Reader
 */
Reader.prototype.getLines = function () {
  return this.$lines()
}

/**
 * Get the remaining unprocessed lines, without consuming them, as a {string}.
 *
 * Lines will not be consumed from the Reader (ie. you will be able to read these lines again).
 *
 * @returns {string} - the remaining unprocessed lines as a {string} (joined by linefeed characters).
 * @memberof Reader
 */
Reader.prototype.getString = function () {
  return this.$string()
}

/**
 * Check whether there are any lines left to read.
 * If a previous call to this method resulted in a value of false, immediately returned the cached value.
 * Otherwise, delegate to peekLine to determine if there is a next line available.
 *
 * @returns {boolean} - true if there are more lines, false if there are not.
 * @memberof Reader
 */
Reader.prototype.hasMoreLines = function () {
  return this['$has_more_lines?']()
}

/**
 * Check whether this reader is empty (contains no lines).
 *
 * @returns {boolean} - true if there are no more lines to peek, otherwise false.
 * @memberof Reader
 */
Reader.prototype.isEmpty = function () {
  return this['$empty?']()
}

/**
 * Peek at the next line.
 * Processes the line if not already marked as processed, but does not consume it (ie. you will be able to read this line again).
 *
 * This method will probe the reader for more lines.
 * If there is a next line that has not previously been visited, the line is passed to the Reader#processLine method to be initialized.
 * This call gives sub-classes the opportunity to do preprocessing.
 * If the return value of the Reader#processLine is undefined, the data is assumed to be changed and Reader#peekLine is invoked again to perform further processing.
 *
 * If hasMoreLines is called immediately before peekLine, the direct flag is implicitly true (since the line is flagged as visited).
 *
 * @param {boolean} direct - A {boolean} flag to bypasses the check for more lines and immediately returns the first element of the internal lines {Array}. (default: false)
 * @returns {string} - the next line as a {string} if there are lines remaining.
 * @memberof Reader
 */
Reader.prototype.peekLine = function (direct) {
  direct = direct || false
  var line = this.$peek_line(direct)
  return line === Opal.nil ? undefined : line
}

/**
 * Consume, preprocess, and return the next line.
 *
 * Line will be consumed from the Reader (ie. you won't be able to read this line again).
 *
 * @returns {string} - the next line as a {string} if data is present.
 * @memberof Reader
 */
Reader.prototype.readLine = function () {
  var line = this.$read_line()
  return line === Opal.nil ? undefined : line
}

/**
 * Consume, preprocess, and return the remaining lines.
 *
 * This method calls Reader#readLine repeatedly until all lines are consumed and returns the lines as an {Array} of {string}.
 * This method differs from Reader#getLines in that it processes each line in turn, hence triggering any preprocessors implemented in sub-classes.
 *
 * Lines will be consumed from the Reader (ie. you won't be able to read these lines again).
 *
 * @returns {Array<string>} - the lines read as an {Array} of {string}.
 * @memberof Reader
 */
Reader.prototype.readLines = function () {
  return this.$read_lines()
}

/**
 * Consume, preprocess, and return the remaining lines joined as a {string}.
 *
 * Delegates to Reader#readLines, then joins the result.
 *
 * Lines will be consumed from the Reader (ie. you won't be able to read these lines again).
 *
 * @returns {string} - the lines read joined as a {string}
 * @memberof Reader
 */
Reader.prototype.read = function () {
  return this.$read()
}

/**
 * Advance to the next line by discarding the line at the front of the stack.
 *
 * @returns {boolean} - a Boolean indicating whether there was a line to discard.
 * @memberof Reader
 */
Reader.prototype.advance = function () {
  return this.$advance()
}

// Cursor API

/** @namespace */
var Cursor = Opal.Asciidoctor.Reader.Cursor

/**
 * Get the file associated to the cursor.
 * @returns {string|undefined}
 * @memberof Cursor
 */
Cursor.prototype.getFile = function () {
  var file = this.file
  return file === Opal.nil ? undefined : file
}

/**
 * Get the directory associated to the cursor.
 * @returns {string|undefined} - the directory associated to the cursor
 * @memberof Cursor
 */
Cursor.prototype.getDirectory = function () {
  var dir = this.dir
  return dir === Opal.nil ? undefined : dir
}

/**
 * Get the path associated to the cursor.
 * @returns {string|undefined} - the path associated to the cursor (or '<stdin>')
 * @memberof Cursor
 */
Cursor.prototype.getPath = function () {
  var path = this.path
  return path === Opal.nil ? undefined : path
}

/**
 * Get the line number of the cursor.
 * @returns {number|undefined} - the line number of the cursor
 * @memberof Cursor
 */
Cursor.prototype.getLineNumber = function () {
  return this.lineno
}

// Logger API (available in Asciidoctor 1.5.7+)

function initializeLoggerFormatterClass (className, functions) {
  var superclass = Opal.const_get_qualified(Opal.Logger, 'Formatter')
  return initializeClass(superclass, className, functions, {}, {
    call: function (args) {
      for (var i = 0; i < args.length; i++) {
        // convert all (Opal) Hash arguments to JSON.
        if (typeof args[i] === 'object' && '$$smap' in args[i]) {
          args[i] = fromHash(args[i])
        }
      }
      return args
    }
  })
}

function initializeLoggerClass (className, functions) {
  var superClass = Opal.const_get_qualified(Opal.Asciidoctor, 'Logger')
  return initializeClass(superClass, className, functions, {}, {
    add: function (args) {
      if (args.length >= 2 && typeof args[2] === 'object' && '$$smap' in args[2]) {
        var message = args[2]
        var messageObject = fromHash(message)
        messageObject.getText = function () {
          return this.text
        }
        messageObject.getSourceLocation = function () {
          return this.source_location
        }
        messageObject.$inspect = function () {
          var sourceLocation = this.getSourceLocation()
          if (sourceLocation) {
            return sourceLocation.getPath() + ': line ' + sourceLocation.getLineNumber() + ': ' + this.getText()
          } else {
            return this.getText()
          }
        }
        args[2] = messageObject
      }
      if (args.length >= 1) {
        args[1] = args[1] === Opal.nil ? undefined : args[1]
      }
      return args
    }
  })
}

/**
 * @namespace
 */
var LoggerManager = Opal.const_get_qualified(Opal.Asciidoctor, 'LoggerManager', true)

// Alias
Opal.Asciidoctor.LoggerManager = LoggerManager

/**
 * @memberof LoggerManager
 */
LoggerManager.getLogger = function () {
  return this.$logger()
}

/**
 * @memberof LoggerManager
 */
LoggerManager.setLogger = function (logger) {
  this['$logger='](logger)
}

/**
 * @memberof LoggerManager
 */
LoggerManager.newLogger = function (name, functions) {
  return initializeLoggerClass(name, functions).$new()
}

/**
 * @memberof LoggerManager
 */
LoggerManager.newFormatter = function (name, functions) {
  return initializeLoggerFormatterClass(name, functions).$new()
}

/**
 * @namespace
 */
var LoggerSeverity = Opal.const_get_qualified(Opal.Logger, 'Severity', true)

// Alias
Opal.Asciidoctor.LoggerSeverity = LoggerSeverity

/**
 * @memberof LoggerSeverity
 */
LoggerSeverity.get = function (severity) {
  return LoggerSeverity.$constants()[severity]
}

/**
 * @namespace
 */
var LoggerFormatter = Opal.const_get_qualified(Opal.Logger, 'Formatter', true)

// Alias
Opal.Asciidoctor.LoggerFormatter = LoggerFormatter

/**
 * @memberof LoggerFormatter
 */
LoggerFormatter.prototype.call = function (severity, time, programName, message) {
  return this.$call(LoggerSeverity.get(severity), time, programName, message)
}

/**
 * @namespace
 */
var MemoryLogger = Opal.const_get_qualified(Opal.Asciidoctor, 'MemoryLogger', true)

// Alias
Opal.Asciidoctor.MemoryLogger = MemoryLogger

/**
 * Create a new MemoryLogger.
 * @returns {MemoryLogger} - a MemoryLogger
 * @memberof MemoryLogger
 */
MemoryLogger.create = function () {
  return this.$new()
}

/**
 * @returns {Array<Object>} - a list of messages
 * @memberof MemoryLogger
 */
MemoryLogger.prototype.getMessages = function () {
  var messages = this.messages
  var result = []
  for (var i = 0; i < messages.length; i++) {
    var message = messages[i]
    var messageObject = fromHash(message)
    if (typeof messageObject.message === 'string') {
      messageObject.getText = function () {
        return this.message
      }
    } else {
      // also convert the message attribute
      messageObject.message = fromHash(messageObject.message)
      messageObject.getText = function () {
        return this.message.text
      }
    }
    messageObject.getSeverity = function () {
      return this.severity.toString()
    }
    messageObject.getSourceLocation = function () {
      return this.message.source_location
    }
    result.push(messageObject)
  }
  return result
}

var Logging = Opal.const_get_qualified(Opal.Asciidoctor, 'Logging', true)

Opal.Asciidoctor.Logging = Logging

Logging.getLogger = function () {
  return LoggerManager.$logger()
}

Logging.createLogMessage = function (text, context) {
  return Logging.prototype.$message_with_context(text, toHash(context))
}

// alias

/**
 * @memberof Reader
 */
Reader.prototype.getLogger = Logging.getLogger
/**
 * @memberof Reader
 */
Reader.prototype.createLogMessage = Logging.createLogMessage

/**
 * @memberof AbstractNode
 */
AbstractNode.prototype.getLogger = Logging.getLogger
/**
 * @memberof AbstractNode
 */
AbstractNode.prototype.createLogMessage = Logging.createLogMessage

/**
 * @namespace
 */
var Logger = Opal.const_get_qualified(Opal.Asciidoctor, 'Logger', true)

// Alias
Opal.Asciidoctor.Logger = Logger

/**
 * @returns {number|undefined} - the maximum severity
 * @memberof Logger
 */
Logger.prototype.getMaxSeverity = function () {
  var result = this.max_severity
  return result === Opal.nil ? undefined : result
}
/**
 * @returns {LoggerFormatter} - the formatter
 * @memberof Logger
 */
Logger.prototype.getFormatter = function () {
  return this.formatter
}
/**
 * @param {LoggerFormatter} formatter - the formatter
 * @memberof Logger
 */
Logger.prototype.setFormatter = function (formatter) {
  this.formatter = formatter
}
/**
 * @returns {number} - the logging severity threshold
 * @memberof Logger
 */
Logger.prototype.getLevel = function () {
  return this.level
}
/**
 * @param {number} level - the logging severity threshold
 * @memberof Logger
 */
Logger.prototype.setLevel = function (level) {
  this.level = level
}
/**
 * @returns {string} - the program name
 * @memberof Logger
 */
Logger.prototype.getProgramName = function () {
  return this.progname
}
/**
 * @param {string} programName - the program name
 * @memberof Logger
 */
Logger.prototype.setProgramName = function (programName) {
  this.progname = programName
}

var RubyLogger = Opal.const_get_qualified('::', 'Logger')

var log = function (logger, level, message) {
  logger['$' + level](message)
}
RubyLogger.prototype.add = function (severity, message, programName) {
  var severityValue = typeof severity === 'string' ? LoggerSeverity[severity.toUpperCase()] : severity
  this.$add(severityValue, message, programName)
}
RubyLogger.prototype.log = RubyLogger.prototype.add
RubyLogger.prototype.debug = function (message) {
  log(this, 'debug', message)
}
RubyLogger.prototype.info = function (message) {
  log(this, 'info', message)
}
RubyLogger.prototype.warn = function (message) {
  log(this, 'warn', message)
}
RubyLogger.prototype.error = function (message) {
  log(this, 'error', message)
}
RubyLogger.prototype.fatal = function (message) {
  log(this, 'fatal', message)
}
RubyLogger.prototype.isDebugEnabled = function () {
  return this['$debug?']()
}
RubyLogger.prototype.isInfoEnabled = function () {
  return this['$info?']()
}
RubyLogger.prototype.isWarnEnabled = function () {
  return this['$warn?']()
}
RubyLogger.prototype.isErrorEnabled = function () {
  return this['$error?']()
}
RubyLogger.prototype.isFatalEnabled = function () {
  return this['$fatal?']()
}

/**
 * @namespace
 */
var NullLogger = Opal.const_get_qualified(Opal.Asciidoctor, 'NullLogger', true)

// Alias
Opal.Asciidoctor.NullLogger = NullLogger

/**
 * Create a new NullLogger.
 * @returns {NullLogger} - a NullLogger
 * @memberof NullLogger
 */
NullLogger.create = function () {
  return this.$new()
}

/**
 * @returns {number|undefined} - the maximum severity
 * @memberof NullLogger
 */
NullLogger.prototype.getMaxSeverity = function () {
  return this.max_severity
}

// Alias
Opal.Asciidoctor.StopIteration = Opal.StopIteration

/**
 * @namespace
 */
var Timings = Opal.const_get_qualified(Opal.Asciidoctor, 'Timings', true)

// Alias
Opal.Asciidoctor.Timings = Timings

/**
 * Create a new Timings.
 * @returns {Timings} - a Timings
 * @memberof Timings
 */
Timings.create = function () {
  return this.$new()
}

/**
 * Print a report to the specified output.
 * The report will include:
 * - the time to read and parse source
 * - the time to convert document
 * - the total time (read, parse and convert)
 * @param {RubyLogger|console|Object} [to] - an optional output (by default stdout)
 * @param {string} [subject] - an optional subject (usually the file name)
 * @memberof Timings
 */
Timings.prototype.printReport = function (to, subject) {
  var outputFunction
  if (to) {
    if (typeof to.$add === 'function') {
      outputFunction = function (message) {
        to.$add(1, message)
      }
    } else if (typeof to.log === 'function') {
      outputFunction = to.log
    } else if (typeof to.write === 'function') {
      outputFunction = function (message) {
        to.write(message, 'utf-8')
      }
    } else {
      throw new Error('The output should be a Stream (with a write function), an object with a log function or a Ruby Logger (with a add function)')
    }
  } else {
    outputFunction = function (message) {
      Opal.gvars.stdout.$write(message)
    }
  }
  if (subject) {
    outputFunction('Input file: ' + subject)
  }
  outputFunction(' Time to read and parse source: ' + this.$read_parse().toFixed(2))
  outputFunction(' Time to convert document: ' + this.$convert().toFixed(2))
  outputFunction(' Total time (read, parse and convert): ' + this.$read_parse_convert().toFixed(2))
}

/**
 * @namespace
 * @description
 * This API is experimental and subject to change.
 *
 * A pluggable adapter for integrating a syntax (aka code) highlighter into AsciiDoc processing.
 *
 * There are two types of syntax highlighter adapters. The first performs syntax highlighting during the convert phase.
 * This adapter type must define a "handlesHighlighting" method that returns true.
 * The companion "highlight" method will then be called to handle the "specialcharacters" substitution for source blocks.
 *
 * The second assumes syntax highlighting is performed on the client (e.g., when the HTML document is loaded).
 * This adapter type must define a "hasDocinfo" method that returns true.
 * The companion "docinfo" method will then be called to insert markup into the output document.
 * The docinfo functionality is available to both adapter types.
 *
 * Asciidoctor.js provides several a built-in adapter for highlight.js.
 * Additional adapters can be registered using SyntaxHighlighter.register.
 */
var SyntaxHighlighter = Opal.const_get_qualified(Opal.Asciidoctor, 'SyntaxHighlighter', true)

// Alias
Opal.Asciidoctor.SyntaxHighlighter = SyntaxHighlighter

/**
 * Associates the syntax highlighter class or object with the specified names.
 *
 * @description This API is experimental and subject to change.
 *
 * @param {string|Array} names - A {string} name or an {Array} of {string} names
 * @param functions - A list of functions representing a {SyntaxHighlighter} or a {SyntaxHighlighter} class to instantiate
 * @memberof SyntaxHighlighter
 */
SyntaxHighlighter.register = function (names, functions) {
  var name = typeof names === 'string' ? names : names[0]
  if (typeof functions === 'function') {
    var classObject = functions
    var prototype = classObject.prototype
    var properties = Object.getOwnPropertyNames(prototype)
    functions = {}
    for (var propertyIdx in properties) {
      var propertyName = properties[propertyIdx]
      functions[propertyName] = prototype[propertyName]
    }
  }
  var scope = initializeClass(SyntaxHighlighterBase, name, functions, {}, {
    format: function (args) {
      if (args.length >= 2 && typeof args[2] === 'object' && '$$smap' in args[2]) {
        args[2] = fromHash(args[2])
      }
      if (args.length >= 1) {
        args[1] = args[1] === Opal.nil ? undefined : args[1]
      }
      return args
    },
    highlight: function (args) {
      if (args.length >= 3 && typeof args[3] === 'object' && '$$smap' in args[3]) {
        var opts = args[3]
        opts = fromHash(opts)
        for (var key in opts) {
          var value = opts[key]
          if (key === 'callouts') {
            var callouts = fromHashKeys(value)
            for (var idx in callouts) {
              var callout = callouts[idx]
              for (var i = 0; i < callout.length; i++) {
                var items = callout[i]
                for (var j = 0; j < items.length; j++) {
                  items[j] = items[j] === Opal.nil ? undefined : items[j]
                }
              }
            }
            opts[key] = callouts
          } else {
            opts[key] = value === Opal.nil ? undefined : value
          }
        }
        args[3] = opts
      }
      if (args.length >= 2) {
        args[2] = args[2] === Opal.nil ? undefined : args[2]
      }
      return args
    }
  })
  for (var functionName in functions) {
    if (Object.prototype.hasOwnProperty.call(functions, functionName)) {
      (function (functionName) {
        var userFunction = functions[functionName]
        if (functionName === 'handlesHighlighting') {
          Opal.def(scope, '$highlight?', function () {
            return userFunction.call()
          })
        } else if (functionName === 'hasDocinfo') {
          Opal.def(scope, '$docinfo?', function (location) {
            return userFunction.apply(this, [location])
          })
        }
      }(functionName))
    }
  }
  Opal.def(scope, '$name', function () {
    return name
  })
  SyntaxHighlighter.$register(scope, names)
  return scope
}

/**
 * Retrieves the syntax highlighter class or object registered for the specified name.
 *
 * @description This API is experimental and subject to change.
 *
 * @param {string} name - The {string} name of the syntax highlighter to retrieve.
 * @returns {SyntaxHighlighter} - the {SyntaxHighlighter} registered for this name.
 * @memberof SyntaxHighlighter
 */
SyntaxHighlighter.get = function (name) {
  var result = SyntaxHighlighter.$for(name)
  return result === Opal.nil ? undefined : result
}

/**
 * @deprecated Please use {SyntaxHighlighter#get} method as "for" is a reserved keyword.
 */
SyntaxHighlighter.for = SyntaxHighlighter.get

/**
 * @namespace
 */
var SyntaxHighlighterBase = Opal.const_get_qualified(SyntaxHighlighter, 'Base', true)

// Alias
Opal.Asciidoctor.SyntaxHighlighterBase = SyntaxHighlighterBase

/**
 * Statically register the current class in the registry for the specified names.
 *
 * @description This API is experimental and subject to change.
 *
 * @param {string|Array<string>} names - A {string} name or an {Array} of {string} names
 * @memberof SyntaxHighlighterBase
 */
SyntaxHighlighterBase.prototype.registerFor = function (names) {
  SyntaxHighlighter.$register(this, names)
}

// Table API

/**
 * Methods for managing AsciiDoc tables.
 * @namespace
 * @extends AbstractBlock
 */
var Table = Opal.Asciidoctor.Table

/**
 * Create a new Table element.
 * @param {AbstractBlock} parent
 * @param {Object|undefined} attributes
 * @returns {Table} - a new {Table} object
 */
Table.create = function (parent, attributes) {
  return this.$new(parent, toHash(attributes))
}

/**
 * Get the caption of the table.
 * @returns {string}
 * @memberof Table
 */
Table.prototype.getCaption = function () {
  return this.caption
}

/**
 * Get the rows of this table.
 * @returns {Table.Rows} - an {Table.Rows} object with the members "head", "body" and "foot"
 * @memberof Table
 */
Table.prototype.getRows = function () {
  return this.rows
}

/**
 * Get the columns of this table.
 * @returns {Array<Column>}
 * @memberof Table
 */
Table.prototype.getColumns = function () {
  return this.columns
}

/**
 * Get the head rows of this table.
 * @returns {Array<Array<Cell>>} - an Array of Array of Cell
 * @memberof Table
 */
Table.prototype.getHeadRows = function () {
  return this.rows.head
}

/**
 * Check if the table has a head rows.
 * @returns {boolean}
 * @memberof Table
 */
Table.prototype.hasHeadRows = function () {
  return this.rows !== Opal.nil && this.rows.head.length > 0
}

/**
 * Get the body rows of this table.
 * @returns {Array<Array<Cell>>} - an Array of Array of Cell
 * @memberof Table
 */
Table.prototype.getBodyRows = function () {
  return this.rows.body
}

/**
 * Check if the table has a body rows.
 * @returns {boolean}
 */
Table.prototype.hasBodyRows = function () {
  return this.rows !== Opal.nil && this.rows.body.length > 0
}

/**
 * Get the foot rows of this table.
 * @returns {Array<Array<Cell>>} - an Array of Array of Cell
 * @memberof Table
 */
Table.prototype.getFootRows = function () {
  return this.rows.foot
}

/**
 * Check if the table has a foot rows.
 * @returns {boolean}
 */
Table.prototype.hasFootRows = function () {
  return this.rows !== Opal.nil && this.rows.foot.length > 0
}

/**
 * Check if the table has a header option set.
 * @returns {boolean}
 * @memberof Table
 */
Table.prototype.hasHeaderOption = function () {
  return this.has_header_option
}

/**
 * Check if the table has the footer option set.
 * @returns {boolean}
 * @memberof Table
 */
Table.prototype.hasFooterOption = function () {
  var footerOption = this.getAttributes()['footer-option']
  return footerOption === ''
}

/**
 * Check if the table has the autowidth option set.
 * @returns {boolean}
 * @memberof Table
 */
Table.prototype.hasAutowidthOption = function () {
  var autowidthOption = this.getAttributes()['autowidth-option']
  return autowidthOption === ''
}

/**
 * Get the number of rows in the table.
 * Please note that the header and footer rows are also counted.
 * @returns {number|undefined}
 * @memberof Table
 */
Table.prototype.getRowCount = function () {
  return this.getAttribute('rowcount')
}

/**
 * Set the number of rows in the table.
 * Please note that the header and footer rows are also counted.
 * @param {number} value - the value
 * @memberof Table
 */
Table.prototype.setRowCount = function (value) {
  this.setAttribute('rowcount', value)
}

/**
 * Get the number of columns in the table.
 * @returns {number|undefined}
 * @memberof Table
 */
Table.prototype.getColumnCount = function () {
  return this.getAttribute('colcount')
}

/**
 * Set the number of columns in the table.
 * @param {number} value - the value
 * @memberof Table
 */
Table.prototype.setColumnCount = function (value) {
  this.setAttribute('colcount', value)
}

// Rows

/**
 * @namespace
 */
var Rows = Opal.Asciidoctor.Table.Rows

/**
 * Create a new Rows element.
 * @param {array<array<Cell>>} head
 * @param {array<array<Cell>>} foot
 * @param {array<array<Cell>>} body
 * @returns Rows
 */
Rows.create = function (head, foot, body) {
  return this.$new(head, foot, body)
}

/**
 * Get head rows.
 * @returns {array<array<Cell>>}
 */
Rows.prototype.getHead = function () {
  return this.head
}

/**
 * Get foot rows.
 * @returns {array<array<Cell>>}
 */
Rows.prototype.getFoot = function () {
  return this.foot
}

/**
 * Get body rows.
 * @returns {array<array<Cell>>}
 */
Rows.prototype.getBody = function () {
  return this.body
}

/**
 * Retrieve the rows grouped by section as a nested Array.
 *
 * Creates a 2-dimensional array of two element entries.
 * The first element is the section name as a string.
 * The second element is the Array of rows in that section.
 * The entries are in document order (head, foot, body).
 * @returns {[[string, array<array<Cell>>], [string, array<array<Cell>>], [string, array<array<Cell>>]]}
 */
Rows.prototype.bySection = function () {
  return [['head', this.head], ['body', this.body], ['foot', this.foot]]
}

// Table Column

/**
 * Methods to manage the columns of an AsciiDoc table.
 * In particular, it keeps track of the column specs.
 * @namespace
 * @extends AbstractNode
 */
var Column = Opal.Asciidoctor.Table.Column

/**
 * Create a new Column element.
 * @param {Table} table
 * @param {number} index
 * @param {Object|undefined} attributes
 * @returns Column
 */
Column.create = function (table, index, attributes) {
  return this.$new(table, index, toHash(attributes))
}

/**
 * Get the column number of this cell.
 * @returns {number|undefined}
 * @memberof Column
 */
Column.prototype.getColumnNumber = function () {
  return this.getAttribute('colnumber')
}

/**
 * Get the width of this cell.
 * @returns {string|undefined}
 * @memberof Column
 */
Column.prototype.getWidth = function () {
  return this.getAttribute('width')
}

/**
 * Get the horizontal align of this cell.
 * @returns {string|undefined}
 * @memberof Column
 */
Column.prototype.getHorizontalAlign = function () {
  return this.getAttribute('halign')
}

/**
 * Get the vertical align of this cell.
 * @returns {string|undefined}
 * @memberof Column
 */
Column.prototype.getVerticalAlign = function () {
  return this.getAttribute('valign')
}

/**
 * Get the style of this cell.
 * @returns {string}
 * @memberof Column
 */
Column.prototype.getStyle = function () {
  var style = this.style
  return style === Opal.nil ? undefined : style
}

// Table Cell

/**
 * Methods for managing the cells in an AsciiDoc table.
 * @namespace
 * @extends AbstractBlock
 */
var Cell = Opal.Asciidoctor.Table.Cell

/**
 * Create a new Cell element
 * @param {Column} column
 * @param {string} cellText
 * @param {Object|undefined} attributes
 * @param {Object|undefined} opts
 * @returns {Cell}
 */
Cell.create = function (column, cellText, attributes, opts) {
  return this.$new(column, cellText, toHash(attributes), toHash(opts))
}

/**
 * Get the column span of this {@link Cell} node.
 * @returns {number} - An Integer of the number of columns this cell will span (default: undefined)
 * @memberof Cell
 */
Cell.prototype.getColumnSpan = function () {
  var colspan = this.colspan
  return colspan === Opal.nil ? undefined : colspan
}

/**
 * Set the column span of this {@link Cell} node.
 * @param {number} value
 * @returns {number} - The new colspan value
 * @memberof Cell
 */
Cell.prototype.setColumnSpan = function (value) {
  return this['$colspan='](value)
}

/**
 * Get the row span of this {@link Cell} node
 * @returns {number|undefined} - An Integer of the number of rows this cell will span (default: undefined)
 * @memberof Cell
 */
Cell.prototype.getRowSpan = function () {
  var rowspan = this.rowspan
  return rowspan === Opal.nil ? undefined : rowspan
}

/**
 * Set the row span of this {@link Cell} node
 * @param {number} value
 * @returns {number} - The new rowspan value
 * @memberof Cell
 */
Cell.prototype.setRowSpan = function (value) {
  return this['$rowspan='](value)
}

/**
 * Get the content of the cell.
 * This method should not be used for cells in the head row or that have the literal style.
 * @returns {string}
 * @memberof Cell
 */
Cell.prototype.getContent = function () {
  return this.$content()
}

/**
 * Get the text of the cell.
 * @returns {string}
 * @memberof Cell
 */
Cell.prototype.getText = function () {
  return this.$text()
}

/**
 * Get the source of the cell.
 * @returns {string}
 * @memberof Cell
 */
Cell.prototype.getSource = function () {
  return this.$source()
}

/**
 * Get the lines of the cell.
 * @returns {Array<string>}
 * @memberof Cell
 */
Cell.prototype.getLines = function () {
  return this.$lines()
}

/**
 * Get the line number of the cell.
 * @returns {number|undefined}
 * @memberof Cell
 */
Cell.prototype.getLineNumber = function () {
  var lineno = this.$lineno()
  return lineno === Opal.nil ? undefined : lineno
}

/**
 * Get the source file of the cell.
 * @returns {string|undefined}
 * @memberof Cell
 */
Cell.prototype.getFile = function () {
  var file = this.$file()
  return file === Opal.nil ? undefined : file
}

/**
 * Get the style of the cell.
 * @returns {string|undefined}
 * @memberof Cell
 */
Cell.prototype.getStyle = function () {
  var style = this.$style()
  return style === Opal.nil ? undefined : style
}

/**
 * Get the column of this cell.
 * @returns {Column|undefined}
 * @memberof Cell
 */
Cell.prototype.getColumn = function () {
  var column = this.$column()
  return column === Opal.nil ? undefined : column
}

/**
 * Get the width of this cell.
 * @returns {string|undefined}
 * @memberof Cell
 */
Cell.prototype.getWidth = function () {
  return this.getAttribute('width')
}

/**
 * Get the column width in percentage of this cell.
 * @returns {string|undefined}
 * @memberof Cell
 */
Cell.prototype.getColumnPercentageWidth = function () {
  return this.getAttribute('colpcwidth')
}

/**
 * Get the nested {Document} of this cell when style is 'asciidoc'.
 * @returns {Document|undefined} - the nested {Document}
 * @memberof Cell
 */
Cell.prototype.getInnerDocument = function () {
  var innerDocument = this.inner_document
  return innerDocument === Opal.nil ? undefined : innerDocument
}

// Templates

/**
 * @description
 * This API is experimental and subject to change.
 *
 * Please note that this API is currently only available in a Node environment.
 * We recommend to use a custom converter if you are running in the browser.
 *
 * @namespace
 * @module Converter/TemplateConverter
 */
var TemplateConverter = Opal.Asciidoctor.Converter.TemplateConverter

if (TemplateConverter) {
  // Alias
  Opal.Asciidoctor.TemplateConverter = TemplateConverter

  /**
   * Create a new TemplateConverter.
   * @param {string} backend - the backend name
   * @param templateDirectories - a list of template directories
   * @param {Object} opts - a JSON of options
   * @param {string} opts.template_engine - the name of the template engine
   * @param {Object} [opts.template_cache] - an optional template cache
   * @param {Object} [opts.template_cache.scans] - a JSON of template objects keyed by template name keyed by path patterns
   * @param {Object} [opts.template_cache.templates] - a JSON of template objects keyed by file paths
   * @returns {TemplateConverter}
   * @memberof Converter/TemplateConverter
   */
  TemplateConverter.create = function (backend, templateDirectories, opts) {
    if (opts && opts.template_cache) {
      opts.template_cache = toHash(opts.template_cache)
    }
    this.$new(backend, templateDirectories, toHash(opts))
  }

  /**
   * @returns {Object} - The global cache
   * @memberof Converter/TemplateConverter
   */
  TemplateConverter.getCache = function () {
    var caches = fromHash(this.caches)
    if (caches) {
      if (caches.scans) {
        caches.scans = fromHash(caches.scans)
        for (var key in caches.scans) {
          caches.scans[key] = fromHash(caches.scans[key])
        }
      }
      if (caches.templates) {
        caches.templates = fromHash(caches.templates)
      }
    }
    return caches
  }

  /**
   * Clear the global cache.
   * @memberof Converter/TemplateConverter
   */
  TemplateConverter.clearCache = function () {
    this.$clear_caches()
  }

  /**
   * Convert an {AbstractNode} to the backend format using the named template.
   *
   * Looks for a template that matches the value of the template name or,
   * if the template name is not specified, the value of the {@see AbstractNode.getNodeName} function.
   *
   * @param {AbstractNode} node - the AbstractNode to convert
   * @param {string} templateName - the {string} name of the template to use, or the node name of the node if a template name is not specified. (optional, default: undefined)
   * @param {Object} opts - an optional JSON that is passed as local variables to the template. (optional, default: undefined)
   * @returns {string} - The {string} result from rendering the template
   * @memberof Converter/TemplateConverter
   */
  TemplateConverter.prototype.convert = function (node, templateName, opts) {
    return this.$convert(node, templateName, toHash(opts))
  }

  /**
   * Checks whether there is a template registered with the specified name.
   *
   * @param {string} name - the {string} template name
   * @returns {boolean} - a {boolean} that indicates whether a template is registered for the specified template name.
   * @memberof Converter/TemplateConverter
   */
  TemplateConverter.prototype.handles = function (name) {
    return this['$handles?'](name)
  }

  /**
   * Retrieves the templates that this converter manages.
   *
   * @returns {Object} - a JSON of template objects keyed by template name
   * @memberof Converter/TemplateConverter
   */
  TemplateConverter.prototype.getTemplates = function () {
    return fromHash(this.$templates())
  }

  /**
   * Registers a template with this converter.
   *
   * @param {string} name - the {string} template name
   * @param {Object} template - the template object to register
   * @returns {Object} - the template object
   * @memberof Converter/TemplateConverter
   */
  TemplateConverter.prototype.register = function (name, template) {
    return this.$register(name, template)
  }

  /**
   * @namespace
   * @description
   * This API is experimental and subject to change.
   *
   * Please note that this API is currently only available in a Node environment.
   * We recommend to use a custom converter if you are running in the browser.
   *
   * A pluggable adapter for integrating a template engine into the built-in template converter.
   */
  var TemplateEngine = {}
  TemplateEngine.registry = {}

  // Alias
  Opal.Asciidoctor.TemplateEngine = TemplateEngine

  /**
   * Register a template engine adapter for the given names.
   * @param {string|Array} names - a {string} name or an {Array} of {string} names
   * @param {Object} templateEngineAdapter - a template engine adapter instance
   * @example
   *  const fs = require('fs')
   *  class DotTemplateEngineAdapter {
   *    constructor () {
   *      this.doT = require('dot')
   *    }
   *    compile (file, _) {
   *      const templateFn = this.doT.template(fs.readFileSync(file, 'utf8'))
   *      return {
   *        render: templateFn
   *      }
   *    }
   *  }
   *  asciidoctor.TemplateEngine.register('dot, new DotTemplateEngineAdapter())
   * @memberof TemplateEngine
   */
  TemplateEngine.register = function (names, templateEngineAdapter) {
    if (typeof names === 'string') {
      this.registry[names] = templateEngineAdapter
    } else {
      // array
      for (var i = 0; i < names.length; i++) {
        var name = names[i]
        this.registry[name] = templateEngineAdapter
      }
    }
  }
}

/* global Opal, fromHash, toHash, initializeClass */
// Extensions API

/**
 * @private
 */
var toBlock = function (block) {
  // arity is a mandatory field
  block.$$arity = block.length
  return block
}

var registerExtension = function (registry, type, processor, name) {
  if (typeof processor === 'object' || processor.$$is_class) {
    // processor is an instance or a class
    return registry['$' + type](processor, name)
  } else {
    // processor is a function/lambda
    return Opal.send(registry, type, name && [name], toBlock(processor))
  }
}

/**
 * @namespace
 * @description
 * Extensions provide a way to participate in the parsing and converting
 * phases of the AsciiDoc processor or extend the AsciiDoc syntax.
 *
 * The various extensions participate in AsciiDoc processing as follows:
 *
 * 1. After the source lines are normalized, {{@link Extensions/Preprocessor}}s modify or replace
 *    the source lines before parsing begins. {{@link Extensions/IncludeProcessor}}s are used to
 *    process include directives for targets which they claim to handle.
 * 2. The Parser parses the block-level content into an abstract syntax tree.
 *    Custom blocks and block macros are processed by associated {{@link Extensions/BlockProcessor}}s
 *    and {{@link Extensions/BlockMacroProcessor}}s, respectively.
 * 3. {{@link Extensions/TreeProcessor}}s are run on the abstract syntax tree.
 * 4. Conversion of the document begins, at which point inline markup is processed
 *    and converted. Custom inline macros are processed by associated {InlineMacroProcessor}s.
 * 5. {{@link Extensions/Postprocessor}}s modify or replace the converted document.
 * 6. The output is written to the output stream.
 *
 * Extensions may be registered globally using the {Extensions.register} method
 * or added to a custom {Registry} instance and passed as an option to a single
 * Asciidoctor processor.
 *
 * @example
 * asciidoctor.Extensions.register(function () {
 *   this.block(function () {
 *     var self = this;
 *     self.named('shout');
 *     self.onContext('paragraph');
 *     self.process(function (parent, reader) {
 *       var lines = reader.getLines().map(function (l) { return l.toUpperCase(); });
 *       return self.createBlock(parent, 'paragraph', lines);
 *     });
 *   });
 * });
 */
var Extensions = Opal.const_get_qualified(Opal.Asciidoctor, 'Extensions')

// Alias
Opal.Asciidoctor.Extensions = Extensions

/**
 * Create a new {@link Extensions/Registry}.
 * @param {string} name
 * @param {function} block
 * @memberof Extensions
 * @returns {Extensions/Registry} - returns a {@link Extensions/Registry}
 */
Extensions.create = function (name, block) {
  if (typeof name === 'function' && typeof block === 'undefined') {
    return Opal.send(this, 'create', null, toBlock(name))
  } else if (typeof block === 'function') {
    return Opal.send(this, 'create', [name], toBlock(block))
  } else {
    return this.$create()
  }
}

/**
 * @memberof Extensions
 */
Extensions.register = function (name, block) {
  if (typeof name === 'function' && typeof block === 'undefined') {
    return Opal.send(this, 'register', null, toBlock(name))
  } else {
    return Opal.send(this, 'register', [name], toBlock(block))
  }
}

/**
 * Get statically-registered extension groups.
 * @memberof Extensions
 */
Extensions.getGroups = function () {
  return fromHash(this.$groups())
}

/**
 * Unregister all statically-registered extension groups.
 * @memberof Extensions
 */
Extensions.unregisterAll = function () {
  this.$unregister_all()
}

/**
 * Unregister the specified statically-registered extension groups.
 *
 * NOTE Opal cannot delete an entry from a Hash that is indexed by symbol, so
 * we have to resort to using low-level operations in this method.
 *
 * @memberof Extensions
 */
Extensions.unregister = function () {
  var names = Array.prototype.concat.apply([], arguments)
  var groups = this.$groups()
  var groupNameIdx = {}
  for (var i = 0, groupSymbolNames = groups.$$keys; i < groupSymbolNames.length; i++) {
    var groupSymbolName = groupSymbolNames[i]
    groupNameIdx[groupSymbolName.toString()] = groupSymbolName
  }
  for (var j = 0; j < names.length; j++) {
    var groupStringName = names[j]
    if (groupStringName in groupNameIdx) Opal.hash_delete(groups, groupNameIdx[groupStringName])
  }
}

/**
 * @namespace
 * @module Extensions/Registry
 */
var Registry = Extensions.Registry

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.getGroups = Extensions.getGroups

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.unregisterAll = function () {
  this.groups = Opal.hash()
}

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.unregister = Extensions.unregister

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.prefer = function (name, processor) {
  if (arguments.length === 1) {
    processor = name
    name = null
  }
  if (typeof processor === 'object' || processor.$$is_class) {
    // processor is an instance or a class
    return this.$prefer(name, processor)
  } else {
    // processor is a function/lambda
    return Opal.send(this, 'prefer', name && [name], toBlock(processor))
  }
}

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.block = function (name, processor) {
  if (arguments.length === 1) {
    processor = name
    name = null
  }
  return registerExtension(this, 'block', processor, name)
}

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.inlineMacro = function (name, processor) {
  if (arguments.length === 1) {
    processor = name
    name = null
  }
  return registerExtension(this, 'inline_macro', processor, name)
}

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.includeProcessor = function (name, processor) {
  if (arguments.length === 1) {
    processor = name
    name = null
  }
  return registerExtension(this, 'include_processor', processor, name)
}

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.blockMacro = function (name, processor) {
  if (arguments.length === 1) {
    processor = name
    name = null
  }
  return registerExtension(this, 'block_macro', processor, name)
}

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.treeProcessor = function (name, processor) {
  if (arguments.length === 1) {
    processor = name
    name = null
  }
  return registerExtension(this, 'tree_processor', processor, name)
}

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.postprocessor = function (name, processor) {
  if (arguments.length === 1) {
    processor = name
    name = null
  }
  return registerExtension(this, 'postprocessor', processor, name)
}

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.preprocessor = function (name, processor) {
  if (arguments.length === 1) {
    processor = name
    name = null
  }
  return registerExtension(this, 'preprocessor', processor, name)
}

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.docinfoProcessor = function (name, processor) {
  if (arguments.length === 1) {
    processor = name
    name = null
  }
  return registerExtension(this, 'docinfo_processor', processor, name)
}

/**
 * Checks whether any {{@link Extensions/Preprocessor}} extensions have been registered.
 *
 * @memberof Extensions/Registry
 * @returns a {boolean} indicating whether any {{@link Extensions/Preprocessor}} extensions are registered.
 */
Registry.prototype.hasPreprocessors = function () {
  return this['$preprocessors?']()
}

/**
 * Checks whether any {{@link Extensions/TreeProcessor}} extensions have been registered.
 *
 * @memberof Extensions/Registry
 * @returns a {boolean} indicating whether any {{@link Extensions/TreeProcessor}} extensions are registered.
 */
Registry.prototype.hasTreeProcessors = function () {
  return this['$tree_processors?']()
}

/**
 * Checks whether any {{@link Extensions/IncludeProcessor}} extensions have been registered.
 *
 * @memberof Extensions/Registry
 * @returns a {boolean} indicating whether any {{@link Extensions/IncludeProcessor}} extensions are registered.
 */
Registry.prototype.hasIncludeProcessors = function () {
  return this['$include_processors?']()
}

/**
 * Checks whether any {{@link Extensions/Postprocessor}} extensions have been registered.
 *
 * @memberof Extensions/Registry
 * @returns a {boolean} indicating whether any {{@link Extensions/Postprocessor}} extensions are registered.
 */
Registry.prototype.hasPostprocessors = function () {
  return this['$postprocessors?']()
}

/**
 * Checks whether any {{@link Extensions/DocinfoProcessor}} extensions have been registered.
 *
 * @memberof Extensions/Registry
 * @param location - A {string} for selecting docinfo extensions at a given location (head or footer) (default: undefined)
 * @returns a {boolean} indicating whether any {{@link Extensions/DocinfoProcessor}} extensions are registered.
 */
Registry.prototype.hasDocinfoProcessors = function (location) {
  return this['$docinfo_processors?'](location)
}

/**
 * Checks whether any {{@link Extensions/BlockProcessor}} extensions have been registered.
 *
 * @memberof Extensions/Registry
 * @returns a {boolean} indicating whether any {{@link Extensions/BlockProcessor}} extensions are registered.
 */
Registry.prototype.hasBlocks = function () {
  return this['$blocks?']()
}

/**
 * Checks whether any {{@link Extensions/BlockMacroProcessor}} extensions have been registered.
 *
 * @memberof Extensions/Registry
 * @returns a {boolean} indicating whether any {{@link Extensions/BlockMacroProcessor}} extensions are registered.
 */
Registry.prototype.hasBlockMacros = function () {
  return this['$block_macros?']()
}

/**
 * Checks whether any {{@link Extensions/InlineMacroProcessor}} extensions have been registered.
 *
 * @memberof Extensions/Registry
 * @returns a {boolean} indicating whether any {{@link Extensions/InlineMacroProcessor}} extensions are registered.
 */
Registry.prototype.hasInlineMacros = function () {
  return this['$inline_macros?']()
}

/**
 * Retrieves the Extension proxy objects for all the {{@link Extensions/Preprocessor}} instances stored in this registry.
 *
 * @memberof Extensions/Registry
 * @returns an {array} of Extension proxy objects.
 */
Registry.prototype.getPreprocessors = function () {
  return this.$preprocessors()
}

/**
 * Retrieves the Extension proxy objects for all the {{@link Extensions/TreeProcessor}} instances stored in this registry.
 *
 * @memberof Extensions/Registry
 * @returns an {array} of Extension proxy objects.
 */
Registry.prototype.getTreeProcessors = function () {
  return this.$tree_processors()
}

/**
 * Retrieves the Extension proxy objects for all the {{@link Extensions/IncludeProcessor}} instances stored in this registry.
 *
 * @memberof Extensions/Registry
 * @returns an {array} of Extension proxy objects.
 */
Registry.prototype.getIncludeProcessors = function () {
  return this.$include_processors()
}

/**
 * Retrieves the Extension proxy objects for all the {{@link Extensions/Postprocessor}} instances stored in this registry.
 *
 * @memberof Extensions/Registry
 * @returns an {array} of Extension proxy objects.
 */
Registry.prototype.getPostprocessors = function () {
  return this.$postprocessors()
}

/**
 * Retrieves the Extension proxy objects for all the {{@link Extensions/DocinfoProcessor}} instances stored in this registry.
 *
 * @memberof Extensions/Registry
 * @param location - A {string} for selecting docinfo extensions at a given location (head or footer) (default: undefined)
 * @returns an {array} of Extension proxy objects.
 */
Registry.prototype.getDocinfoProcessors = function (location) {
  return this.$docinfo_processors(location)
}

/**
 * Retrieves the Extension proxy objects for all the {{@link Extensions/BlockProcessor}} instances stored in this registry.
 *
 * @memberof Extensions/Registry
 * @returns an {array} of Extension proxy objects.
 */
Registry.prototype.getBlocks = function () {
  return this.block_extensions.$values()
}

/**
 * Retrieves the Extension proxy objects for all the {{@link Extensions/BlockMacroProcessor}} instances stored in this registry.
 *
 * @memberof Extensions/Registry
 * @returns an {array} of Extension proxy objects.
 */
Registry.prototype.getBlockMacros = function () {
  return this.block_macro_extensions.$values()
}

/**
 * Retrieves the Extension proxy objects for all the {{@link Extensions/InlineMacroProcessor}} instances stored in this registry.
 *
 * @memberof Extensions/Registry
 * @returns an {array} of Extension proxy objects.
 */
Registry.prototype.getInlineMacros = function () {
  return this.$inline_macros()
}

/**
 * Get any {{@link Extensions/InlineMacroProcessor}} extensions are registered to handle the specified inline macro name.
 *
 * @param name - the {string} inline macro name
 * @memberof Extensions/Registry
 * @returns the Extension proxy object for the {{@link Extensions/InlineMacroProcessor}} that matches the inline macro name or undefined if no match is found.
 */
Registry.prototype.getInlineMacroFor = function (name) {
  var result = this['$registered_for_inline_macro?'](name)
  return result === false ? undefined : result
}

/**
 * Get any {{@link Extensions/BlockProcessor}} extensions are registered to handle the specified block name appearing on the specified context.
 * @param name - the {string} block name
 * @param context - the context of the block: paragraph, open... (optional)
 * @memberof Extensions/Registry
 * @returns the Extension proxy object for the {{@link Extensions/BlockProcessor}} that matches the block name and context or undefined if no match is found.
 */
Registry.prototype.getBlockFor = function (name, context) {
  if (typeof context === 'undefined') {
    var ext = this.$find_block_extension(name)
    return ext === Opal.nil ? undefined : ext
  }
  var result = this['$registered_for_block?'](name, context)
  return result === false ? undefined : result
}

/**
 * Get any {{@link Extensions/BlockMacroProcessor}} extensions are registered to handle the specified macro name.
 *
 * @param name - the {string} macro name
 * @memberof Extensions/Registry
 * @returns the Extension proxy object for the {{@link Extensions/BlockMacroProcessor}} that matches the macro name or undefined if no match is found.
 */
Registry.prototype.getBlockMacroFor = function (name) {
  var result = this['$registered_for_block_macro?'](name)
  return result === false ? undefined : result
}

/**
 * @namespace
 * @module Extensions/Processor
 */
var Processor = Extensions.Processor

/**
 * The extension will be added to the beginning of the list for that extension type. (default is append).
 * @memberof Extensions/Processor
 * @deprecated Please use the <code>prefer</pre> function on the {@link Extensions/Registry},
 * the {@link Extensions/IncludeProcessor},
 * the {@link Extensions/TreeProcessor},
 * the {@link Extensions/Postprocessor},
 * the {@link Extensions/Preprocessor}
 * or the {@link Extensions/DocinfoProcessor}
 */
Processor.prototype.prepend = function () {
  this.$option('position', '>>')
}

/**
 * @memberof Extensions/Processor
 */
Processor.prototype.process = function (block) {
  var handler = {
    apply: function (target, thisArg, argumentsList) {
      for (var i = 0; i < argumentsList.length; i++) {
        // convert all (Opal) Hash arguments to JSON.
        if (typeof argumentsList[i] === 'object' && '$$smap' in argumentsList[i]) {
          argumentsList[i] = fromHash(argumentsList[i])
        }
      }
      return target.apply(thisArg, argumentsList)
    }
  }
  var blockProxy = new Proxy(block, handler)
  return Opal.send(this, 'process', null, toBlock(blockProxy))
}

/**
 * @param {string} name
 * @memberof Extensions/Processor
 */
Processor.prototype.named = function (name) {
  return this.$named(name)
}

/**
 * Creates a block and links it to the specified parent.
 *
 * @param {Block|Section|Document} parent - The parent Block (Block, Section, or Document) of this new block.
 * @param {string} context
 * @param {string|Array<string>} source
 * @param {Object|undefined} attrs - A JSON of attributes
 * @param {Object|undefined} opts - A JSON of options
 * @return {Block}
 * @memberof Extensions/Processor
 */
Processor.prototype.createBlock = function (parent, context, source, attrs, opts) {
  return this.$create_block(parent, context, source, toHash(attrs), toHash(opts))
}

/**
 * Creates a list block node and links it to the specified parent.
 *
 * @param parent - The parent Block (Block, Section, or Document) of this new list block.
 * @param {string} context - The list context (e.g., ulist, olist, colist, dlist)
 * @param {Object} attrs - An object of attributes to set on this list block
 * @returns {List}
 * @memberof Extensions/Processor
 */
Processor.prototype.createList = function (parent, context, attrs) {
  return this.$create_list(parent, context, toHash(attrs))
}

/**
 * Creates a list item node and links it to the specified parent.
 *
 * @param {List} parent - The parent {List} of this new list item block.
 * @param {string} text - The text of the list item.
 * @returns {ListItem}
 * @memberof Extensions/Processor
 */
Processor.prototype.createListItem = function (parent, text) {
  return this.$create_list_item(parent, text)
}

/**
 * Creates an image block node and links it to the specified parent.
 * @param {Block|Section|Document} parent - The parent Block of this new image block.
 * @param {Object} attrs - A JSON of attributes
 * @param {string} attrs.target - the target attribute to set the source of the image.
 * @param {string} attrs.alt - the alt attribute to specify an alternative text for the image.
 * @param {Object} opts - A JSON of options
 * @returns {Block}
 * @memberof Extensions/Processor
 */
Processor.prototype.createImageBlock = function (parent, attrs, opts) {
  return this.$create_image_block(parent, toHash(attrs), toHash(opts))
}

/**
 * Creates a paragraph block and links it to the specified parent.
 *
 * @param {Block|Section|Document} parent - The parent Block (Block, Section, or Document) of this new block.
 * @param {string|Array<string>} source - The source
 * @param {Object|undefined} attrs - An object of attributes to set on this block
 * @param {Object|undefined} opts - An object of options to set on this block
 * @returns {Block} - a paragraph {Block}
 * @memberof Extensions/Processor
 */
Processor.prototype.createParagraph = function (parent, source, attrs, opts) {
  return this.$create_paragraph(parent, source, toHash(attrs), toHash(opts))
}

/**
 * Creates an open block and links it to the specified parent.
 *
 * @param {Block|Section|Document} parent - The parent Block (Block, Section, or Document) of this new block.
 * @param {string|Array<string>} source - The source
 * @param {Object|undefined} attrs - An object of attributes to set on this block
 * @param {Object|undefined} opts - An object of options to set on this block
 * @returns {Block} - an open {Block}
 * @memberof Extensions/Processor
 */
Processor.prototype.createOpenBlock = function (parent, source, attrs, opts) {
  return this.$create_open_block(parent, source, toHash(attrs), toHash(opts))
}

/**
 * Creates an example block and links it to the specified parent.
 *
 * @param {Block|Section|Document} parent - The parent Block (Block, Section, or Document) of this new block.
 * @param {string|Array<string>} source - The source
 * @param {Object|undefined} attrs - An object of attributes to set on this block
 * @param {Object|undefined} opts - An object of options to set on this block
 * @returns {Block} - an example {Block}
 * @memberof Extensions/Processor
 */
Processor.prototype.createExampleBlock = function (parent, source, attrs, opts) {
  return this.$create_example_block(parent, source, toHash(attrs), toHash(opts))
}

/**
 * Creates a literal block and links it to the specified parent.
 *
 * @param {Block|Section|Document} parent - The parent Block (Block, Section, or Document) of this new block.
 * @param {string|Array<string>} source - The source
 * @param {Object|undefined} attrs - An object of attributes to set on this block
 * @param {Object|undefined} opts - An object of options to set on this block
 * @returns {Block} - a literal {Block}
 * @memberof Extensions/Processor
 */
Processor.prototype.createPassBlock = function (parent, source, attrs, opts) {
  return this.$create_pass_block(parent, source, toHash(attrs), toHash(opts))
}

/**
 * Creates a listing block and links it to the specified parent.
 *
 * @param {Block|Section|Document} parent - The parent Block (Block, Section, or Document) of this new block.
 * @param {string|Array<string>} source - The source
 * @param {Object|undefined} attrs - An object of attributes to set on this block
 * @param {Object|undefined} opts - An object of options to set on this block
 * @returns {Block} - a listing {Block}
 * @memberof Extensions/Processor
 */
Processor.prototype.createListingBlock = function (parent, source, attrs, opts) {
  return this.$create_listing_block(parent, source, toHash(attrs), toHash(opts))
}

/**
 * Creates a literal block and links it to the specified parent.
 *
 * @param {Block|Section|Document} parent - The parent Block (Block, Section, or Document) of this new block.
 * @param {string|Array<string>} source - The source
 * @param {Object|undefined} attrs - An object of attributes to set on this block
 * @param {Object|undefined} opts - An object of options to set on this block
 * @returns {Block} - a literal {Block}
 * @memberof Extensions/Processor
 */
Processor.prototype.createLiteralBlock = function (parent, source, attrs, opts) {
  return this.$create_literal_block(parent, source, toHash(attrs), toHash(opts))
}

/**
 * Creates an inline anchor and links it to the specified parent.
 *
 * @param {Block|Section|Document} parent - The parent Block (Block, Section, or Document) of this new block.
 * @param {string} text - The text
 * @param {Object|undefined} opts - An object of options to set on this block
 * @returns {Inline} - an {Inline} anchor
 * @memberof Extensions/Processor
 */
Processor.prototype.createAnchor = function (parent, text, opts) {
  if (opts && opts.attributes) {
    opts.attributes = toHash(opts.attributes)
  }
  return this.$create_anchor(parent, text, toHash(opts))
}

/**
 * Creates an inline pass and links it to the specified parent.
 *
 * @param {Block|Section|Document} parent - The parent Block (Block, Section, or Document) of this new block.
 * @param {string} text - The text
 * @param {Object|undefined} opts - An object of options to set on this block
 * @returns {Inline} - an {Inline} pass
 * @memberof Extensions/Processor
 */
Processor.prototype.createInlinePass = function (parent, text, opts) {
  if (opts && opts.attributes) {
    opts.attributes = toHash(opts.attributes)
  }
  return this.$create_inline_pass(parent, text, toHash(opts))
}

/**
 * Creates an inline node and links it to the specified parent.
 *
 * @param {Block|Section|Document} parent - The parent Block of this new inline node.
 * @param {string} context - The context name
 * @param {string} text - The text
 * @param {Object|undefined} opts - A JSON of options
 * @returns {Inline} - an {Inline} node
 * @memberof Extensions/Processor
 */
Processor.prototype.createInline = function (parent, context, text, opts) {
  if (opts && opts.attributes) {
    opts.attributes = toHash(opts.attributes)
  }
  return this.$create_inline(parent, context, text, toHash(opts))
}

/**
 * Parses blocks in the content and attaches the block to the parent.
 * @param {AbstractBlock} parent - the parent block
 * @param {string|Array<string>} content - the content
 * @param {Object|undefined} attrs - an object of attributes
 * @returns {AbstractNode} - The parent node into which the blocks are parsed.
 * @memberof Extensions/Processor
 */
Processor.prototype.parseContent = function (parent, content, attrs) {
  return this.$parse_content(parent, content, attrs)
}

/**
 *  Parses the attrlist String into a JSON of attributes
 * @param {AbstractBlock} block - the current AbstractBlock or the parent AbstractBlock if there is no current block (used for applying subs)
 * @param {string} attrlist - the list of attributes as a String
 * @param {Object|undefined} opts - an optional JSON of options to control processing:
 * - positional_attributes: an Array of attribute names to map positional arguments to (optional, default: [])
 * - sub_attributes: enables attribute substitution on the attrlist argument (optional, default: false)
 *
 * @returns - a JSON of parsed attributes
 * @memberof Extensions/Processor
 */
Processor.prototype.parseAttributes = function (block, attrlist, opts) {
  if (opts && opts.attributes) {
    opts.attributes = toHash(opts.attributes)
  }
  return fromHash(this.$parse_attributes(block, attrlist, toHash(opts)))
}

/**
 * @param {string|Array<string>} value - Name of a positional attribute or an Array of positional attribute names
 * @memberof Extensions/Processor
 */
Processor.prototype.positionalAttributes = function (value) {
  return this.$positional_attrs(value)
}

/**
 * Specify how to resolve attributes.
 *
 * @param {string|Array<string>|Object|boolean} [value] - A specification to resolve attributes.
 * @memberof Extensions/Processor
 */
Processor.prototype.resolveAttributes = function (value) {
  if (typeof value === 'object' && !Array.isArray(value)) {
    return this.$resolves_attributes(toHash(value))
  }
  if (arguments.length > 1) {
    return this.$resolves_attributes(Array.prototype.slice.call(arguments))
  }
  if (typeof value === 'undefined') {
    // Convert to nil otherwise an exception is thrown at:
    // https://github.com/asciidoctor/asciidoctor/blob/0bcb4addc17b307f62975aad203fb556a1bcd8a5/lib/asciidoctor/extensions.rb#L583
    //
    // if args.size == 1 && !args[0]
    //
    // In the above Ruby code, args[0] is undefined and Opal will try to call the function "!" on an undefined object.
    return this.$resolves_attributes(Opal.nil)
  }
  return this.$resolves_attributes(value)
}

/**
 * @deprecated Please use the <code>resolveAttributes</pre> function on the {@link Extensions/Processor}.
 * @memberof Extensions/Processor
 * @see {Processor#resolveAttributes}
 */
Processor.prototype.resolvesAttributes = Processor.prototype.resolveAttributes

/**
 * Get the configuration JSON for this processor instance.
 * @memberof Extensions/Processor
 */
Processor.prototype.getConfig = function () {
  return fromHash(this.config)
}

/**
 * @memberof Extensions/Processor
 */
Processor.prototype.option = function (key, value) {
  this.$option(key, value)
}

/**
 * @namespace
 * @module Extensions/BlockProcessor
 */
var BlockProcessor = Extensions.BlockProcessor

/**
 * @param {Object} value - a JSON of default values for attributes
 * @memberof Extensions/BlockProcessor
 */
BlockProcessor.prototype.defaultAttributes = function (value) {
  this.$default_attributes(toHash(value))
}

/**
 * @param {string} context - A context name
 * @memberof Extensions/BlockProcessor
 */
BlockProcessor.prototype.onContext = function (context) {
  return this.$on_context(context)
}

/**
 * @param {...string} contexts - A list of context names
 * @memberof Extensions/BlockProcessor
 */
BlockProcessor.prototype.onContexts = function (contexts) {
  return this.$on_contexts(Array.prototype.slice.call(arguments))
}

/**
 * @returns {string}
 * @memberof Extensions/BlockProcessor
 */
BlockProcessor.prototype.getName = function () {
  var name = this.name
  return name === Opal.nil ? undefined : name
}

/**
 * @param {string} value
 * @memberof Extensions/BlockProcessor
 */
BlockProcessor.prototype.parseContentAs = function (value) {
  this.$parse_content_as(value)
}

/**
 * @namespace
 * @module Extensions/BlockMacroProcessor
 */
var BlockMacroProcessor = Extensions.BlockMacroProcessor

/**
 * @param {Object} value - a JSON of default values for attributes
 * @memberof Extensions/BlockMacroProcessor
 */
BlockMacroProcessor.prototype.defaultAttributes = function (value) {
  this.$default_attributes(toHash(value))
}

/**
 * @returns {string} - the block macro name
 * @memberof Extensions/BlockMacroProcessor
 */
BlockMacroProcessor.prototype.getName = function () {
  var name = this.name
  return name === Opal.nil ? undefined : name
}

/**
 * @param {string} value
 * @memberof Extensions/BlockMacroProcessor
 */
BlockMacroProcessor.prototype.parseContentAs = function (value) {
  this.$parse_content_as(value)
}

/**
 * @namespace
 * @module Extensions/InlineMacroProcessor
 */
var InlineMacroProcessor = Extensions.InlineMacroProcessor

/**
 * @param {Object} value - a JSON of default values for attributes
 * @memberof Extensions/InlineMacroProcessor
 */
InlineMacroProcessor.prototype.defaultAttributes = function (value) {
  this.$default_attributes(toHash(value))
}

/**
 * @returns {string} - the inline macro name
 * @memberof Extensions/InlineMacroProcessor
 */
InlineMacroProcessor.prototype.getName = function () {
  var name = this.name
  return name === Opal.nil ? undefined : name
}

/**
 * @param {string} value
 * @memberof Extensions/InlineMacroProcessor
 */
InlineMacroProcessor.prototype.parseContentAs = function (value) {
  this.$parse_content_as(value)
}

/**
 * @param {string} value
 * @memberof Extensions/InlineMacroProcessor
 */
InlineMacroProcessor.prototype.matchFormat = function (value) {
  this.$match_format(value)
}

/**
 * @param {RegExp} value
 * @memberof Extensions/InlineMacroProcessor
 */
InlineMacroProcessor.prototype.match = function (value) {
  this.$match(value)
}

/**
 * @namespace
 * @module Extensions/IncludeProcessor
 */
var IncludeProcessor = Extensions.IncludeProcessor

/**
 * @memberof Extensions/IncludeProcessor
 */
IncludeProcessor.prototype.handles = function (block) {
  return Opal.send(this, 'handles?', null, toBlock(block))
}

/**
 * @memberof Extensions/IncludeProcessor
 */
IncludeProcessor.prototype.prefer = function () {
  this.$prefer()
}

/**
 * @namespace
 * @module Extensions/TreeProcessor
 */
var TreeProcessor = Extensions.TreeProcessor

/**
 * @memberof Extensions/TreeProcessor
 */
TreeProcessor.prototype.prefer = function () {
  this.$prefer()
}

/**
 * @namespace
 * @module Extensions/Postprocessor
 */
var Postprocessor = Extensions.Postprocessor

/**
 * @memberof Extensions/Postprocessor
 */
Postprocessor.prototype.prefer = function () {
  this.$prefer()
}

/**
 * @namespace
 * @module Extensions/Preprocessor
 */
var Preprocessor = Extensions.Preprocessor

/**
 * @memberof Extensions/Preprocessor
 */
Preprocessor.prototype.prefer = function () {
  this.$prefer()
}

/**
 * @namespace
 * @module Extensions/DocinfoProcessor
 */
var DocinfoProcessor = Extensions.DocinfoProcessor

/**
 * @memberof Extensions/DocinfoProcessor
 */
DocinfoProcessor.prototype.prefer = function () {
  this.$prefer()
}

/**
 * @param {string} value - The docinfo location ("head", "header" or "footer")
 * @memberof Extensions/DocinfoProcessor
 */
DocinfoProcessor.prototype.atLocation = function (value) {
  this.$at_location(value)
}

function initializeProcessorClass (superclassName, className, functions) {
  var superClass = Opal.const_get_qualified(Extensions, superclassName)
  return initializeClass(superClass, className, functions, {
    'handles?': function () {
      return true
    }
  })
}

// Postprocessor

/**
 * Create a postprocessor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.createPostprocessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name
    name = null
  }
  return initializeProcessorClass('Postprocessor', name, functions)
}

/**
 * Create and instantiate a postprocessor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.newPostprocessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name
    name = null
  }
  return this.createPostprocessor(name, functions).$new()
}

// Preprocessor

/**
 * Create a preprocessor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.createPreprocessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name
    name = null
  }
  return initializeProcessorClass('Preprocessor', name, functions)
}

/**
 * Create and instantiate a preprocessor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.newPreprocessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name
    name = null
  }
  return this.createPreprocessor(name, functions).$new()
}

// Tree Processor

/**
 * Create a tree processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.createTreeProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name
    name = null
  }
  return initializeProcessorClass('TreeProcessor', name, functions)
}

/**
 * Create and instantiate a tree processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.newTreeProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name
    name = null
  }
  return this.createTreeProcessor(name, functions).$new()
}

// Include Processor

/**
 * Create an include processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.createIncludeProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name
    name = null
  }
  return initializeProcessorClass('IncludeProcessor', name, functions)
}

/**
 * Create and instantiate an include processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.newIncludeProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name
    name = null
  }
  return this.createIncludeProcessor(name, functions).$new()
}

// Docinfo Processor

/**
 * Create a Docinfo processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.createDocinfoProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name
    name = null
  }
  return initializeProcessorClass('DocinfoProcessor', name, functions)
}

/**
 * Create and instantiate a Docinfo processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.newDocinfoProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name
    name = null
  }
  return this.createDocinfoProcessor(name, functions).$new()
}

// Block Processor

/**
 * Create a block processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.createBlockProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name
    name = null
  }
  return initializeProcessorClass('BlockProcessor', name, functions)
}

/**
 * Create and instantiate a block processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.newBlockProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name
    name = null
  }
  return this.createBlockProcessor(name, functions).$new()
}

// Inline Macro Processor

/**
 * Create an inline macro processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.createInlineMacroProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name
    name = null
  }
  return initializeProcessorClass('InlineMacroProcessor', name, functions)
}

/**
 * Create and instantiate an inline macro processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.newInlineMacroProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name
    name = null
  }
  return this.createInlineMacroProcessor(name, functions).$new()
}

// Block Macro Processor

/**
 * Create a block macro processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.createBlockMacroProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name
    name = null
  }
  return initializeProcessorClass('BlockMacroProcessor', name, functions)
}

/**
 * Create and instantiate a block macro processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.newBlockMacroProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name
    name = null
  }
  return this.createBlockMacroProcessor(name, functions).$new()
}

// Converter API

/**
 * @namespace
 * @module Converter
 */
var Converter = Opal.const_get_qualified(Opal.Asciidoctor, 'Converter')

// Alias
Opal.Asciidoctor.Converter = Converter

/**
 * Convert the specified node.
 *
 * @param {AbstractNode} node - the AbstractNode to convert
 * @param {string} transform - an optional String transform that hints at
 * which transformation should be applied to this node.
 * @param {Object} opts - a JSON of options that provide additional hints about how to convert the node (default: {})
 * @returns the {Object} result of the conversion, typically a {string}.
 * @memberof Converter
 */
Converter.prototype.convert = function (node, transform, opts) {
  return this.$convert(node, transform, toHash(opts))
}

/**
 * Create an instance of the converter bound to the specified backend.
 *
 * @param {string} backend - look for a converter bound to this keyword.
 * @param {Object} opts - a JSON of options to pass to the converter (default: {})
 * @returns {Converter} - a converter instance for converting nodes in an Asciidoctor AST.
 * @memberof Converter
 */
Converter.create = function (backend, opts) {
  return this.$create(backend, toHash(opts))
}

// Converter Factory API

/**
 * @namespace
 * @module Converter/Factory
 */
var ConverterFactory = Opal.Asciidoctor.Converter.Factory

var ConverterBase = Opal.Asciidoctor.Converter.Base

// Alias
Opal.Asciidoctor.ConverterFactory = ConverterFactory

var ConverterBackendTraits = Opal.Asciidoctor.Converter.BackendTraits

// Alias
Opal.Asciidoctor.ConverterBackendTraits = ConverterBackendTraits

/**
 * Register a custom converter in the global converter factory to handle conversion to the specified backends.
 * If the backend value is an asterisk, the converter is used to handle any backend that does not have an explicit converter.
 *
 * @param converter - The Converter instance to register
 * @param backends {Array} - A {string} {Array} of backend names that this converter should be registered to handle (optional, default: ['*'])
 * @return {*} - Returns nothing
 * @memberof Converter/Factory
 */
ConverterFactory.register = function (converter, backends) {
  var object
  var buildBackendTraitsFromObject = function (obj) {
    return Object.assign({},
      obj.basebackend ? { basebackend: obj.basebackend } : {},
      obj.outfilesuffix ? { outfilesuffix: obj.outfilesuffix } : {},
      obj.filetype ? { filetype: obj.filetype } : {},
      obj.htmlsyntax ? { htmlsyntax: obj.htmlsyntax } : {},
      obj.supports_templates ? { supports_templates: obj.supports_templates } : {}
    )
  }
  var assignBackendTraitsToInstance = function (obj, instance) {
    if (obj.backend_traits) {
      instance.backend_traits = toHash(obj.backend_traits)
    } else if (obj.backendTraits) {
      instance.backend_traits = toHash(obj.backendTraits)
    } else if (obj.basebackend || obj.outfilesuffix || obj.filetype || obj.htmlsyntax || obj.supports_templates) {
      instance.backend_traits = toHash(buildBackendTraitsFromObject(obj))
    }
  }
  var bridgeHandlesMethodToInstance = function (obj, instance) {
    bridgeMethodToInstance(obj, instance, '$handles?', 'handles', function () {
      return true
    })
  }
  var bridgeComposedMethodToInstance = function (obj, instance) {
    bridgeMethodToInstance(obj, instance, '$composed', 'composed')
  }
  var bridgeEqEqMethodToInstance = function (obj, instance) {
    bridgeMethodToInstance(obj, instance, '$==', '==', function (other) {
      return instance === other
    })
  }
  var bridgeSendMethodToInstance = function (obj, instance) {
    bridgeMethodToInstance(obj, instance, '$send', 'send', function (symbol) {
      var args = Array.prototype.slice.call(arguments, 1)
      var func = instance['$' + symbol]
      if (func) {
        return func.apply(instance, args)
      }
      throw new Error(`undefined method \`${symbol}\` for \`${instance.toString()}\``)
    })
  }
  var bridgeMethodToInstance = function (obj, instance, methodName, functionName, defaultImplementation) {
    if (typeof obj[methodName] === 'undefined') {
      if (typeof obj[functionName] === 'function') {
        instance[methodName] = obj[functionName]
      } else if (defaultImplementation) {
        instance[methodName] = defaultImplementation
      }
    }
  }
  var addRespondToMethod = function (instance) {
    if (typeof instance['$respond_to?'] !== 'function') {
      instance['$respond_to?'] = function (name) {
        return typeof this[name] === 'function'
      }
    }
  }
  if (typeof converter === 'function') {
    // Class
    object = initializeClass(ConverterBase, converter.constructor.name, {
      initialize: function (backend, opts) {
        var self = this
        var result = new converter(backend, opts) // eslint-disable-line
        Object.assign(this, result)
        assignBackendTraitsToInstance(result, self)
        var propertyNames = Object.getOwnPropertyNames(converter.prototype)
        for (var i = 0; i < propertyNames.length; i++) {
          var propertyName = propertyNames[i]
          if (propertyName !== 'constructor') {
            self[propertyName] = result[propertyName]
          }
        }
        if (typeof result.$convert === 'undefined' && typeof result.convert === 'function') {
          self.$convert = result.convert
        }
        bridgeHandlesMethodToInstance(result, self)
        bridgeComposedMethodToInstance(result, self)
        addRespondToMethod(self)
        self.super(backend, opts)
      }
    })
    object.$extend(ConverterBackendTraits)
  } else if (typeof converter === 'object') {
    // Instance
    if (typeof converter.$convert === 'undefined' && typeof converter.convert === 'function') {
      converter.$convert = converter.convert
    }
    assignBackendTraitsToInstance(converter, converter)
    if (converter.backend_traits) {
      // "extends" ConverterBackendTraits
      var converterBackendTraitsFunctionNames = [
        'basebackend',
        'filetype',
        'htmlsyntax',
        'outfilesuffix',
        'supports_templates',
        'supports_templates?',
        'init_backend_traits',
        'backend_traits'
      ]
      for (var functionName of converterBackendTraitsFunctionNames) {
        converter['$' + functionName] = ConverterBackendTraits.prototype['$' + functionName]
      }
      converter.$$meta = ConverterBackendTraits
    }
    bridgeHandlesMethodToInstance(converter, converter)
    bridgeComposedMethodToInstance(converter, converter)
    bridgeEqEqMethodToInstance(converter, converter)
    bridgeSendMethodToInstance(converter, converter)
    addRespondToMethod(converter)
    object = converter
  }
  var args = [object].concat(backends)
  return Converter.$register.apply(Converter, args)
}

/**
 * Retrieves the singleton instance of the converter factory.
 *
 * @param {boolean} initialize - instantiate the singleton if it has not yet
 * been instantiated. If this value is false and the singleton has not yet been
 * instantiated, this method returns a fresh instance.
 * @returns {Converter/Factory} an instance of the converter factory.
 * @memberof Converter/Factory
 */
ConverterFactory.getDefault = function (initialize) {
  return this.$default(initialize)
}

/**
 * Create an instance of the converter bound to the specified backend.
 *
 * @param {string} backend - look for a converter bound to this keyword.
 * @param {Object} opts - a JSON of options to pass to the converter (default: {})
 * @returns {Converter} - a converter instance for converting nodes in an Asciidoctor AST.
 * @memberof Converter/Factory
 */
ConverterFactory.prototype.create = function (backend, opts) {
  return this.$create(backend, toHash(opts))
}

/**
 * Get the converter registry.
 * @returns the registry of converter instances or classes keyed by backend name
 * @memberof Converter/Factory
 */
ConverterFactory.getRegistry = function () {
  return fromHash(Converter.$registry())
}

/**
 * Lookup the custom converter registered with this factory to handle the specified backend.
 *
 * @param {string} backend - The {string} backend name.
 * @returns the {Converter} class or instance registered to convert the specified backend or undefined if no match is found.
 * @memberof Converter/Factory
 */
ConverterFactory.for = function (backend) {
  const converter = Converter.$for(backend)
  return converter === Opal.nil ? undefined : converter
}

/*
 * Unregister any custom converter classes that are registered with this factory.
 * Intended for testing only!
 */
ConverterFactory.unregisterAll = function () {
  var internalRegistry = Converter.DefaultFactory.$$cvars['@@registry']
  Converter.DefaultFactory.$$cvars['@@registry'] = toHash({ html5: internalRegistry['$[]']('html5') })
}

// Built-in converter

/**
 * @namespace
 * @module Converter/Html5Converter
 */
var Html5Converter = Opal.Asciidoctor.Converter.Html5Converter

// Alias
Opal.Asciidoctor.Html5Converter = Html5Converter

/**
 * Create a new Html5Converter.
 * @returns {Html5Converter} - a Html5Converter
 * @memberof Converter/Html5Converter
 */
Html5Converter.create = function () {
  return this.$new()
}

/**
 * Converts an {AbstractNode} using the given transform.
 * This method must be implemented by a concrete converter class.
 *
 * @param {AbstractNode} node - The concrete instance of AbstractNode to convert.
 * @param {string} [transform] - An optional String transform that hints at which transformation should be applied to this node.
 * If a transform is not given, the transform is often derived from the value of the {AbstractNode#getNodeName} property. (optional, default: undefined)
 * @param {Object} [opts]- An optional JSON of options hints about how to convert the node. (optional, default: undefined)
 *
 * @returns {string} - the String result.
 * @memberof Converter/Html5Converter
 */
Html5Converter.prototype.convert = function (node, transform, opts) {
  return this.$convert(node, transform, opts)
}


var ASCIIDOCTOR_JS_VERSION = '2.2.6';

  /**
   * Get Asciidoctor.js version number.
   *
   * @memberof Asciidoctor
   * @returns {string} - returns the version number of Asciidoctor.js.
   */
  Asciidoctor.prototype.getVersion = function () {
    return ASCIIDOCTOR_JS_VERSION
  }
  return Opal.Asciidoctor
}))


/***/ }),

/***/ 9560:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/* global globalThis, self */
var globalObject
if (typeof globalThis !== 'undefined') {
  globalObject = globalThis
} else if (typeof self !== 'undefined') {
  globalObject = self
} else if (typeof window !== 'undefined') {
  globalObject = window
} else if (typeof global !== 'undefined') {
  globalObject = global
} else {
  throw new Error('Unable to locate global object. Unsupported runtime.')
}
if (globalObject && globalObject.Opal) {
  // Opal is already loaded!
  var rubyEngineVersion = globalObject.Opal.$$['RUBY_ENGINE_VERSION']
  if (!rubyEngineVersion.startsWith('0.11')) {
    // incompatible version!
    throw new Error('Opal is already loaded and version ' + rubyEngineVersion + ' is not compatible with 0.11. Please upgrade Asciidoctor.js to the latest version.')
  }
} else {
  // load Opal
  __nccwpck_require__(4274)
  __nccwpck_require__(8555)
  __nccwpck_require__(4007)
  __nccwpck_require__(9442)
}

module.exports.s = globalObject.Opal


/***/ }),

/***/ 8555:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __nccwpck_require__) => {

/* Generated by Opal 0.11.99.dev */
Opal.modules["nodejs/kernel"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  Opal.add_stubs(['$warn', '$to_str']);
  
  Opal.exit = process.exit;
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_caller$1, $Kernel_node_require$2;

    
    Opal.const_set($nesting[0], 'NODE_REQUIRE', require);
    
    Opal.def(self, '$caller', $Kernel_caller$1 = function $$caller($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var stack;
      try {
        var err = Error("my error");
        throw err;
      } catch(e) {
        stack = e.stack;
      }
      return stack.$split("\n").slice(3);
    ;
    }, $Kernel_caller$1.$$arity = -1);
    
    Opal.def(self, '$node_require', $Kernel_node_require$2 = function $$node_require(path) {
      var self = this;

      
      self.$warn("[DEPRECATION] node_require is deprecated. Please use `require('module')` instead.");
      return $$($nesting, 'NODE_REQUIRE')(path.$to_str());
    }, $Kernel_node_require$2.$$arity = 1);
  })($nesting[0], $nesting);
  return Opal.const_set($nesting[0], 'ARGV', process.argv.slice(2));
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["nodejs/file"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$raise', '$warn', '$const_get', '$new', '$const_defined?', '$const_set', '$include', '$size', '$respond_to?', '$path', '$join', '$call', '$exist?', '$realpath', '$!=', '$close', '$to_path', '$pwd', '$to_str', '$include?', '$delete', '$match?', '$sub', '$attr_reader', '$to_a', '$each_line', '$to_enum', '$read', '$chomp']);
  
  
  var warnings = {}, errno_code, errno_codes = [
    'EACCES',
    'EISDIR',
    'EMFILE',
    'ENOENT',
    'EPERM'
  ];

  function handle_unsupported_feature(message) {
    switch (Opal.config.unsupported_features_severity) {
    case 'error':
      $$($nesting, 'Kernel').$raise($$($nesting, 'NotImplementedError'), message)
      break;
    case 'warning':
      warn(message)
      break;
    default: // ignore
      // noop
    }
  }
  function warn(string) {
    if (warnings[string]) {
      return;
    }
    warnings[string] = true;
    self.$warn(string);
  }
  function is_utf8(bytes) {
    var i = 0;
    while (i < bytes.length) {
      if ((// ASCII
        bytes[i] === 0x09 ||
        bytes[i] === 0x0A ||
        bytes[i] === 0x0D ||
        (0x20 <= bytes[i] && bytes[i] <= 0x7E)
      )
      ) {
        i += 1;
        continue;
      }

      if ((// non-overlong 2-byte
        (0xC2 <= bytes[i] && bytes[i] <= 0xDF) &&
        (0x80 <= bytes[i + 1] && bytes[i + 1] <= 0xBF)
      )
      ) {
        i += 2;
        continue;
      }

      if ((// excluding overlongs
          bytes[i] === 0xE0 &&
          (0xA0 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
          (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF)
        ) ||
        (// straight 3-byte
          ((0xE1 <= bytes[i] && bytes[i] <= 0xEC) ||
            bytes[i] === 0xEE ||
            bytes[i] === 0xEF) &&
          (0x80 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
          (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF)
        ) ||
        (// excluding surrogates
          bytes[i] === 0xED &&
          (0x80 <= bytes[i + 1] && bytes[i + 1] <= 0x9F) &&
          (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF)
        )
      ) {
        i += 3;
        continue;
      }

      if ((// planes 1-3
          bytes[i] === 0xF0 &&
          (0x90 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
          (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF) &&
          (0x80 <= bytes[i + 3] && bytes[i + 3] <= 0xBF)
        ) ||
        (// planes 4-15
          (0xF1 <= bytes[i] && bytes[i] <= 0xF3) &&
          (0x80 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
          (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF) &&
          (0x80 <= bytes[i + 3] && bytes[i + 3] <= 0xBF)
        ) ||
        (// plane 16
          bytes[i] === 0xF4 &&
          (0x80 <= bytes[i + 1] && bytes[i + 1] <= 0x8F) &&
          (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF) &&
          (0x80 <= bytes[i + 3] && bytes[i + 3] <= 0xBF)
        )
      ) {
        i += 4;
        continue;
      }

      return false;
    }

    return true;
  }
  function executeIOAction(action) {
    try {
      return action();
    } catch (error) {
      if (errno_codes.indexOf(error.code) >= 0) {
        var error_class = $$($nesting, 'Errno').$const_get(error.code)
        throw (error_class).$new(error.message);
      }
      throw error;
    }
  }

  for(var i = 0, ii = errno_codes.length; i < ii; i++) {
    errno_code = errno_codes[i];
    if (!$$($nesting, 'Errno')['$const_defined?'](errno_code)) {
      $$($nesting, 'Errno').$const_set(errno_code, $$($nesting, 'Class').$new($$($nesting, 'SystemCallError')))
    }
  }
;
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), $File_read$1, $File_write$2, $File_exist$ques$3, $File_realpath$4, $File_join$5, $File_directory$ques$6, $File_file$ques$7, $File_readable$ques$8, $File_size$9, $File_open$10, $File_stat$11, $File_mtime$12, $File_symlink$ques$13, $File_absolute_path$14, $File_initialize$15, $File_read$16, $File_readlines$17, $File_each_line$18, $File_write$19, $File_flush$20, $File_close$21, $File_mtime$22;
    if (self.__fs__ == null) self.__fs__ = nil;
    if (self.__path__ == null) self.__path__ = nil;
    if (self.__util__ == null) self.__util__ = nil;

    self.$$prototype.eof = self.$$prototype.binary_flag = self.$$prototype.path = self.$$prototype.fd = nil;
    
    self.$include($$$($$$('::', 'IO'), 'Writable'));
    self.$include($$$($$$('::', 'IO'), 'Readable'));
    self.__fs__ = __nccwpck_require__(7147);
    self.__path__ = __nccwpck_require__(1017);
    self.__util__ = __nccwpck_require__(3837);
    var __fs__ = self.__fs__;
    var __path__ = self.__path__;
    var __util__ = self.__util__;
    var __TextEncoder__ = typeof TextEncoder !== 'undefined' ? TextEncoder : __util__.TextEncoder;
    var __TextDecoder__ = typeof TextDecoder !== 'undefined' ? TextDecoder : __util__.TextDecoder;
    var __utf8TextDecoder__ = new __TextDecoder__('utf8');
    var __textEncoder__ = new __TextEncoder__();
    if ($truthy(__path__.sep !== $$($nesting, 'Separator'))) {
      Opal.const_set($nesting[0], 'ALT_SEPARATOR', __path__.sep)};
    Opal.defs(self, '$read', $File_read$1 = function $$read(path) {
      var self = this;

      return executeIOAction(function(){return __fs__.readFileSync(path).toString()})
    }, $File_read$1.$$arity = 1);
    Opal.defs(self, '$write', $File_write$2 = function $$write(path, data) {
      var self = this;

      
      executeIOAction(function(){return __fs__.writeFileSync(path, data)});
      return data.$size();
    }, $File_write$2.$$arity = 2);
    Opal.defs(self, '$exist?', $File_exist$ques$3 = function(path) {
      var self = this;

      
      if ($truthy(path['$respond_to?']("path"))) {
        path = path.$path()};
      return executeIOAction(function(){return __fs__.existsSync(path)});
    }, $File_exist$ques$3.$$arity = 1);
    Opal.defs(self, '$realpath', $File_realpath$4 = function $$realpath(pathname, dir_string, cache) {
      var $iter = $File_realpath$4.$$p, block = $iter || nil, self = this;

      if ($iter) $File_realpath$4.$$p = null;
      
      
      if ($iter) $File_realpath$4.$$p = null;;
      
      if (dir_string == null) {
        dir_string = nil;
      };
      
      if (cache == null) {
        cache = nil;
      };
      if ($truthy(dir_string)) {
        pathname = self.$join(dir_string, pathname)};
      if ((block !== nil)) {
        
        __fs__.realpath(pathname, cache, function(error, realpath){
          if (error) Opal.IOError.$new(error.message)
          else block.$call(realpath)
        })
        
      } else {
        return executeIOAction(function(){return __fs__.realpathSync(pathname, cache)})
      };
    }, $File_realpath$4.$$arity = -2);
    Opal.defs(self, '$join', $File_join$5 = function $$join($a) {
      var $post_args, paths, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      paths = $post_args;;
      return __path__.posix.join.apply(__path__, paths);
    }, $File_join$5.$$arity = -1);
    Opal.defs(self, '$directory?', $File_directory$ques$6 = function(path) {
      var self = this, result = nil, realpath = nil;

      
      if ($truthy(self['$exist?'](path))) {
      } else {
        return false
      };
      result = executeIOAction(function(){return !!__fs__.lstatSync(path).isDirectory()});
      if ($truthy(result)) {
      } else {
        
        realpath = self.$realpath(path);
        if ($truthy(realpath['$!='](path))) {
          result = executeIOAction(function(){return !!__fs__.lstatSync(realpath).isDirectory()})};
      };
      return result;
    }, $File_directory$ques$6.$$arity = 1);
    Opal.defs(self, '$file?', $File_file$ques$7 = function(path) {
      var self = this, result = nil, realpath = nil;

      
      if ($truthy(self['$exist?'](path))) {
      } else {
        return false
      };
      result = executeIOAction(function(){return !!__fs__.lstatSync(path).isFile()});
      if ($truthy(result)) {
      } else {
        
        realpath = self.$realpath(path);
        if ($truthy(realpath['$!='](path))) {
          result = executeIOAction(function(){return !!__fs__.lstatSync(realpath).isFile()})};
      };
      return result;
    }, $File_file$ques$7.$$arity = 1);
    Opal.defs(self, '$readable?', $File_readable$ques$8 = function(path) {
      var self = this;

      
      if ($truthy(self['$exist?'](path))) {
      } else {
        return false
      };
      return "" + "\n" + "        try {\n" + "          __fs__.accessSync(path, __fs__.R_OK);\n" + "          return true;\n" + "        } catch (error) {\n" + "          return false;\n" + "        }\n" + "      ";
    }, $File_readable$ques$8.$$arity = 1);
    Opal.defs(self, '$size', $File_size$9 = function $$size(path) {
      var self = this;

      return executeIOAction(function(){return __fs__.lstatSync(path).size});
    }, $File_size$9.$$arity = 1);
    Opal.defs(self, '$open', $File_open$10 = function $$open(path, mode) {
      var $iter = $File_open$10.$$p, $yield = $iter || nil, self = this, file = nil;

      if ($iter) $File_open$10.$$p = null;
      
      
      if (mode == null) {
        mode = "r";
      };
      file = self.$new(path, mode);
      if (($yield !== nil)) {
        
        return (function() { try {
        return Opal.yield1($yield, file);
        } finally {
          file.$close()
        }; })();
      } else {
        return file
      };
    }, $File_open$10.$$arity = -2);
    Opal.defs(self, '$stat', $File_stat$11 = function $$stat(path) {
      var self = this;

      
      if ($truthy(path['$respond_to?']("path"))) {
        path = path.$path()};
      return $$$($$($nesting, 'File'), 'Stat').$new(path);
    }, $File_stat$11.$$arity = 1);
    Opal.defs(self, '$mtime', $File_mtime$12 = function $$mtime(path) {
      var self = this;

      return executeIOAction(function(){return __fs__.statSync(path).mtime})
    }, $File_mtime$12.$$arity = 1);
    Opal.defs(self, '$symlink?', $File_symlink$ques$13 = function(path) {
      var self = this;

      return executeIOAction(function(){return __fs__.lstatSync(path).isSymbolicLink()})
    }, $File_symlink$ques$13.$$arity = 1);
    Opal.defs(self, '$absolute_path', $File_absolute_path$14 = function $$absolute_path(path, basedir) {
      var $a, self = this;

      
      
      if (basedir == null) {
        basedir = nil;
      };
      path = (function() {if ($truthy(path['$respond_to?']("to_path"))) {
        return path.$to_path()
      } else {
        return path
      }; return nil; })();
      basedir = ($truthy($a = basedir) ? $a : $$($nesting, 'Dir').$pwd());
      return __path__.normalize(__path__.resolve(basedir.$to_str(), path.$to_str())).split(__path__.sep).join(__path__.posix.sep);
    }, $File_absolute_path$14.$$arity = -2);
    
    Opal.def(self, '$initialize', $File_initialize$15 = function $$initialize(path, flags) {
      var self = this, encoding_option_rx = nil;

      
      
      if (flags == null) {
        flags = "r";
      };
      self.binary_flag = flags['$include?']("b");
      flags = flags.$delete("b");
      encoding_option_rx = /:(.*)/;
      if ($truthy(encoding_option_rx['$match?'](flags))) {
        
        handle_unsupported_feature("Encoding option (:encoding) is unsupported by Node.js openSync method and will be removed.");
        flags = flags.$sub(encoding_option_rx, "");};
      self.path = path;
      self.flags = flags;
      return (self.fd = executeIOAction(function(){return __fs__.openSync(path, flags)}));
    }, $File_initialize$15.$$arity = -2);
    self.$attr_reader("path");
    
    Opal.def(self, '$read', $File_read$16 = function $$read() {
      var self = this, res = nil;

      if ($truthy(self.eof)) {
        return ""
      } else {
        
        if ($truthy(self.binary_flag)) {
          
          
          var buf = executeIOAction(function(){return __fs__.readFileSync(self.path)})
          var content
          if (is_utf8(buf)) {
            content = buf.toString('utf8')
          } else {
            // coerce to utf8
            content = __utf8TextDecoder__.decode(__textEncoder__.encode(buf.toString('binary')))
          }
        ;
          res = content;
        } else {
          res = executeIOAction(function(){return __fs__.readFileSync(self.path).toString('utf8')})
        };
        self.eof = true;
        self.lineno = res.$size();
        return res;
      }
    }, $File_read$16.$$arity = 0);
    
    Opal.def(self, '$readlines', $File_readlines$17 = function $$readlines(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      return self.$each_line(separator).$to_a();
    }, $File_readlines$17.$$arity = -1);
    
    Opal.def(self, '$each_line', $File_each_line$18 = function $$each_line(separator) {
      var $iter = $File_each_line$18.$$p, block = $iter || nil, self = this, lines = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if ($iter) $File_each_line$18.$$p = null;
      
      
      if ($iter) $File_each_line$18.$$p = null;;
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      if ($truthy(self.eof)) {
        return (function() {if ((block !== nil)) {
          return self
        } else {
          return [].$to_enum()
        }; return nil; })()};
      if ((block !== nil)) {
        
        lines = $$($nesting, 'File').$read(self.path);
        
        self.eof = false;
        self.lineno = 0;
        var chomped  = lines.$chomp(),
            trailing = lines.length != chomped.length,
            splitted = chomped.split(separator);
        for (var i = 0, length = splitted.length; i < length; i++) {
          self.lineno += 1;
          if (i < length - 1 || trailing) {
            Opal.yield1(block, splitted[i] + separator);
          }
          else {
            Opal.yield1(block, splitted[i]);
          }
        }
        self.eof = true;
      ;
        return self;
      } else {
        return self.$read().$each_line(separator)
      };
    }, $File_each_line$18.$$arity = -1);
    
    Opal.def(self, '$write', $File_write$19 = function $$write(string) {
      var self = this;

      return executeIOAction(function(){return __fs__.writeSync(self.fd, string)})
    }, $File_write$19.$$arity = 1);
    
    Opal.def(self, '$flush', $File_flush$20 = function $$flush() {
      var self = this;

      return executeIOAction(function(){return __fs__.fsyncSync(self.fd)})
    }, $File_flush$20.$$arity = 0);
    
    Opal.def(self, '$close', $File_close$21 = function $$close() {
      var self = this;

      return executeIOAction(function(){return __fs__.closeSync(self.fd)})
    }, $File_close$21.$$arity = 0);
    return (Opal.def(self, '$mtime', $File_mtime$22 = function $$mtime() {
      var self = this;

      return executeIOAction(function(){return __fs__.statSync(self.path).mtime})
    }, $File_mtime$22.$$arity = 0), nil) && 'mtime';
  })($nesting[0], $$($nesting, 'IO'), $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Stat');

    var $nesting = [self].concat($parent_nesting), $Stat_initialize$23, $Stat_file$ques$24, $Stat_mtime$25;
    if (self.__fs__ == null) self.__fs__ = nil;

    self.$$prototype.path = nil;
    
    self.__fs__ = __nccwpck_require__(7147);
    var __fs__ = self.__fs__;
    
    Opal.def(self, '$initialize', $Stat_initialize$23 = function $$initialize(path) {
      var self = this;

      return (self.path = path)
    }, $Stat_initialize$23.$$arity = 1);
    
    Opal.def(self, '$file?', $Stat_file$ques$24 = function() {
      var self = this;

      return executeIOAction(function(){return __fs__.statSync(self.path).isFile()})
    }, $Stat_file$ques$24.$$arity = 0);
    return (Opal.def(self, '$mtime', $Stat_mtime$25 = function $$mtime() {
      var self = this;

      return executeIOAction(function(){return __fs__.statSync(self.path).mtime})
    }, $Stat_mtime$25.$$arity = 0), nil) && 'mtime';
  })($$($nesting, 'File'), null, $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["nodejs/dir"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$respond_to?', '$flat_map', '$to_path', '$coerce_to!']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Dir');

    var $nesting = [self].concat($parent_nesting);
    if (self.__glob__ == null) self.__glob__ = nil;
    if (self.__fs__ == null) self.__fs__ = nil;
    if (self.__path__ == null) self.__path__ = nil;
    if (self.__os__ == null) self.__os__ = nil;

    
    self.__glob__ = __nccwpck_require__(1957);
    self.__fs__ = __nccwpck_require__(7147);
    self.__path__ = __nccwpck_require__(1017);
    self.__os__ = __nccwpck_require__(2037);
    var __glob__ = self.__glob__;
    var __fs__ = self.__fs__;
    var __path__ = self.__path__;
    var __os__ = self.__os__;
    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$$1, $pwd$2, $home$3, $chdir$4, $mkdir$5, $entries$6, $glob$7;

      
      
      Opal.def(self, '$[]', $$$1 = function(glob) {
        var self = this;

        return __glob__.sync(glob)
      }, $$$1.$$arity = 1);
      
      Opal.def(self, '$pwd', $pwd$2 = function $$pwd() {
        var self = this;

        return process.cwd().split(__path__.sep).join(__path__.posix.sep);
      }, $pwd$2.$$arity = 0);
      
      Opal.def(self, '$home', $home$3 = function $$home() {
        var self = this;

        return __os__.homedir();
      }, $home$3.$$arity = 0);
      
      Opal.def(self, '$chdir', $chdir$4 = function $$chdir(path) {
        var self = this;

        return process.chdir(path)
      }, $chdir$4.$$arity = 1);
      
      Opal.def(self, '$mkdir', $mkdir$5 = function $$mkdir(path) {
        var self = this;

        return __fs__.mkdirSync(path)
      }, $mkdir$5.$$arity = 1);
      
      Opal.def(self, '$entries', $entries$6 = function $$entries(dirname) {
        var self = this;

        
        var result = [];
        var entries = __fs__.readdirSync(dirname);
        for (var i = 0, ii = entries.length; i < ii; i++) {
          result.push(entries[i]);
        }
        return result;
      
      }, $entries$6.$$arity = 1);
      
      Opal.def(self, '$glob', $glob$7 = function $$glob(pattern) {
        var $$8, self = this;

        
        if ($truthy(pattern['$respond_to?']("each"))) {
        } else {
          pattern = [pattern]
        };
        return $send(pattern, 'flat_map', [], ($$8 = function(subpattern){var self = $$8.$$s || this;

        
          
          if (subpattern == null) {
            subpattern = nil;
          };
          if ($truthy(subpattern['$respond_to?']("to_path"))) {
            subpattern = subpattern.$to_path()};
          subpattern = $$($nesting, 'Opal')['$coerce_to!'](subpattern, $$($nesting, 'String'), "to_str");
          return __glob__.sync(subpattern);;}, $$8.$$s = self, $$8.$$arity = 1, $$8));
      }, $glob$7.$$arity = 1);
      return Opal.alias(self, "getwd", "pwd");
    })(Opal.get_singleton_class(self), $nesting);
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["nodejs/io"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var $$5, $$6, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $lambda = Opal.lambda, $send = Opal.send, $writer = nil;

  Opal.add_stubs(['$attr_reader', '$write', '$read', '$write_proc=', '$-', '$tty=']);
  
  
  function executeIOAction(action) {
    try {
      return action();
    } catch (error) {
      if (error.code === 'EACCES' ||
          error.code === 'EISDIR' ||
          error.code === 'EMFILE' ||
          error.code === 'ENOENT' ||
          error.code === 'EPERM') {
        throw Opal.IOError.$new(error.message)
      }
      throw error;
    }
  }
;
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IO');

    var $nesting = [self].concat($parent_nesting), $IO_initialize$1, $IO_write$2, $IO_read$3, $IO_binread$4;
    if (self.__fs__ == null) self.__fs__ = nil;

    
    self.__fs__ = __nccwpck_require__(7147);
    var __fs__ = self.__fs__;
    self.$attr_reader("eof");
    self.$attr_reader("lineno");
    
    Opal.def(self, '$initialize', $IO_initialize$1 = function $$initialize() {
      var self = this;

      
      self.eof = false;
      return (self.lineno = 0);
    }, $IO_initialize$1.$$arity = 0);
    Opal.defs(self, '$write', $IO_write$2 = function $$write(path, data) {
      var self = this;

      return $$($nesting, 'File').$write(path, data)
    }, $IO_write$2.$$arity = 2);
    Opal.defs(self, '$read', $IO_read$3 = function $$read(path) {
      var self = this;

      return $$($nesting, 'File').$read(path)
    }, $IO_read$3.$$arity = 1);
    return (Opal.defs(self, '$binread', $IO_binread$4 = function $$binread(path) {
      var self = this;

      return executeIOAction(function(){return __fs__.readFileSync(path).toString('binary')})
    }, $IO_binread$4.$$arity = 1), nil) && 'binread';
  })($nesting[0], null, $nesting);
  
  $writer = [$lambda(($$5 = function(string){var self = $$5.$$s || this;

  
    
    if (string == null) {
      string = nil;
    };
    return process.stdout.write(string);;}, $$5.$$s = self, $$5.$$arity = 1, $$5))];
  $send($$($nesting, 'STDOUT'), 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [$lambda(($$6 = function(string){var self = $$6.$$s || this;

  
    
    if (string == null) {
      string = nil;
    };
    return process.stderr.write(string);;}, $$6.$$s = self, $$6.$$arity = 1, $$6))];
  $send($$($nesting, 'STDERR'), 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [true];
  $send($$($nesting, 'STDOUT'), 'tty=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [true];
  $send($$($nesting, 'STDERR'), 'tty=', Opal.to_a($writer));
  return $writer[$rb_minus($writer["length"], 1)];;
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["nodejs/open-uri"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'OpenURI');

    var $nesting = [self].concat($parent_nesting), $OpenURI_request$1, $OpenURI_data$2;
    if (self.__xmlhttprequest__ == null) self.__xmlhttprequest__ = nil;

    
    self.__xmlhttprequest__ = __nccwpck_require__(4315);
    var __XMLHttpRequest__ = self.__xmlhttprequest__.XMLHttpRequest;
    Opal.defs(self, '$request', $OpenURI_request$1 = function $$request(uri) {
      var self = this;

      
      var xhr = new __XMLHttpRequest__();
      xhr.open('GET', uri, false);
      xhr.responseType = 'arraybuffer';
      xhr.send();
      return xhr;
    
    }, $OpenURI_request$1.$$arity = 1);
    Opal.defs(self, '$data', $OpenURI_data$2 = function $$data(req) {
      var self = this;

      
      var arrayBuffer = req.response;
      var byteArray = new Uint8Array(arrayBuffer);
      var result = []
      for (var i = 0; i < byteArray.byteLength; i++) {
        result.push(byteArray[i]);
      }
      return result;
    
    }, $OpenURI_data$2.$$arity = 1);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/comparable"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$===', '$>', '$<', '$equal?', '$<=>', '$normalize', '$raise', '$class']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Comparable');

    var $nesting = [self].concat($parent_nesting), $Comparable_normalize$1, $Comparable_$eq_eq$2, $Comparable_$gt$3, $Comparable_$gt_eq$4, $Comparable_$lt$5, $Comparable_$lt_eq$6, $Comparable_between$ques$7, $Comparable_clamp$8;

    
    Opal.defs(self, '$normalize', $Comparable_normalize$1 = function $$normalize(what) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](what))) {
        return what};
      if ($truthy($rb_gt(what, 0))) {
        return 1};
      if ($truthy($rb_lt(what, 0))) {
        return -1};
      return 0;
    }, $Comparable_normalize$1.$$arity = 1);
    
    Opal.def(self, '$==', $Comparable_$eq_eq$2 = function(other) {
      var self = this, cmp = nil;

      try {
        
        if ($truthy(self['$equal?'](other))) {
          return true};
        
      if (self["$<=>"] == Opal.Kernel["$<=>"]) {
        return false;
      }

      // check for infinite recursion
      if (self.$$comparable) {
        delete self.$$comparable;
        return false;
      }
    ;
        if ($truthy((cmp = self['$<=>'](other)))) {
        } else {
          return false
        };
        return $$($nesting, 'Comparable').$normalize(cmp) == 0;
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
          try {
            return false
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Comparable_$eq_eq$2.$$arity = 1);
    
    Opal.def(self, '$>', $Comparable_$gt$3 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
      };
      return $$($nesting, 'Comparable').$normalize(cmp) > 0;
    }, $Comparable_$gt$3.$$arity = 1);
    
    Opal.def(self, '$>=', $Comparable_$gt_eq$4 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
      };
      return $$($nesting, 'Comparable').$normalize(cmp) >= 0;
    }, $Comparable_$gt_eq$4.$$arity = 1);
    
    Opal.def(self, '$<', $Comparable_$lt$5 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
      };
      return $$($nesting, 'Comparable').$normalize(cmp) < 0;
    }, $Comparable_$lt$5.$$arity = 1);
    
    Opal.def(self, '$<=', $Comparable_$lt_eq$6 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
      };
      return $$($nesting, 'Comparable').$normalize(cmp) <= 0;
    }, $Comparable_$lt_eq$6.$$arity = 1);
    
    Opal.def(self, '$between?', $Comparable_between$ques$7 = function(min, max) {
      var self = this;

      
      if ($rb_lt(self, min)) {
        return false};
      if ($rb_gt(self, max)) {
        return false};
      return true;
    }, $Comparable_between$ques$7.$$arity = 2);
    
    Opal.def(self, '$clamp', $Comparable_clamp$8 = function $$clamp(min, max) {
      var self = this, cmp = nil;

      
      cmp = min['$<=>'](max);
      if ($truthy(cmp)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (min.$class()) + " with " + (max.$class()) + " failed")
      };
      if ($truthy($rb_gt($$($nesting, 'Comparable').$normalize(cmp), 0))) {
        self.$raise($$($nesting, 'ArgumentError'), "min argument must be smaller than max argument")};
      if ($truthy($rb_lt($$($nesting, 'Comparable').$normalize(self['$<=>'](min)), 0))) {
        return min};
      if ($truthy($rb_gt($$($nesting, 'Comparable').$normalize(self['$<=>'](max)), 0))) {
        return max};
      return self;
    }, $Comparable_clamp$8.$$arity = 2);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["pathname"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $module = Opal.module;

  Opal.add_stubs(['$require', '$include', '$quote', '$===', '$to_s', '$path', '$respond_to?', '$to_path', '$is_a?', '$nil?', '$raise', '$class', '$==', '$attr_reader', '$!', '$relative?', '$chop_basename', '$basename', '$=~', '$new', '$source', '$[]', '$rindex', '$sub', '$absolute?', '$expand_path', '$plus', '$unshift', '$length', '$!=', '$empty?', '$first', '$shift', '$+', '$join', '$dirname', '$pop', '$reverse_each', '$directory?', '$extname', '$<=>', '$nonzero?', '$proc', '$casecmp', '$cleanpath', '$inspect', '$include?', '$fill', '$map', '$entries']);
  
  self.$require("corelib/comparable");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Pathname');

    var $nesting = [self].concat($parent_nesting), $Pathname_initialize$1, $Pathname_$eq_eq$2, $Pathname_absolute$ques$3, $Pathname_relative$ques$4, $Pathname_chop_basename$5, $Pathname_root$ques$6, $Pathname_parent$7, $Pathname_sub$8, $Pathname_cleanpath$9, $Pathname_to_path$10, $Pathname_hash$11, $Pathname_expand_path$12, $Pathname_$plus$13, $Pathname_plus$14, $Pathname_join$15, $Pathname_split$17, $Pathname_dirname$18, $Pathname_basename$19, $Pathname_directory$ques$20, $Pathname_extname$21, $Pathname_$lt_eq_gt$22, $Pathname$23, $Pathname$24, $Pathname_relative_path_from$25, $Pathname_entries$26;

    self.$$prototype.path = nil;
    
    self.$include($$($nesting, 'Comparable'));
    Opal.const_set($nesting[0], 'SEPARATOR_PAT', new RegExp($$($nesting, 'Regexp').$quote($$$($$($nesting, 'File'), 'SEPARATOR'))));
    
    Opal.def(self, '$initialize', $Pathname_initialize$1 = function $$initialize(path) {
      var self = this;

      
      if ($truthy($$($nesting, 'Pathname')['$==='](path))) {
        self.path = path.$path().$to_s()
      } else if ($truthy(path['$respond_to?']("to_path"))) {
        self.path = path.$to_path()
      } else if ($truthy(path['$is_a?']($$($nesting, 'String')))) {
        self.path = path
      } else if ($truthy(path['$nil?']())) {
        self.$raise($$($nesting, 'TypeError'), "no implicit conversion of nil into String")
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + (path.$class()) + " into String")
      };
      if (self.path['$==']("\u0000")) {
        return self.$raise($$($nesting, 'ArgumentError'))
      } else {
        return nil
      };
    }, $Pathname_initialize$1.$$arity = 1);
    self.$attr_reader("path");
    
    Opal.def(self, '$==', $Pathname_$eq_eq$2 = function(other) {
      var self = this;

      return other.$path()['$=='](self.path)
    }, $Pathname_$eq_eq$2.$$arity = 1);
    
    Opal.def(self, '$absolute?', $Pathname_absolute$ques$3 = function() {
      var self = this;

      return self['$relative?']()['$!']()
    }, $Pathname_absolute$ques$3.$$arity = 0);
    
    Opal.def(self, '$relative?', $Pathname_relative$ques$4 = function() {
      var $a, $b, $c, self = this, path = nil, r = nil;

      
      path = self.path;
      while ($truthy((r = self.$chop_basename(path)))) {
        $c = r, $b = Opal.to_ary($c), (path = ($b[0] == null ? nil : $b[0])), $c
      };
      return path['$==']("");
    }, $Pathname_relative$ques$4.$$arity = 0);
    
    Opal.def(self, '$chop_basename', $Pathname_chop_basename$5 = function $$chop_basename(path) {
      var self = this, base = nil;

      
      base = $$($nesting, 'File').$basename(path);
      if ($truthy($$($nesting, 'Regexp').$new("" + "^" + ($$$($$($nesting, 'Pathname'), 'SEPARATOR_PAT').$source()) + "?$")['$=~'](base))) {
        return nil
      } else {
        return [path['$[]'](0, path.$rindex(base)), base]
      };
    }, $Pathname_chop_basename$5.$$arity = 1);
    
    Opal.def(self, '$root?', $Pathname_root$ques$6 = function() {
      var self = this;

      return self.path['$==']("/")
    }, $Pathname_root$ques$6.$$arity = 0);
    
    Opal.def(self, '$parent', $Pathname_parent$7 = function $$parent() {
      var self = this, new_path = nil;

      
      new_path = self.path.$sub(/\/([^\/]+\/?$)/, "");
      if (new_path['$==']("")) {
        new_path = (function() {if ($truthy(self['$absolute?']())) {
          return "/"
        } else {
          return "."
        }; return nil; })()};
      return $$($nesting, 'Pathname').$new(new_path);
    }, $Pathname_parent$7.$$arity = 0);
    
    Opal.def(self, '$sub', $Pathname_sub$8 = function $$sub($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $$($nesting, 'Pathname').$new($send(self.path, 'sub', Opal.to_a(args)));
    }, $Pathname_sub$8.$$arity = -1);
    
    Opal.def(self, '$cleanpath', $Pathname_cleanpath$9 = function $$cleanpath() {
      var self = this;

      return Opal.normalize(self.path)
    }, $Pathname_cleanpath$9.$$arity = 0);
    
    Opal.def(self, '$to_path', $Pathname_to_path$10 = function $$to_path() {
      var self = this;

      return self.path
    }, $Pathname_to_path$10.$$arity = 0);
    
    Opal.def(self, '$hash', $Pathname_hash$11 = function $$hash() {
      var self = this;

      return self.path
    }, $Pathname_hash$11.$$arity = 0);
    
    Opal.def(self, '$expand_path', $Pathname_expand_path$12 = function $$expand_path() {
      var self = this;

      return $$($nesting, 'Pathname').$new($$($nesting, 'File').$expand_path(self.path))
    }, $Pathname_expand_path$12.$$arity = 0);
    
    Opal.def(self, '$+', $Pathname_$plus$13 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Pathname')['$==='](other))) {
      } else {
        other = $$($nesting, 'Pathname').$new(other)
      };
      return $$($nesting, 'Pathname').$new(self.$plus(self.path, other.$to_s()));
    }, $Pathname_$plus$13.$$arity = 1);
    
    Opal.def(self, '$plus', $Pathname_plus$14 = function $$plus(path1, path2) {
      var $a, $b, $c, self = this, prefix2 = nil, index_list2 = nil, basename_list2 = nil, r2 = nil, basename2 = nil, prefix1 = nil, r1 = nil, basename1 = nil, suffix2 = nil;

      
      prefix2 = path2;
      index_list2 = [];
      basename_list2 = [];
      while ($truthy((r2 = self.$chop_basename(prefix2)))) {
        
        $c = r2, $b = Opal.to_ary($c), (prefix2 = ($b[0] == null ? nil : $b[0])), (basename2 = ($b[1] == null ? nil : $b[1])), $c;
        index_list2.$unshift(prefix2.$length());
        basename_list2.$unshift(basename2);
      };
      if ($truthy(prefix2['$!='](""))) {
        return path2};
      prefix1 = path1;
      while ($truthy(true)) {
        
        while ($truthy(($truthy($c = basename_list2['$empty?']()['$!']()) ? basename_list2.$first()['$=='](".") : $c))) {
          
          index_list2.$shift();
          basename_list2.$shift();
        };
        if ($truthy((r1 = self.$chop_basename(prefix1)))) {
        } else {
          break;
        };
        $c = r1, $b = Opal.to_ary($c), (prefix1 = ($b[0] == null ? nil : $b[0])), (basename1 = ($b[1] == null ? nil : $b[1])), $c;
        if (basename1['$=='](".")) {
          continue;};
        if ($truthy(($truthy($b = ($truthy($c = basename1['$==']("..")) ? $c : basename_list2['$empty?']())) ? $b : basename_list2.$first()['$!=']("..")))) {
          
          prefix1 = $rb_plus(prefix1, basename1);
          break;;};
        index_list2.$shift();
        basename_list2.$shift();
      };
      r1 = self.$chop_basename(prefix1);
      if ($truthy(($truthy($a = r1['$!']()) ? new RegExp($$($nesting, 'SEPARATOR_PAT'))['$=~']($$($nesting, 'File').$basename(prefix1)) : $a))) {
        while ($truthy(($truthy($b = basename_list2['$empty?']()['$!']()) ? basename_list2.$first()['$==']("..") : $b))) {
          
          index_list2.$shift();
          basename_list2.$shift();
        }};
      if ($truthy(basename_list2['$empty?']()['$!']())) {
        
        suffix2 = path2['$[]'](Opal.Range.$new(index_list2.$first(), -1, false));
        if ($truthy(r1)) {
          return $$($nesting, 'File').$join(prefix1, suffix2)
        } else {
          return $rb_plus(prefix1, suffix2)
        };
      } else if ($truthy(r1)) {
        return prefix1
      } else {
        return $$($nesting, 'File').$dirname(prefix1)
      };
    }, $Pathname_plus$14.$$arity = 2);
    
    Opal.def(self, '$join', $Pathname_join$15 = function $$join($a) {try {

      var $post_args, args, $$16, self = this, result = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(args['$empty?']())) {
        return self};
      result = args.$pop();
      if ($truthy($$($nesting, 'Pathname')['$==='](result))) {
      } else {
        result = $$($nesting, 'Pathname').$new(result)
      };
      if ($truthy(result['$absolute?']())) {
        return result};
      $send(args, 'reverse_each', [], ($$16 = function(arg){var self = $$16.$$s || this;

      
        
        if (arg == null) {
          arg = nil;
        };
        if ($truthy($$($nesting, 'Pathname')['$==='](arg))) {
        } else {
          arg = $$($nesting, 'Pathname').$new(arg)
        };
        result = $rb_plus(arg, result);
        if ($truthy(result['$absolute?']())) {
          Opal.ret(result)
        } else {
          return nil
        };}, $$16.$$s = self, $$16.$$arity = 1, $$16));
      return $rb_plus(self, result);
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Pathname_join$15.$$arity = -1);
    
    Opal.def(self, '$split', $Pathname_split$17 = function $$split() {
      var self = this;

      return [self.$dirname(), self.$basename()]
    }, $Pathname_split$17.$$arity = 0);
    
    Opal.def(self, '$dirname', $Pathname_dirname$18 = function $$dirname() {
      var self = this;

      return $$($nesting, 'Pathname').$new($$($nesting, 'File').$dirname(self.path))
    }, $Pathname_dirname$18.$$arity = 0);
    
    Opal.def(self, '$basename', $Pathname_basename$19 = function $$basename() {
      var self = this;

      return $$($nesting, 'Pathname').$new($$($nesting, 'File').$basename(self.path))
    }, $Pathname_basename$19.$$arity = 0);
    
    Opal.def(self, '$directory?', $Pathname_directory$ques$20 = function() {
      var self = this;

      return $$($nesting, 'File')['$directory?'](self.path)
    }, $Pathname_directory$ques$20.$$arity = 0);
    
    Opal.def(self, '$extname', $Pathname_extname$21 = function $$extname() {
      var self = this;

      return $$($nesting, 'File').$extname(self.path)
    }, $Pathname_extname$21.$$arity = 0);
    
    Opal.def(self, '$<=>', $Pathname_$lt_eq_gt$22 = function(other) {
      var self = this;

      return self.$path()['$<=>'](other.$path())
    }, $Pathname_$lt_eq_gt$22.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    Opal.alias(self, "===", "==");
    Opal.alias(self, "to_str", "to_path");
    Opal.alias(self, "to_s", "to_path");
    Opal.const_set($nesting[0], 'SAME_PATHS', (function() {if ($truthy($$$($$($nesting, 'File'), 'FNM_SYSCASE')['$nonzero?']())) {
      return $send(self, 'proc', [], ($Pathname$23 = function(a, b){var self = $Pathname$23.$$s || this;

      
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return a.$casecmp(b)['$=='](0);}, $Pathname$23.$$s = self, $Pathname$23.$$arity = 2, $Pathname$23))
    } else {
      return $send(self, 'proc', [], ($Pathname$24 = function(a, b){var self = $Pathname$24.$$s || this;

      
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return a['$=='](b);}, $Pathname$24.$$s = self, $Pathname$24.$$arity = 2, $Pathname$24))
    }; return nil; })());
    
    Opal.def(self, '$relative_path_from', $Pathname_relative_path_from$25 = function $$relative_path_from(base_directory) {
      var $a, $b, $c, self = this, dest_directory = nil, dest_prefix = nil, dest_names = nil, r = nil, basename = nil, base_prefix = nil, base_names = nil, relpath_names = nil;

      
      dest_directory = self.$cleanpath().$to_s();
      base_directory = base_directory.$cleanpath().$to_s();
      dest_prefix = dest_directory;
      dest_names = [];
      while ($truthy((r = self.$chop_basename(dest_prefix)))) {
        
        $c = r, $b = Opal.to_ary($c), (dest_prefix = ($b[0] == null ? nil : $b[0])), (basename = ($b[1] == null ? nil : $b[1])), $c;
        if ($truthy(basename['$!=']("."))) {
          dest_names.$unshift(basename)};
      };
      base_prefix = base_directory;
      base_names = [];
      while ($truthy((r = self.$chop_basename(base_prefix)))) {
        
        $c = r, $b = Opal.to_ary($c), (base_prefix = ($b[0] == null ? nil : $b[0])), (basename = ($b[1] == null ? nil : $b[1])), $c;
        if ($truthy(basename['$!=']("."))) {
          base_names.$unshift(basename)};
      };
      if ($truthy($$($nesting, 'SAME_PATHS')['$[]'](dest_prefix, base_prefix))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "different prefix: " + (dest_prefix.$inspect()) + " and " + (base_directory.$inspect()))
      };
      while ($truthy(($truthy($b = ($truthy($c = dest_names['$empty?']()['$!']()) ? base_names['$empty?']()['$!']() : $c)) ? $$($nesting, 'SAME_PATHS')['$[]'](dest_names.$first(), base_names.$first()) : $b))) {
        
        dest_names.$shift();
        base_names.$shift();
      };
      if ($truthy(base_names['$include?'](".."))) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "base_directory has ..: " + (base_directory.$inspect()))};
      base_names.$fill("..");
      relpath_names = $rb_plus(base_names, dest_names);
      if ($truthy(relpath_names['$empty?']())) {
        return $$($nesting, 'Pathname').$new(".")
      } else {
        return $$($nesting, 'Pathname').$new($send($$($nesting, 'File'), 'join', Opal.to_a(relpath_names)))
      };
    }, $Pathname_relative_path_from$25.$$arity = 1);
    return (Opal.def(self, '$entries', $Pathname_entries$26 = function $$entries() {
      var $$27, self = this;

      return $send($$($nesting, 'Dir').$entries(self.path), 'map', [], ($$27 = function(f){var self = $$27.$$s || this;

      
        
        if (f == null) {
          f = nil;
        };
        return self.$class().$new(f);}, $$27.$$s = self, $$27.$$arity = 1, $$27))
    }, $Pathname_entries$26.$$arity = 0), nil) && 'entries';
  })($nesting[0], null, $nesting);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_Pathname$28;

    
    Opal.def(self, '$Pathname', $Kernel_Pathname$28 = function $$Pathname(path) {
      var self = this;

      return $$($nesting, 'Pathname').$new(path)
    }, $Kernel_Pathname$28.$$arity = 1)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["nodejs/pathname"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass;

  Opal.add_stubs(['$require', '$include', '$to_str', '$!', '$absolute?']);
  
  self.$require("pathname");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Pathname');

    var $nesting = [self].concat($parent_nesting), $Pathname_absolute$ques$1, $Pathname_relative$ques$2, $Pathname_to_path$3;
    if (self.__path__ == null) self.__path__ = nil;

    self.$$prototype.path = nil;
    
    self.$include($$($nesting, 'Comparable'));
    self.__path__ = __nccwpck_require__(1017);
    var __path__ = self.__path__;
    
    Opal.def(self, '$absolute?', $Pathname_absolute$ques$1 = function() {
      var self = this;

      return __path__.isAbsolute(self.path.$to_str())
    }, $Pathname_absolute$ques$1.$$arity = 0);
    
    Opal.def(self, '$relative?', $Pathname_relative$ques$2 = function() {
      var self = this;

      return self['$absolute?']()['$!']()
    }, $Pathname_relative$ques$2.$$arity = 0);
    return (Opal.def(self, '$to_path', $Pathname_to_path$3 = function $$to_path() {
      var self = this;

      return self.path
    }, $Pathname_to_path$3.$$arity = 0), nil) && 'to_path';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["nodejs/env"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$new', '$to_s']);
  
  Opal.const_set($nesting[0], 'ENV', $$($nesting, 'Object').$new());
  return (function(self, $parent_nesting) {
    var $nesting = [self].concat($parent_nesting), $$$1, $$$eq$2, $key$ques$3, $empty$ques$4, $keys$5, $delete$6, $to_s$7;

    
    
    Opal.def(self, '$[]', $$$1 = function(name) {
      var self = this;

      return process.env[name] || nil
    }, $$$1.$$arity = 1);
    
    Opal.def(self, '$[]=', $$$eq$2 = function(name, value) {
      var self = this;

      return process.env[name.$to_s()] = value.$to_s()
    }, $$$eq$2.$$arity = 2);
    
    Opal.def(self, '$key?', $key$ques$3 = function(name) {
      var self = this;

      return process.env.hasOwnProperty(name)
    }, $key$ques$3.$$arity = 1);
    Opal.alias(self, "has_key?", "key?");
    Opal.alias(self, "include?", "key?");
    Opal.alias(self, "member?", "key?");
    
    Opal.def(self, '$empty?', $empty$ques$4 = function() {
      var self = this;

      return Object.keys(process.env).length === 0;
    }, $empty$ques$4.$$arity = 0);
    
    Opal.def(self, '$keys', $keys$5 = function $$keys() {
      var self = this;

      return Object.keys(process.env);
    }, $keys$5.$$arity = 0);
    
    Opal.def(self, '$delete', $delete$6 = function(name) {
      var self = this;

      
      var value = process.env[name] || nil;
      delete process.env[name];
      return value;
    
    }, $delete$6.$$arity = 1);
    return (Opal.def(self, '$to_s', $to_s$7 = function $$to_s() {
      var self = this;

      return "ENV"
    }, $to_s$7.$$arity = 0), nil) && 'to_s';
  })(Opal.get_singleton_class($$($nesting, 'ENV')), $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["nodejs"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  Opal.add_stubs(['$require']);
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'NodeJS');

    var $nesting = [self].concat($parent_nesting);

    nil
  })($nesting[0], $nesting);
  self.$require("nodejs/kernel");
  self.$require("nodejs/file");
  self.$require("nodejs/dir");
  self.$require("nodejs/io");
  self.$require("nodejs/open-uri");
  self.$require("nodejs/pathname");
  return self.$require("nodejs/env");
};


/***/ }),

/***/ 4274:
/***/ (function() {

(function(undefined) {
  // @note
  //   A few conventions for the documentation of this file:
  //   1. Always use "//" (in contrast with "/**/")
  //   2. The syntax used is Yardoc (yardoc.org), which is intended for Ruby (se below)
  //   3. `@param` and `@return` types should be preceded by `JS.` when referring to
  //      JavaScript constructors (e.g. `JS.Function`) otherwise Ruby is assumed.
  //   4. `nil` and `null` being unambiguous refer to the respective
  //      objects/values in Ruby and JavaScript
  //   5. This is still WIP :) so please give feedback and suggestions on how
  //      to improve or for alternative solutions
  //
  //   The way the code is digested before going through Yardoc is a secret kept
  //   in the docs repo (https://github.com/opal/docs/tree/master).

  var global_object = this, console;

  // Detect the global object
  if (typeof(global) !== 'undefined') { global_object = global; }
  if (typeof(window) !== 'undefined') { global_object = window; }

  // Setup a dummy console object if missing
  if (typeof(global_object.console) === 'object') {
    console = global_object.console;
  } else if (global_object.console == null) {
    console = global_object.console = {};
  } else {
    console = {};
  }

  if (!('log' in console)) { console.log = function () {}; }
  if (!('warn' in console)) { console.warn = console.log; }

  if (typeof(global_object.Opal) !== 'undefined') {
    console.warn('Opal already loaded. Loading twice can cause troubles, please fix your setup.');
    return global_object.Opal;
  }

  var nil;

  // The actual class for BasicObject
  var BasicObject;

  // The actual Object class.
  // The leading underscore is to avoid confusion with window.Object()
  var _Object;

  // The actual Module class
  var Module;

  // The actual Class class
  var Class;

  // The Opal object that is exposed globally
  var Opal = this.Opal = {};

  // This is a useful reference to global object inside ruby files
  Opal.global = global_object;
  global_object.Opal = Opal;

  // Configure runtime behavior with regards to require and unsupported fearures
  Opal.config = {
    missing_require_severity: 'error',        // error, warning, ignore
    unsupported_features_severity: 'warning', // error, warning, ignore
    enable_stack_trace: true                  // true, false
  }

  // Minify common function calls
  var $hasOwn       = Object.hasOwnProperty;
  var $bind         = Function.prototype.bind;
  var $setPrototype = Object.setPrototypeOf;
  var $slice        = Array.prototype.slice;
  var $splice       = Array.prototype.splice;

  // Nil object id is always 4
  var nil_id = 4;

  // Generates even sequential numbers greater than 4
  // (nil_id) to serve as unique ids for ruby objects
  var unique_id = nil_id;

  // Return next unique id
  Opal.uid = function() {
    unique_id += 2;
    return unique_id;
  };

  // Retrieve or assign the id of an object
  Opal.id = function(obj) {
    if (obj.$$is_number) return (obj * 2)+1;
    if (obj.$$id != null) {
      return obj.$$id;
    };
    $defineProperty(obj, '$$id', Opal.uid());
    return obj.$$id;
  };

  // Globals table
  Opal.gvars = {};

  // Exit function, this should be replaced by platform specific implementation
  // (See nodejs and chrome for examples)
  Opal.exit = function(status) { if (Opal.gvars.DEBUG) console.log('Exited with status '+status); };

  // keeps track of exceptions for $!
  Opal.exceptions = [];

  // @private
  // Pops an exception from the stack and updates `$!`.
  Opal.pop_exception = function() {
    Opal.gvars["!"] = Opal.exceptions.pop() || nil;
  }

  // Inspect any kind of object, including non Ruby ones
  Opal.inspect = function(obj) {
    if (obj === undefined) {
      return "undefined";
    }
    else if (obj === null) {
      return "null";
    }
    else if (!obj.$$class) {
      return obj.toString();
    }
    else {
      return obj.$inspect();
    }
  }

  function $defineProperty(object, name, initialValue) {
    if (typeof(object) === "string") {
      // Special case for:
      //   s = "string"
      //   def s.m; end
      // String class is the only class that:
      // + compiles to JS primitive
      // + allows method definition directly on instances
      // numbers, true, false and nil do not support it.
      object[name] = initialValue;
    } else {
      Object.defineProperty(object, name, {
        value: initialValue,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
  }

  Opal.defineProperty = $defineProperty;

  Opal.slice = $slice;


  // Truth
  // -----

  Opal.truthy = function(val) {
    return (val !== nil && val != null && (!val.$$is_boolean || val == true));
  };

  Opal.falsy = function(val) {
    return (val === nil || val == null || (val.$$is_boolean && val == false))
  };


  // Constants
  // ---------
  //
  // For future reference:
  // - The Rails autoloading guide (http://guides.rubyonrails.org/v5.0/autoloading_and_reloading_constants.html)
  // - @ConradIrwin's 2012 post on “Everything you ever wanted to know about constant lookup in Ruby” (http://cirw.in/blog/constant-lookup.html)
  //
  // Legend of MRI concepts/names:
  // - constant reference (cref): the module/class that acts as a namespace
  // - nesting: the namespaces wrapping the current scope, e.g. nesting inside
  //            `module A; module B::C; end; end` is `[B::C, A]`

  // Get the constant in the scope of the current cref
  function const_get_name(cref, name) {
    if (cref) return cref.$$const[name];
  }

  // Walk up the nesting array looking for the constant
  function const_lookup_nesting(nesting, name) {
    var i, ii, result, constant;

    if (nesting.length === 0) return;

    // If the nesting is not empty the constant is looked up in its elements
    // and in order. The ancestors of those elements are ignored.
    for (i = 0, ii = nesting.length; i < ii; i++) {
      constant = nesting[i].$$const[name];
      if (constant != null) return constant;
    }
  }

  // Walk up the ancestors chain looking for the constant
  function const_lookup_ancestors(cref, name) {
    var i, ii, result, ancestors;

    if (cref == null) return;

    ancestors = Opal.ancestors(cref);

    for (i = 0, ii = ancestors.length; i < ii; i++) {
      if (ancestors[i].$$const && $hasOwn.call(ancestors[i].$$const, name)) {
        return ancestors[i].$$const[name];
      }
    }
  }

  // Walk up Object's ancestors chain looking for the constant,
  // but only if cref is missing or a module.
  function const_lookup_Object(cref, name) {
    if (cref == null || cref.$$is_module) {
      return const_lookup_ancestors(_Object, name);
    }
  }

  // Call const_missing if nothing else worked
  function const_missing(cref, name, skip_missing) {
    if (!skip_missing) {
      return (cref || _Object).$const_missing(name);
    }
  }

  // Look for the constant just in the current cref or call `#const_missing`
  Opal.const_get_local = function(cref, name, skip_missing) {
    var result;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    result = const_get_name(cref, name);              if (result != null) return result;
    result = const_missing(cref, name, skip_missing); if (result != null) return result;
  }

  // Look for the constant relative to a cref or call `#const_missing` (when the
  // constant is prefixed by `::`).
  Opal.const_get_qualified = function(cref, name, skip_missing) {
    var result, cache, cached, current_version = Opal.const_cache_version;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    if ((cache = cref.$$const_cache) == null) {
      $defineProperty(cref, '$$const_cache', Object.create(null));
      cache = cref.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null);
      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null ? result : const_missing(cref, name, skip_missing);
  };

  // Initialize the top level constant cache generation counter
  Opal.const_cache_version = 1;

  // Look for the constant in the open using the current nesting and the nearest
  // cref ancestors or call `#const_missing` (when the constant has no :: prefix).
  Opal.const_get_relative = function(nesting, name, skip_missing) {
    var cref = nesting[0], result, current_version = Opal.const_cache_version, cache, cached;

    if ((cache = nesting.$$const_cache) == null) {
      $defineProperty(nesting, '$$const_cache', Object.create(null));
      cache = nesting.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_nesting(nesting, name))     != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null) ||
      ((result = const_lookup_Object(cref, name))         != null);

      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null ? result : const_missing(cref, name, skip_missing);
  };

  // Register the constant on a cref and opportunistically set the name of
  // unnamed classes/modules.
  Opal.const_set = function(cref, name, value) {
    if (cref == null || cref === '::') cref = _Object;

    if (value.$$is_a_module) {
      if (value.$$name == null || value.$$name === nil) value.$$name = name;
      if (value.$$base_module == null) value.$$base_module = cref;
    }

    cref.$$const = (cref.$$const || Object.create(null));
    cref.$$const[name] = value;

    // Add a short helper to navigate constants manually.
    // @example
    //   Opal.$$.Regexp.$$.IGNORECASE
    cref.$$ = cref.$$const;

    Opal.const_cache_version++;

    // Expose top level constants onto the Opal object
    if (cref === _Object) Opal[name] = value;

    // Name new class directly onto current scope (Opal.Foo.Baz = klass)
    $defineProperty(cref, name, value);

    return value;
  };

  // Get all the constants reachable from a given cref, by default will include
  // inherited constants.
  Opal.constants = function(cref, inherit) {
    if (inherit == null) inherit = true;

    var module, modules = [cref], module_constants, i, ii, constants = {}, constant;

    if (inherit) modules = modules.concat(Opal.ancestors(cref));
    if (inherit && cref.$$is_module) modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));

    for (i = 0, ii = modules.length; i < ii; i++) {
      module = modules[i];

      // Don not show Objects constants unless we're querying Object itself
      if (cref !== _Object && module == _Object) break;

      for (constant in module.$$const) {
        constants[constant] = true;
      }
    }

    return Object.keys(constants);
  };

  // Remove a constant from a cref.
  Opal.const_remove = function(cref, name) {
    Opal.const_cache_version++;

    if (cref.$$const[name] != null) {
      var old = cref.$$const[name];
      delete cref.$$const[name];
      return old;
    }

    if (cref.$$autoload != null && cref.$$autoload[name] != null) {
      delete cref.$$autoload[name];
      return nil;
    }

    throw Opal.NameError.$new("constant "+cref+"::"+cref.$name()+" not defined");
  };


  // Modules & Classes
  // -----------------

  // A `class Foo; end` expression in ruby is compiled to call this runtime
  // method which either returns an existing class of the given name, or creates
  // a new class in the given `base` scope.
  //
  // If a constant with the given name exists, then we check to make sure that
  // it is a class and also that the superclasses match. If either of these
  // fail, then we raise a `TypeError`. Note, `superclass` may be null if one
  // was not specified in the ruby code.
  //
  // We pass a constructor to this method of the form `function ClassName() {}`
  // simply so that classes show up with nicely formatted names inside debuggers
  // in the web browser (or node/sprockets).
  //
  // The `scope` is the current `self` value where the class is being created
  // from. We use this to get the scope for where the class should be created.
  // If `scope` is an object (not a class/module), we simple get its class and
  // use that as the scope instead.
  //
  // @param scope        [Object] where the class is being created
  // @param superclass  [Class,null] superclass of the new class (may be null)
  // @param id          [String] the name of the class to be created
  // @param constructor [JS.Function] function to use as constructor
  //
  // @return new [Class]  or existing ruby class
  //
  Opal.allocate_class = function(name, superclass) {
    var klass, constructor;

    if (superclass != null && superclass.$$bridge) {
      // Inheritance from bridged classes requires
      // calling original JS constructors
      constructor = function() {
        var args = $slice.call(arguments),
            self = new ($bind.apply(superclass.$$constructor, [null].concat(args)))();

        // and replacing a __proto__ manually
        $setPrototype(self, klass.$$prototype);
        return self;
      }
    } else {
      constructor = function(){};
    }

    if (name) {
      $defineProperty(constructor, 'displayName', '::'+name);
    }

    klass = constructor;

    $defineProperty(klass, '$$name', name);
    $defineProperty(klass, '$$constructor', constructor);
    $defineProperty(klass, '$$prototype', constructor.prototype);
    $defineProperty(klass, '$$const', {});
    $defineProperty(klass, '$$is_class', true);
    $defineProperty(klass, '$$is_a_module', true);
    $defineProperty(klass, '$$super', superclass);
    $defineProperty(klass, '$$cvars', {});
    $defineProperty(klass, '$$own_included_modules', []);
    $defineProperty(klass, '$$own_prepended_modules', []);
    $defineProperty(klass, '$$ancestors', []);
    $defineProperty(klass, '$$ancestors_cache_version', null);

    $defineProperty(klass.$$prototype, '$$class', klass);

    // By default if there are no singleton class methods
    // __proto__ is Class.prototype
    // Later singleton methods generate a singleton_class
    // and inject it into ancestors chain
    if (Opal.Class) {
      $setPrototype(klass, Opal.Class.prototype);
    }

    if (superclass != null) {
      $setPrototype(klass.$$prototype, superclass.$$prototype);

      if (superclass.$$meta) {
        // If superclass has metaclass then we have explicitely inherit it.
        Opal.build_class_singleton_class(klass);
      }
    };

    return klass;
  }


  function find_existing_class(scope, name) {
    // Try to find the class in the current scope
    var klass = const_get_name(scope, name);

    // If the class exists in the scope, then we must use that
    if (klass) {
      // Make sure the existing constant is a class, or raise error
      if (!klass.$$is_class) {
        throw Opal.TypeError.$new(name + " is not a class");
      }

      return klass;
    }
  }

  function ensureSuperclassMatch(klass, superclass) {
    if (klass.$$super !== superclass) {
      throw Opal.TypeError.$new("superclass mismatch for class " + klass.$$name);
    }
  }

  Opal.klass = function(scope, superclass, name) {
    var bridged;

    if (scope == null) {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    // If the superclass is not an Opal-generated class then we're bridging a native JS class
    if (superclass != null && !superclass.hasOwnProperty('$$is_class')) {
      bridged = superclass;
      superclass = _Object;
    }

    var klass = find_existing_class(scope, name);

    if (klass) {
      if (superclass) {
        // Make sure existing class has same superclass
        ensureSuperclassMatch(klass, superclass);
      }
      return klass;
    }

    // Class doesn't exist, create a new one with given superclass...

    // Not specifying a superclass means we can assume it to be Object
    if (superclass == null) {
      superclass = _Object;
    }

    // Create the class object (instance of Class)
    klass = Opal.allocate_class(name, superclass);
    Opal.const_set(scope, name, klass);

    // Call .inherited() hook with new class on the superclass
    if (superclass.$inherited) {
      superclass.$inherited(klass);
    }

    if (bridged) {
      Opal.bridge(bridged, klass);
    }

    return klass;
  }

  // Define new module (or return existing module). The given `scope` is basically
  // the current `self` value the `module` statement was defined in. If this is
  // a ruby module or class, then it is used, otherwise if the scope is a ruby
  // object then that objects real ruby class is used (e.g. if the scope is the
  // main object, then the top level `Object` class is used as the scope).
  //
  // If a module of the given name is already defined in the scope, then that
  // instance is just returned.
  //
  // If there is a class of the given name in the scope, then an error is
  // generated instead (cannot have a class and module of same name in same scope).
  //
  // Otherwise, a new module is created in the scope with the given name, and that
  // new instance is returned back (to be referenced at runtime).
  //
  // @param  scope [Module, Class] class or module this definition is inside
  // @param  id   [String] the name of the new (or existing) module
  //
  // @return [Module]
  Opal.allocate_module = function(name) {
    var constructor = function(){};
    if (name) {
      $defineProperty(constructor, 'displayName', name+'.$$constructor');
    }

    var module = constructor;

    if (name)
      $defineProperty(constructor, 'displayName', name+'.constructor');

    $defineProperty(module, '$$name', name);
    $defineProperty(module, '$$prototype', constructor.prototype);
    $defineProperty(module, '$$const', {});
    $defineProperty(module, '$$is_module', true);
    $defineProperty(module, '$$is_a_module', true);
    $defineProperty(module, '$$cvars', {});
    $defineProperty(module, '$$iclasses', []);
    $defineProperty(module, '$$own_included_modules', []);
    $defineProperty(module, '$$own_prepended_modules', []);
    $defineProperty(module, '$$ancestors', [module]);
    $defineProperty(module, '$$ancestors_cache_version', null);

    $setPrototype(module, Opal.Module.prototype);

    return module;
  }

  function find_existing_module(scope, name) {
    var module = const_get_name(scope, name);
    if (module == null && scope === _Object) module = const_lookup_ancestors(_Object, name);

    if (module) {
      if (!module.$$is_module && module !== _Object) {
        throw Opal.TypeError.$new(name + " is not a module");
      }
    }

    return module;
  }

  Opal.module = function(scope, name) {
    var module;

    if (scope == null) {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    module = find_existing_module(scope, name);

    if (module) {
      return module;
    }

    // Module doesnt exist, create a new one...
    module = Opal.allocate_module(name);
    Opal.const_set(scope, name, module);

    return module;
  }

  // Return the singleton class for the passed object.
  //
  // If the given object alredy has a singleton class, then it will be stored on
  // the object as the `$$meta` property. If this exists, then it is simply
  // returned back.
  //
  // Otherwise, a new singleton object for the class or object is created, set on
  // the object at `$$meta` for future use, and then returned.
  //
  // @param object [Object] the ruby object
  // @return [Class] the singleton class for object
  Opal.get_singleton_class = function(object) {
    if (object.$$meta) {
      return object.$$meta;
    }

    if (object.hasOwnProperty('$$is_class')) {
      return Opal.build_class_singleton_class(object);
    } else if (object.hasOwnProperty('$$is_module')) {
      return Opal.build_module_singletin_class(object);
    } else {
      return Opal.build_object_singleton_class(object);
    }
  };

  // Build the singleton class for an existing class. Class object are built
  // with their singleton class already in the prototype chain and inheriting
  // from their superclass object (up to `Class` itself).
  //
  // NOTE: Actually in MRI a class' singleton class inherits from its
  // superclass' singleton class which in turn inherits from Class.
  //
  // @param klass [Class]
  // @return [Class]
  Opal.build_class_singleton_class = function(klass) {
    var superclass, meta;

    if (klass.$$meta) {
      return klass.$$meta;
    }

    // The singleton_class superclass is the singleton_class of its superclass;
    // but BasicObject has no superclass (its `$$super` is null), thus we
    // fallback on `Class`.
    superclass = klass === BasicObject ? Class : Opal.get_singleton_class(klass.$$super);

    meta = Opal.allocate_class(null, superclass, function(){});

    $defineProperty(meta, '$$is_singleton', true);
    $defineProperty(meta, '$$singleton_of', klass);
    $defineProperty(klass, '$$meta', meta);
    $setPrototype(klass, meta.$$prototype);
    // Restoring ClassName.class
    $defineProperty(klass, '$$class', Opal.Class);

    return meta;
  };

  Opal.build_module_singletin_class = function(mod) {
    if (mod.$$meta) {
      return mod.$$meta;
    }

    var meta = Opal.allocate_class(null, Opal.Module, function(){});

    $defineProperty(meta, '$$is_singleton', true);
    $defineProperty(meta, '$$singleton_of', mod);
    $defineProperty(mod, '$$meta', meta);
    $setPrototype(mod, meta.$$prototype);
    // Restoring ModuleName.class
    $defineProperty(mod, '$$class', Opal.Module);

    return meta;
  }

  // Build the singleton class for a Ruby (non class) Object.
  //
  // @param object [Object]
  // @return [Class]
  Opal.build_object_singleton_class = function(object) {
    var superclass = object.$$class,
        klass = Opal.allocate_class(nil, superclass, function(){});

    $defineProperty(klass, '$$is_singleton', true);
    $defineProperty(klass, '$$singleton_of', object);

    delete klass.$$prototype.$$class;

    $defineProperty(object, '$$meta', klass);

    $setPrototype(object, object.$$meta.$$prototype);

    return klass;
  };

  Opal.is_method = function(prop) {
    return (prop[0] === '$' && prop[1] !== '$');
  }

  Opal.instance_methods = function(mod) {
    var exclude = [], results = [], ancestors = Opal.ancestors(mod);

    for (var i = 0, l = ancestors.length; i < l; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      var props = Object.getOwnPropertyNames(proto);

      for (var j = 0, ll = props.length; j < ll; j++) {
        var prop = props[j];

        if (Opal.is_method(prop)) {
          var method_name = prop.slice(1),
              method = proto[prop];

          if (method.$$stub && exclude.indexOf(method_name) === -1) {
            exclude.push(method_name);
          }

          if (!method.$$stub && results.indexOf(method_name) === -1 && exclude.indexOf(method_name) === -1) {
            results.push(method_name);
          }
        }
      }
    }

    return results;
  }

  Opal.own_instance_methods = function(mod) {
    var results = [],
        proto = mod.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto);

    for (var i = 0, length = props.length; i < length; i++) {
      var prop = props[i];

      if (Opal.is_method(prop)) {
        var method = proto[prop];

        if (!method.$$stub) {
          var method_name = prop.slice(1);
          results.push(method_name);
        }
      }
    }

    return results;
  }

  Opal.methods = function(obj) {
    return Opal.instance_methods(Opal.get_singleton_class(obj));
  }

  Opal.own_methods = function(obj) {
    return Opal.own_instance_methods(Opal.get_singleton_class(obj));
  }

  Opal.receiver_methods = function(obj) {
    var mod = Opal.get_singleton_class(obj);
    var singleton_methods = Opal.own_instance_methods(mod);
    var instance_methods = Opal.own_instance_methods(mod.$$super);
    return singleton_methods.concat(instance_methods);
  }

  // Returns an object containing all pairs of names/values
  // for all class variables defined in provided +module+
  // and its ancestors.
  //
  // @param module [Module]
  // @return [Object]
  Opal.class_variables = function(module) {
    var ancestors = Opal.ancestors(module),
        i, length = ancestors.length,
        result = {};

    for (i = length - 1; i >= 0; i--) {
      var ancestor = ancestors[i];

      for (var cvar in ancestor.$$cvars) {
        result[cvar] = ancestor.$$cvars[cvar];
      }
    }

    return result;
  }

  // Sets class variable with specified +name+ to +value+
  // in provided +module+
  //
  // @param module [Module]
  // @param name [String]
  // @param value [Object]
  Opal.class_variable_set = function(module, name, value) {
    var ancestors = Opal.ancestors(module),
        i, length = ancestors.length;

    for (i = length - 2; i >= 0; i--) {
      var ancestor = ancestors[i];

      if ($hasOwn.call(ancestor.$$cvars, name)) {
        ancestor.$$cvars[name] = value;
        return value;
      }
    }

    module.$$cvars[name] = value;

    return value;
  }

  function isRoot(proto) {
    return proto.hasOwnProperty('$$iclass') && proto.hasOwnProperty('$$root');
  }

  function own_included_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    while (proto) {
      if (proto.hasOwnProperty('$$class')) {
        // superclass
        break;
      }
      mod = protoToModule(proto);
      if (mod) {
        result.push(mod);
      }
      proto = Object.getPrototypeOf(proto);
    }

    return result;
  }

  function own_prepended_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    if (module.$$prototype.hasOwnProperty('$$dummy')) {
      while (proto) {
        if (proto === module.$$prototype.$$define_methods_on) {
          break;
        }

        mod = protoToModule(proto);
        if (mod) {
          result.push(mod);
        }

        proto = Object.getPrototypeOf(proto);
      }
    }

    return result;
  }


  // The actual inclusion of a module into a class.
  //
  // ## Class `$$parent` and `iclass`
  //
  // To handle `super` calls, every class has a `$$parent`. This parent is
  // used to resolve the next class for a super call. A normal class would
  // have this point to its superclass. However, if a class includes a module
  // then this would need to take into account the module. The module would
  // also have to then point its `$$parent` to the actual superclass. We
  // cannot modify modules like this, because it might be included in more
  // then one class. To fix this, we actually insert an `iclass` as the class'
  // `$$parent` which can then point to the superclass. The `iclass` acts as
  // a proxy to the actual module, so the `super` chain can then search it for
  // the required method.
  //
  // @param module [Module] the module to include
  // @param includer [Module] the target class to include module into
  // @return [null]
  Opal.append_features = function(module, includer) {
    var module_ancestors = Opal.ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(includer) !== -1) {
      throw Opal.ArgumentError.$new('cyclic include detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $defineProperty(iclass, '$$included', true);
      iclasses.push(iclass);
    }
    var includer_ancestors = Opal.ancestors(includer),
        chain = chain_iclasses(iclasses),
        start_chain_after,
        end_chain_on;

    if (includer_ancestors.indexOf(module) === -1) {
      // first time include

      // includer -> chain.first -> ...chain... -> chain.last -> includer.parent
      start_chain_after = includer.$$prototype;
      end_chain_on = Object.getPrototypeOf(includer.$$prototype);
    } else {
      // The module has been already included,
      // we don't need to put it into the ancestors chain again,
      // but this module may have new included modules.
      // If it's true we need to copy them.
      //
      // The simplest way is to replace ancestors chain from
      //          parent
      //            |
      //   `module` iclass (has a $$root flag)
      //            |
      //   ...previos chain of module.included_modules ...
      //            |
      //  "next ancestor" (has a $$root flag or is a real class)
      //
      // to
      //          parent
      //            |
      //    `module` iclass (has a $$root flag)
      //            |
      //   ...regenerated chain of module.included_modules
      //            |
      //   "next ancestor" (has a $$root flag or is a real class)
      //
      // because there are no intermediate classes between `parent` and `next ancestor`.
      // It doesn't break any prototypes of other objects as we don't change class references.

      var proto = includer.$$prototype, parent = proto, module_iclass = Object.getPrototypeOf(parent);

      while (module_iclass != null) {
        if (isRoot(module_iclass) && module_iclass.$$module === module) {
          break;
        }

        parent = module_iclass;
        module_iclass = Object.getPrototypeOf(module_iclass);
      }

      var next_ancestor = Object.getPrototypeOf(module_iclass);

      // skip non-root iclasses (that were recursively included)
      while (next_ancestor.hasOwnProperty('$$iclass') && !isRoot(next_ancestor)) {
        next_ancestor = Object.getPrototypeOf(next_ancestor);
      }

      start_chain_after = parent;
      end_chain_on = next_ancestor;
    }

    $setPrototype(start_chain_after, chain.first);
    $setPrototype(chain.last, end_chain_on);

    // recalculate own_included_modules cache
    includer.$$own_included_modules = own_included_modules(includer);

    Opal.const_cache_version++;
  }

  Opal.prepend_features = function(module, prepender) {
    // Here we change the ancestors chain from
    //
    //   prepender
    //      |
    //    parent
    //
    // to:
    //
    // dummy(prepender)
    //      |
    //  iclass(module)
    //      |
    // iclass(prepender)
    //      |
    //    parent
    var module_ancestors = Opal.ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(prepender) !== -1) {
      throw Opal.ArgumentError.$new('cyclic prepend detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $defineProperty(iclass, '$$prepended', true);
      iclasses.push(iclass);
    }

    var chain = chain_iclasses(iclasses),
        dummy_prepender = prepender.$$prototype,
        previous_parent = Object.getPrototypeOf(dummy_prepender),
        prepender_iclass,
        start_chain_after,
        end_chain_on;

    if (dummy_prepender.hasOwnProperty('$$dummy')) {
      // The module already has some prepended modules
      // which means that we don't need to make it "dummy"
      prepender_iclass = dummy_prepender.$$define_methods_on;
    } else {
      // Making the module "dummy"
      prepender_iclass = create_dummy_iclass(prepender);
      flush_methods_in(prepender);
      $defineProperty(dummy_prepender, '$$dummy', true);
      $defineProperty(dummy_prepender, '$$define_methods_on', prepender_iclass);

      // Converting
      //   dummy(prepender) -> previous_parent
      // to
      //   dummy(prepender) -> iclass(prepender) -> previous_parent
      $setPrototype(dummy_prepender, prepender_iclass);
      $setPrototype(prepender_iclass, previous_parent);
    }

    var prepender_ancestors = Opal.ancestors(prepender);

    if (prepender_ancestors.indexOf(module) === -1) {
      // first time prepend

      start_chain_after = dummy_prepender;

      // next $$root or prepender_iclass or non-$$iclass
      end_chain_on = Object.getPrototypeOf(dummy_prepender);
      while (end_chain_on != null) {
        if (
          end_chain_on.hasOwnProperty('$$root') ||
          end_chain_on === prepender_iclass ||
          !end_chain_on.hasOwnProperty('$$iclass')
        ) {
          break;
        }

        end_chain_on = Object.getPrototypeOf(end_chain_on);
      }
    } else {
      throw Opal.RuntimeError.$new("Prepending a module multiple times is not supported");
    }

    $setPrototype(start_chain_after, chain.first);
    $setPrototype(chain.last, end_chain_on);

    // recalculate own_prepended_modules cache
    prepender.$$own_prepended_modules = own_prepended_modules(prepender);

    Opal.const_cache_version++;
  }

  function flush_methods_in(module) {
    var proto = module.$$prototype,
        props = Object.getOwnPropertyNames(proto);

    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      if (Opal.is_method(prop)) {
        delete proto[prop];
      }
    }
  }

  function create_iclass(module) {
    var iclass = create_dummy_iclass(module);

    if (module.$$is_module) {
      module.$$iclasses.push(iclass);
    }

    return iclass;
  }

  // Dummy iclass doesn't receive updates when the module gets a new method.
  function create_dummy_iclass(module) {
    var iclass = {},
        proto = module.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto),
        length = props.length, i;

    for (i = 0; i < length; i++) {
      var prop = props[i];
      $defineProperty(iclass, prop, proto[prop]);
    }

    $defineProperty(iclass, '$$iclass', true);
    $defineProperty(iclass, '$$module', module);

    return iclass;
  }

  function chain_iclasses(iclasses) {
    var length = iclasses.length, first = iclasses[0];

    $defineProperty(first, '$$root', true);

    if (length === 1) {
      return { first: first, last: first };
    }

    var previous = first;

    for (var i = 1; i < length; i++) {
      var current = iclasses[i];
      $setPrototype(previous, current);
      previous = current;
    }


    return { first: iclasses[0], last: iclasses[length - 1] };
  }

  // For performance, some core Ruby classes are toll-free bridged to their
  // native JavaScript counterparts (e.g. a Ruby Array is a JavaScript Array).
  //
  // This method is used to setup a native constructor (e.g. Array), to have
  // its prototype act like a normal Ruby class. Firstly, a new Ruby class is
  // created using the native constructor so that its prototype is set as the
  // target for the new class. Note: all bridged classes are set to inherit
  // from Object.
  //
  // Example:
  //
  //    Opal.bridge(self, Function);
  //
  // @param klass       [Class] the Ruby class to bridge
  // @param constructor [JS.Function] native JavaScript constructor to use
  // @return [Class] returns the passed Ruby class
  //
  Opal.bridge = function(native_klass, klass) {
    if (native_klass.hasOwnProperty('$$bridge')) {
      throw Opal.ArgumentError.$new("already bridged");
    }

    var klass_to_inject, klass_reference;

    klass_to_inject = klass.$$super || Opal.Object;
    klass_reference = klass;
    var original_prototype = klass.$$prototype;

    // constructor is a JS function with a prototype chain like:
    // - constructor
    //   - super
    //
    // What we need to do is to inject our class (with its prototype chain)
    // between constructor and super. For example, after injecting ::Object
    // into JS String we get:
    //
    // - constructor (window.String)
    //   - Opal.Object
    //     - Opal.Kernel
    //       - Opal.BasicObject
    //         - super (window.Object)
    //           - null
    //
    $defineProperty(native_klass, '$$bridge', klass);
    $setPrototype(native_klass.prototype, (klass.$$super || Opal.Object).$$prototype);
    $defineProperty(klass, '$$prototype', native_klass.prototype);

    $defineProperty(klass.$$prototype, '$$class', klass);
    $defineProperty(klass, '$$constructor', native_klass);
    $defineProperty(klass, '$$bridge', true);
  };

  function protoToModule(proto) {
    if (proto.hasOwnProperty('$$dummy')) {
      return;
    } else if (proto.hasOwnProperty('$$iclass')) {
      return proto.$$module;
    } else if (proto.hasOwnProperty('$$class')) {
      return proto.$$class;
    }
  }

  function own_ancestors(module) {
    return module.$$own_prepended_modules.concat([module]).concat(module.$$own_included_modules);
  }

  // The Array of ancestors for a given module/class
  Opal.ancestors = function(module) {
    if (!module) { return []; }

    if (module.$$ancestors_cache_version === Opal.const_cache_version) {
      return module.$$ancestors;
    }

    var result = [], i, mods, length;

    for (i = 0, mods = own_ancestors(module), length = mods.length; i < length; i++) {
      result.push(mods[i]);
    }

    if (module.$$super) {
      for (i = 0, mods = Opal.ancestors(module.$$super), length = mods.length; i < length; i++) {
        result.push(mods[i]);
      }
    }

    module.$$ancestors_cache_version = Opal.const_cache_version;
    module.$$ancestors = result;

    return result;
  }

  Opal.included_modules = function(module) {
    var result = [], mod = null, proto = Object.getPrototypeOf(module.$$prototype);

    for (; proto && Object.getPrototypeOf(proto); proto = Object.getPrototypeOf(proto)) {
      mod = protoToModule(proto);
      if (mod && mod.$$is_module && proto.$$iclass && proto.$$included) {
        result.push(mod);
      }
    }

    return result;
  }


  // Method Missing
  // --------------

  // Methods stubs are used to facilitate method_missing in opal. A stub is a
  // placeholder function which just calls `method_missing` on the receiver.
  // If no method with the given name is actually defined on an object, then it
  // is obvious to say that the stub will be called instead, and then in turn
  // method_missing will be called.
  //
  // When a file in ruby gets compiled to javascript, it includes a call to
  // this function which adds stubs for every method name in the compiled file.
  // It should then be safe to assume that method_missing will work for any
  // method call detected.
  //
  // Method stubs are added to the BasicObject prototype, which every other
  // ruby object inherits, so all objects should handle method missing. A stub
  // is only added if the given property name (method name) is not already
  // defined.
  //
  // Note: all ruby methods have a `$` prefix in javascript, so all stubs will
  // have this prefix as well (to make this method more performant).
  //
  //    Opal.add_stubs(["$foo", "$bar", "$baz="]);
  //
  // All stub functions will have a private `$$stub` property set to true so
  // that other internal methods can detect if a method is just a stub or not.
  // `Kernel#respond_to?` uses this property to detect a methods presence.
  //
  // @param stubs [Array] an array of method stubs to add
  // @return [undefined]
  Opal.add_stubs = function(stubs) {
    var proto = Opal.BasicObject.$$prototype;

    for (var i = 0, length = stubs.length; i < length; i++) {
      var stub = stubs[i], existing_method = proto[stub];

      if (existing_method == null || existing_method.$$stub) {
        Opal.add_stub_for(proto, stub);
      }
    }
  };

  // Add a method_missing stub function to the given prototype for the
  // given name.
  //
  // @param prototype [Prototype] the target prototype
  // @param stub [String] stub name to add (e.g. "$foo")
  // @return [undefined]
  Opal.add_stub_for = function(prototype, stub) {
    var method_missing_stub = Opal.stub_for(stub);
    $defineProperty(prototype, stub, method_missing_stub);
  };

  // Generate the method_missing stub for a given method name.
  //
  // @param method_name [String] The js-name of the method to stub (e.g. "$foo")
  // @return [undefined]
  Opal.stub_for = function(method_name) {
    function method_missing_stub() {
      // Copy any given block onto the method_missing dispatcher
      this.$method_missing.$$p = method_missing_stub.$$p;

      // Set block property to null ready for the next call (stop false-positives)
      method_missing_stub.$$p = null;

      // call method missing with correct args (remove '$' prefix on method name)
      var args_ary = new Array(arguments.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = arguments[i]; }

      return this.$method_missing.apply(this, [method_name.slice(1)].concat(args_ary));
    }

    method_missing_stub.$$stub = true;

    return method_missing_stub;
  };


  // Methods
  // -------

  // Arity count error dispatcher for methods
  //
  // @param actual [Fixnum] number of arguments given to method
  // @param expected [Fixnum] expected number of arguments
  // @param object [Object] owner of the method +meth+
  // @param meth [String] method name that got wrong number of arguments
  // @raise [ArgumentError]
  Opal.ac = function(actual, expected, object, meth) {
    var inspect = '';
    if (object.$$is_a_module) {
      inspect += object.$$name + '.';
    }
    else {
      inspect += object.$$class.$$name + '#';
    }
    inspect += meth;

    throw Opal.ArgumentError.$new('[' + inspect + '] wrong number of arguments(' + actual + ' for ' + expected + ')');
  };

  // Arity count error dispatcher for blocks
  //
  // @param actual [Fixnum] number of arguments given to block
  // @param expected [Fixnum] expected number of arguments
  // @param context [Object] context of the block definition
  // @raise [ArgumentError]
  Opal.block_ac = function(actual, expected, context) {
    var inspect = "`block in " + context + "'";

    throw Opal.ArgumentError.$new(inspect + ': wrong number of arguments (' + actual + ' for ' + expected + ')');
  };

  // Super dispatcher
  Opal.find_super_dispatcher = function(obj, mid, current_func, defcheck, defs) {
    var jsid = '$' + mid, ancestors, super_method;

    if (obj.hasOwnProperty('$$meta')) {
      ancestors = Opal.ancestors(obj.$$meta);
    } else {
      ancestors = Opal.ancestors(obj.$$class);
    }

    var current_index = ancestors.indexOf(current_func.$$owner);

    for (var i = current_index + 1; i < ancestors.length; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      if (proto.hasOwnProperty(jsid)) {
        var method = proto[jsid];

        if (!method.$$stub) {
          super_method = method;
        }
        break;
      }
    }

    if (!defcheck && super_method == null && Opal.Kernel.$method_missing === obj.$method_missing) {
      // method_missing hasn't been explicitly defined
      throw Opal.NoMethodError.$new('super: no superclass method `'+mid+"' for "+obj, mid);
    }

    return super_method;
  };

  // Iter dispatcher for super in a block
  Opal.find_iter_super_dispatcher = function(obj, jsid, current_func, defcheck, implicit) {
    var call_jsid = jsid;

    if (!current_func) {
      throw Opal.RuntimeError.$new("super called outside of method");
    }

    if (implicit && current_func.$$define_meth) {
      throw Opal.RuntimeError.$new("implicit argument passing of super from method defined by define_method() is not supported. Specify all arguments explicitly");
    }

    if (current_func.$$def) {
      call_jsid = current_func.$$jsid;
    }

    return Opal.find_super_dispatcher(obj, call_jsid, current_func, defcheck);
  };

  // Used to return as an expression. Sometimes, we can't simply return from
  // a javascript function as if we were a method, as the return is used as
  // an expression, or even inside a block which must "return" to the outer
  // method. This helper simply throws an error which is then caught by the
  // method. This approach is expensive, so it is only used when absolutely
  // needed.
  //
  Opal.ret = function(val) {
    Opal.returner.$v = val;
    throw Opal.returner;
  };

  // Used to break out of a block.
  Opal.brk = function(val, breaker) {
    breaker.$v = val;
    throw breaker;
  };

  // Builds a new unique breaker, this is to avoid multiple nested breaks to get
  // in the way of each other.
  Opal.new_brk = function() {
    return new Error('unexpected break');
  };

  // handles yield calls for 1 yielded arg
  Opal.yield1 = function(block, arg) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    var has_mlhs = block.$$has_top_level_mlhs_arg,
        has_trailing_comma = block.$$has_trailing_comma_in_args;

    if (block.length > 1 || ((has_mlhs || has_trailing_comma) && block.length === 1)) {
      arg = Opal.to_ary(arg);
    }

    if ((block.length > 1 || (has_trailing_comma && block.length === 1)) && arg.$$is_array) {
      return block.apply(null, arg);
    }
    else {
      return block(arg);
    }
  };

  // handles yield for > 1 yielded arg
  Opal.yieldX = function(block, args) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    if (block.length > 1 && args.length === 1) {
      if (args[0].$$is_array) {
        return block.apply(null, args[0]);
      }
    }

    if (!args.$$is_array) {
      var args_ary = new Array(args.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

      return block.apply(null, args_ary);
    }

    return block.apply(null, args);
  };

  // Finds the corresponding exception match in candidates.  Each candidate can
  // be a value, or an array of values.  Returns null if not found.
  Opal.rescue = function(exception, candidates) {
    for (var i = 0; i < candidates.length; i++) {
      var candidate = candidates[i];

      if (candidate.$$is_array) {
        var result = Opal.rescue(exception, candidate);

        if (result) {
          return result;
        }
      }
      else if (candidate === Opal.JS.Error) {
        return candidate;
      }
      else if (candidate['$==='](exception)) {
        return candidate;
      }
    }

    return null;
  };

  Opal.is_a = function(object, klass) {
    if (klass != null && object.$$meta === klass || object.$$class === klass) {
      return true;
    }

    if (object.$$is_number && klass.$$is_number_class) {
      return true;
    }

    var i, length, ancestors = Opal.ancestors(object.$$is_class ? Opal.get_singleton_class(object) : (object.$$meta || object.$$class));

    for (i = 0, length = ancestors.length; i < length; i++) {
      if (ancestors[i] === klass) {
        return true;
      }
    }

    return false;
  };

  // Helpers for extracting kwsplats
  // Used for: { **h }
  Opal.to_hash = function(value) {
    if (value.$$is_hash) {
      return value;
    }
    else if (value['$respond_to?']('to_hash', true)) {
      var hash = value.$to_hash();
      if (hash.$$is_hash) {
        return hash;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Hash (" + value.$$class + "#to_hash gives " + hash.$$class + ")");
      }
    }
    else {
      throw Opal.TypeError.$new("no implicit conversion of " + value.$$class + " into Hash");
    }
  };

  // Helpers for implementing multiple assignment
  // Our code for extracting the values and assigning them only works if the
  // return value is a JS array.
  // So if we get an Array subclass, extract the wrapped JS array from it

  // Used for: a, b = something (no splat)
  Opal.to_ary = function(value) {
    if (value.$$is_array) {
      return value;
    }
    else if (value['$respond_to?']('to_ary', true)) {
      var ary = value.$to_ary();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_ary gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for: a, b = *something (with splat)
  Opal.to_a = function(value) {
    if (value.$$is_array) {
      // A splatted array must be copied
      return value.slice();
    }
    else if (value['$respond_to?']('to_a', true)) {
      var ary = value.$to_a();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_a gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for extracting keyword arguments from arguments passed to
  // JS function. If provided +arguments+ list doesn't have a Hash
  // as a last item, returns a blank Hash.
  //
  // @param parameters [Array]
  // @return [Hash]
  //
  Opal.extract_kwargs = function(parameters) {
    var kwargs = parameters[parameters.length - 1];
    if (kwargs != null && kwargs['$respond_to?']('to_hash', true)) {
      $splice.call(parameters, parameters.length - 1, 1);
      return kwargs.$to_hash();
    }
    else {
      return Opal.hash2([], {});
    }
  }

  // Used to get a list of rest keyword arguments. Method takes the given
  // keyword args, i.e. the hash literal passed to the method containing all
  // keyword arguemnts passed to method, as well as the used args which are
  // the names of required and optional arguments defined. This method then
  // just returns all key/value pairs which have not been used, in a new
  // hash literal.
  //
  // @param given_args [Hash] all kwargs given to method
  // @param used_args [Object<String: true>] all keys used as named kwargs
  // @return [Hash]
  //
  Opal.kwrestargs = function(given_args, used_args) {
    var keys      = [],
        map       = {},
        key       = null,
        given_map = given_args.$$smap;

    for (key in given_map) {
      if (!used_args[key]) {
        keys.push(key);
        map[key] = given_map[key];
      }
    }

    return Opal.hash2(keys, map);
  };

  // Calls passed method on a ruby object with arguments and block:
  //
  // Can take a method or a method name.
  //
  // 1. When method name gets passed it invokes it by its name
  //    and calls 'method_missing' when object doesn't have this method.
  //    Used internally by Opal to invoke method that takes a block or a splat.
  // 2. When method (i.e. method body) gets passed, it doesn't trigger 'method_missing'
  //    because it doesn't know the name of the actual method.
  //    Used internally by Opal to invoke 'super'.
  //
  // @example
  //   var my_array = [1, 2, 3, 4]
  //   Opal.send(my_array, 'length')                    # => 4
  //   Opal.send(my_array, my_array.$length)            # => 4
  //
  //   Opal.send(my_array, 'reverse!')                  # => [4, 3, 2, 1]
  //   Opal.send(my_array, my_array['$reverse!']')      # => [4, 3, 2, 1]
  //
  // @param recv [Object] ruby object
  // @param method [Function, String] method body or name of the method
  // @param args [Array] arguments that will be passed to the method call
  // @param block [Function] ruby block
  // @return [Object] returning value of the method call
  Opal.send = function(recv, method, args, block) {
    var body = (typeof(method) === 'string') ? recv['$'+method] : method;

    if (body != null) {
      if (typeof block === 'function') {
        body.$$p = block;
      }
      return body.apply(recv, args);
    }

    return recv.$method_missing.apply(recv, [method].concat(args));
  }

  Opal.lambda = function(block) {
    block.$$is_lambda = true;
    return block;
  }

  // Used to define methods on an object. This is a helper method, used by the
  // compiled source to define methods on special case objects when the compiler
  // can not determine the destination object, or the object is a Module
  // instance. This can get called by `Module#define_method` as well.
  //
  // ## Modules
  //
  // Any method defined on a module will come through this runtime helper.
  // The method is added to the module body, and the owner of the method is
  // set to be the module itself. This is used later when choosing which
  // method should show on a class if more than 1 included modules define
  // the same method. Finally, if the module is in `module_function` mode,
  // then the method is also defined onto the module itself.
  //
  // ## Classes
  //
  // This helper will only be called for classes when a method is being
  // defined indirectly; either through `Module#define_method`, or by a
  // literal `def` method inside an `instance_eval` or `class_eval` body. In
  // either case, the method is simply added to the class' prototype. A special
  // exception exists for `BasicObject` and `Object`. These two classes are
  // special because they are used in toll-free bridged classes. In each of
  // these two cases, extra work is required to define the methods on toll-free
  // bridged class' prototypes as well.
  //
  // ## Objects
  //
  // If a simple ruby object is the object, then the method is simply just
  // defined on the object as a singleton method. This would be the case when
  // a method is defined inside an `instance_eval` block.
  //
  // @param obj  [Object, Class] the actual obj to define method for
  // @param jsid [String] the JavaScript friendly method name (e.g. '$foo')
  // @param body [JS.Function] the literal JavaScript function used as method
  // @return [null]
  //
  Opal.def = function(obj, jsid, body) {
    // Special case for a method definition in the
    // top-level namespace
    if (obj === Opal.top) {
      Opal.defn(Opal.Object, jsid, body)
    }
    // if instance_eval is invoked on a module/class, it sets inst_eval_mod
    else if (!obj.$$eval && obj.$$is_a_module) {
      Opal.defn(obj, jsid, body);
    }
    else {
      Opal.defs(obj, jsid, body);
    }
  };

  // Define method on a module or class (see Opal.def).
  Opal.defn = function(module, jsid, body) {
    body.displayName = jsid;
    body.$$owner = module;

    var proto = module.$$prototype;
    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }
    $defineProperty(proto, jsid, body);

    if (module.$$is_module) {
      if (module.$$module_function) {
        Opal.defs(module, jsid, body)
      }

      for (var i = 0, iclasses = module.$$iclasses, length = iclasses.length; i < length; i++) {
        var iclass = iclasses[i];
        $defineProperty(iclass, jsid, body);
      }
    }

    var singleton_of = module.$$singleton_of;
    if (module.$method_added && !module.$method_added.$$stub && !singleton_of) {
      module.$method_added(jsid.substr(1));
    }
    else if (singleton_of && singleton_of.$singleton_method_added && !singleton_of.$singleton_method_added.$$stub) {
      singleton_of.$singleton_method_added(jsid.substr(1));
    }
  }

  // Define a singleton method on the given object (see Opal.def).
  Opal.defs = function(obj, jsid, body) {
    if (obj.$$is_string || obj.$$is_number) {
      throw Opal.TypeError.$new("can't define singleton");
    }
    Opal.defn(Opal.get_singleton_class(obj), jsid, body)
  };

  // Called from #remove_method.
  Opal.rdef = function(obj, jsid) {
    if (!$hasOwn.call(obj.$$prototype, jsid)) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    delete obj.$$prototype[jsid];

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_removed && !obj.$$prototype.$singleton_method_removed.$$stub) {
        obj.$$prototype.$singleton_method_removed(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_removed && !obj.$method_removed.$$stub) {
        obj.$method_removed(jsid.substr(1));
      }
    }
  };

  // Called from #undef_method.
  Opal.udef = function(obj, jsid) {
    if (!obj.$$prototype[jsid] || obj.$$prototype[jsid].$$stub) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    Opal.add_stub_for(obj.$$prototype, jsid);

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_undefined && !obj.$$prototype.$singleton_method_undefined.$$stub) {
        obj.$$prototype.$singleton_method_undefined(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_undefined && !obj.$method_undefined.$$stub) {
        obj.$method_undefined(jsid.substr(1));
      }
    }
  };

  function is_method_body(body) {
    return (typeof(body) === "function" && !body.$$stub);
  }

  Opal.alias = function(obj, name, old) {
    var id     = '$' + name,
        old_id = '$' + old,
        body   = obj.$$prototype['$' + old],
        alias;

    // When running inside #instance_eval the alias refers to class methods.
    if (obj.$$eval) {
      return Opal.alias(Opal.get_singleton_class(obj), name, old);
    }

    if (!is_method_body(body)) {
      var ancestor = obj.$$super;

      while (typeof(body) !== "function" && ancestor) {
        body     = ancestor[old_id];
        ancestor = ancestor.$$super;
      }

      if (!is_method_body(body) && obj.$$is_module) {
        // try to look into Object
        body = Opal.Object.$$prototype[old_id]
      }

      if (!is_method_body(body)) {
        throw Opal.NameError.$new("undefined method `" + old + "' for class `" + obj.$name() + "'")
      }
    }

    // If the body is itself an alias use the original body
    // to keep the max depth at 1.
    if (body.$$alias_of) body = body.$$alias_of;

    // We need a wrapper because otherwise properties
    // would be ovrewritten on the original body.
    alias = function() {
      var block = alias.$$p, args, i, ii;

      args = new Array(arguments.length);
      for(i = 0, ii = arguments.length; i < ii; i++) {
        args[i] = arguments[i];
      }

      if (block != null) { alias.$$p = null }

      return Opal.send(this, body, args, block);
    };

    // Try to make the browser pick the right name
    alias.displayName       = name;
    alias.length            = body.length;
    alias.$$arity           = body.$$arity;
    alias.$$parameters      = body.$$parameters;
    alias.$$source_location = body.$$source_location;
    alias.$$alias_of        = body;
    alias.$$alias_name      = name;

    Opal.defn(obj, id, alias);

    return obj;
  };

  Opal.alias_native = function(obj, name, native_name) {
    var id   = '$' + name,
        body = obj.$$prototype[native_name];

    if (typeof(body) !== "function" || body.$$stub) {
      throw Opal.NameError.$new("undefined native method `" + native_name + "' for class `" + obj.$name() + "'")
    }

    Opal.defn(obj, id, body);

    return obj;
  };


  // Hashes
  // ------

  Opal.hash_init = function(hash) {
    hash.$$smap = Object.create(null);
    hash.$$map  = Object.create(null);
    hash.$$keys = [];
  };

  Opal.hash_clone = function(from_hash, to_hash) {
    to_hash.$$none = from_hash.$$none;
    to_hash.$$proc = from_hash.$$proc;

    for (var i = 0, keys = from_hash.$$keys, smap = from_hash.$$smap, len = keys.length, key, value; i < len; i++) {
      key = keys[i];

      if (key.$$is_string) {
        value = smap[key];
      } else {
        value = key.value;
        key = key.key;
      }

      Opal.hash_put(to_hash, key, value);
    }
  };

  Opal.hash_put = function(hash, key, value) {
    if (key.$$is_string) {
      if (!$hasOwn.call(hash.$$smap, key)) {
        hash.$$keys.push(key);
      }
      hash.$$smap[key] = value;
      return;
    }

    var key_hash, bucket, last_bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if (!$hasOwn.call(hash.$$map, key_hash)) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      hash.$$map[key_hash] = bucket;
      return;
    }

    bucket = hash.$$map[key_hash];

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        last_bucket = undefined;
        bucket.value = value;
        break;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }

    if (last_bucket) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      last_bucket.next = bucket;
    }
  };

  Opal.hash_get = function(hash, key) {
    if (key.$$is_string) {
      if ($hasOwn.call(hash.$$smap, key)) {
        return hash.$$smap[key];
      }
      return;
    }

    var key_hash, bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if ($hasOwn.call(hash.$$map, key_hash)) {
      bucket = hash.$$map[key_hash];

      while (bucket) {
        if (key === bucket.key || key['$eql?'](bucket.key)) {
          return bucket.value;
        }
        bucket = bucket.next;
      }
    }
  };

  Opal.hash_delete = function(hash, key) {
    var i, keys = hash.$$keys, length = keys.length, value;

    if (key.$$is_string) {
      if (!$hasOwn.call(hash.$$smap, key)) {
        return;
      }

      for (i = 0; i < length; i++) {
        if (keys[i] === key) {
          keys.splice(i, 1);
          break;
        }
      }

      value = hash.$$smap[key];
      delete hash.$$smap[key];
      return value;
    }

    var key_hash = key.$hash();

    if (!$hasOwn.call(hash.$$map, key_hash)) {
      return;
    }

    var bucket = hash.$$map[key_hash], last_bucket;

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        value = bucket.value;

        for (i = 0; i < length; i++) {
          if (keys[i] === bucket) {
            keys.splice(i, 1);
            break;
          }
        }

        if (last_bucket && bucket.next) {
          last_bucket.next = bucket.next;
        }
        else if (last_bucket) {
          delete last_bucket.next;
        }
        else if (bucket.next) {
          hash.$$map[key_hash] = bucket.next;
        }
        else {
          delete hash.$$map[key_hash];
        }

        return value;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }
  };

  Opal.hash_rehash = function(hash) {
    for (var i = 0, length = hash.$$keys.length, key_hash, bucket, last_bucket; i < length; i++) {

      if (hash.$$keys[i].$$is_string) {
        continue;
      }

      key_hash = hash.$$keys[i].key.$hash();

      if (key_hash === hash.$$keys[i].key_hash) {
        continue;
      }

      bucket = hash.$$map[hash.$$keys[i].key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          if (last_bucket && bucket.next) {
            last_bucket.next = bucket.next;
          }
          else if (last_bucket) {
            delete last_bucket.next;
          }
          else if (bucket.next) {
            hash.$$map[hash.$$keys[i].key_hash] = bucket.next;
          }
          else {
            delete hash.$$map[hash.$$keys[i].key_hash];
          }
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      hash.$$keys[i].key_hash = key_hash;

      if (!$hasOwn.call(hash.$$map, key_hash)) {
        hash.$$map[key_hash] = hash.$$keys[i];
        continue;
      }

      bucket = hash.$$map[key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          last_bucket = undefined;
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      if (last_bucket) {
        last_bucket.next = hash.$$keys[i];
      }
    }
  };

  Opal.hash = function() {
    var arguments_length = arguments.length, args, hash, i, length, key, value;

    if (arguments_length === 1 && arguments[0].$$is_hash) {
      return arguments[0];
    }

    hash = new Opal.Hash();
    Opal.hash_init(hash);

    if (arguments_length === 1 && arguments[0].$$is_array) {
      args = arguments[0];
      length = args.length;

      for (i = 0; i < length; i++) {
        if (args[i].length !== 2) {
          throw Opal.ArgumentError.$new("value not of length 2: " + args[i].$inspect());
        }

        key = args[i][0];
        value = args[i][1];

        Opal.hash_put(hash, key, value);
      }

      return hash;
    }

    if (arguments_length === 1) {
      args = arguments[0];
      for (key in args) {
        if ($hasOwn.call(args, key)) {
          value = args[key];

          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    }

    if (arguments_length % 2 !== 0) {
      throw Opal.ArgumentError.$new("odd number of arguments for Hash");
    }

    for (i = 0; i < arguments_length; i += 2) {
      key = arguments[i];
      value = arguments[i + 1];

      Opal.hash_put(hash, key, value);
    }

    return hash;
  };

  // A faster Hash creator for hashes that just use symbols and
  // strings as keys. The map and keys array can be constructed at
  // compile time, so they are just added here by the constructor
  // function.
  //
  Opal.hash2 = function(keys, smap) {
    var hash = new Opal.Hash();

    hash.$$smap = smap;
    hash.$$map  = Object.create(null);
    hash.$$keys = keys;

    return hash;
  };

  // Create a new range instance with first and last values, and whether the
  // range excludes the last value.
  //
  Opal.range = function(first, last, exc) {
    var range         = new Opal.Range();
        range.begin   = first;
        range.end     = last;
        range.excl    = exc;

    return range;
  };

  // Get the ivar name for a given name.
  // Mostly adds a trailing $ to reserved names.
  //
  Opal.ivar = function(name) {
    if (
        // properties
        name === "constructor" ||
        name === "displayName" ||
        name === "__count__" ||
        name === "__noSuchMethod__" ||
        name === "__parent__" ||
        name === "__proto__" ||

        // methods
        name === "hasOwnProperty" ||
        name === "valueOf"
       )
    {
      return name + "$";
    }

    return name;
  };


  // Regexps
  // -------

  // Escape Regexp special chars letting the resulting string be used to build
  // a new Regexp.
  //
  Opal.escape_regexp = function(str) {
    return str.replace(/([-[\]\/{}()*+?.^$\\| ])/g, '\\$1')
              .replace(/[\n]/g, '\\n')
              .replace(/[\r]/g, '\\r')
              .replace(/[\f]/g, '\\f')
              .replace(/[\t]/g, '\\t');
  };

  // Create a global Regexp from a RegExp object and cache the result
  // on the object itself ($$g attribute).
  //
  Opal.global_regexp = function(pattern) {
    if (pattern.global) {
      return pattern; // RegExp already has the global flag
    }
    if (pattern.$$g == null) {
      pattern.$$g = new RegExp(pattern.source, (pattern.multiline ? 'gm' : 'g') + (pattern.ignoreCase ? 'i' : ''));
    } else {
      pattern.$$g.lastIndex = null; // reset lastIndex property
    }
    return pattern.$$g;
  };

  // Create a global multiline Regexp from a RegExp object and cache the result
  // on the object itself ($$gm or $$g attribute).
  //
  Opal.global_multiline_regexp = function(pattern) {
    var result;
    if (pattern.multiline) {
      if (pattern.global) {
        return pattern; // RegExp already has the global and multiline flag
      }
      // we are using the $$g attribute because the Regexp is already multiline
      if (pattern.$$g != null) {
        result = pattern.$$g;
      } else {
        result = pattern.$$g = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
      }
    } else if (pattern.$$gm != null) {
      result = pattern.$$gm;
    } else {
      result = pattern.$$gm = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
    }
    result.lastIndex = null; // reset lastIndex property
    return result;
  };

  // Require system
  // --------------

  Opal.modules         = {};
  Opal.loaded_features = ['corelib/runtime'];
  Opal.current_dir     = '.';
  Opal.require_table   = {'corelib/runtime': true};

  Opal.normalize = function(path) {
    var parts, part, new_parts = [], SEPARATOR = '/';

    if (Opal.current_dir !== '.') {
      path = Opal.current_dir.replace(/\/*$/, '/') + path;
    }

    path = path.replace(/^\.\//, '');
    path = path.replace(/\.(rb|opal|js)$/, '');
    parts = path.split(SEPARATOR);

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part === '') continue;
      (part === '..') ? new_parts.pop() : new_parts.push(part)
    }

    return new_parts.join(SEPARATOR);
  };

  Opal.loaded = function(paths) {
    var i, l, path;

    for (i = 0, l = paths.length; i < l; i++) {
      path = Opal.normalize(paths[i]);

      if (Opal.require_table[path]) {
        continue;
      }

      Opal.loaded_features.push(path);
      Opal.require_table[path] = true;
    }
  };

  Opal.load = function(path) {
    path = Opal.normalize(path);

    Opal.loaded([path]);

    var module = Opal.modules[path];

    if (module) {
      module(Opal);
    }
    else {
      var severity = Opal.config.missing_require_severity;
      var message  = 'cannot load such file -- ' + path;

      if (severity === "error") {
        if (Opal.LoadError) {
          throw Opal.LoadError.$new(message)
        } else {
          throw message
        }
      }
      else if (severity === "warning") {
        console.warn('WARNING: LoadError: ' + message);
      }
    }

    return true;
  };

  Opal.require = function(path) {
    path = Opal.normalize(path);

    if (Opal.require_table[path]) {
      return false;
    }

    return Opal.load(path);
  };


  // Strings
  // -------

  Opal.encodings = Object.create(null);

  // Sets the encoding on a string, will treat string literals as frozen strings
  // raising a FrozenError.
  // @param str [String] the string on which the encoding should be set.
  // @param name [String] the canonical name of the encoding
  Opal.set_encoding = function(str, name) {
    if (typeof str === 'string')
      throw Opal.FrozenError.$new("can't modify frozen String");

    var encoding = Opal.encodings[name];

    if (encoding === str.encoding) { return str; }

    str.encoding = encoding;

    return str;
  };

  // @returns a String object with the encoding set from a string literal
  Opal.enc = function(str, name) {
    var dup = new String(str);
    Opal.set_encoding(dup, name);
    dup.internal_encoding = dup.encoding;
    return dup
  }


  // Initialization
  // --------------
  function $BasicObject() {};
  function $Object() {};
  function $Module() {};
  function $Class() {};

  Opal.BasicObject = BasicObject = Opal.allocate_class('BasicObject', null, $BasicObject);
  Opal.Object      = _Object     = Opal.allocate_class('Object', Opal.BasicObject, $Object);
  Opal.Module      = Module      = Opal.allocate_class('Module', Opal.Object, $Module);
  Opal.Class       = Class       = Opal.allocate_class('Class', Opal.Module, $Class);

  $setPrototype(Opal.BasicObject, Opal.Class.$$prototype);
  $setPrototype(Opal.Object, Opal.Class.$$prototype);
  $setPrototype(Opal.Module, Opal.Class.$$prototype);
  $setPrototype(Opal.Class, Opal.Class.$$prototype);

  // BasicObject can reach itself, avoid const_set to skip the $$base_module logic
  BasicObject.$$const["BasicObject"] = BasicObject;

  // Assign basic constants
  Opal.const_set(_Object, "BasicObject",  BasicObject);
  Opal.const_set(_Object, "Object",       _Object);
  Opal.const_set(_Object, "Module",       Module);
  Opal.const_set(_Object, "Class",        Class);

  // Fix booted classes to have correct .class value
  BasicObject.$$class = Class;
  _Object.$$class     = Class;
  Module.$$class      = Class;
  Class.$$class       = Class;

  // Forward .toString() to #to_s
  $defineProperty(_Object.$$prototype, 'toString', function() {
    var to_s = this.$to_s();
    if (to_s.$$is_string && typeof(to_s) === 'object') {
      // a string created using new String('string')
      return to_s.valueOf();
    } else {
      return to_s;
    }
  });

  // Make Kernel#require immediately available as it's needed to require all the
  // other corelib files.
  $defineProperty(_Object.$$prototype, '$require', Opal.require);

  // Add a short helper to navigate constants manually.
  // @example
  //   Opal.$$.Regexp.$$.IGNORECASE
  Opal.$$ = _Object.$$;

  // Instantiate the main object
  Opal.top = new _Object();
  Opal.top.$to_s = Opal.top.$inspect = function() { return 'main' };


  // Nil
  function $NilClass() {};
  Opal.NilClass = Opal.allocate_class('NilClass', Opal.Object, $NilClass);
  Opal.const_set(_Object, 'NilClass', Opal.NilClass);
  nil = Opal.nil = new Opal.NilClass();
  nil.$$id = nil_id;
  nil.call = nil.apply = function() { throw Opal.LocalJumpError.$new('no block given'); };

  // Errors
  Opal.breaker  = new Error('unexpected break (old)');
  Opal.returner = new Error('unexpected return');
  TypeError.$$super = Error;
}).call(this);
Opal.loaded(["corelib/runtime.js"]);
/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/helpers"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$new', '$class', '$===', '$respond_to?', '$raise', '$type_error', '$__send__', '$coerce_to', '$nil?', '$<=>', '$coerce_to!', '$!=', '$[]', '$upcase']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting), $Opal_bridge$1, $Opal_type_error$2, $Opal_coerce_to$3, $Opal_coerce_to$excl$4, $Opal_coerce_to$ques$5, $Opal_try_convert$6, $Opal_compare$7, $Opal_destructure$8, $Opal_respond_to$ques$9, $Opal_inspect_obj$10, $Opal_instance_variable_name$excl$11, $Opal_class_variable_name$excl$12, $Opal_const_name$excl$13, $Opal_pristine$14;

    
    Opal.defs(self, '$bridge', $Opal_bridge$1 = function $$bridge(constructor, klass) {
      var self = this;

      return Opal.bridge(constructor, klass);
    }, $Opal_bridge$1.$$arity = 2);
    Opal.defs(self, '$type_error', $Opal_type_error$2 = function $$type_error(object, type, method, coerced) {
      var $a, self = this;

      
      
      if (method == null) {
        method = nil;
      };
      
      if (coerced == null) {
        coerced = nil;
      };
      if ($truthy(($truthy($a = method) ? coerced : $a))) {
        return $$($nesting, 'TypeError').$new("" + "can't convert " + (object.$class()) + " into " + (type) + " (" + (object.$class()) + "#" + (method) + " gives " + (coerced.$class()) + ")")
      } else {
        return $$($nesting, 'TypeError').$new("" + "no implicit conversion of " + (object.$class()) + " into " + (type))
      };
    }, $Opal_type_error$2.$$arity = -3);
    Opal.defs(self, '$coerce_to', $Opal_coerce_to$3 = function $$coerce_to(object, type, method) {
      var self = this;

      
      if ($truthy(type['$==='](object))) {
        return object};
      if ($truthy(object['$respond_to?'](method))) {
      } else {
        self.$raise(self.$type_error(object, type))
      };
      return object.$__send__(method);
    }, $Opal_coerce_to$3.$$arity = 3);
    Opal.defs(self, '$coerce_to!', $Opal_coerce_to$excl$4 = function(object, type, method) {
      var self = this, coerced = nil;

      
      coerced = self.$coerce_to(object, type, method);
      if ($truthy(type['$==='](coerced))) {
      } else {
        self.$raise(self.$type_error(object, type, method, coerced))
      };
      return coerced;
    }, $Opal_coerce_to$excl$4.$$arity = 3);
    Opal.defs(self, '$coerce_to?', $Opal_coerce_to$ques$5 = function(object, type, method) {
      var self = this, coerced = nil;

      
      if ($truthy(object['$respond_to?'](method))) {
      } else {
        return nil
      };
      coerced = self.$coerce_to(object, type, method);
      if ($truthy(coerced['$nil?']())) {
        return nil};
      if ($truthy(type['$==='](coerced))) {
      } else {
        self.$raise(self.$type_error(object, type, method, coerced))
      };
      return coerced;
    }, $Opal_coerce_to$ques$5.$$arity = 3);
    Opal.defs(self, '$try_convert', $Opal_try_convert$6 = function $$try_convert(object, type, method) {
      var self = this;

      
      if ($truthy(type['$==='](object))) {
        return object};
      if ($truthy(object['$respond_to?'](method))) {
        return object.$__send__(method)
      } else {
        return nil
      };
    }, $Opal_try_convert$6.$$arity = 3);
    Opal.defs(self, '$compare', $Opal_compare$7 = function $$compare(a, b) {
      var self = this, compare = nil;

      
      compare = a['$<=>'](b);
      if ($truthy(compare === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (a.$class()) + " with " + (b.$class()) + " failed")};
      return compare;
    }, $Opal_compare$7.$$arity = 2);
    Opal.defs(self, '$destructure', $Opal_destructure$8 = function $$destructure(args) {
      var self = this;

      
      if (args.length == 1) {
        return args[0];
      }
      else if (args.$$is_array) {
        return args;
      }
      else {
        var args_ary = new Array(args.length);
        for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

        return args_ary;
      }
    
    }, $Opal_destructure$8.$$arity = 1);
    Opal.defs(self, '$respond_to?', $Opal_respond_to$ques$9 = function(obj, method, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      
      if (obj == null || !obj.$$class) {
        return false;
      }
    ;
      return obj['$respond_to?'](method, include_all);
    }, $Opal_respond_to$ques$9.$$arity = -3);
    Opal.defs(self, '$inspect_obj', $Opal_inspect_obj$10 = function $$inspect_obj(obj) {
      var self = this;

      return Opal.inspect(obj);
    }, $Opal_inspect_obj$10.$$arity = 1);
    Opal.defs(self, '$instance_variable_name!', $Opal_instance_variable_name$excl$11 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      if ($truthy(/^@[a-zA-Z_][a-zA-Z0-9_]*?$/.test(name))) {
      } else {
        self.$raise($$($nesting, 'NameError').$new("" + "'" + (name) + "' is not allowed as an instance variable name", name))
      };
      return name;
    }, $Opal_instance_variable_name$excl$11.$$arity = 1);
    Opal.defs(self, '$class_variable_name!', $Opal_class_variable_name$excl$12 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      if ($truthy(name.length < 3 || name.slice(0,2) !== '@@')) {
        self.$raise($$($nesting, 'NameError').$new("" + "`" + (name) + "' is not allowed as a class variable name", name))};
      return name;
    }, $Opal_class_variable_name$excl$12.$$arity = 1);
    Opal.defs(self, '$const_name!', $Opal_const_name$excl$13 = function(const_name) {
      var self = this;

      
      const_name = $$($nesting, 'Opal')['$coerce_to!'](const_name, $$($nesting, 'String'), "to_str");
      if ($truthy(const_name['$[]'](0)['$!='](const_name['$[]'](0).$upcase()))) {
        self.$raise($$($nesting, 'NameError'), "" + "wrong constant name " + (const_name))};
      return const_name;
    }, $Opal_const_name$excl$13.$$arity = 1);
    Opal.defs(self, '$pristine', $Opal_pristine$14 = function $$pristine(owner_class, $a) {
      var $post_args, method_names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      method_names = $post_args;;
      
      var method_name, method;
      for (var i = method_names.length - 1; i >= 0; i--) {
        method_name = method_names[i];
        method = owner_class.$$prototype['$'+method_name];

        if (method && !method.$$stub) {
          method.$$pristine = true;
        }
      }
    ;
      return nil;
    }, $Opal_pristine$14.$$arity = -2);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/module"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $lambda = Opal.lambda, $range = Opal.range, $hash2 = Opal.hash2;

  Opal.add_stubs(['$module_eval', '$to_proc', '$===', '$raise', '$equal?', '$<', '$>', '$nil?', '$attr_reader', '$attr_writer', '$class_variable_name!', '$new', '$const_name!', '$=~', '$inject', '$split', '$const_get', '$==', '$!~', '$start_with?', '$bind', '$call', '$class', '$append_features', '$included', '$name', '$cover?', '$size', '$merge', '$compile', '$proc', '$any?', '$prepend_features', '$prepended', '$to_s', '$__id__', '$constants', '$include?', '$copy_class_variables', '$copy_constants']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $Module_allocate$1, $Module_initialize$2, $Module_$eq_eq_eq$3, $Module_$lt$4, $Module_$lt_eq$5, $Module_$gt$6, $Module_$gt_eq$7, $Module_$lt_eq_gt$8, $Module_alias_method$9, $Module_alias_native$10, $Module_ancestors$11, $Module_append_features$12, $Module_attr_accessor$13, $Module_attr_reader$14, $Module_attr_writer$15, $Module_autoload$16, $Module_class_variables$17, $Module_class_variable_get$18, $Module_class_variable_set$19, $Module_class_variable_defined$ques$20, $Module_remove_class_variable$21, $Module_constants$22, $Module_constants$23, $Module_nesting$24, $Module_const_defined$ques$25, $Module_const_get$26, $Module_const_missing$28, $Module_const_set$29, $Module_public_constant$30, $Module_define_method$31, $Module_remove_method$33, $Module_singleton_class$ques$34, $Module_include$35, $Module_included_modules$36, $Module_include$ques$37, $Module_instance_method$38, $Module_instance_methods$39, $Module_included$40, $Module_extended$41, $Module_extend_object$42, $Module_method_added$43, $Module_method_removed$44, $Module_method_undefined$45, $Module_module_eval$46, $Module_module_exec$48, $Module_method_defined$ques$49, $Module_module_function$50, $Module_name$51, $Module_prepend$52, $Module_prepend_features$53, $Module_prepended$54, $Module_remove_const$55, $Module_to_s$56, $Module_undef_method$57, $Module_instance_variables$58, $Module_dup$59, $Module_copy_class_variables$60, $Module_copy_constants$61;

    
    Opal.defs(self, '$allocate', $Module_allocate$1 = function $$allocate() {
      var self = this;

      
      var module = Opal.allocate_module(nil, function(){});
      // Link the prototype of Module subclasses
      if (self !== Opal.Module) Object.setPrototypeOf(module, self.$$prototype);
      return module;
    
    }, $Module_allocate$1.$$arity = 0);
    
    Opal.def(self, '$initialize', $Module_initialize$2 = function $$initialize() {
      var $iter = $Module_initialize$2.$$p, block = $iter || nil, self = this;

      if ($iter) $Module_initialize$2.$$p = null;
      
      
      if ($iter) $Module_initialize$2.$$p = null;;
      if ((block !== nil)) {
        return $send(self, 'module_eval', [], block.$to_proc())
      } else {
        return nil
      };
    }, $Module_initialize$2.$$arity = 0);
    
    Opal.def(self, '$===', $Module_$eq_eq_eq$3 = function(object) {
      var self = this;

      
      if ($truthy(object == null)) {
        return false};
      return Opal.is_a(object, self);;
    }, $Module_$eq_eq_eq$3.$$arity = 1);
    
    Opal.def(self, '$<', $Module_$lt$4 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Module')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "compared with non class/module")
      };
      
      var working = self,
          ancestors,
          i, length;

      if (working === other) {
        return false;
      }

      for (i = 0, ancestors = Opal.ancestors(self), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === other) {
          return true;
        }
      }

      for (i = 0, ancestors = Opal.ancestors(other), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === self) {
          return false;
        }
      }

      return nil;
    ;
    }, $Module_$lt$4.$$arity = 1);
    
    Opal.def(self, '$<=', $Module_$lt_eq$5 = function(other) {
      var $a, self = this;

      return ($truthy($a = self['$equal?'](other)) ? $a : $rb_lt(self, other))
    }, $Module_$lt_eq$5.$$arity = 1);
    
    Opal.def(self, '$>', $Module_$gt$6 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Module')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "compared with non class/module")
      };
      return $rb_lt(other, self);
    }, $Module_$gt$6.$$arity = 1);
    
    Opal.def(self, '$>=', $Module_$gt_eq$7 = function(other) {
      var $a, self = this;

      return ($truthy($a = self['$equal?'](other)) ? $a : $rb_gt(self, other))
    }, $Module_$gt_eq$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $Module_$lt_eq_gt$8 = function(other) {
      var self = this, lt = nil;

      
      
      if (self === other) {
        return 0;
      }
    ;
      if ($truthy($$($nesting, 'Module')['$==='](other))) {
      } else {
        return nil
      };
      lt = $rb_lt(self, other);
      if ($truthy(lt['$nil?']())) {
        return nil};
      if ($truthy(lt)) {
        return -1
      } else {
        return 1
      };
    }, $Module_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$alias_method', $Module_alias_method$9 = function $$alias_method(newname, oldname) {
      var self = this;

      
      Opal.alias(self, newname, oldname);
      return self;
    }, $Module_alias_method$9.$$arity = 2);
    
    Opal.def(self, '$alias_native', $Module_alias_native$10 = function $$alias_native(mid, jsid) {
      var self = this;

      
      
      if (jsid == null) {
        jsid = mid;
      };
      Opal.alias_native(self, mid, jsid);
      return self;
    }, $Module_alias_native$10.$$arity = -2);
    
    Opal.def(self, '$ancestors', $Module_ancestors$11 = function $$ancestors() {
      var self = this;

      return Opal.ancestors(self);
    }, $Module_ancestors$11.$$arity = 0);
    
    Opal.def(self, '$append_features', $Module_append_features$12 = function $$append_features(includer) {
      var self = this;

      
      Opal.append_features(self, includer);
      return self;
    }, $Module_append_features$12.$$arity = 1);
    
    Opal.def(self, '$attr_accessor', $Module_attr_accessor$13 = function $$attr_accessor($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      $send(self, 'attr_reader', Opal.to_a(names));
      return $send(self, 'attr_writer', Opal.to_a(names));
    }, $Module_attr_accessor$13.$$arity = -1);
    Opal.alias(self, "attr", "attr_accessor");
    
    Opal.def(self, '$attr_reader', $Module_attr_reader$14 = function $$attr_reader($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name,
            ivar = Opal.ivar(name);

        // the closure here is needed because name will change at the next
        // cycle, I wish we could use let.
        var body = (function(ivar) {
          return function() {
            if (this[ivar] == null) {
              return nil;
            }
            else {
              return this[ivar];
            }
          };
        })(ivar);

        // initialize the instance variable as nil
        Opal.defineProperty(proto, ivar, nil);

        body.$$parameters = [];
        body.$$arity = 0;

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, $Module_attr_reader$14.$$arity = -1);
    
    Opal.def(self, '$attr_writer', $Module_attr_writer$15 = function $$attr_writer($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name + '=',
            ivar = Opal.ivar(name);

        // the closure here is needed because name will change at the next
        // cycle, I wish we could use let.
        var body = (function(ivar){
          return function(value) {
            return this[ivar] = value;
          }
        })(ivar);

        body.$$parameters = [['req']];
        body.$$arity = 1;

        // initialize the instance variable as nil
        Opal.defineProperty(proto, ivar, nil);

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, $Module_attr_writer$15.$$arity = -1);
    
    Opal.def(self, '$autoload', $Module_autoload$16 = function $$autoload(const$, path) {
      var self = this;

      
      if (self.$$autoload == null) self.$$autoload = {};
      Opal.const_cache_version++;
      self.$$autoload[const$] = path;
      return nil;
    
    }, $Module_autoload$16.$$arity = 2);
    
    Opal.def(self, '$class_variables', $Module_class_variables$17 = function $$class_variables() {
      var self = this;

      return Object.keys(Opal.class_variables(self));
    }, $Module_class_variables$17.$$arity = 0);
    
    Opal.def(self, '$class_variable_get', $Module_class_variable_get$18 = function $$class_variable_get(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      
      var value = Opal.class_variables(self)[name];
      if (value == null) {
        self.$raise($$($nesting, 'NameError').$new("" + "uninitialized class variable " + (name) + " in " + (self), name))
      }
      return value;
    ;
    }, $Module_class_variable_get$18.$$arity = 1);
    
    Opal.def(self, '$class_variable_set', $Module_class_variable_set$19 = function $$class_variable_set(name, value) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      return Opal.class_variable_set(self, name, value);;
    }, $Module_class_variable_set$19.$$arity = 2);
    
    Opal.def(self, '$class_variable_defined?', $Module_class_variable_defined$ques$20 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      return Opal.class_variables(self).hasOwnProperty(name);;
    }, $Module_class_variable_defined$ques$20.$$arity = 1);
    
    Opal.def(self, '$remove_class_variable', $Module_remove_class_variable$21 = function $$remove_class_variable(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      
      if (Opal.hasOwnProperty.call(self.$$cvars, name)) {
        var value = self.$$cvars[name];
        delete self.$$cvars[name];
        return value;
      } else {
        self.$raise($$($nesting, 'NameError'), "" + "cannot remove " + (name) + " for " + (self))
      }
    ;
    }, $Module_remove_class_variable$21.$$arity = 1);
    
    Opal.def(self, '$constants', $Module_constants$22 = function $$constants(inherit) {
      var self = this;

      
      
      if (inherit == null) {
        inherit = true;
      };
      return Opal.constants(self, inherit);;
    }, $Module_constants$22.$$arity = -1);
    Opal.defs(self, '$constants', $Module_constants$23 = function $$constants(inherit) {
      var self = this;

      
      ;
      
      if (inherit == null) {
        var nesting = (self.$$nesting || []).concat(Opal.Object),
            constant, constants = {},
            i, ii;

        for(i = 0, ii = nesting.length; i < ii; i++) {
          for (constant in nesting[i].$$const) {
            constants[constant] = true;
          }
        }
        return Object.keys(constants);
      } else {
        return Opal.constants(self, inherit)
      }
    ;
    }, $Module_constants$23.$$arity = -1);
    Opal.defs(self, '$nesting', $Module_nesting$24 = function $$nesting() {
      var self = this;

      return self.$$nesting || [];
    }, $Module_nesting$24.$$arity = 0);
    
    Opal.def(self, '$const_defined?', $Module_const_defined$ques$25 = function(name, inherit) {
      var self = this;

      
      
      if (inherit == null) {
        inherit = true;
      };
      name = $$($nesting, 'Opal')['$const_name!'](name);
      if ($truthy(name['$=~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {
      } else {
        self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))
      };
      
      var module, modules = [self], module_constants, i, ii;

      // Add up ancestors if inherit is true
      if (inherit) {
        modules = modules.concat(Opal.ancestors(self));

        // Add Object's ancestors if it's a module – modules have no ancestors otherwise
        if (self.$$is_module) {
          modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));
        }
      }

      for (i = 0, ii = modules.length; i < ii; i++) {
        module = modules[i];
        if (module.$$const[name] != null) {
          return true;
        }
      }

      return false;
    ;
    }, $Module_const_defined$ques$25.$$arity = -2);
    
    Opal.def(self, '$const_get', $Module_const_get$26 = function $$const_get(name, inherit) {
      var $$27, self = this;

      
      
      if (inherit == null) {
        inherit = true;
      };
      name = $$($nesting, 'Opal')['$const_name!'](name);
      
      if (name.indexOf('::') === 0 && name !== '::'){
        name = name.slice(2);
      }
    ;
      if ($truthy(name.indexOf('::') != -1 && name != '::')) {
        return $send(name.$split("::"), 'inject', [self], ($$27 = function(o, c){var self = $$27.$$s || this;

        
          
          if (o == null) {
            o = nil;
          };
          
          if (c == null) {
            c = nil;
          };
          return o.$const_get(c);}, $$27.$$s = self, $$27.$$arity = 2, $$27))};
      if ($truthy(name['$=~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {
      } else {
        self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))
      };
      
      if (inherit) {
        return $$([self], name);
      } else {
        return Opal.const_get_local(self, name);
      }
    ;
    }, $Module_const_get$26.$$arity = -2);
    
    Opal.def(self, '$const_missing', $Module_const_missing$28 = function $$const_missing(name) {
      var self = this, full_const_name = nil;

      
      
      if (self.$$autoload) {
        var file = self.$$autoload[name];

        if (file) {
          self.$require(file);

          return self.$const_get(name);
        }
      }
    ;
      full_const_name = (function() {if (self['$==']($$($nesting, 'Object'))) {
        return name
      } else {
        return "" + (self) + "::" + (name)
      }; return nil; })();
      return self.$raise($$($nesting, 'NameError').$new("" + "uninitialized constant " + (full_const_name), name));
    }, $Module_const_missing$28.$$arity = 1);
    
    Opal.def(self, '$const_set', $Module_const_set$29 = function $$const_set(name, value) {
      var $a, self = this;

      
      name = $$($nesting, 'Opal')['$const_name!'](name);
      if ($truthy(($truthy($a = name['$!~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP'))) ? $a : name['$start_with?']("::")))) {
        self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))};
      Opal.const_set(self, name, value);
      return value;
    }, $Module_const_set$29.$$arity = 2);
    
    Opal.def(self, '$public_constant', $Module_public_constant$30 = function $$public_constant(const_name) {
      var self = this;

      return nil
    }, $Module_public_constant$30.$$arity = 1);
    
    Opal.def(self, '$define_method', $Module_define_method$31 = function $$define_method(name, method) {
      var $iter = $Module_define_method$31.$$p, block = $iter || nil, $a, $$32, self = this, $case = nil;

      if ($iter) $Module_define_method$31.$$p = null;
      
      
      if ($iter) $Module_define_method$31.$$p = null;;
      ;
      if ($truthy(method === undefined && block === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "tried to create a Proc object without a block")};
      block = ($truthy($a = block) ? $a : (function() {$case = method;
      if ($$($nesting, 'Proc')['$===']($case)) {return method}
      else if ($$($nesting, 'Method')['$===']($case)) {return method.$to_proc().$$unbound}
      else if ($$($nesting, 'UnboundMethod')['$===']($case)) {return $lambda(($$32 = function($b){var self = $$32.$$s || this, $post_args, args, bound = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        bound = method.$bind(self);
        return $send(bound, 'call', Opal.to_a(args));}, $$32.$$s = self, $$32.$$arity = -1, $$32))}
      else {return self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (block.$class()) + " (expected Proc/Method)")}})());
      
      var id = '$' + name;

      block.$$jsid        = name;
      block.$$s           = null;
      block.$$def         = block;
      block.$$define_meth = true;

      Opal.defn(self, id, block);

      return name;
    ;
    }, $Module_define_method$31.$$arity = -2);
    
    Opal.def(self, '$remove_method', $Module_remove_method$33 = function $$remove_method($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      for (var i = 0, length = names.length; i < length; i++) {
        Opal.rdef(self, "$" + names[i]);
      }
    ;
      return self;
    }, $Module_remove_method$33.$$arity = -1);
    
    Opal.def(self, '$singleton_class?', $Module_singleton_class$ques$34 = function() {
      var self = this;

      return !!self.$$is_singleton;
    }, $Module_singleton_class$ques$34.$$arity = 0);
    
    Opal.def(self, '$include', $Module_include$35 = function $$include($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      mods = $post_args;;
      
      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(self);
        (mod).$included(self);
      }
    ;
      return self;
    }, $Module_include$35.$$arity = -1);
    
    Opal.def(self, '$included_modules', $Module_included_modules$36 = function $$included_modules() {
      var self = this;

      return Opal.included_modules(self);
    }, $Module_included_modules$36.$$arity = 0);
    
    Opal.def(self, '$include?', $Module_include$ques$37 = function(mod) {
      var self = this;

      
      if (!mod.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
      }

      var i, ii, mod2, ancestors = Opal.ancestors(self);

      for (i = 0, ii = ancestors.length; i < ii; i++) {
        mod2 = ancestors[i];
        if (mod2 === mod && mod2 !== self) {
          return true;
        }
      }

      return false;
    
    }, $Module_include$ques$37.$$arity = 1);
    
    Opal.def(self, '$instance_method', $Module_instance_method$38 = function $$instance_method(name) {
      var self = this;

      
      var meth = self.$$prototype['$' + name];

      if (!meth || meth.$$stub) {
        self.$raise($$($nesting, 'NameError').$new("" + "undefined method `" + (name) + "' for class `" + (self.$name()) + "'", name));
      }

      return $$($nesting, 'UnboundMethod').$new(self, meth.$$owner || self, meth, name);
    
    }, $Module_instance_method$38.$$arity = 1);
    
    Opal.def(self, '$instance_methods', $Module_instance_methods$39 = function $$instance_methods(include_super) {
      var self = this;

      
      
      if (include_super == null) {
        include_super = true;
      };
      
      if ($truthy(include_super)) {
        return Opal.instance_methods(self);
      } else {
        return Opal.own_instance_methods(self);
      }
    ;
    }, $Module_instance_methods$39.$$arity = -1);
    
    Opal.def(self, '$included', $Module_included$40 = function $$included(mod) {
      var self = this;

      return nil
    }, $Module_included$40.$$arity = 1);
    
    Opal.def(self, '$extended', $Module_extended$41 = function $$extended(mod) {
      var self = this;

      return nil
    }, $Module_extended$41.$$arity = 1);
    
    Opal.def(self, '$extend_object', $Module_extend_object$42 = function $$extend_object(object) {
      var self = this;

      return nil
    }, $Module_extend_object$42.$$arity = 1);
    
    Opal.def(self, '$method_added', $Module_method_added$43 = function $$method_added($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_method_added$43.$$arity = -1);
    
    Opal.def(self, '$method_removed', $Module_method_removed$44 = function $$method_removed($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_method_removed$44.$$arity = -1);
    
    Opal.def(self, '$method_undefined', $Module_method_undefined$45 = function $$method_undefined($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_method_undefined$45.$$arity = -1);
    
    Opal.def(self, '$module_eval', $Module_module_eval$46 = function $$module_eval($a) {
      var $iter = $Module_module_eval$46.$$p, block = $iter || nil, $post_args, args, $b, $$47, self = this, string = nil, file = nil, _lineno = nil, default_eval_options = nil, compiling_options = nil, compiled = nil;

      if ($iter) $Module_module_eval$46.$$p = null;
      
      
      if ($iter) $Module_module_eval$46.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(($truthy($b = block['$nil?']()) ? !!Opal.compile : $b))) {
        
        if ($truthy($range(1, 3, false)['$cover?'](args.$size()))) {
        } else {
          $$($nesting, 'Kernel').$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat(Opal.to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": ($truthy($b = file) ? $b : "(eval)"), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $$($nesting, 'Opal').$compile(string, compiling_options);
        block = $send($$($nesting, 'Kernel'), 'proc', [], ($$47 = function(){var self = $$47.$$s || this;

        
          return (function(self) {
            return eval(compiled);
          })(self)
        }, $$47.$$s = self, $$47.$$arity = 0, $$47));
      } else if ($truthy(args['$any?']())) {
        $$($nesting, 'Kernel').$raise($$($nesting, 'ArgumentError'), "" + ("" + "wrong number of arguments (" + (args.$size()) + " for 0)") + "\n\n  NOTE:If you want to enable passing a String argument please add \"require 'opal-parser'\" to your script\n")};
      
      var old = block.$$s,
          result;

      block.$$s = null;
      result = block.apply(self, [self]);
      block.$$s = old;

      return result;
    ;
    }, $Module_module_eval$46.$$arity = -1);
    Opal.alias(self, "class_eval", "module_eval");
    
    Opal.def(self, '$module_exec', $Module_module_exec$48 = function $$module_exec($a) {
      var $iter = $Module_module_exec$48.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Module_module_exec$48.$$p = null;
      
      
      if ($iter) $Module_module_exec$48.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      if (block === nil) {
        self.$raise($$($nesting, 'LocalJumpError'), "no block given")
      }

      var block_self = block.$$s, result;

      block.$$s = null;
      result = block.apply(self, args);
      block.$$s = block_self;

      return result;
    ;
    }, $Module_module_exec$48.$$arity = -1);
    Opal.alias(self, "class_exec", "module_exec");
    
    Opal.def(self, '$method_defined?', $Module_method_defined$ques$49 = function(method) {
      var self = this;

      
      var body = self.$$prototype['$' + method];
      return (!!body) && !body.$$stub;
    
    }, $Module_method_defined$ques$49.$$arity = 1);
    
    Opal.def(self, '$module_function', $Module_module_function$50 = function $$module_function($a) {
      var $post_args, methods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      methods = $post_args;;
      
      if (methods.length === 0) {
        self.$$module_function = true;
      }
      else {
        for (var i = 0, length = methods.length; i < length; i++) {
          var meth = methods[i],
              id   = '$' + meth,
              func = self.$$prototype[id];

          Opal.defs(self, id, func);
        }
      }

      return self;
    ;
    }, $Module_module_function$50.$$arity = -1);
    
    Opal.def(self, '$name', $Module_name$51 = function $$name() {
      var self = this;

      
      if (self.$$full_name) {
        return self.$$full_name;
      }

      var result = [], base = self;

      while (base) {
        // Give up if any of the ancestors is unnamed
        if (base.$$name === nil || base.$$name == null) return nil;

        result.unshift(base.$$name);

        base = base.$$base_module;

        if (base === Opal.Object) {
          break;
        }
      }

      if (result.length === 0) {
        return nil;
      }

      return self.$$full_name = result.join('::');
    
    }, $Module_name$51.$$arity = 0);
    
    Opal.def(self, '$prepend', $Module_prepend$52 = function $$prepend($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      mods = $post_args;;
      
      if (mods.length === 0) {
        self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (given 0, expected 1+)")
      }

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$prepend_features(self);
        (mod).$prepended(self);
      }
    ;
      return self;
    }, $Module_prepend$52.$$arity = -1);
    
    Opal.def(self, '$prepend_features', $Module_prepend_features$53 = function $$prepend_features(prepender) {
      var self = this;

      
      
      if (!self.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (self.$class()) + " (expected Module)");
      }

      Opal.prepend_features(self, prepender)
    ;
      return self;
    }, $Module_prepend_features$53.$$arity = 1);
    
    Opal.def(self, '$prepended', $Module_prepended$54 = function $$prepended(mod) {
      var self = this;

      return nil
    }, $Module_prepended$54.$$arity = 1);
    
    Opal.def(self, '$remove_const', $Module_remove_const$55 = function $$remove_const(name) {
      var self = this;

      return Opal.const_remove(self, name);
    }, $Module_remove_const$55.$$arity = 1);
    
    Opal.def(self, '$to_s', $Module_to_s$56 = function $$to_s() {
      var $a, self = this;

      return ($truthy($a = Opal.Module.$name.call(self)) ? $a : "" + "#<" + (self.$$is_module ? 'Module' : 'Class') + ":0x" + (self.$__id__().$to_s(16)) + ">")
    }, $Module_to_s$56.$$arity = 0);
    
    Opal.def(self, '$undef_method', $Module_undef_method$57 = function $$undef_method($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      for (var i = 0, length = names.length; i < length; i++) {
        Opal.udef(self, "$" + names[i]);
      }
    ;
      return self;
    }, $Module_undef_method$57.$$arity = -1);
    
    Opal.def(self, '$instance_variables', $Module_instance_variables$58 = function $$instance_variables() {
      var self = this, consts = nil;

      
      consts = (Opal.Module.$$nesting = $nesting, self.$constants());
      
      var result = [];

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$' && name !== 'constructor' && !consts['$include?'](name)) {
          result.push('@' + name);
        }
      }

      return result;
    ;
    }, $Module_instance_variables$58.$$arity = 0);
    
    Opal.def(self, '$dup', $Module_dup$59 = function $$dup() {
      var $iter = $Module_dup$59.$$p, $yield = $iter || nil, self = this, copy = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Module_dup$59.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      copy = $send(self, Opal.find_super_dispatcher(self, 'dup', $Module_dup$59, false), $zuper, $iter);
      copy.$copy_class_variables(self);
      copy.$copy_constants(self);
      return copy;
    }, $Module_dup$59.$$arity = 0);
    
    Opal.def(self, '$copy_class_variables', $Module_copy_class_variables$60 = function $$copy_class_variables(other) {
      var self = this;

      
      for (var name in other.$$cvars) {
        self.$$cvars[name] = other.$$cvars[name];
      }
    
    }, $Module_copy_class_variables$60.$$arity = 1);
    return (Opal.def(self, '$copy_constants', $Module_copy_constants$61 = function $$copy_constants(other) {
      var self = this;

      
      var name, other_constants = other.$$const;

      for (name in other_constants) {
        Opal.const_set(self, name, other_constants[name]);
      }
    
    }, $Module_copy_constants$61.$$arity = 1), nil) && 'copy_constants';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/class"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send;

  Opal.add_stubs(['$require', '$class_eval', '$to_proc', '$initialize_copy', '$allocate', '$name', '$to_s']);
  
  self.$require("corelib/module");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $Class_new$1, $Class_allocate$2, $Class_inherited$3, $Class_initialize_dup$4, $Class_new$5, $Class_superclass$6, $Class_to_s$7;

    
    Opal.defs(self, '$new', $Class_new$1 = function(superclass) {
      var $iter = $Class_new$1.$$p, block = $iter || nil, self = this;

      if ($iter) $Class_new$1.$$p = null;
      
      
      if ($iter) $Class_new$1.$$p = null;;
      
      if (superclass == null) {
        superclass = $$($nesting, 'Object');
      };
      
      if (!superclass.$$is_class) {
        throw Opal.TypeError.$new("superclass must be a Class");
      }

      var klass = Opal.allocate_class(nil, superclass);
      superclass.$inherited(klass);
      (function() {if ((block !== nil)) {
        return $send((klass), 'class_eval', [], block.$to_proc())
      } else {
        return nil
      }; return nil; })()
      return klass;
    ;
    }, $Class_new$1.$$arity = -1);
    
    Opal.def(self, '$allocate', $Class_allocate$2 = function $$allocate() {
      var self = this;

      
      var obj = new self.$$constructor();
      obj.$$id = Opal.uid();
      return obj;
    
    }, $Class_allocate$2.$$arity = 0);
    
    Opal.def(self, '$inherited', $Class_inherited$3 = function $$inherited(cls) {
      var self = this;

      return nil
    }, $Class_inherited$3.$$arity = 1);
    
    Opal.def(self, '$initialize_dup', $Class_initialize_dup$4 = function $$initialize_dup(original) {
      var self = this;

      
      self.$initialize_copy(original);
      
      self.$$name = null;
      self.$$full_name = null;
    ;
    }, $Class_initialize_dup$4.$$arity = 1);
    
    Opal.def(self, '$new', $Class_new$5 = function($a) {
      var $iter = $Class_new$5.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Class_new$5.$$p = null;
      
      
      if ($iter) $Class_new$5.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var object = self.$allocate();
      Opal.send(object, object.$initialize, args, block);
      return object;
    ;
    }, $Class_new$5.$$arity = -1);
    
    Opal.def(self, '$superclass', $Class_superclass$6 = function $$superclass() {
      var self = this;

      return self.$$super || nil;
    }, $Class_superclass$6.$$arity = 0);
    return (Opal.def(self, '$to_s', $Class_to_s$7 = function $$to_s() {
      var $iter = $Class_to_s$7.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Class_to_s$7.$$p = null;
      
      var singleton_of = self.$$singleton_of;

      if (singleton_of && (singleton_of.$$is_a_module)) {
        return "" + "#<Class:" + ((singleton_of).$name()) + ">";
      }
      else if (singleton_of) {
        // a singleton class created from an object
        return "" + "#<Class:#<" + ((singleton_of.$$class).$name()) + ":0x" + ((Opal.id(singleton_of)).$to_s(16)) + ">>";
      }
      return $send(self, Opal.find_super_dispatcher(self, 'to_s', $Class_to_s$7, false), [], null);
    
    }, $Class_to_s$7.$$arity = 0), nil) && 'to_s';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/basic_object"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$==', '$!', '$nil?', '$cover?', '$size', '$raise', '$merge', '$compile', '$proc', '$any?', '$inspect', '$new']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'BasicObject');

    var $nesting = [self].concat($parent_nesting), $BasicObject_initialize$1, $BasicObject_$eq_eq$2, $BasicObject_eql$ques$3, $BasicObject___id__$4, $BasicObject___send__$5, $BasicObject_$excl$6, $BasicObject_$not_eq$7, $BasicObject_instance_eval$8, $BasicObject_instance_exec$10, $BasicObject_singleton_method_added$11, $BasicObject_singleton_method_removed$12, $BasicObject_singleton_method_undefined$13, $BasicObject_class$14, $BasicObject_method_missing$15;

    
    
    Opal.def(self, '$initialize', $BasicObject_initialize$1 = function $$initialize($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_initialize$1.$$arity = -1);
    
    Opal.def(self, '$==', $BasicObject_$eq_eq$2 = function(other) {
      var self = this;

      return self === other;
    }, $BasicObject_$eq_eq$2.$$arity = 1);
    
    Opal.def(self, '$eql?', $BasicObject_eql$ques$3 = function(other) {
      var self = this;

      return self['$=='](other)
    }, $BasicObject_eql$ques$3.$$arity = 1);
    Opal.alias(self, "equal?", "==");
    
    Opal.def(self, '$__id__', $BasicObject___id__$4 = function $$__id__() {
      var self = this;

      
      if (self.$$id != null) {
        return self.$$id;
      }
      Opal.defineProperty(self, '$$id', Opal.uid());
      return self.$$id;
    
    }, $BasicObject___id__$4.$$arity = 0);
    
    Opal.def(self, '$__send__', $BasicObject___send__$5 = function $$__send__(symbol, $a) {
      var $iter = $BasicObject___send__$5.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $BasicObject___send__$5.$$p = null;
      
      
      if ($iter) $BasicObject___send__$5.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      
      var func = self['$' + symbol]

      if (func) {
        if (block !== nil) {
          func.$$p = block;
        }

        return func.apply(self, args);
      }

      if (block !== nil) {
        self.$method_missing.$$p = block;
      }

      return self.$method_missing.apply(self, [symbol].concat(args));
    ;
    }, $BasicObject___send__$5.$$arity = -2);
    
    Opal.def(self, '$!', $BasicObject_$excl$6 = function() {
      var self = this;

      return false
    }, $BasicObject_$excl$6.$$arity = 0);
    
    Opal.def(self, '$!=', $BasicObject_$not_eq$7 = function(other) {
      var self = this;

      return self['$=='](other)['$!']()
    }, $BasicObject_$not_eq$7.$$arity = 1);
    
    Opal.def(self, '$instance_eval', $BasicObject_instance_eval$8 = function $$instance_eval($a) {
      var $iter = $BasicObject_instance_eval$8.$$p, block = $iter || nil, $post_args, args, $b, $$9, self = this, string = nil, file = nil, _lineno = nil, default_eval_options = nil, compiling_options = nil, compiled = nil;

      if ($iter) $BasicObject_instance_eval$8.$$p = null;
      
      
      if ($iter) $BasicObject_instance_eval$8.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(($truthy($b = block['$nil?']()) ? !!Opal.compile : $b))) {
        
        if ($truthy($range(1, 3, false)['$cover?'](args.$size()))) {
        } else {
          $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat(Opal.to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": ($truthy($b = file) ? $b : "(eval)"), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $$$('::', 'Opal').$compile(string, compiling_options);
        block = $send($$$('::', 'Kernel'), 'proc', [], ($$9 = function(){var self = $$9.$$s || this;

        
          return (function(self) {
            return eval(compiled);
          })(self)
        }, $$9.$$s = self, $$9.$$arity = 0, $$9));
      } else if ($truthy(args['$any?']())) {
        $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "" + "wrong number of arguments (" + (args.$size()) + " for 0)")};
      
      var old = block.$$s,
          result;

      block.$$s = null;

      // Need to pass $$eval so that method definitions know if this is
      // being done on a class/module. Cannot be compiler driven since
      // send(:instance_eval) needs to work.
      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.call(self, self);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.call(self, self);
      }

      block.$$s = old;

      return result;
    ;
    }, $BasicObject_instance_eval$8.$$arity = -1);
    
    Opal.def(self, '$instance_exec', $BasicObject_instance_exec$10 = function $$instance_exec($a) {
      var $iter = $BasicObject_instance_exec$10.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $BasicObject_instance_exec$10.$$p = null;
      
      
      if ($iter) $BasicObject_instance_exec$10.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(block)) {
      } else {
        $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "no block given")
      };
      
      var block_self = block.$$s,
          result;

      block.$$s = null;

      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.apply(self, args);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.apply(self, args);
      }

      block.$$s = block_self;

      return result;
    ;
    }, $BasicObject_instance_exec$10.$$arity = -1);
    
    Opal.def(self, '$singleton_method_added', $BasicObject_singleton_method_added$11 = function $$singleton_method_added($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_singleton_method_added$11.$$arity = -1);
    
    Opal.def(self, '$singleton_method_removed', $BasicObject_singleton_method_removed$12 = function $$singleton_method_removed($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_singleton_method_removed$12.$$arity = -1);
    
    Opal.def(self, '$singleton_method_undefined', $BasicObject_singleton_method_undefined$13 = function $$singleton_method_undefined($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_singleton_method_undefined$13.$$arity = -1);
    
    Opal.def(self, '$class', $BasicObject_class$14 = function() {
      var self = this;

      return self.$$class;
    }, $BasicObject_class$14.$$arity = 0);
    return (Opal.def(self, '$method_missing', $BasicObject_method_missing$15 = function $$method_missing(symbol, $a) {
      var $iter = $BasicObject_method_missing$15.$$p, block = $iter || nil, $post_args, args, self = this, message = nil;

      if ($iter) $BasicObject_method_missing$15.$$p = null;
      
      
      if ($iter) $BasicObject_method_missing$15.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      message = (function() {if ($truthy(self.$inspect && !self.$inspect.$$stub)) {
        return "" + "undefined method `" + (symbol) + "' for " + (self.$inspect()) + ":" + (self.$$class)
      } else {
        return "" + "undefined method `" + (symbol) + "' for " + (self.$$class)
      }; return nil; })();
      return $$$('::', 'Kernel').$raise($$$('::', 'NoMethodError').$new(message, symbol));
    }, $BasicObject_method_missing$15.$$arity = -2), nil) && 'method_missing';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/kernel"] = function(Opal) {
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $gvars = Opal.gvars, $hash2 = Opal.hash2, $send = Opal.send, $klass = Opal.klass;

  Opal.add_stubs(['$raise', '$new', '$inspect', '$!', '$=~', '$==', '$object_id', '$class', '$coerce_to?', '$<<', '$allocate', '$copy_instance_variables', '$copy_singleton_methods', '$initialize_clone', '$initialize_copy', '$define_method', '$singleton_class', '$to_proc', '$initialize_dup', '$for', '$empty?', '$pop', '$call', '$coerce_to', '$append_features', '$extend_object', '$extended', '$__id__', '$to_s', '$instance_variable_name!', '$respond_to?', '$to_int', '$coerce_to!', '$Integer', '$nil?', '$===', '$enum_for', '$result', '$any?', '$print', '$format', '$puts', '$each', '$<=', '$length', '$[]', '$exception', '$is_a?', '$rand', '$respond_to_missing?', '$try_convert!', '$expand_path', '$join', '$start_with?', '$new_seed', '$srand', '$sym', '$arg', '$open', '$include']);
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_method_missing$1, $Kernel_$eq_tilde$2, $Kernel_$excl_tilde$3, $Kernel_$eq_eq_eq$4, $Kernel_$lt_eq_gt$5, $Kernel_method$6, $Kernel_methods$7, $Kernel_public_methods$8, $Kernel_Array$9, $Kernel_at_exit$10, $Kernel_caller$11, $Kernel_class$12, $Kernel_copy_instance_variables$13, $Kernel_copy_singleton_methods$14, $Kernel_clone$15, $Kernel_initialize_clone$16, $Kernel_define_singleton_method$17, $Kernel_dup$18, $Kernel_initialize_dup$19, $Kernel_enum_for$20, $Kernel_equal$ques$21, $Kernel_exit$22, $Kernel_extend$23, $Kernel_hash$24, $Kernel_initialize_copy$25, $Kernel_inspect$26, $Kernel_instance_of$ques$27, $Kernel_instance_variable_defined$ques$28, $Kernel_instance_variable_get$29, $Kernel_instance_variable_set$30, $Kernel_remove_instance_variable$31, $Kernel_instance_variables$32, $Kernel_Integer$33, $Kernel_Float$34, $Kernel_Hash$35, $Kernel_is_a$ques$36, $Kernel_itself$37, $Kernel_lambda$38, $Kernel_load$39, $Kernel_loop$40, $Kernel_nil$ques$42, $Kernel_printf$43, $Kernel_proc$44, $Kernel_puts$45, $Kernel_p$46, $Kernel_print$48, $Kernel_warn$49, $Kernel_raise$50, $Kernel_rand$51, $Kernel_respond_to$ques$52, $Kernel_respond_to_missing$ques$53, $Kernel_require$54, $Kernel_require_relative$55, $Kernel_require_tree$56, $Kernel_singleton_class$57, $Kernel_sleep$58, $Kernel_srand$59, $Kernel_String$60, $Kernel_tap$61, $Kernel_to_proc$62, $Kernel_to_s$63, $Kernel_catch$64, $Kernel_throw$65, $Kernel_open$66, $Kernel_yield_self$67;

    
    
    Opal.def(self, '$method_missing', $Kernel_method_missing$1 = function $$method_missing(symbol, $a) {
      var $iter = $Kernel_method_missing$1.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Kernel_method_missing$1.$$p = null;
      
      
      if ($iter) $Kernel_method_missing$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      return self.$raise($$($nesting, 'NoMethodError').$new("" + "undefined method `" + (symbol) + "' for " + (self.$inspect()), symbol, args));
    }, $Kernel_method_missing$1.$$arity = -2);
    
    Opal.def(self, '$=~', $Kernel_$eq_tilde$2 = function(obj) {
      var self = this;

      return false
    }, $Kernel_$eq_tilde$2.$$arity = 1);
    
    Opal.def(self, '$!~', $Kernel_$excl_tilde$3 = function(obj) {
      var self = this;

      return self['$=~'](obj)['$!']()
    }, $Kernel_$excl_tilde$3.$$arity = 1);
    
    Opal.def(self, '$===', $Kernel_$eq_eq_eq$4 = function(other) {
      var $a, self = this;

      return ($truthy($a = self.$object_id()['$=='](other.$object_id())) ? $a : self['$=='](other))
    }, $Kernel_$eq_eq_eq$4.$$arity = 1);
    
    Opal.def(self, '$<=>', $Kernel_$lt_eq_gt$5 = function(other) {
      var self = this;

      
      // set guard for infinite recursion
      self.$$comparable = true;

      var x = self['$=='](other);

      if (x && x !== nil) {
        return 0;
      }

      return nil;
    
    }, $Kernel_$lt_eq_gt$5.$$arity = 1);
    
    Opal.def(self, '$method', $Kernel_method$6 = function $$method(name) {
      var self = this;

      
      var meth = self['$' + name];

      if (!meth || meth.$$stub) {
        self.$raise($$($nesting, 'NameError').$new("" + "undefined method `" + (name) + "' for class `" + (self.$class()) + "'", name));
      }

      return $$($nesting, 'Method').$new(self, meth.$$owner || self.$class(), meth, name);
    
    }, $Kernel_method$6.$$arity = 1);
    
    Opal.def(self, '$methods', $Kernel_methods$7 = function $$methods(all) {
      var self = this;

      
      
      if (all == null) {
        all = true;
      };
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.own_methods(self);
      }
    ;
    }, $Kernel_methods$7.$$arity = -1);
    
    Opal.def(self, '$public_methods', $Kernel_public_methods$8 = function $$public_methods(all) {
      var self = this;

      
      
      if (all == null) {
        all = true;
      };
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.receiver_methods(self);
      }
    ;
    }, $Kernel_public_methods$8.$$arity = -1);
    
    Opal.def(self, '$Array', $Kernel_Array$9 = function $$Array(object) {
      var self = this;

      
      var coerced;

      if (object === nil) {
        return [];
      }

      if (object.$$is_array) {
        return object;
      }

      coerced = $$($nesting, 'Opal')['$coerce_to?'](object, $$($nesting, 'Array'), "to_ary");
      if (coerced !== nil) { return coerced; }

      coerced = $$($nesting, 'Opal')['$coerce_to?'](object, $$($nesting, 'Array'), "to_a");
      if (coerced !== nil) { return coerced; }

      return [object];
    
    }, $Kernel_Array$9.$$arity = 1);
    
    Opal.def(self, '$at_exit', $Kernel_at_exit$10 = function $$at_exit() {
      var $iter = $Kernel_at_exit$10.$$p, block = $iter || nil, $a, self = this;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      if ($iter) $Kernel_at_exit$10.$$p = null;
      
      
      if ($iter) $Kernel_at_exit$10.$$p = null;;
      $gvars.__at_exit__ = ($truthy($a = $gvars.__at_exit__) ? $a : []);
      return $gvars.__at_exit__['$<<'](block);
    }, $Kernel_at_exit$10.$$arity = 0);
    
    Opal.def(self, '$caller', $Kernel_caller$11 = function $$caller($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return [];
    }, $Kernel_caller$11.$$arity = -1);
    
    Opal.def(self, '$class', $Kernel_class$12 = function() {
      var self = this;

      return self.$$class;
    }, $Kernel_class$12.$$arity = 0);
    
    Opal.def(self, '$copy_instance_variables', $Kernel_copy_instance_variables$13 = function $$copy_instance_variables(other) {
      var self = this;

      
      var keys = Object.keys(other), i, ii, name;
      for (i = 0, ii = keys.length; i < ii; i++) {
        name = keys[i];
        if (name.charAt(0) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, $Kernel_copy_instance_variables$13.$$arity = 1);
    
    Opal.def(self, '$copy_singleton_methods', $Kernel_copy_singleton_methods$14 = function $$copy_singleton_methods(other) {
      var self = this;

      
      var i, name, names, length;

      if (other.hasOwnProperty('$$meta')) {
        var other_singleton_class = Opal.get_singleton_class(other);
        var self_singleton_class = Opal.get_singleton_class(self);
        names = Object.getOwnPropertyNames(other_singleton_class.$$prototype);

        for (i = 0, length = names.length; i < length; i++) {
          name = names[i];
          if (Opal.is_method(name)) {
            self_singleton_class.$$prototype[name] = other_singleton_class.$$prototype[name];
          }
        }

        self_singleton_class.$$const = Object.assign({}, other_singleton_class.$$const);
        Object.setPrototypeOf(
          self_singleton_class.$$prototype,
          Object.getPrototypeOf(other_singleton_class.$$prototype)
        );
      }

      for (i = 0, names = Object.getOwnPropertyNames(other), length = names.length; i < length; i++) {
        name = names[i];
        if (name.charAt(0) === '$' && name.charAt(1) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, $Kernel_copy_singleton_methods$14.$$arity = 1);
    
    Opal.def(self, '$clone', $Kernel_clone$15 = function $$clone($kwargs) {
      var freeze, self = this, copy = nil;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self);
      return copy;
    }, $Kernel_clone$15.$$arity = -1);
    
    Opal.def(self, '$initialize_clone', $Kernel_initialize_clone$16 = function $$initialize_clone(other) {
      var self = this;

      return self.$initialize_copy(other)
    }, $Kernel_initialize_clone$16.$$arity = 1);
    
    Opal.def(self, '$define_singleton_method', $Kernel_define_singleton_method$17 = function $$define_singleton_method(name, method) {
      var $iter = $Kernel_define_singleton_method$17.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_define_singleton_method$17.$$p = null;
      
      
      if ($iter) $Kernel_define_singleton_method$17.$$p = null;;
      ;
      return $send(self.$singleton_class(), 'define_method', [name, method], block.$to_proc());
    }, $Kernel_define_singleton_method$17.$$arity = -2);
    
    Opal.def(self, '$dup', $Kernel_dup$18 = function $$dup() {
      var self = this, copy = nil;

      
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, $Kernel_dup$18.$$arity = 0);
    
    Opal.def(self, '$initialize_dup', $Kernel_initialize_dup$19 = function $$initialize_dup(other) {
      var self = this;

      return self.$initialize_copy(other)
    }, $Kernel_initialize_dup$19.$$arity = 1);
    
    Opal.def(self, '$enum_for', $Kernel_enum_for$20 = function $$enum_for($a, $b) {
      var $iter = $Kernel_enum_for$20.$$p, block = $iter || nil, $post_args, method, args, self = this;

      if ($iter) $Kernel_enum_for$20.$$p = null;
      
      
      if ($iter) $Kernel_enum_for$20.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      if ($post_args.length > 0) {
        method = $post_args[0];
        $post_args.splice(0, 1);
      }
      if (method == null) {
        method = "each";
      };
      
      args = $post_args;;
      return $send($$($nesting, 'Enumerator'), 'for', [self, method].concat(Opal.to_a(args)), block.$to_proc());
    }, $Kernel_enum_for$20.$$arity = -1);
    Opal.alias(self, "to_enum", "enum_for");
    
    Opal.def(self, '$equal?', $Kernel_equal$ques$21 = function(other) {
      var self = this;

      return self === other;
    }, $Kernel_equal$ques$21.$$arity = 1);
    
    Opal.def(self, '$exit', $Kernel_exit$22 = function $$exit(status) {
      var $a, self = this, block = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      
      
      if (status == null) {
        status = true;
      };
      $gvars.__at_exit__ = ($truthy($a = $gvars.__at_exit__) ? $a : []);
      while (!($truthy($gvars.__at_exit__['$empty?']()))) {
        
        block = $gvars.__at_exit__.$pop();
        block.$call();
      };
      
      if (status.$$is_boolean) {
        status = status ? 0 : 1;
      } else {
        status = $$($nesting, 'Opal').$coerce_to(status, $$($nesting, 'Integer'), "to_int")
      }

      Opal.exit(status);
    ;
      return nil;
    }, $Kernel_exit$22.$$arity = -1);
    
    Opal.def(self, '$extend', $Kernel_extend$23 = function $$extend($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      mods = $post_args;;
      
      var singleton = self.$singleton_class();

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(singleton);
        (mod).$extend_object(self);
        (mod).$extended(self);
      }
    ;
      return self;
    }, $Kernel_extend$23.$$arity = -1);
    
    Opal.def(self, '$hash', $Kernel_hash$24 = function $$hash() {
      var self = this;

      return self.$__id__()
    }, $Kernel_hash$24.$$arity = 0);
    
    Opal.def(self, '$initialize_copy', $Kernel_initialize_copy$25 = function $$initialize_copy(other) {
      var self = this;

      return nil
    }, $Kernel_initialize_copy$25.$$arity = 1);
    
    Opal.def(self, '$inspect', $Kernel_inspect$26 = function $$inspect() {
      var self = this;

      return self.$to_s()
    }, $Kernel_inspect$26.$$arity = 0);
    
    Opal.def(self, '$instance_of?', $Kernel_instance_of$ques$27 = function(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "class or module required");
      }

      return self.$$class === klass;
    
    }, $Kernel_instance_of$ques$27.$$arity = 1);
    
    Opal.def(self, '$instance_variable_defined?', $Kernel_instance_variable_defined$ques$28 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      return Opal.hasOwnProperty.call(self, name.substr(1));;
    }, $Kernel_instance_variable_defined$ques$28.$$arity = 1);
    
    Opal.def(self, '$instance_variable_get', $Kernel_instance_variable_get$29 = function $$instance_variable_get(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      
      var ivar = self[Opal.ivar(name.substr(1))];

      return ivar == null ? nil : ivar;
    ;
    }, $Kernel_instance_variable_get$29.$$arity = 1);
    
    Opal.def(self, '$instance_variable_set', $Kernel_instance_variable_set$30 = function $$instance_variable_set(name, value) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      return self[Opal.ivar(name.substr(1))] = value;;
    }, $Kernel_instance_variable_set$30.$$arity = 2);
    
    Opal.def(self, '$remove_instance_variable', $Kernel_remove_instance_variable$31 = function $$remove_instance_variable(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      
      var key = Opal.ivar(name.substr(1)),
          val;
      if (self.hasOwnProperty(key)) {
        val = self[key];
        delete self[key];
        return val;
      }
    ;
      return self.$raise($$($nesting, 'NameError'), "" + "instance variable " + (name) + " not defined");
    }, $Kernel_remove_instance_variable$31.$$arity = 1);
    
    Opal.def(self, '$instance_variables', $Kernel_instance_variables$32 = function $$instance_variables() {
      var self = this;

      
      var result = [], ivar;

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$') {
          if (name.substr(-1) === '$') {
            ivar = name.slice(0, name.length - 1);
          } else {
            ivar = name;
          }
          result.push('@' + ivar);
        }
      }

      return result;
    
    }, $Kernel_instance_variables$32.$$arity = 0);
    
    Opal.def(self, '$Integer', $Kernel_Integer$33 = function $$Integer(value, base) {
      var self = this;

      
      ;
      
      var i, str, base_digits;

      if (!value.$$is_string) {
        if (base !== undefined) {
          self.$raise($$($nesting, 'ArgumentError'), "base specified for non string value")
        }
        if (value === nil) {
          self.$raise($$($nesting, 'TypeError'), "can't convert nil into Integer")
        }
        if (value.$$is_number) {
          if (value === Infinity || value === -Infinity || isNaN(value)) {
            self.$raise($$($nesting, 'FloatDomainError'), value)
          }
          return Math.floor(value);
        }
        if (value['$respond_to?']("to_int")) {
          i = value.$to_int();
          if (i !== nil) {
            return i;
          }
        }
        return $$($nesting, 'Opal')['$coerce_to!'](value, $$($nesting, 'Integer'), "to_i");
      }

      if (value === "0") {
        return 0;
      }

      if (base === undefined) {
        base = 0;
      } else {
        base = $$($nesting, 'Opal').$coerce_to(base, $$($nesting, 'Integer'), "to_int");
        if (base === 1 || base < 0 || base > 36) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (base))
        }
      }

      str = value.toLowerCase();

      str = str.replace(/(\d)_(?=\d)/g, '$1');

      str = str.replace(/^(\s*[+-]?)(0[bodx]?)/, function (_, head, flag) {
        switch (flag) {
        case '0b':
          if (base === 0 || base === 2) {
            base = 2;
            return head;
          }
        case '0':
        case '0o':
          if (base === 0 || base === 8) {
            base = 8;
            return head;
          }
        case '0d':
          if (base === 0 || base === 10) {
            base = 10;
            return head;
          }
        case '0x':
          if (base === 0 || base === 16) {
            base = 16;
            return head;
          }
        }
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      });

      base = (base === 0 ? 10 : base);

      base_digits = '0-' + (base <= 10 ? base - 1 : '9a-' + String.fromCharCode(97 + (base - 11)));

      if (!(new RegExp('^\\s*[+-]?[' + base_digits + ']+\\s*$')).test(str)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      }

      i = parseInt(str, base);

      if (isNaN(i)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      }

      return i;
    ;
    }, $Kernel_Integer$33.$$arity = -2);
    
    Opal.def(self, '$Float', $Kernel_Float$34 = function $$Float(value) {
      var self = this;

      
      var str;

      if (value === nil) {
        self.$raise($$($nesting, 'TypeError'), "can't convert nil into Float")
      }

      if (value.$$is_string) {
        str = value.toString();

        str = str.replace(/(\d)_(?=\d)/g, '$1');

        //Special case for hex strings only:
        if (/^\s*[-+]?0[xX][0-9a-fA-F]+\s*$/.test(str)) {
          return self.$Integer(str);
        }

        if (!/^\s*[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\s*$/.test(str)) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Float(): \"" + (value) + "\"")
        }

        return parseFloat(str);
      }

      return $$($nesting, 'Opal')['$coerce_to!'](value, $$($nesting, 'Float'), "to_f");
    
    }, $Kernel_Float$34.$$arity = 1);
    
    Opal.def(self, '$Hash', $Kernel_Hash$35 = function $$Hash(arg) {
      var $a, self = this;

      
      if ($truthy(($truthy($a = arg['$nil?']()) ? $a : arg['$==']([])))) {
        return $hash2([], {})};
      if ($truthy($$($nesting, 'Hash')['$==='](arg))) {
        return arg};
      return $$($nesting, 'Opal')['$coerce_to!'](arg, $$($nesting, 'Hash'), "to_hash");
    }, $Kernel_Hash$35.$$arity = 1);
    
    Opal.def(self, '$is_a?', $Kernel_is_a$ques$36 = function(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "class or module required");
      }

      return Opal.is_a(self, klass);
    
    }, $Kernel_is_a$ques$36.$$arity = 1);
    
    Opal.def(self, '$itself', $Kernel_itself$37 = function $$itself() {
      var self = this;

      return self
    }, $Kernel_itself$37.$$arity = 0);
    Opal.alias(self, "kind_of?", "is_a?");
    
    Opal.def(self, '$lambda', $Kernel_lambda$38 = function $$lambda() {
      var $iter = $Kernel_lambda$38.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_lambda$38.$$p = null;
      
      
      if ($iter) $Kernel_lambda$38.$$p = null;;
      return Opal.lambda(block);;
    }, $Kernel_lambda$38.$$arity = 0);
    
    Opal.def(self, '$load', $Kernel_load$39 = function $$load(file) {
      var self = this;

      
      file = $$($nesting, 'Opal')['$coerce_to!'](file, $$($nesting, 'String'), "to_str");
      return Opal.load(file);
    }, $Kernel_load$39.$$arity = 1);
    
    Opal.def(self, '$loop', $Kernel_loop$40 = function $$loop() {
      var $$41, $a, $iter = $Kernel_loop$40.$$p, $yield = $iter || nil, self = this, e = nil;

      if ($iter) $Kernel_loop$40.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["loop"], ($$41 = function(){var self = $$41.$$s || this;

        return $$$($$($nesting, 'Float'), 'INFINITY')}, $$41.$$s = self, $$41.$$arity = 0, $$41))
      };
      while ($truthy(true)) {
        
        try {
          Opal.yieldX($yield, [])
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, 'StopIteration')])) {e = $err;
            try {
              return e.$result()
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };
      };
      return self;
    }, $Kernel_loop$40.$$arity = 0);
    
    Opal.def(self, '$nil?', $Kernel_nil$ques$42 = function() {
      var self = this;

      return false
    }, $Kernel_nil$ques$42.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    
    Opal.def(self, '$printf', $Kernel_printf$43 = function $$printf($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(args['$any?']())) {
        self.$print($send(self, 'format', Opal.to_a(args)))};
      return nil;
    }, $Kernel_printf$43.$$arity = -1);
    
    Opal.def(self, '$proc', $Kernel_proc$44 = function $$proc() {
      var $iter = $Kernel_proc$44.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_proc$44.$$p = null;
      
      
      if ($iter) $Kernel_proc$44.$$p = null;;
      if ($truthy(block)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "tried to create Proc object without a block")
      };
      block.$$is_lambda = false;
      return block;
    }, $Kernel_proc$44.$$arity = 0);
    
    Opal.def(self, '$puts', $Kernel_puts$45 = function $$puts($a) {
      var $post_args, strs, self = this;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      strs = $post_args;;
      return $send($gvars.stdout, 'puts', Opal.to_a(strs));
    }, $Kernel_puts$45.$$arity = -1);
    
    Opal.def(self, '$p', $Kernel_p$46 = function $$p($a) {
      var $post_args, args, $$47, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      $send(args, 'each', [], ($$47 = function(obj){var self = $$47.$$s || this;
        if ($gvars.stdout == null) $gvars.stdout = nil;

      
        
        if (obj == null) {
          obj = nil;
        };
        return $gvars.stdout.$puts(obj.$inspect());}, $$47.$$s = self, $$47.$$arity = 1, $$47));
      if ($truthy($rb_le(args.$length(), 1))) {
        return args['$[]'](0)
      } else {
        return args
      };
    }, $Kernel_p$46.$$arity = -1);
    
    Opal.def(self, '$print', $Kernel_print$48 = function $$print($a) {
      var $post_args, strs, self = this;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      strs = $post_args;;
      return $send($gvars.stdout, 'print', Opal.to_a(strs));
    }, $Kernel_print$48.$$arity = -1);
    
    Opal.def(self, '$warn', $Kernel_warn$49 = function $$warn($a) {
      var $post_args, strs, $b, self = this;
      if ($gvars.VERBOSE == null) $gvars.VERBOSE = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      strs = $post_args;;
      if ($truthy(($truthy($b = $gvars.VERBOSE['$nil?']()) ? $b : strs['$empty?']()))) {
        return nil
      } else {
        return $send($gvars.stderr, 'puts', Opal.to_a(strs))
      };
    }, $Kernel_warn$49.$$arity = -1);
    
    Opal.def(self, '$raise', $Kernel_raise$50 = function $$raise(exception, string, _backtrace) {
      var self = this;
      if ($gvars["!"] == null) $gvars["!"] = nil;

      
      ;
      
      if (string == null) {
        string = nil;
      };
      
      if (_backtrace == null) {
        _backtrace = nil;
      };
      
      if (exception == null && $gvars["!"] !== nil) {
        throw $gvars["!"];
      }
      if (exception == null) {
        exception = $$($nesting, 'RuntimeError').$new();
      }
      else if (exception.$$is_string) {
        exception = $$($nesting, 'RuntimeError').$new(exception);
      }
      // using respond_to? and not an undefined check to avoid method_missing matching as true
      else if (exception.$$is_class && exception['$respond_to?']("exception")) {
        exception = exception.$exception(string);
      }
      else if (exception['$is_a?']($$($nesting, 'Exception'))) {
        // exception is fine
      }
      else {
        exception = $$($nesting, 'TypeError').$new("exception class/object expected");
      }

      if ($gvars["!"] !== nil) {
        Opal.exceptions.push($gvars["!"]);
      }

      $gvars["!"] = exception;

      throw exception;
    ;
    }, $Kernel_raise$50.$$arity = -1);
    Opal.alias(self, "fail", "raise");
    
    Opal.def(self, '$rand', $Kernel_rand$51 = function $$rand(max) {
      var self = this;

      
      ;
      
      if (max === undefined) {
        return $$$($$($nesting, 'Random'), 'DEFAULT').$rand();
      }

      if (max.$$is_number) {
        if (max < 0) {
          max = Math.abs(max);
        }

        if (max % 1 !== 0) {
          max = max.$to_i();
        }

        if (max === 0) {
          max = undefined;
        }
      }
    ;
      return $$$($$($nesting, 'Random'), 'DEFAULT').$rand(max);
    }, $Kernel_rand$51.$$arity = -1);
    
    Opal.def(self, '$respond_to?', $Kernel_respond_to$ques$52 = function(name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      if ($truthy(self['$respond_to_missing?'](name, include_all))) {
        return true};
      
      var body = self['$' + name];

      if (typeof(body) === "function" && !body.$$stub) {
        return true;
      }
    ;
      return false;
    }, $Kernel_respond_to$ques$52.$$arity = -2);
    
    Opal.def(self, '$respond_to_missing?', $Kernel_respond_to_missing$ques$53 = function(method_name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      return false;
    }, $Kernel_respond_to_missing$ques$53.$$arity = -2);
    
    Opal.def(self, '$require', $Kernel_require$54 = function $$require(file) {
      var self = this;

      
      file = $$($nesting, 'Opal')['$coerce_to!'](file, $$($nesting, 'String'), "to_str");
      return Opal.require(file);
    }, $Kernel_require$54.$$arity = 1);
    
    Opal.def(self, '$require_relative', $Kernel_require_relative$55 = function $$require_relative(file) {
      var self = this;

      
      $$($nesting, 'Opal')['$try_convert!'](file, $$($nesting, 'String'), "to_str");
      file = $$($nesting, 'File').$expand_path($$($nesting, 'File').$join(Opal.current_file, "..", file));
      return Opal.require(file);
    }, $Kernel_require_relative$55.$$arity = 1);
    
    Opal.def(self, '$require_tree', $Kernel_require_tree$56 = function $$require_tree(path) {
      var self = this;

      
      var result = [];

      path = $$($nesting, 'File').$expand_path(path)
      path = Opal.normalize(path);
      if (path === '.') path = '';
      for (var name in Opal.modules) {
        if ((name)['$start_with?'](path)) {
          result.push([name, Opal.require(name)]);
        }
      }

      return result;
    
    }, $Kernel_require_tree$56.$$arity = 1);
    Opal.alias(self, "send", "__send__");
    Opal.alias(self, "public_send", "__send__");
    
    Opal.def(self, '$singleton_class', $Kernel_singleton_class$57 = function $$singleton_class() {
      var self = this;

      return Opal.get_singleton_class(self);
    }, $Kernel_singleton_class$57.$$arity = 0);
    
    Opal.def(self, '$sleep', $Kernel_sleep$58 = function $$sleep(seconds) {
      var self = this;

      
      
      if (seconds == null) {
        seconds = nil;
      };
      
      if (seconds === nil) {
        self.$raise($$($nesting, 'TypeError'), "can't convert NilClass into time interval")
      }
      if (!seconds.$$is_number) {
        self.$raise($$($nesting, 'TypeError'), "" + "can't convert " + (seconds.$class()) + " into time interval")
      }
      if (seconds < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "time interval must be positive")
      }
      var get_time = Opal.global.performance ?
        function() {return performance.now()} :
        function() {return new Date()}

      var t = get_time();
      while (get_time() - t <= seconds * 1000);
      return seconds;
    ;
    }, $Kernel_sleep$58.$$arity = -1);
    
    Opal.def(self, '$srand', $Kernel_srand$59 = function $$srand(seed) {
      var self = this;

      
      
      if (seed == null) {
        seed = $$($nesting, 'Random').$new_seed();
      };
      return $$($nesting, 'Random').$srand(seed);
    }, $Kernel_srand$59.$$arity = -1);
    
    Opal.def(self, '$String', $Kernel_String$60 = function $$String(str) {
      var $a, self = this;

      return ($truthy($a = $$($nesting, 'Opal')['$coerce_to?'](str, $$($nesting, 'String'), "to_str")) ? $a : $$($nesting, 'Opal')['$coerce_to!'](str, $$($nesting, 'String'), "to_s"))
    }, $Kernel_String$60.$$arity = 1);
    
    Opal.def(self, '$tap', $Kernel_tap$61 = function $$tap() {
      var $iter = $Kernel_tap$61.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_tap$61.$$p = null;
      
      
      if ($iter) $Kernel_tap$61.$$p = null;;
      Opal.yield1(block, self);
      return self;
    }, $Kernel_tap$61.$$arity = 0);
    
    Opal.def(self, '$to_proc', $Kernel_to_proc$62 = function $$to_proc() {
      var self = this;

      return self
    }, $Kernel_to_proc$62.$$arity = 0);
    
    Opal.def(self, '$to_s', $Kernel_to_s$63 = function $$to_s() {
      var self = this;

      return "" + "#<" + (self.$class()) + ":0x" + (self.$__id__().$to_s(16)) + ">"
    }, $Kernel_to_s$63.$$arity = 0);
    
    Opal.def(self, '$catch', $Kernel_catch$64 = function(sym) {
      var $iter = $Kernel_catch$64.$$p, $yield = $iter || nil, self = this, e = nil;

      if ($iter) $Kernel_catch$64.$$p = null;
      try {
        return Opal.yieldX($yield, []);
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'UncaughtThrowError')])) {e = $err;
          try {
            
            if (e.$sym()['$=='](sym)) {
              return e.$arg()};
            return self.$raise();
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Kernel_catch$64.$$arity = 1);
    
    Opal.def(self, '$throw', $Kernel_throw$65 = function($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self.$raise($$($nesting, 'UncaughtThrowError'), args);
    }, $Kernel_throw$65.$$arity = -1);
    
    Opal.def(self, '$open', $Kernel_open$66 = function $$open($a) {
      var $iter = $Kernel_open$66.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Kernel_open$66.$$p = null;
      
      
      if ($iter) $Kernel_open$66.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send($$($nesting, 'File'), 'open', Opal.to_a(args), block.$to_proc());
    }, $Kernel_open$66.$$arity = -1);
    
    Opal.def(self, '$yield_self', $Kernel_yield_self$67 = function $$yield_self() {
      var $$68, $iter = $Kernel_yield_self$67.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Kernel_yield_self$67.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["yield_self"], ($$68 = function(){var self = $$68.$$s || this;

        return 1}, $$68.$$s = self, $$68.$$arity = 0, $$68))
      };
      return Opal.yield1($yield, self);;
    }, $Kernel_yield_self$67.$$arity = 0);
  })($nesting[0], $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Object');

    var $nesting = [self].concat($parent_nesting);

    return self.$include($$($nesting, 'Kernel'))
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/error"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $module = Opal.module, $hash2 = Opal.hash2;

  Opal.add_stubs(['$new', '$clone', '$to_s', '$empty?', '$class', '$raise', '$+', '$attr_reader', '$[]', '$>', '$length', '$inspect']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Exception');

    var $nesting = [self].concat($parent_nesting), $Exception_new$1, $Exception_exception$2, $Exception_initialize$3, $Exception_backtrace$4, $Exception_exception$5, $Exception_message$6, $Exception_inspect$7, $Exception_set_backtrace$8, $Exception_to_s$9;

    self.$$prototype.message = nil;
    
    var stack_trace_limit;
    Opal.defs(self, '$new', $Exception_new$1 = function($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var message   = (args.length > 0) ? args[0] : nil;
      var error     = new self.$$constructor(message);
      error.name    = self.$$name;
      error.message = message;
      Opal.send(error, error.$initialize, args);

      // Error.captureStackTrace() will use .name and .toString to build the
      // first line of the stack trace so it must be called after the error
      // has been initialized.
      // https://nodejs.org/dist/latest-v6.x/docs/api/errors.html
      if (Opal.config.enable_stack_trace && Error.captureStackTrace) {
        // Passing Kernel.raise will cut the stack trace from that point above
        Error.captureStackTrace(error, stack_trace_limit);
      }

      return error;
    ;
    }, $Exception_new$1.$$arity = -1);
    stack_trace_limit = self.$new;
    Opal.defs(self, '$exception', $Exception_exception$2 = function $$exception($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send(self, 'new', Opal.to_a(args));
    }, $Exception_exception$2.$$arity = -1);
    
    Opal.def(self, '$initialize', $Exception_initialize$3 = function $$initialize($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self.message = (args.length > 0) ? args[0] : nil;;
    }, $Exception_initialize$3.$$arity = -1);
    
    Opal.def(self, '$backtrace', $Exception_backtrace$4 = function $$backtrace() {
      var self = this;

      
      if (self.backtrace) {
        // nil is a valid backtrace
        return self.backtrace;
      }

      var backtrace = self.stack;

      if (typeof(backtrace) === 'string') {
        return backtrace.split("\n").slice(0, 15);
      }
      else if (backtrace) {
        return backtrace.slice(0, 15);
      }

      return [];
    
    }, $Exception_backtrace$4.$$arity = 0);
    
    Opal.def(self, '$exception', $Exception_exception$5 = function $$exception(str) {
      var self = this;

      
      
      if (str == null) {
        str = nil;
      };
      
      if (str === nil || self === str) {
        return self;
      }

      var cloned = self.$clone();
      cloned.message = str;
      return cloned;
    ;
    }, $Exception_exception$5.$$arity = -1);
    
    Opal.def(self, '$message', $Exception_message$6 = function $$message() {
      var self = this;

      return self.$to_s()
    }, $Exception_message$6.$$arity = 0);
    
    Opal.def(self, '$inspect', $Exception_inspect$7 = function $$inspect() {
      var self = this, as_str = nil;

      
      as_str = self.$to_s();
      if ($truthy(as_str['$empty?']())) {
        return self.$class().$to_s()
      } else {
        return "" + "#<" + (self.$class().$to_s()) + ": " + (self.$to_s()) + ">"
      };
    }, $Exception_inspect$7.$$arity = 0);
    
    Opal.def(self, '$set_backtrace', $Exception_set_backtrace$8 = function $$set_backtrace(backtrace) {
      var self = this;

      
      var valid = true, i, ii;

      if (backtrace === nil) {
        self.backtrace = nil;
      } else if (backtrace.$$is_string) {
        self.backtrace = [backtrace];
      } else {
        if (backtrace.$$is_array) {
          for (i = 0, ii = backtrace.length; i < ii; i++) {
            if (!backtrace[i].$$is_string) {
              valid = false;
              break;
            }
          }
        } else {
          valid = false;
        }

        if (valid === false) {
          self.$raise($$($nesting, 'TypeError'), "backtrace must be Array of String")
        }

        self.backtrace = backtrace;
      }

      return backtrace;
    
    }, $Exception_set_backtrace$8.$$arity = 1);
    return (Opal.def(self, '$to_s', $Exception_to_s$9 = function $$to_s() {
      var $a, $b, self = this;

      return ($truthy($a = ($truthy($b = self.message) ? self.message.$to_s() : $b)) ? $a : self.$class().$to_s())
    }, $Exception_to_s$9.$$arity = 0), nil) && 'to_s';
  })($nesting[0], Error, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ScriptError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SyntaxError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'LoadError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NotImplementedError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SystemExit');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NoMemoryError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SignalException');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Interrupt');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SecurityError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StandardError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'EncodingError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ZeroDivisionError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NameError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NoMethodError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'NameError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RuntimeError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'FrozenError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'RuntimeError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'LocalJumpError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'TypeError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ArgumentError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IndexError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StopIteration');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'IndexError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'KeyError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'IndexError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RangeError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'FloatDomainError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'RangeError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IOError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SystemCallError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Errno');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'EINVAL');

      var $nesting = [self].concat($parent_nesting), $EINVAL_new$10;

      return (Opal.defs(self, '$new', $EINVAL_new$10 = function(name) {
        var $iter = $EINVAL_new$10.$$p, $yield = $iter || nil, self = this, message = nil;

        if ($iter) $EINVAL_new$10.$$p = null;
        
        
        if (name == null) {
          name = nil;
        };
        message = "Invalid argument";
        if ($truthy(name)) {
          message = $rb_plus(message, "" + " - " + (name))};
        return $send(self, Opal.find_super_dispatcher(self, 'new', $EINVAL_new$10, false, self.$$class.$$prototype), [message], null);
      }, $EINVAL_new$10.$$arity = -1), nil) && 'new'
    })($nesting[0], $$($nesting, 'SystemCallError'), $nesting)
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'UncaughtThrowError');

    var $nesting = [self].concat($parent_nesting), $UncaughtThrowError_initialize$11;

    self.$$prototype.sym = nil;
    
    self.$attr_reader("sym", "arg");
    return (Opal.def(self, '$initialize', $UncaughtThrowError_initialize$11 = function $$initialize(args) {
      var $iter = $UncaughtThrowError_initialize$11.$$p, $yield = $iter || nil, self = this;

      if ($iter) $UncaughtThrowError_initialize$11.$$p = null;
      
      self.sym = args['$[]'](0);
      if ($truthy($rb_gt(args.$length(), 1))) {
        self.arg = args['$[]'](1)};
      return $send(self, Opal.find_super_dispatcher(self, 'initialize', $UncaughtThrowError_initialize$11, false), ["" + "uncaught throw " + (self.sym.$inspect())], null);
    }, $UncaughtThrowError_initialize$11.$$arity = 1), nil) && 'initialize';
  })($nesting[0], $$($nesting, 'ArgumentError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NameError');

    var $nesting = [self].concat($parent_nesting), $NameError_initialize$12;

    
    self.$attr_reader("name");
    return (Opal.def(self, '$initialize', $NameError_initialize$12 = function $$initialize(message, name) {
      var $iter = $NameError_initialize$12.$$p, $yield = $iter || nil, self = this;

      if ($iter) $NameError_initialize$12.$$p = null;
      
      
      if (name == null) {
        name = nil;
      };
      $send(self, Opal.find_super_dispatcher(self, 'initialize', $NameError_initialize$12, false), [message], null);
      return (self.name = name);
    }, $NameError_initialize$12.$$arity = -2), nil) && 'initialize';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NoMethodError');

    var $nesting = [self].concat($parent_nesting), $NoMethodError_initialize$13;

    
    self.$attr_reader("args");
    return (Opal.def(self, '$initialize', $NoMethodError_initialize$13 = function $$initialize(message, name, args) {
      var $iter = $NoMethodError_initialize$13.$$p, $yield = $iter || nil, self = this;

      if ($iter) $NoMethodError_initialize$13.$$p = null;
      
      
      if (name == null) {
        name = nil;
      };
      
      if (args == null) {
        args = [];
      };
      $send(self, Opal.find_super_dispatcher(self, 'initialize', $NoMethodError_initialize$13, false), [message, name], null);
      return (self.args = args);
    }, $NoMethodError_initialize$13.$$arity = -2), nil) && 'initialize';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StopIteration');

    var $nesting = [self].concat($parent_nesting);

    return self.$attr_reader("result")
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'KeyError');

    var $nesting = [self].concat($parent_nesting), $KeyError_initialize$14, $KeyError_receiver$15, $KeyError_key$16;

    self.$$prototype.receiver = self.$$prototype.key = nil;
    
    
    Opal.def(self, '$initialize', $KeyError_initialize$14 = function $$initialize(message, $kwargs) {
      var receiver, key, $iter = $KeyError_initialize$14.$$p, $yield = $iter || nil, self = this;

      if ($iter) $KeyError_initialize$14.$$p = null;
      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      receiver = $kwargs.$$smap["receiver"];
      if (receiver == null) {
        receiver = nil
      };
      
      key = $kwargs.$$smap["key"];
      if (key == null) {
        key = nil
      };
      $send(self, Opal.find_super_dispatcher(self, 'initialize', $KeyError_initialize$14, false), [message], null);
      self.receiver = receiver;
      return (self.key = key);
    }, $KeyError_initialize$14.$$arity = -2);
    
    Opal.def(self, '$receiver', $KeyError_receiver$15 = function $$receiver() {
      var $a, self = this;

      return ($truthy($a = self.receiver) ? $a : self.$raise($$($nesting, 'ArgumentError'), "no receiver is available"))
    }, $KeyError_receiver$15.$$arity = 0);
    return (Opal.def(self, '$key', $KeyError_key$16 = function $$key() {
      var $a, self = this;

      return ($truthy($a = self.key) ? $a : self.$raise($$($nesting, 'ArgumentError'), "no key is available"))
    }, $KeyError_key$16.$$arity = 0), nil) && 'key';
  })($nesting[0], null, $nesting);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'JS');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Error');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/constants"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  
  Opal.const_set($nesting[0], 'RUBY_PLATFORM', "opal");
  Opal.const_set($nesting[0], 'RUBY_ENGINE', "opal");
  Opal.const_set($nesting[0], 'RUBY_VERSION', "2.5.1");
  Opal.const_set($nesting[0], 'RUBY_ENGINE_VERSION', "0.11.99.dev");
  Opal.const_set($nesting[0], 'RUBY_RELEASE_DATE', "2018-12-25");
  Opal.const_set($nesting[0], 'RUBY_PATCHLEVEL', 0);
  Opal.const_set($nesting[0], 'RUBY_REVISION', 0);
  Opal.const_set($nesting[0], 'RUBY_COPYRIGHT', "opal - Copyright (C) 2013-2018 Adam Beynon and the Opal contributors");
  return Opal.const_set($nesting[0], 'RUBY_DESCRIPTION', "" + "opal " + ($$($nesting, 'RUBY_ENGINE_VERSION')) + " (" + ($$($nesting, 'RUBY_RELEASE_DATE')) + " revision " + ($$($nesting, 'RUBY_REVISION')) + ")");
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["opal/base"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$require']);
  
  self.$require("corelib/runtime");
  self.$require("corelib/helpers");
  self.$require("corelib/module");
  self.$require("corelib/class");
  self.$require("corelib/basic_object");
  self.$require("corelib/kernel");
  self.$require("corelib/error");
  return self.$require("corelib/constants");
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/nil"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$raise', '$name', '$new', '$>', '$length', '$Rational']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting), $NilClass_$excl$2, $NilClass_$$3, $NilClass_$$4, $NilClass_$$5, $NilClass_$eq_eq$6, $NilClass_dup$7, $NilClass_clone$8, $NilClass_inspect$9, $NilClass_nil$ques$10, $NilClass_singleton_class$11, $NilClass_to_a$12, $NilClass_to_h$13, $NilClass_to_i$14, $NilClass_to_s$15, $NilClass_to_c$16, $NilClass_rationalize$17, $NilClass_to_r$18, $NilClass_instance_variables$19;

    
    self.$$prototype.$$meta = self;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$!', $NilClass_$excl$2 = function() {
      var self = this;

      return true
    }, $NilClass_$excl$2.$$arity = 0);
    
    Opal.def(self, '$&', $NilClass_$$3 = function(other) {
      var self = this;

      return false
    }, $NilClass_$$3.$$arity = 1);
    
    Opal.def(self, '$|', $NilClass_$$4 = function(other) {
      var self = this;

      return other !== false && other !== nil;
    }, $NilClass_$$4.$$arity = 1);
    
    Opal.def(self, '$^', $NilClass_$$5 = function(other) {
      var self = this;

      return other !== false && other !== nil;
    }, $NilClass_$$5.$$arity = 1);
    
    Opal.def(self, '$==', $NilClass_$eq_eq$6 = function(other) {
      var self = this;

      return other === nil;
    }, $NilClass_$eq_eq$6.$$arity = 1);
    
    Opal.def(self, '$dup', $NilClass_dup$7 = function $$dup() {
      var self = this;

      return nil
    }, $NilClass_dup$7.$$arity = 0);
    
    Opal.def(self, '$clone', $NilClass_clone$8 = function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      return nil;
    }, $NilClass_clone$8.$$arity = -1);
    
    Opal.def(self, '$inspect', $NilClass_inspect$9 = function $$inspect() {
      var self = this;

      return "nil"
    }, $NilClass_inspect$9.$$arity = 0);
    
    Opal.def(self, '$nil?', $NilClass_nil$ques$10 = function() {
      var self = this;

      return true
    }, $NilClass_nil$ques$10.$$arity = 0);
    
    Opal.def(self, '$singleton_class', $NilClass_singleton_class$11 = function $$singleton_class() {
      var self = this;

      return $$($nesting, 'NilClass')
    }, $NilClass_singleton_class$11.$$arity = 0);
    
    Opal.def(self, '$to_a', $NilClass_to_a$12 = function $$to_a() {
      var self = this;

      return []
    }, $NilClass_to_a$12.$$arity = 0);
    
    Opal.def(self, '$to_h', $NilClass_to_h$13 = function $$to_h() {
      var self = this;

      return Opal.hash();
    }, $NilClass_to_h$13.$$arity = 0);
    
    Opal.def(self, '$to_i', $NilClass_to_i$14 = function $$to_i() {
      var self = this;

      return 0
    }, $NilClass_to_i$14.$$arity = 0);
    Opal.alias(self, "to_f", "to_i");
    
    Opal.def(self, '$to_s', $NilClass_to_s$15 = function $$to_s() {
      var self = this;

      return ""
    }, $NilClass_to_s$15.$$arity = 0);
    
    Opal.def(self, '$to_c', $NilClass_to_c$16 = function $$to_c() {
      var self = this;

      return $$($nesting, 'Complex').$new(0, 0)
    }, $NilClass_to_c$16.$$arity = 0);
    
    Opal.def(self, '$rationalize', $NilClass_rationalize$17 = function $$rationalize($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy($rb_gt(args.$length(), 1))) {
        self.$raise($$($nesting, 'ArgumentError'))};
      return self.$Rational(0, 1);
    }, $NilClass_rationalize$17.$$arity = -1);
    
    Opal.def(self, '$to_r', $NilClass_to_r$18 = function $$to_r() {
      var self = this;

      return self.$Rational(0, 1)
    }, $NilClass_to_r$18.$$arity = 0);
    return (Opal.def(self, '$instance_variables', $NilClass_instance_variables$19 = function $$instance_variables() {
      var self = this;

      return []
    }, $NilClass_instance_variables$19.$$arity = 0), nil) && 'instance_variables';
  })($nesting[0], null, $nesting);
  return Opal.const_set($nesting[0], 'NIL', nil);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/boolean"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2;

  Opal.add_stubs(['$raise', '$name']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Boolean');

    var $nesting = [self].concat($parent_nesting), $Boolean___id__$2, $Boolean_$excl$3, $Boolean_$$4, $Boolean_$$5, $Boolean_$$6, $Boolean_$eq_eq$7, $Boolean_singleton_class$8, $Boolean_to_s$9, $Boolean_dup$10, $Boolean_clone$11;

    
    Opal.defineProperty(self.$$prototype, '$$is_boolean', true);
    Opal.defineProperty(self.$$prototype, '$$meta', self);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$__id__', $Boolean___id__$2 = function $$__id__() {
      var self = this;

      return self.valueOf() ? 2 : 0;
    }, $Boolean___id__$2.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    
    Opal.def(self, '$!', $Boolean_$excl$3 = function() {
      var self = this;

      return self != true;
    }, $Boolean_$excl$3.$$arity = 0);
    
    Opal.def(self, '$&', $Boolean_$$4 = function(other) {
      var self = this;

      return (self == true) ? (other !== false && other !== nil) : false;
    }, $Boolean_$$4.$$arity = 1);
    
    Opal.def(self, '$|', $Boolean_$$5 = function(other) {
      var self = this;

      return (self == true) ? true : (other !== false && other !== nil);
    }, $Boolean_$$5.$$arity = 1);
    
    Opal.def(self, '$^', $Boolean_$$6 = function(other) {
      var self = this;

      return (self == true) ? (other === false || other === nil) : (other !== false && other !== nil);
    }, $Boolean_$$6.$$arity = 1);
    
    Opal.def(self, '$==', $Boolean_$eq_eq$7 = function(other) {
      var self = this;

      return (self == true) === other.valueOf();
    }, $Boolean_$eq_eq$7.$$arity = 1);
    Opal.alias(self, "equal?", "==");
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$singleton_class', $Boolean_singleton_class$8 = function $$singleton_class() {
      var self = this;

      return $$($nesting, 'Boolean')
    }, $Boolean_singleton_class$8.$$arity = 0);
    
    Opal.def(self, '$to_s', $Boolean_to_s$9 = function $$to_s() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    }, $Boolean_to_s$9.$$arity = 0);
    
    Opal.def(self, '$dup', $Boolean_dup$10 = function $$dup() {
      var self = this;

      return self
    }, $Boolean_dup$10.$$arity = 0);
    return (Opal.def(self, '$clone', $Boolean_clone$11 = function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      return self;
    }, $Boolean_clone$11.$$arity = -1), nil) && 'clone';
  })($nesting[0], Boolean, $nesting);
  Opal.const_set($nesting[0], 'TrueClass', $$($nesting, 'Boolean'));
  Opal.const_set($nesting[0], 'FalseClass', $$($nesting, 'Boolean'));
  Opal.const_set($nesting[0], 'TRUE', true);
  return Opal.const_set($nesting[0], 'FALSE', false);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/comparable"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$===', '$>', '$<', '$equal?', '$<=>', '$normalize', '$raise', '$class']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Comparable');

    var $nesting = [self].concat($parent_nesting), $Comparable_normalize$1, $Comparable_$eq_eq$2, $Comparable_$gt$3, $Comparable_$gt_eq$4, $Comparable_$lt$5, $Comparable_$lt_eq$6, $Comparable_between$ques$7, $Comparable_clamp$8;

    
    Opal.defs(self, '$normalize', $Comparable_normalize$1 = function $$normalize(what) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](what))) {
        return what};
      if ($truthy($rb_gt(what, 0))) {
        return 1};
      if ($truthy($rb_lt(what, 0))) {
        return -1};
      return 0;
    }, $Comparable_normalize$1.$$arity = 1);
    
    Opal.def(self, '$==', $Comparable_$eq_eq$2 = function(other) {
      var self = this, cmp = nil;

      try {
        
        if ($truthy(self['$equal?'](other))) {
          return true};
        
      if (self["$<=>"] == Opal.Kernel["$<=>"]) {
        return false;
      }

      // check for infinite recursion
      if (self.$$comparable) {
        delete self.$$comparable;
        return false;
      }
    ;
        if ($truthy((cmp = self['$<=>'](other)))) {
        } else {
          return false
        };
        return $$($nesting, 'Comparable').$normalize(cmp) == 0;
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
          try {
            return false
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Comparable_$eq_eq$2.$$arity = 1);
    
    Opal.def(self, '$>', $Comparable_$gt$3 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
      };
      return $$($nesting, 'Comparable').$normalize(cmp) > 0;
    }, $Comparable_$gt$3.$$arity = 1);
    
    Opal.def(self, '$>=', $Comparable_$gt_eq$4 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
      };
      return $$($nesting, 'Comparable').$normalize(cmp) >= 0;
    }, $Comparable_$gt_eq$4.$$arity = 1);
    
    Opal.def(self, '$<', $Comparable_$lt$5 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
      };
      return $$($nesting, 'Comparable').$normalize(cmp) < 0;
    }, $Comparable_$lt$5.$$arity = 1);
    
    Opal.def(self, '$<=', $Comparable_$lt_eq$6 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
      };
      return $$($nesting, 'Comparable').$normalize(cmp) <= 0;
    }, $Comparable_$lt_eq$6.$$arity = 1);
    
    Opal.def(self, '$between?', $Comparable_between$ques$7 = function(min, max) {
      var self = this;

      
      if ($rb_lt(self, min)) {
        return false};
      if ($rb_gt(self, max)) {
        return false};
      return true;
    }, $Comparable_between$ques$7.$$arity = 2);
    
    Opal.def(self, '$clamp', $Comparable_clamp$8 = function $$clamp(min, max) {
      var self = this, cmp = nil;

      
      cmp = min['$<=>'](max);
      if ($truthy(cmp)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (min.$class()) + " with " + (max.$class()) + " failed")
      };
      if ($truthy($rb_gt($$($nesting, 'Comparable').$normalize(cmp), 0))) {
        self.$raise($$($nesting, 'ArgumentError'), "min argument must be smaller than max argument")};
      if ($truthy($rb_lt($$($nesting, 'Comparable').$normalize(self['$<=>'](min)), 0))) {
        return min};
      if ($truthy($rb_gt($$($nesting, 'Comparable').$normalize(self['$<=>'](max)), 0))) {
        return max};
      return self;
    }, $Comparable_clamp$8.$$arity = 2);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/regexp"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$nil?', '$[]', '$raise', '$escape', '$options', '$to_str', '$new', '$join', '$coerce_to!', '$!', '$match', '$coerce_to?', '$begin', '$coerce_to', '$=~', '$attr_reader', '$===', '$inspect', '$to_a']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RegexpError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Regexp');

    var $nesting = [self].concat($parent_nesting), $Regexp_$eq_eq$6, $Regexp_$eq_eq_eq$7, $Regexp_$eq_tilde$8, $Regexp_inspect$9, $Regexp_match$10, $Regexp_match$ques$11, $Regexp_$$12, $Regexp_source$13, $Regexp_options$14, $Regexp_casefold$ques$15;

    
    Opal.const_set($nesting[0], 'IGNORECASE', 1);
    Opal.const_set($nesting[0], 'EXTENDED', 2);
    Opal.const_set($nesting[0], 'MULTILINE', 4);
    Opal.defineProperty(self.$$prototype, '$$is_regexp', true);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1, $escape$2, $last_match$3, $union$4, $new$5;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var $iter = $allocate$1.$$p, $yield = $iter || nil, self = this, allocated = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $allocate$1.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        allocated = $send(self, Opal.find_super_dispatcher(self, 'allocate', $allocate$1, false), $zuper, $iter);
        allocated.uninitialized = true;
        return allocated;
      }, $allocate$1.$$arity = 0);
      
      Opal.def(self, '$escape', $escape$2 = function $$escape(string) {
        var self = this;

        return Opal.escape_regexp(string);
      }, $escape$2.$$arity = 1);
      
      Opal.def(self, '$last_match', $last_match$3 = function $$last_match(n) {
        var self = this;
        if ($gvars["~"] == null) $gvars["~"] = nil;

        
        
        if (n == null) {
          n = nil;
        };
        if ($truthy(n['$nil?']())) {
          return $gvars["~"]
        } else {
          return $gvars["~"]['$[]'](n)
        };
      }, $last_match$3.$$arity = -1);
      Opal.alias(self, "quote", "escape");
      
      Opal.def(self, '$union', $union$4 = function $$union($a) {
        var $post_args, parts, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        parts = $post_args;;
        
        var is_first_part_array, quoted_validated, part, options, each_part_options;
        if (parts.length == 0) {
          return /(?!)/;
        }
        // return fast if there's only one element
        if (parts.length == 1 && parts[0].$$is_regexp) {
          return parts[0];
        }
        // cover the 2 arrays passed as arguments case
        is_first_part_array = parts[0].$$is_array;
        if (parts.length > 1 && is_first_part_array) {
          self.$raise($$($nesting, 'TypeError'), "no implicit conversion of Array into String")
        }
        // deal with splat issues (related to https://github.com/opal/opal/issues/858)
        if (is_first_part_array) {
          parts = parts[0];
        }
        options = undefined;
        quoted_validated = [];
        for (var i=0; i < parts.length; i++) {
          part = parts[i];
          if (part.$$is_string) {
            quoted_validated.push(self.$escape(part));
          }
          else if (part.$$is_regexp) {
            each_part_options = (part).$options();
            if (options != undefined && options != each_part_options) {
              self.$raise($$($nesting, 'TypeError'), "All expressions must use the same options")
            }
            options = each_part_options;
            quoted_validated.push('('+part.source+')');
          }
          else {
            quoted_validated.push(self.$escape((part).$to_str()));
          }
        }
      ;
        return self.$new((quoted_validated).$join("|"), options);
      }, $union$4.$$arity = -1);
      return (Opal.def(self, '$new', $new$5 = function(regexp, options) {
        var self = this;

        
        ;
        
        if (regexp.$$is_regexp) {
          return new RegExp(regexp);
        }

        regexp = $$($nesting, 'Opal')['$coerce_to!'](regexp, $$($nesting, 'String'), "to_str");

        if (regexp.charAt(regexp.length - 1) === '\\' && regexp.charAt(regexp.length - 2) !== '\\') {
          self.$raise($$($nesting, 'RegexpError'), "" + "too short escape sequence: /" + (regexp) + "/")
        }

        if (options === undefined || options['$!']()) {
          return new RegExp(regexp);
        }

        if (options.$$is_number) {
          var temp = '';
          if ($$($nesting, 'IGNORECASE') & options) { temp += 'i'; }
          if ($$($nesting, 'MULTILINE')  & options) { temp += 'm'; }
          options = temp;
        }
        else {
          options = 'i';
        }

        return new RegExp(regexp, options);
      ;
      }, $new$5.$$arity = -2), nil) && 'new';
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$==', $Regexp_$eq_eq$6 = function(other) {
      var self = this;

      return other instanceof RegExp && self.toString() === other.toString();
    }, $Regexp_$eq_eq$6.$$arity = 1);
    
    Opal.def(self, '$===', $Regexp_$eq_eq_eq$7 = function(string) {
      var self = this;

      return self.$match($$($nesting, 'Opal')['$coerce_to?'](string, $$($nesting, 'String'), "to_str")) !== nil
    }, $Regexp_$eq_eq_eq$7.$$arity = 1);
    
    Opal.def(self, '$=~', $Regexp_$eq_tilde$8 = function(string) {
      var $a, self = this;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      return ($truthy($a = self.$match(string)) ? $gvars["~"].$begin(0) : $a)
    }, $Regexp_$eq_tilde$8.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$inspect', $Regexp_inspect$9 = function $$inspect() {
      var self = this;

      
      var regexp_format = /^\/(.*)\/([^\/]*)$/;
      var value = self.toString();
      var matches = regexp_format.exec(value);
      if (matches) {
        var regexp_pattern = matches[1];
        var regexp_flags = matches[2];
        var chars = regexp_pattern.split('');
        var chars_length = chars.length;
        var char_escaped = false;
        var regexp_pattern_escaped = '';
        for (var i = 0; i < chars_length; i++) {
          var current_char = chars[i];
          if (!char_escaped && current_char == '/') {
            regexp_pattern_escaped = regexp_pattern_escaped.concat('\\');
          }
          regexp_pattern_escaped = regexp_pattern_escaped.concat(current_char);
          if (current_char == '\\') {
            if (char_escaped) {
              // does not over escape
              char_escaped = false;
            } else {
              char_escaped = true;
            }
          } else {
            char_escaped = false;
          }
        }
        return '/' + regexp_pattern_escaped + '/' + regexp_flags;
      } else {
        return value;
      }
    
    }, $Regexp_inspect$9.$$arity = 0);
    
    Opal.def(self, '$match', $Regexp_match$10 = function $$match(string, pos) {
      var $iter = $Regexp_match$10.$$p, block = $iter || nil, self = this;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      if ($iter) $Regexp_match$10.$$p = null;
      
      
      if ($iter) $Regexp_match$10.$$p = null;;
      ;
      
      if (self.uninitialized) {
        self.$raise($$($nesting, 'TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        if (string === nil) return ($gvars["~"] = nil);
        var m = self.exec($$($nesting, 'Opal').$coerce_to(string, $$($nesting, 'String'), "to_str"));
        if (m) {
          ($gvars["~"] = $$($nesting, 'MatchData').$new(self, m));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        } else {
          return ($gvars["~"] = nil);
        }
      }

      pos = $$($nesting, 'Opal').$coerce_to(pos, $$($nesting, 'Integer'), "to_int");

      if (string === nil) {
        return ($gvars["~"] = nil);
      }

      string = $$($nesting, 'Opal').$coerce_to(string, $$($nesting, 'String'), "to_str");

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return ($gvars["~"] = nil);
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      while (true) {
        md = re.exec(string);
        if (md === null) {
          return ($gvars["~"] = nil);
        }
        if (md.index >= pos) {
          ($gvars["~"] = $$($nesting, 'MatchData').$new(re, md));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        }
        re.lastIndex = md.index + 1;
      }
    ;
    }, $Regexp_match$10.$$arity = -2);
    
    Opal.def(self, '$match?', $Regexp_match$ques$11 = function(string, pos) {
      var self = this;

      
      ;
      
      if (self.uninitialized) {
        self.$raise($$($nesting, 'TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        return string === nil ? false : self.test($$($nesting, 'Opal').$coerce_to(string, $$($nesting, 'String'), "to_str"));
      }

      pos = $$($nesting, 'Opal').$coerce_to(pos, $$($nesting, 'Integer'), "to_int");

      if (string === nil) {
        return false;
      }

      string = $$($nesting, 'Opal').$coerce_to(string, $$($nesting, 'String'), "to_str");

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return false;
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      md = re.exec(string);
      if (md === null || md.index < pos) {
        return false;
      } else {
        return true;
      }
    ;
    }, $Regexp_match$ques$11.$$arity = -2);
    
    Opal.def(self, '$~', $Regexp_$$12 = function() {
      var self = this;
      if ($gvars._ == null) $gvars._ = nil;

      return self['$=~']($gvars._)
    }, $Regexp_$$12.$$arity = 0);
    
    Opal.def(self, '$source', $Regexp_source$13 = function $$source() {
      var self = this;

      return self.source;
    }, $Regexp_source$13.$$arity = 0);
    
    Opal.def(self, '$options', $Regexp_options$14 = function $$options() {
      var self = this;

      
      if (self.uninitialized) {
        self.$raise($$($nesting, 'TypeError'), "uninitialized Regexp")
      }
      var result = 0;
      // should be supported in IE6 according to https://msdn.microsoft.com/en-us/library/7f5z26w4(v=vs.94).aspx
      if (self.multiline) {
        result |= $$($nesting, 'MULTILINE');
      }
      if (self.ignoreCase) {
        result |= $$($nesting, 'IGNORECASE');
      }
      return result;
    
    }, $Regexp_options$14.$$arity = 0);
    
    Opal.def(self, '$casefold?', $Regexp_casefold$ques$15 = function() {
      var self = this;

      return self.ignoreCase;
    }, $Regexp_casefold$ques$15.$$arity = 0);
    return Opal.alias(self, "to_s", "source");
  })($nesting[0], RegExp, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'MatchData');

    var $nesting = [self].concat($parent_nesting), $MatchData_initialize$16, $MatchData_$$$17, $MatchData_offset$18, $MatchData_$eq_eq$19, $MatchData_begin$20, $MatchData_end$21, $MatchData_captures$22, $MatchData_inspect$23, $MatchData_length$24, $MatchData_to_a$25, $MatchData_to_s$26, $MatchData_values_at$27;

    self.$$prototype.matches = nil;
    
    self.$attr_reader("post_match", "pre_match", "regexp", "string");
    
    Opal.def(self, '$initialize', $MatchData_initialize$16 = function $$initialize(regexp, match_groups) {
      var self = this;

      
      $gvars["~"] = self;
      self.regexp = regexp;
      self.begin = match_groups.index;
      self.string = match_groups.input;
      self.pre_match = match_groups.input.slice(0, match_groups.index);
      self.post_match = match_groups.input.slice(match_groups.index + match_groups[0].length);
      self.matches = [];
      
      for (var i = 0, length = match_groups.length; i < length; i++) {
        var group = match_groups[i];

        if (group == null) {
          self.matches.push(nil);
        }
        else {
          self.matches.push(group);
        }
      }
    ;
    }, $MatchData_initialize$16.$$arity = 2);
    
    Opal.def(self, '$[]', $MatchData_$$$17 = function($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send(self.matches, '[]', Opal.to_a(args));
    }, $MatchData_$$$17.$$arity = -1);
    
    Opal.def(self, '$offset', $MatchData_offset$18 = function $$offset(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "MatchData#offset only supports 0th element")
      }
      return [self.begin, self.begin + self.matches[n].length];
    
    }, $MatchData_offset$18.$$arity = 1);
    
    Opal.def(self, '$==', $MatchData_$eq_eq$19 = function(other) {
      var $a, $b, $c, $d, self = this;

      
      if ($truthy($$($nesting, 'MatchData')['$==='](other))) {
      } else {
        return false
      };
      return ($truthy($a = ($truthy($b = ($truthy($c = ($truthy($d = self.string == other.string) ? self.regexp.toString() == other.regexp.toString() : $d)) ? self.pre_match == other.pre_match : $c)) ? self.post_match == other.post_match : $b)) ? self.begin == other.begin : $a);
    }, $MatchData_$eq_eq$19.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$begin', $MatchData_begin$20 = function $$begin(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "MatchData#begin only supports 0th element")
      }
      return self.begin;
    
    }, $MatchData_begin$20.$$arity = 1);
    
    Opal.def(self, '$end', $MatchData_end$21 = function $$end(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "MatchData#end only supports 0th element")
      }
      return self.begin + self.matches[n].length;
    
    }, $MatchData_end$21.$$arity = 1);
    
    Opal.def(self, '$captures', $MatchData_captures$22 = function $$captures() {
      var self = this;

      return self.matches.slice(1)
    }, $MatchData_captures$22.$$arity = 0);
    
    Opal.def(self, '$inspect', $MatchData_inspect$23 = function $$inspect() {
      var self = this;

      
      var str = "#<MatchData " + (self.matches[0]).$inspect();

      for (var i = 1, length = self.matches.length; i < length; i++) {
        str += " " + i + ":" + (self.matches[i]).$inspect();
      }

      return str + ">";
    
    }, $MatchData_inspect$23.$$arity = 0);
    
    Opal.def(self, '$length', $MatchData_length$24 = function $$length() {
      var self = this;

      return self.matches.length
    }, $MatchData_length$24.$$arity = 0);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$to_a', $MatchData_to_a$25 = function $$to_a() {
      var self = this;

      return self.matches
    }, $MatchData_to_a$25.$$arity = 0);
    
    Opal.def(self, '$to_s', $MatchData_to_s$26 = function $$to_s() {
      var self = this;

      return self.matches[0]
    }, $MatchData_to_s$26.$$arity = 0);
    return (Opal.def(self, '$values_at', $MatchData_values_at$27 = function $$values_at($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var i, a, index, values = [];

      for (i = 0; i < args.length; i++) {

        if (args[i].$$is_range) {
          a = (args[i]).$to_a();
          a.unshift(i, 1);
          Array.prototype.splice.apply(args, a);
        }

        index = $$($nesting, 'Opal')['$coerce_to!'](args[i], $$($nesting, 'Integer'), "to_int");

        if (index < 0) {
          index += self.matches.length;
          if (index < 0) {
            values.push(nil);
            continue;
          }
        }

        values.push(self.matches[index]);
      }

      return values;
    ;
    }, $MatchData_values_at$27.$$arity = -1), nil) && 'values_at';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/string"] = function(Opal) {
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $gvars = Opal.gvars;

  Opal.add_stubs(['$require', '$include', '$coerce_to?', '$coerce_to', '$raise', '$===', '$format', '$to_s', '$respond_to?', '$to_str', '$<=>', '$==', '$=~', '$new', '$force_encoding', '$casecmp', '$empty?', '$ljust', '$ceil', '$/', '$+', '$rjust', '$floor', '$to_a', '$each_char', '$to_proc', '$coerce_to!', '$copy_singleton_methods', '$initialize_clone', '$initialize_dup', '$enum_for', '$size', '$chomp', '$[]', '$to_i', '$each_line', '$class', '$match', '$match?', '$captures', '$proc', '$succ', '$escape']);
  
  self.$require("corelib/comparable");
  self.$require("corelib/regexp");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String___id__$1, $String_try_convert$2, $String_new$3, $String_initialize$4, $String_$percent$5, $String_$$6, $String_$plus$7, $String_$lt_eq_gt$8, $String_$eq_eq$9, $String_$eq_tilde$10, $String_$$$11, $String_b$12, $String_capitalize$13, $String_casecmp$14, $String_casecmp$ques$15, $String_center$16, $String_chars$17, $String_chomp$18, $String_chop$19, $String_chr$20, $String_clone$21, $String_dup$22, $String_count$23, $String_delete$24, $String_delete_prefix$25, $String_delete_suffix$26, $String_downcase$27, $String_each_char$28, $String_each_line$30, $String_empty$ques$31, $String_end_with$ques$32, $String_gsub$33, $String_hash$34, $String_hex$35, $String_include$ques$36, $String_index$37, $String_inspect$38, $String_intern$39, $String_lines$40, $String_length$41, $String_ljust$42, $String_lstrip$43, $String_ascii_only$ques$44, $String_match$45, $String_match$ques$46, $String_next$47, $String_oct$48, $String_ord$49, $String_partition$50, $String_reverse$51, $String_rindex$52, $String_rjust$53, $String_rpartition$54, $String_rstrip$55, $String_scan$56, $String_split$57, $String_squeeze$58, $String_start_with$ques$59, $String_strip$60, $String_sub$61, $String_sum$62, $String_swapcase$63, $String_to_f$64, $String_to_i$65, $String_to_proc$66, $String_to_s$68, $String_tr$69, $String_tr_s$70, $String_upcase$71, $String_upto$72, $String_instance_variables$73, $String__load$74, $String_unicode_normalize$75, $String_unicode_normalized$ques$76, $String_unpack$77, $String_unpack1$78;

    
    self.$include($$($nesting, 'Comparable'));
    
    Opal.defineProperty(self.$$prototype, '$$is_string', true);

    Opal.defineProperty(self.$$prototype, '$$cast', function(string) {
      var klass = this.$$class;
      if (klass.$$constructor === String) {
        return string;
      } else {
        return new klass.$$constructor(string);
      }
    });
  ;
    
    Opal.def(self, '$__id__', $String___id__$1 = function $$__id__() {
      var self = this;

      return self.toString();
    }, $String___id__$1.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    Opal.defs(self, '$try_convert', $String_try_convert$2 = function $$try_convert(what) {
      var self = this;

      return $$($nesting, 'Opal')['$coerce_to?'](what, $$($nesting, 'String'), "to_str")
    }, $String_try_convert$2.$$arity = 1);
    Opal.defs(self, '$new', $String_new$3 = function(str) {
      var self = this;

      
      
      if (str == null) {
        str = "";
      };
      str = $$($nesting, 'Opal').$coerce_to(str, $$($nesting, 'String'), "to_str");
      return new self.$$constructor(str);;
    }, $String_new$3.$$arity = -1);
    
    Opal.def(self, '$initialize', $String_initialize$4 = function $$initialize(str) {
      var self = this;

      
      ;
      
      if (str === undefined) {
        return self;
      }
    ;
      return self.$raise($$($nesting, 'NotImplementedError'), "Mutable strings are not supported in Opal.");
    }, $String_initialize$4.$$arity = -1);
    
    Opal.def(self, '$%', $String_$percent$5 = function(data) {
      var self = this;

      if ($truthy($$($nesting, 'Array')['$==='](data))) {
        return $send(self, 'format', [self].concat(Opal.to_a(data)))
      } else {
        return self.$format(self, data)
      }
    }, $String_$percent$5.$$arity = 1);
    
    Opal.def(self, '$*', $String_$$6 = function(count) {
      var self = this;

      
      count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), "to_int");

      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative argument")
      }

      if (count === 0) {
        return self.$$cast('');
      }

      var result = '',
          string = self.toString();

      // All credit for the bit-twiddling magic code below goes to Mozilla
      // polyfill implementation of String.prototype.repeat() posted here:
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat

      if (string.length * count >= 1 << 28) {
        self.$raise($$($nesting, 'RangeError'), "multiply count must not overflow maximum string size")
      }

      for (;;) {
        if ((count & 1) === 1) {
          result += string;
        }
        count >>>= 1;
        if (count === 0) {
          break;
        }
        string += string;
      }

      return self.$$cast(result);
    
    }, $String_$$6.$$arity = 1);
    
    Opal.def(self, '$+', $String_$plus$7 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'String'), "to_str");
      return self + other.$to_s();
    }, $String_$plus$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $String_$lt_eq_gt$8 = function(other) {
      var self = this;

      if ($truthy(other['$respond_to?']("to_str"))) {
        
        other = other.$to_str().$to_s();
        return self > other ? 1 : (self < other ? -1 : 0);;
      } else {
        
        var cmp = other['$<=>'](self);

        if (cmp === nil) {
          return nil;
        }
        else {
          return cmp > 0 ? -1 : (cmp < 0 ? 1 : 0);
        }
      
      }
    }, $String_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$==', $String_$eq_eq$9 = function(other) {
      var self = this;

      
      if (other.$$is_string) {
        return self.toString() === other.toString();
      }
      if ($$($nesting, 'Opal')['$respond_to?'](other, "to_str")) {
        return other['$=='](self);
      }
      return false;
    
    }, $String_$eq_eq$9.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    Opal.alias(self, "===", "==");
    
    Opal.def(self, '$=~', $String_$eq_tilde$10 = function(other) {
      var self = this;

      
      if (other.$$is_string) {
        self.$raise($$($nesting, 'TypeError'), "type mismatch: String given");
      }

      return other['$=~'](self);
    
    }, $String_$eq_tilde$10.$$arity = 1);
    
    Opal.def(self, '$[]', $String_$$$11 = function(index, length) {
      var self = this;

      
      ;
      
      var size = self.length, exclude;

      if (index.$$is_range) {
        exclude = index.excl;
        length  = $$($nesting, 'Opal').$coerce_to(index.end, $$($nesting, 'Integer'), "to_int");
        index   = $$($nesting, 'Opal').$coerce_to(index.begin, $$($nesting, 'Integer'), "to_int");

        if (Math.abs(index) > size) {
          return nil;
        }

        if (index < 0) {
          index += size;
        }

        if (length < 0) {
          length += size;
        }

        if (!exclude) {
          length += 1;
        }

        length = length - index;

        if (length < 0) {
          length = 0;
        }

        return self.$$cast(self.substr(index, length));
      }


      if (index.$$is_string) {
        if (length != null) {
          self.$raise($$($nesting, 'TypeError'))
        }
        return self.indexOf(index) !== -1 ? self.$$cast(index) : nil;
      }


      if (index.$$is_regexp) {
        var match = self.match(index);

        if (match === null) {
          ($gvars["~"] = nil)
          return nil;
        }

        ($gvars["~"] = $$($nesting, 'MatchData').$new(index, match))

        if (length == null) {
          return self.$$cast(match[0]);
        }

        length = $$($nesting, 'Opal').$coerce_to(length, $$($nesting, 'Integer'), "to_int");

        if (length < 0 && -length < match.length) {
          return self.$$cast(match[length += match.length]);
        }

        if (length >= 0 && length < match.length) {
          return self.$$cast(match[length]);
        }

        return nil;
      }


      index = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");

      if (index < 0) {
        index += size;
      }

      if (length == null) {
        if (index >= size || index < 0) {
          return nil;
        }
        return self.$$cast(self.substr(index, 1));
      }

      length = $$($nesting, 'Opal').$coerce_to(length, $$($nesting, 'Integer'), "to_int");

      if (length < 0) {
        return nil;
      }

      if (index > size || index < 0) {
        return nil;
      }

      return self.$$cast(self.substr(index, length));
    ;
    }, $String_$$$11.$$arity = -2);
    Opal.alias(self, "byteslice", "[]");
    
    Opal.def(self, '$b', $String_b$12 = function $$b() {
      var self = this;

      return self.$force_encoding("binary")
    }, $String_b$12.$$arity = 0);
    
    Opal.def(self, '$capitalize', $String_capitalize$13 = function $$capitalize() {
      var self = this;

      return self.$$cast(self.charAt(0).toUpperCase() + self.substr(1).toLowerCase());
    }, $String_capitalize$13.$$arity = 0);
    
    Opal.def(self, '$casecmp', $String_casecmp$14 = function $$casecmp(other) {
      var self = this;

      
      if ($truthy(other['$respond_to?']("to_str"))) {
      } else {
        return nil
      };
      other = $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'String'), "to_str").$to_s();
      
      var ascii_only = /^[\x00-\x7F]*$/;
      if (ascii_only.test(self) && ascii_only.test(other)) {
        self = self.toLowerCase();
        other = other.toLowerCase();
      }
    ;
      return self['$<=>'](other);
    }, $String_casecmp$14.$$arity = 1);
    
    Opal.def(self, '$casecmp?', $String_casecmp$ques$15 = function(other) {
      var self = this;

      
      var cmp = self.$casecmp(other);
      if (cmp === nil) {
        return nil;
      } else {
        return cmp === 0;
      }
    
    }, $String_casecmp$ques$15.$$arity = 1);
    
    Opal.def(self, '$center', $String_center$16 = function $$center(width, padstr) {
      var self = this;

      
      
      if (padstr == null) {
        padstr = " ";
      };
      width = $$($nesting, 'Opal').$coerce_to(width, $$($nesting, 'Integer'), "to_int");
      padstr = $$($nesting, 'Opal').$coerce_to(padstr, $$($nesting, 'String'), "to_str").$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var ljustified = self.$ljust($rb_divide($rb_plus(width, self.length), 2).$ceil(), padstr),
          rjustified = self.$rjust($rb_divide($rb_plus(width, self.length), 2).$floor(), padstr);

      return self.$$cast(rjustified + ljustified.slice(self.length));
    ;
    }, $String_center$16.$$arity = -2);
    
    Opal.def(self, '$chars', $String_chars$17 = function $$chars() {
      var $iter = $String_chars$17.$$p, block = $iter || nil, self = this;

      if ($iter) $String_chars$17.$$p = null;
      
      
      if ($iter) $String_chars$17.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$each_char().$to_a()
      };
      return $send(self, 'each_char', [], block.$to_proc());
    }, $String_chars$17.$$arity = 0);
    
    Opal.def(self, '$chomp', $String_chomp$18 = function $$chomp(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      if ($truthy(separator === nil || self.length === 0)) {
        return self};
      separator = $$($nesting, 'Opal')['$coerce_to!'](separator, $$($nesting, 'String'), "to_str").$to_s();
      
      var result;

      if (separator === "\n") {
        result = self.replace(/\r?\n?$/, '');
      }
      else if (separator === "") {
        result = self.replace(/(\r?\n)+$/, '');
      }
      else if (self.length >= separator.length) {
        var tail = self.substr(self.length - separator.length, separator.length);

        if (tail === separator) {
          result = self.substr(0, self.length - separator.length);
        }
      }

      if (result != null) {
        return self.$$cast(result);
      }
    ;
      return self;
    }, $String_chomp$18.$$arity = -1);
    
    Opal.def(self, '$chop', $String_chop$19 = function $$chop() {
      var self = this;

      
      var length = self.length, result;

      if (length <= 1) {
        result = "";
      } else if (self.charAt(length - 1) === "\n" && self.charAt(length - 2) === "\r") {
        result = self.substr(0, length - 2);
      } else {
        result = self.substr(0, length - 1);
      }

      return self.$$cast(result);
    
    }, $String_chop$19.$$arity = 0);
    
    Opal.def(self, '$chr', $String_chr$20 = function $$chr() {
      var self = this;

      return self.charAt(0);
    }, $String_chr$20.$$arity = 0);
    
    Opal.def(self, '$clone', $String_clone$21 = function $$clone() {
      var self = this, copy = nil;

      
      copy = self.slice();
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self);
      return copy;
    }, $String_clone$21.$$arity = 0);
    
    Opal.def(self, '$dup', $String_dup$22 = function $$dup() {
      var self = this, copy = nil;

      
      copy = self.slice();
      copy.$initialize_dup(self);
      return copy;
    }, $String_dup$22.$$arity = 0);
    
    Opal.def(self, '$count', $String_count$23 = function $$count($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        self.$raise($$($nesting, 'ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return 0;
      }
      return self.length - self.replace(new RegExp(char_class, 'g'), '').length;
    ;
    }, $String_count$23.$$arity = -1);
    
    Opal.def(self, '$delete', $String_delete$24 = function($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        self.$raise($$($nesting, 'ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.$$cast(self.replace(new RegExp(char_class, 'g'), ''));
    ;
    }, $String_delete$24.$$arity = -1);
    
    Opal.def(self, '$delete_prefix', $String_delete_prefix$25 = function $$delete_prefix(prefix) {
      var self = this;

      
      if (!prefix.$$is_string) {
        (prefix = $$($nesting, 'Opal').$coerce_to(prefix, $$($nesting, 'String'), "to_str"))
      }

      if (self.slice(0, prefix.length) === prefix) {
        return self.$$cast(self.slice(prefix.length));
      } else {
        return self;
      }
    
    }, $String_delete_prefix$25.$$arity = 1);
    
    Opal.def(self, '$delete_suffix', $String_delete_suffix$26 = function $$delete_suffix(suffix) {
      var self = this;

      
      if (!suffix.$$is_string) {
        (suffix = $$($nesting, 'Opal').$coerce_to(suffix, $$($nesting, 'String'), "to_str"))
      }

      if (self.slice(self.length - suffix.length) === suffix) {
        return self.$$cast(self.slice(0, self.length - suffix.length));
      } else {
        return self;
      }
    
    }, $String_delete_suffix$26.$$arity = 1);
    
    Opal.def(self, '$downcase', $String_downcase$27 = function $$downcase() {
      var self = this;

      return self.$$cast(self.toLowerCase());
    }, $String_downcase$27.$$arity = 0);
    
    Opal.def(self, '$each_char', $String_each_char$28 = function $$each_char() {
      var $iter = $String_each_char$28.$$p, block = $iter || nil, $$29, self = this;

      if ($iter) $String_each_char$28.$$p = null;
      
      
      if ($iter) $String_each_char$28.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_char"], ($$29 = function(){var self = $$29.$$s || this;

        return self.$size()}, $$29.$$s = self, $$29.$$arity = 0, $$29))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        Opal.yield1(block, self.charAt(i));
      }
    ;
      return self;
    }, $String_each_char$28.$$arity = 0);
    
    Opal.def(self, '$each_line', $String_each_line$30 = function $$each_line(separator) {
      var $iter = $String_each_line$30.$$p, block = $iter || nil, self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if ($iter) $String_each_line$30.$$p = null;
      
      
      if ($iter) $String_each_line$30.$$p = null;;
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each_line", separator)
      };
      
      if (separator === nil) {
        Opal.yield1(block, self);

        return self;
      }

      separator = $$($nesting, 'Opal').$coerce_to(separator, $$($nesting, 'String'), "to_str")

      var a, i, n, length, chomped, trailing, splitted;

      if (separator.length === 0) {
        for (a = self.split(/(\n{2,})/), i = 0, n = a.length; i < n; i += 2) {
          if (a[i] || a[i + 1]) {
            var value = (a[i] || "") + (a[i + 1] || "");
            Opal.yield1(block, self.$$cast(value));
          }
        }

        return self;
      }

      chomped  = self.$chomp(separator);
      trailing = self.length != chomped.length;
      splitted = chomped.split(separator);

      for (i = 0, length = splitted.length; i < length; i++) {
        if (i < length - 1 || trailing) {
          Opal.yield1(block, self.$$cast(splitted[i] + separator));
        }
        else {
          Opal.yield1(block, self.$$cast(splitted[i]));
        }
      }
    ;
      return self;
    }, $String_each_line$30.$$arity = -1);
    
    Opal.def(self, '$empty?', $String_empty$ques$31 = function() {
      var self = this;

      return self.length === 0;
    }, $String_empty$ques$31.$$arity = 0);
    
    Opal.def(self, '$end_with?', $String_end_with$ques$32 = function($a) {
      var $post_args, suffixes, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      suffixes = $post_args;;
      
      for (var i = 0, length = suffixes.length; i < length; i++) {
        var suffix = $$($nesting, 'Opal').$coerce_to(suffixes[i], $$($nesting, 'String'), "to_str").$to_s();

        if (self.length >= suffix.length &&
            self.substr(self.length - suffix.length, suffix.length) == suffix) {
          return true;
        }
      }
    ;
      return false;
    }, $String_end_with$ques$32.$$arity = -1);
    Opal.alias(self, "equal?", "===");
    
    Opal.def(self, '$gsub', $String_gsub$33 = function $$gsub(pattern, replacement) {
      var $iter = $String_gsub$33.$$p, block = $iter || nil, self = this;

      if ($iter) $String_gsub$33.$$p = null;
      
      
      if ($iter) $String_gsub$33.$$p = null;;
      ;
      
      if (replacement === undefined && block === nil) {
        return self.$enum_for("gsub", pattern);
      }

      var result = '', match_data = nil, index = 0, match, _replacement;

      if (pattern.$$is_regexp) {
        pattern = Opal.global_multiline_regexp(pattern);
      } else {
        pattern = $$($nesting, 'Opal').$coerce_to(pattern, $$($nesting, 'String'), "to_str");
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      var lastIndex;
      while (true) {
        match = pattern.exec(self);

        if (match === null) {
          ($gvars["~"] = nil)
          result += self.slice(index);
          break;
        }

        match_data = $$($nesting, 'MatchData').$new(pattern, match);

        if (replacement === undefined) {
          lastIndex = pattern.lastIndex;
          _replacement = block(match[0]);
          pattern.lastIndex = lastIndex; // save and restore lastIndex
        }
        else if (replacement.$$is_hash) {
          _replacement = (replacement)['$[]'](match[0]).$to_s();
        }
        else {
          if (!replacement.$$is_string) {
            replacement = $$($nesting, 'Opal').$coerce_to(replacement, $$($nesting, 'String'), "to_str");
          }
          _replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');
        }

        if (pattern.lastIndex === match.index) {
          result += (_replacement + self.slice(index, match.index + 1))
          pattern.lastIndex += 1;
        }
        else {
          result += (self.slice(index, match.index) + _replacement)
        }
        index = pattern.lastIndex;
      }

      ($gvars["~"] = match_data)
      return self.$$cast(result);
    ;
    }, $String_gsub$33.$$arity = -2);
    
    Opal.def(self, '$hash', $String_hash$34 = function $$hash() {
      var self = this;

      return self.toString();
    }, $String_hash$34.$$arity = 0);
    
    Opal.def(self, '$hex', $String_hex$35 = function $$hex() {
      var self = this;

      return self.$to_i(16)
    }, $String_hex$35.$$arity = 0);
    
    Opal.def(self, '$include?', $String_include$ques$36 = function(other) {
      var self = this;

      
      if (!other.$$is_string) {
        (other = $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'String'), "to_str"))
      }
      return self.indexOf(other) !== -1;
    
    }, $String_include$ques$36.$$arity = 1);
    
    Opal.def(self, '$index', $String_index$37 = function $$index(search, offset) {
      var self = this;

      
      ;
      
      var index,
          match,
          regex;

      if (offset === undefined) {
        offset = 0;
      } else {
        offset = $$($nesting, 'Opal').$coerce_to(offset, $$($nesting, 'Integer'), "to_int");
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        regex = Opal.global_multiline_regexp(search);
        while (true) {
          match = regex.exec(self);
          if (match === null) {
            ($gvars["~"] = nil);
            index = -1;
            break;
          }
          if (match.index >= offset) {
            ($gvars["~"] = $$($nesting, 'MatchData').$new(regex, match))
            index = match.index;
            break;
          }
          regex.lastIndex = match.index + 1;
        }
      } else {
        search = $$($nesting, 'Opal').$coerce_to(search, $$($nesting, 'String'), "to_str");
        if (search.length === 0 && offset > self.length) {
          index = -1;
        } else {
          index = self.indexOf(search, offset);
        }
      }

      return index === -1 ? nil : index;
    ;
    }, $String_index$37.$$arity = -2);
    
    Opal.def(self, '$inspect', $String_inspect$38 = function $$inspect() {
      var self = this;

      
      var escapable = /[\\\"\x00-\x1f\u007F-\u009F\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
          meta = {
            '\u0007': '\\a',
            '\u001b': '\\e',
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '\v': '\\v',
            '"' : '\\"',
            '\\': '\\\\'
          },
          escaped = self.replace(escapable, function (chr) {
            return meta[chr] || '\\u' + ('0000' + chr.charCodeAt(0).toString(16).toUpperCase()).slice(-4);
          });
      return '"' + escaped.replace(/\#[\$\@\{]/g, '\\$&') + '"';
    
    }, $String_inspect$38.$$arity = 0);
    
    Opal.def(self, '$intern', $String_intern$39 = function $$intern() {
      var self = this;

      return self.toString();
    }, $String_intern$39.$$arity = 0);
    
    Opal.def(self, '$lines', $String_lines$40 = function $$lines(separator) {
      var $iter = $String_lines$40.$$p, block = $iter || nil, self = this, e = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if ($iter) $String_lines$40.$$p = null;
      
      
      if ($iter) $String_lines$40.$$p = null;;
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      e = $send(self, 'each_line', [separator], block.$to_proc());
      if ($truthy(block)) {
        return self
      } else {
        return e.$to_a()
      };
    }, $String_lines$40.$$arity = -1);
    
    Opal.def(self, '$length', $String_length$41 = function $$length() {
      var self = this;

      return self.length;
    }, $String_length$41.$$arity = 0);
    
    Opal.def(self, '$ljust', $String_ljust$42 = function $$ljust(width, padstr) {
      var self = this;

      
      
      if (padstr == null) {
        padstr = " ";
      };
      width = $$($nesting, 'Opal').$coerce_to(width, $$($nesting, 'Integer'), "to_int");
      padstr = $$($nesting, 'Opal').$coerce_to(padstr, $$($nesting, 'String'), "to_str").$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var index  = -1,
          result = "";

      width -= self.length;

      while (++index < width) {
        result += padstr;
      }

      return self.$$cast(self + result.slice(0, width));
    ;
    }, $String_ljust$42.$$arity = -2);
    
    Opal.def(self, '$lstrip', $String_lstrip$43 = function $$lstrip() {
      var self = this;

      return self.replace(/^\s*/, '');
    }, $String_lstrip$43.$$arity = 0);
    
    Opal.def(self, '$ascii_only?', $String_ascii_only$ques$44 = function() {
      var self = this;

      return self.match(/[ -~\n]*/)[0] === self;
    }, $String_ascii_only$ques$44.$$arity = 0);
    
    Opal.def(self, '$match', $String_match$45 = function $$match(pattern, pos) {
      var $iter = $String_match$45.$$p, block = $iter || nil, $a, self = this;

      if ($iter) $String_match$45.$$p = null;
      
      
      if ($iter) $String_match$45.$$p = null;;
      ;
      if ($truthy(($truthy($a = $$($nesting, 'String')['$==='](pattern)) ? $a : pattern['$respond_to?']("to_str")))) {
        pattern = $$($nesting, 'Regexp').$new(pattern.$to_str())};
      if ($truthy($$($nesting, 'Regexp')['$==='](pattern))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return $send(pattern, 'match', [self, pos], block.$to_proc());
    }, $String_match$45.$$arity = -2);
    
    Opal.def(self, '$match?', $String_match$ques$46 = function(pattern, pos) {
      var $a, self = this;

      
      ;
      if ($truthy(($truthy($a = $$($nesting, 'String')['$==='](pattern)) ? $a : pattern['$respond_to?']("to_str")))) {
        pattern = $$($nesting, 'Regexp').$new(pattern.$to_str())};
      if ($truthy($$($nesting, 'Regexp')['$==='](pattern))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return pattern['$match?'](self, pos);
    }, $String_match$ques$46.$$arity = -2);
    
    Opal.def(self, '$next', $String_next$47 = function $$next() {
      var self = this;

      
      var i = self.length;
      if (i === 0) {
        return self.$$cast('');
      }
      var result = self;
      var first_alphanum_char_index = self.search(/[a-zA-Z0-9]/);
      var carry = false;
      var code;
      while (i--) {
        code = self.charCodeAt(i);
        if ((code >= 48 && code <= 57) ||
          (code >= 65 && code <= 90) ||
          (code >= 97 && code <= 122)) {
          switch (code) {
          case 57:
            carry = true;
            code = 48;
            break;
          case 90:
            carry = true;
            code = 65;
            break;
          case 122:
            carry = true;
            code = 97;
            break;
          default:
            carry = false;
            code += 1;
          }
        } else {
          if (first_alphanum_char_index === -1) {
            if (code === 255) {
              carry = true;
              code = 0;
            } else {
              carry = false;
              code += 1;
            }
          } else {
            carry = true;
          }
        }
        result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i + 1);
        if (carry && (i === 0 || i === first_alphanum_char_index)) {
          switch (code) {
          case 65:
            break;
          case 97:
            break;
          default:
            code += 1;
          }
          if (i === 0) {
            result = String.fromCharCode(code) + result;
          } else {
            result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i);
          }
          carry = false;
        }
        if (!carry) {
          break;
        }
      }
      return self.$$cast(result);
    
    }, $String_next$47.$$arity = 0);
    
    Opal.def(self, '$oct', $String_oct$48 = function $$oct() {
      var self = this;

      
      var result,
          string = self,
          radix = 8;

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/i, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x') {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          radix = 2;
          break;
        case '0':
        case '0o':
          radix = 8;
          break;
        case '0d':
          radix = 10;
          break;
        case '0x':
          radix = 16;
          break;
        }
        return head + tail;
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    
    }, $String_oct$48.$$arity = 0);
    
    Opal.def(self, '$ord', $String_ord$49 = function $$ord() {
      var self = this;

      return self.charCodeAt(0);
    }, $String_ord$49.$$arity = 0);
    
    Opal.def(self, '$partition', $String_partition$50 = function $$partition(sep) {
      var self = this;

      
      var i, m;

      if (sep.$$is_regexp) {
        m = sep.exec(self);
        if (m === null) {
          i = -1;
        } else {
          $$($nesting, 'MatchData').$new(sep, m);
          sep = m[0];
          i = m.index;
        }
      } else {
        sep = $$($nesting, 'Opal').$coerce_to(sep, $$($nesting, 'String'), "to_str");
        i = self.indexOf(sep);
      }

      if (i === -1) {
        return [self, '', ''];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, $String_partition$50.$$arity = 1);
    
    Opal.def(self, '$reverse', $String_reverse$51 = function $$reverse() {
      var self = this;

      return self.split('').reverse().join('');
    }, $String_reverse$51.$$arity = 0);
    
    Opal.def(self, '$rindex', $String_rindex$52 = function $$rindex(search, offset) {
      var self = this;

      
      ;
      
      var i, m, r, _m;

      if (offset === undefined) {
        offset = self.length;
      } else {
        offset = $$($nesting, 'Opal').$coerce_to(offset, $$($nesting, 'Integer'), "to_int");
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        m = null;
        r = Opal.global_multiline_regexp(search);
        while (true) {
          _m = r.exec(self);
          if (_m === null || _m.index > offset) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }
        if (m === null) {
          ($gvars["~"] = nil)
          i = -1;
        } else {
          $$($nesting, 'MatchData').$new(r, m);
          i = m.index;
        }
      } else {
        search = $$($nesting, 'Opal').$coerce_to(search, $$($nesting, 'String'), "to_str");
        i = self.lastIndexOf(search, offset);
      }

      return i === -1 ? nil : i;
    ;
    }, $String_rindex$52.$$arity = -2);
    
    Opal.def(self, '$rjust', $String_rjust$53 = function $$rjust(width, padstr) {
      var self = this;

      
      
      if (padstr == null) {
        padstr = " ";
      };
      width = $$($nesting, 'Opal').$coerce_to(width, $$($nesting, 'Integer'), "to_int");
      padstr = $$($nesting, 'Opal').$coerce_to(padstr, $$($nesting, 'String'), "to_str").$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var chars     = Math.floor(width - self.length),
          patterns  = Math.floor(chars / padstr.length),
          result    = Array(patterns + 1).join(padstr),
          remaining = chars - result.length;

      return self.$$cast(result + padstr.slice(0, remaining) + self);
    ;
    }, $String_rjust$53.$$arity = -2);
    
    Opal.def(self, '$rpartition', $String_rpartition$54 = function $$rpartition(sep) {
      var self = this;

      
      var i, m, r, _m;

      if (sep.$$is_regexp) {
        m = null;
        r = Opal.global_multiline_regexp(sep);

        while (true) {
          _m = r.exec(self);
          if (_m === null) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }

        if (m === null) {
          i = -1;
        } else {
          $$($nesting, 'MatchData').$new(r, m);
          sep = m[0];
          i = m.index;
        }

      } else {
        sep = $$($nesting, 'Opal').$coerce_to(sep, $$($nesting, 'String'), "to_str");
        i = self.lastIndexOf(sep);
      }

      if (i === -1) {
        return ['', '', self];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, $String_rpartition$54.$$arity = 1);
    
    Opal.def(self, '$rstrip', $String_rstrip$55 = function $$rstrip() {
      var self = this;

      return self.replace(/[\s\u0000]*$/, '');
    }, $String_rstrip$55.$$arity = 0);
    
    Opal.def(self, '$scan', $String_scan$56 = function $$scan(pattern) {
      var $iter = $String_scan$56.$$p, block = $iter || nil, self = this;

      if ($iter) $String_scan$56.$$p = null;
      
      
      if ($iter) $String_scan$56.$$p = null;;
      
      var result = [],
          match_data = nil,
          match;

      if (pattern.$$is_regexp) {
        pattern = Opal.global_multiline_regexp(pattern);
      } else {
        pattern = $$($nesting, 'Opal').$coerce_to(pattern, $$($nesting, 'String'), "to_str");
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      while ((match = pattern.exec(self)) != null) {
        match_data = $$($nesting, 'MatchData').$new(pattern, match);
        if (block === nil) {
          match.length == 1 ? result.push(match[0]) : result.push((match_data).$captures());
        } else {
          match.length == 1 ? block(match[0]) : block.call(self, (match_data).$captures());
        }
        if (pattern.lastIndex === match.index) {
          pattern.lastIndex += 1;
        }
      }

      ($gvars["~"] = match_data)

      return (block !== nil ? self : result);
    ;
    }, $String_scan$56.$$arity = 1);
    Opal.alias(self, "size", "length");
    Opal.alias(self, "slice", "[]");
    
    Opal.def(self, '$split', $String_split$57 = function $$split(pattern, limit) {
      var $a, self = this;
      if ($gvars[";"] == null) $gvars[";"] = nil;

      
      ;
      ;
      
      if (self.length === 0) {
        return [];
      }

      if (limit === undefined) {
        limit = 0;
      } else {
        limit = $$($nesting, 'Opal')['$coerce_to!'](limit, $$($nesting, 'Integer'), "to_int");
        if (limit === 1) {
          return [self];
        }
      }

      if (pattern === undefined || pattern === nil) {
        pattern = ($truthy($a = $gvars[";"]) ? $a : " ");
      }

      var result = [],
          string = self.toString(),
          index = 0,
          match,
          i, ii;

      if (pattern.$$is_regexp) {
        pattern = Opal.global_multiline_regexp(pattern);
      } else {
        pattern = $$($nesting, 'Opal').$coerce_to(pattern, $$($nesting, 'String'), "to_str").$to_s();
        if (pattern === ' ') {
          pattern = /\s+/gm;
          string = string.replace(/^\s+/, '');
        } else {
          pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
        }
      }

      result = string.split(pattern);

      if (result.length === 1 && result[0] === string) {
        return [self.$$cast(result[0])];
      }

      while ((i = result.indexOf(undefined)) !== -1) {
        result.splice(i, 1);
      }

      function castResult() {
        for (i = 0; i < result.length; i++) {
          result[i] = self.$$cast(result[i]);
        }
      }

      if (limit === 0) {
        while (result[result.length - 1] === '') {
          result.length -= 1;
        }
        castResult();
        return result;
      }

      match = pattern.exec(string);

      if (limit < 0) {
        if (match !== null && match[0] === '' && pattern.source.indexOf('(?=') === -1) {
          for (i = 0, ii = match.length; i < ii; i++) {
            result.push('');
          }
        }
        castResult();
        return result;
      }

      if (match !== null && match[0] === '') {
        result.splice(limit - 1, result.length - 1, result.slice(limit - 1).join(''));
        castResult();
        return result;
      }

      if (limit >= result.length) {
        castResult();
        return result;
      }

      i = 0;
      while (match !== null) {
        i++;
        index = pattern.lastIndex;
        if (i + 1 === limit) {
          break;
        }
        match = pattern.exec(string);
      }
      result.splice(limit - 1, result.length - 1, string.slice(index));
      castResult();
      return result;
    ;
    }, $String_split$57.$$arity = -1);
    
    Opal.def(self, '$squeeze', $String_squeeze$58 = function $$squeeze($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        return self.$$cast(self.replace(/(.)\1+/g, '$1'));
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.$$cast(self.replace(new RegExp('(' + char_class + ')\\1+', 'g'), '$1'));
    ;
    }, $String_squeeze$58.$$arity = -1);
    
    Opal.def(self, '$start_with?', $String_start_with$ques$59 = function($a) {
      var $post_args, prefixes, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      prefixes = $post_args;;
      
      for (var i = 0, length = prefixes.length; i < length; i++) {
        var prefix = $$($nesting, 'Opal').$coerce_to(prefixes[i], $$($nesting, 'String'), "to_str").$to_s();

        if (self.indexOf(prefix) === 0) {
          return true;
        }
      }

      return false;
    ;
    }, $String_start_with$ques$59.$$arity = -1);
    
    Opal.def(self, '$strip', $String_strip$60 = function $$strip() {
      var self = this;

      return self.replace(/^\s*/, '').replace(/[\s\u0000]*$/, '');
    }, $String_strip$60.$$arity = 0);
    
    Opal.def(self, '$sub', $String_sub$61 = function $$sub(pattern, replacement) {
      var $iter = $String_sub$61.$$p, block = $iter || nil, self = this;

      if ($iter) $String_sub$61.$$p = null;
      
      
      if ($iter) $String_sub$61.$$p = null;;
      ;
      
      if (!pattern.$$is_regexp) {
        pattern = $$($nesting, 'Opal').$coerce_to(pattern, $$($nesting, 'String'), "to_str");
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
      }

      var result, match = pattern.exec(self);

      if (match === null) {
        ($gvars["~"] = nil)
        result = self.toString();
      } else {
        $$($nesting, 'MatchData').$new(pattern, match)

        if (replacement === undefined) {

          if (block === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (1 for 2)")
          }
          result = self.slice(0, match.index) + block(match[0]) + self.slice(match.index + match[0].length);

        } else if (replacement.$$is_hash) {

          result = self.slice(0, match.index) + (replacement)['$[]'](match[0]).$to_s() + self.slice(match.index + match[0].length);

        } else {

          replacement = $$($nesting, 'Opal').$coerce_to(replacement, $$($nesting, 'String'), "to_str");

          replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');

          result = self.slice(0, match.index) + replacement + self.slice(match.index + match[0].length);
        }
      }

      return self.$$cast(result);
    ;
    }, $String_sub$61.$$arity = -2);
    Opal.alias(self, "succ", "next");
    
    Opal.def(self, '$sum', $String_sum$62 = function $$sum(n) {
      var self = this;

      
      
      if (n == null) {
        n = 16;
      };
      
      n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), "to_int");

      var result = 0,
          length = self.length,
          i = 0;

      for (; i < length; i++) {
        result += self.charCodeAt(i);
      }

      if (n <= 0) {
        return result;
      }

      return result & (Math.pow(2, n) - 1);
    ;
    }, $String_sum$62.$$arity = -1);
    
    Opal.def(self, '$swapcase', $String_swapcase$63 = function $$swapcase() {
      var self = this;

      
      var str = self.replace(/([a-z]+)|([A-Z]+)/g, function($0,$1,$2) {
        return $1 ? $0.toUpperCase() : $0.toLowerCase();
      });

      if (self.constructor === String) {
        return str;
      }

      return self.$class().$new(str);
    
    }, $String_swapcase$63.$$arity = 0);
    
    Opal.def(self, '$to_f', $String_to_f$64 = function $$to_f() {
      var self = this;

      
      if (self.charAt(0) === '_') {
        return 0;
      }

      var result = parseFloat(self.replace(/_/g, ''));

      if (isNaN(result) || result == Infinity || result == -Infinity) {
        return 0;
      }
      else {
        return result;
      }
    
    }, $String_to_f$64.$$arity = 0);
    
    Opal.def(self, '$to_i', $String_to_i$65 = function $$to_i(base) {
      var self = this;

      
      
      if (base == null) {
        base = 10;
      };
      
      var result,
          string = self.toLowerCase(),
          radix = $$($nesting, 'Opal').$coerce_to(base, $$($nesting, 'Integer'), "to_int");

      if (radix === 1 || radix < 0 || radix > 36) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (radix))
      }

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x' && (radix === 0 || radix === 16)) {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          if (radix === 0 || radix === 2) {
            radix = 2;
            return head + tail;
          }
          break;
        case '0':
        case '0o':
          if (radix === 0 || radix === 8) {
            radix = 8;
            return head + tail;
          }
          break;
        case '0d':
          if (radix === 0 || radix === 10) {
            radix = 10;
            return head + tail;
          }
          break;
        case '0x':
          if (radix === 0 || radix === 16) {
            radix = 16;
            return head + tail;
          }
          break;
        }
        return original
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    ;
    }, $String_to_i$65.$$arity = -1);
    
    Opal.def(self, '$to_proc', $String_to_proc$66 = function $$to_proc() {
      var $$67, $iter = $String_to_proc$66.$$p, $yield = $iter || nil, self = this, method_name = nil;

      if ($iter) $String_to_proc$66.$$p = null;
      
      method_name = $rb_plus("$", self.valueOf());
      return $send(self, 'proc', [], ($$67 = function($a){var self = $$67.$$s || this, $iter = $$67.$$p, block = $iter || nil, $post_args, args;

      
        
        if ($iter) $$67.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        
        if (args.length === 0) {
          self.$raise($$($nesting, 'ArgumentError'), "no receiver given")
        }

        var recv = args[0];

        if (recv == null) recv = nil;

        var body = recv[method_name];

        if (!body) {
          return recv.$method_missing.apply(recv, args);
        }

        if (typeof block === 'function') {
          body.$$p = block;
        }

        if (args.length === 1) {
          return body.call(recv);
        } else {
          return body.apply(recv, args.slice(1));
        }
      ;}, $$67.$$s = self, $$67.$$arity = -1, $$67));
    }, $String_to_proc$66.$$arity = 0);
    
    Opal.def(self, '$to_s', $String_to_s$68 = function $$to_s() {
      var self = this;

      return self.toString();
    }, $String_to_s$68.$$arity = 0);
    Opal.alias(self, "to_str", "to_s");
    Opal.alias(self, "to_sym", "intern");
    
    Opal.def(self, '$tr', $String_tr$69 = function $$tr(from, to) {
      var self = this;

      
      from = $$($nesting, 'Opal').$coerce_to(from, $$($nesting, 'String'), "to_str").$to_s();
      to = $$($nesting, 'Opal').$coerce_to(to, $$($nesting, 'String'), "to_str").$to_s();
      
      if (from.length == 0 || from === to) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_to == null) {
              last_to = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_to.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_to = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }

      var new_str = ''
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch];
        if (inverse) {
          new_str += (sub == null ? global_sub : ch);
        }
        else {
          new_str += (sub != null ? sub : ch);
        }
      }
      return self.$$cast(new_str);
    ;
    }, $String_tr$69.$$arity = 2);
    
    Opal.def(self, '$tr_s', $String_tr_s$70 = function $$tr_s(from, to) {
      var self = this;

      
      from = $$($nesting, 'Opal').$coerce_to(from, $$($nesting, 'String'), "to_str").$to_s();
      to = $$($nesting, 'Opal').$coerce_to(to, $$($nesting, 'String'), "to_str").$to_s();
      
      if (from.length == 0) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_from == null) {
              last_from = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_from.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_from = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }
      var new_str = ''
      var last_substitute = null
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch]
        if (inverse) {
          if (sub == null) {
            if (last_substitute == null) {
              new_str += global_sub;
              last_substitute = true;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
        else {
          if (sub != null) {
            if (last_substitute == null || last_substitute !== sub) {
              new_str += sub;
              last_substitute = sub;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
      }
      return self.$$cast(new_str);
    ;
    }, $String_tr_s$70.$$arity = 2);
    
    Opal.def(self, '$upcase', $String_upcase$71 = function $$upcase() {
      var self = this;

      return self.$$cast(self.toUpperCase());
    }, $String_upcase$71.$$arity = 0);
    
    Opal.def(self, '$upto', $String_upto$72 = function $$upto(stop, excl) {
      var $iter = $String_upto$72.$$p, block = $iter || nil, self = this;

      if ($iter) $String_upto$72.$$p = null;
      
      
      if ($iter) $String_upto$72.$$p = null;;
      
      if (excl == null) {
        excl = false;
      };
      if ((block !== nil)) {
      } else {
        return self.$enum_for("upto", stop, excl)
      };
      stop = $$($nesting, 'Opal').$coerce_to(stop, $$($nesting, 'String'), "to_str");
      
      var a, b, s = self.toString();

      if (s.length === 1 && stop.length === 1) {

        a = s.charCodeAt(0);
        b = stop.charCodeAt(0);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(String.fromCharCode(a));

          a += 1;
        }

      } else if (parseInt(s, 10).toString() === s && parseInt(stop, 10).toString() === stop) {

        a = parseInt(s, 10);
        b = parseInt(stop, 10);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(a.toString());

          a += 1;
        }

      } else {

        while (s.length <= stop.length && s <= stop) {
          if (excl && s === stop) {
            break;
          }

          block(s);

          s = (s).$succ();
        }

      }
      return self;
    ;
    }, $String_upto$72.$$arity = -2);
    
    function char_class_from_char_sets(sets) {
      function explode_sequences_in_character_set(set) {
        var result = '',
            i, len = set.length,
            curr_char,
            skip_next_dash,
            char_code_from,
            char_code_upto,
            char_code;
        for (i = 0; i < len; i++) {
          curr_char = set.charAt(i);
          if (curr_char === '-' && i > 0 && i < (len - 1) && !skip_next_dash) {
            char_code_from = set.charCodeAt(i - 1);
            char_code_upto = set.charCodeAt(i + 1);
            if (char_code_from > char_code_upto) {
              self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (char_code_from) + "-" + (char_code_upto) + "\" in string transliteration")
            }
            for (char_code = char_code_from + 1; char_code < char_code_upto + 1; char_code++) {
              result += String.fromCharCode(char_code);
            }
            skip_next_dash = true;
            i++;
          } else {
            skip_next_dash = (curr_char === '\\');
            result += curr_char;
          }
        }
        return result;
      }

      function intersection(setA, setB) {
        if (setA.length === 0) {
          return setB;
        }
        var result = '',
            i, len = setA.length,
            chr;
        for (i = 0; i < len; i++) {
          chr = setA.charAt(i);
          if (setB.indexOf(chr) !== -1) {
            result += chr;
          }
        }
        return result;
      }

      var i, len, set, neg, chr, tmp,
          pos_intersection = '',
          neg_intersection = '';

      for (i = 0, len = sets.length; i < len; i++) {
        set = $$($nesting, 'Opal').$coerce_to(sets[i], $$($nesting, 'String'), "to_str");
        neg = (set.charAt(0) === '^' && set.length > 1);
        set = explode_sequences_in_character_set(neg ? set.slice(1) : set);
        if (neg) {
          neg_intersection = intersection(neg_intersection, set);
        } else {
          pos_intersection = intersection(pos_intersection, set);
        }
      }

      if (pos_intersection.length > 0 && neg_intersection.length > 0) {
        tmp = '';
        for (i = 0, len = pos_intersection.length; i < len; i++) {
          chr = pos_intersection.charAt(i);
          if (neg_intersection.indexOf(chr) === -1) {
            tmp += chr;
          }
        }
        pos_intersection = tmp;
        neg_intersection = '';
      }

      if (pos_intersection.length > 0) {
        return '[' + $$($nesting, 'Regexp').$escape(pos_intersection) + ']';
      }

      if (neg_intersection.length > 0) {
        return '[^' + $$($nesting, 'Regexp').$escape(neg_intersection) + ']';
      }

      return null;
    }
  ;
    
    Opal.def(self, '$instance_variables', $String_instance_variables$73 = function $$instance_variables() {
      var self = this;

      return []
    }, $String_instance_variables$73.$$arity = 0);
    Opal.defs(self, '$_load', $String__load$74 = function $$_load($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send(self, 'new', Opal.to_a(args));
    }, $String__load$74.$$arity = -1);
    
    Opal.def(self, '$unicode_normalize', $String_unicode_normalize$75 = function $$unicode_normalize(form) {
      var self = this;

      
      ;
      return self.toString();;
    }, $String_unicode_normalize$75.$$arity = -1);
    
    Opal.def(self, '$unicode_normalized?', $String_unicode_normalized$ques$76 = function(form) {
      var self = this;

      
      ;
      return true;
    }, $String_unicode_normalized$ques$76.$$arity = -1);
    
    Opal.def(self, '$unpack', $String_unpack$77 = function $$unpack(format) {
      var self = this;

      return self.$raise("To use String#unpack, you must first require 'corelib/string/unpack'.")
    }, $String_unpack$77.$$arity = 1);
    return (Opal.def(self, '$unpack1', $String_unpack1$78 = function $$unpack1(format) {
      var self = this;

      return self.$raise("To use String#unpack1, you must first require 'corelib/string/unpack'.")
    }, $String_unpack1$78.$$arity = 1), nil) && 'unpack1';
  })($nesting[0], String, $nesting);
  return Opal.const_set($nesting[0], 'Symbol', $$($nesting, 'String'));
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/enumerable"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send, $falsy = Opal.falsy, $hash2 = Opal.hash2, $lambda = Opal.lambda;

  Opal.add_stubs(['$each', '$public_send', '$destructure', '$to_enum', '$enumerator_size', '$new', '$yield', '$raise', '$slice_when', '$!', '$enum_for', '$flatten', '$map', '$warn', '$proc', '$==', '$nil?', '$respond_to?', '$coerce_to!', '$>', '$*', '$coerce_to', '$try_convert', '$<', '$+', '$-', '$ceil', '$/', '$size', '$__send__', '$length', '$<=', '$[]', '$push', '$<<', '$[]=', '$===', '$inspect', '$<=>', '$first', '$reverse', '$sort', '$to_proc', '$compare', '$call', '$dup', '$to_a', '$sort!', '$map!', '$key?', '$values', '$zip']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Enumerable');

    var $nesting = [self].concat($parent_nesting), $Enumerable_all$ques$1, $Enumerable_any$ques$5, $Enumerable_chunk$9, $Enumerable_chunk_while$12, $Enumerable_collect$14, $Enumerable_collect_concat$16, $Enumerable_count$19, $Enumerable_cycle$23, $Enumerable_detect$25, $Enumerable_drop$27, $Enumerable_drop_while$28, $Enumerable_each_cons$29, $Enumerable_each_entry$31, $Enumerable_each_slice$33, $Enumerable_each_with_index$35, $Enumerable_each_with_object$37, $Enumerable_entries$39, $Enumerable_find_all$40, $Enumerable_find_index$42, $Enumerable_first$45, $Enumerable_grep$48, $Enumerable_grep_v$50, $Enumerable_group_by$52, $Enumerable_include$ques$54, $Enumerable_inject$56, $Enumerable_lazy$57, $Enumerable_enumerator_size$59, $Enumerable_max$60, $Enumerable_max_by$61, $Enumerable_min$63, $Enumerable_min_by$64, $Enumerable_minmax$66, $Enumerable_minmax_by$68, $Enumerable_none$ques$69, $Enumerable_one$ques$73, $Enumerable_partition$77, $Enumerable_reject$79, $Enumerable_reverse_each$81, $Enumerable_slice_before$83, $Enumerable_slice_after$85, $Enumerable_slice_when$88, $Enumerable_sort$90, $Enumerable_sort_by$92, $Enumerable_sum$97, $Enumerable_take$99, $Enumerable_take_while$100, $Enumerable_uniq$102, $Enumerable_zip$104;

    
    
    function comparableForPattern(value) {
      if (value.length === 0) {
        value = [nil];
      }

      if (value.length > 1) {
        value = [value];
      }

      return value;
    }
  ;
    
    Opal.def(self, '$all?', $Enumerable_all$ques$1 = function(pattern) {try {

      var $iter = $Enumerable_all$ques$1.$$p, block = $iter || nil, $$2, $$3, $$4, self = this;

      if ($iter) $Enumerable_all$ques$1.$$p = null;
      
      
      if ($iter) $Enumerable_all$ques$1.$$p = null;;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$2 = function($a){var self = $$2.$$s || this, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            return nil
          } else {
            Opal.ret(false)
          };}, $$2.$$s = self, $$2.$$arity = -1, $$2))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$3 = function($a){var self = $$3.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            return nil
          } else {
            Opal.ret(false)
          };}, $$3.$$s = self, $$3.$$arity = -1, $$3))
      } else {
        $send(self, 'each', [], ($$4 = function($a){var self = $$4.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy($$($nesting, 'Opal').$destructure(value))) {
            return nil
          } else {
            Opal.ret(false)
          };}, $$4.$$s = self, $$4.$$arity = -1, $$4))
      };
      return true;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_all$ques$1.$$arity = -1);
    
    Opal.def(self, '$any?', $Enumerable_any$ques$5 = function(pattern) {try {

      var $iter = $Enumerable_any$ques$5.$$p, block = $iter || nil, $$6, $$7, $$8, self = this;

      if ($iter) $Enumerable_any$ques$5.$$p = null;
      
      
      if ($iter) $Enumerable_any$ques$5.$$p = null;;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$6 = function($a){var self = $$6.$$s || this, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            Opal.ret(true)
          } else {
            return nil
          };}, $$6.$$s = self, $$6.$$arity = -1, $$6))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$7 = function($a){var self = $$7.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(true)
          } else {
            return nil
          };}, $$7.$$s = self, $$7.$$arity = -1, $$7))
      } else {
        $send(self, 'each', [], ($$8 = function($a){var self = $$8.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy($$($nesting, 'Opal').$destructure(value))) {
            Opal.ret(true)
          } else {
            return nil
          };}, $$8.$$s = self, $$8.$$arity = -1, $$8))
      };
      return false;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_any$ques$5.$$arity = -1);
    
    Opal.def(self, '$chunk', $Enumerable_chunk$9 = function $$chunk() {
      var $iter = $Enumerable_chunk$9.$$p, block = $iter || nil, $$10, $$11, self = this;

      if ($iter) $Enumerable_chunk$9.$$p = null;
      
      
      if ($iter) $Enumerable_chunk$9.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'to_enum', ["chunk"], ($$10 = function(){var self = $$10.$$s || this;

        return self.$enumerator_size()}, $$10.$$s = self, $$10.$$arity = 0, $$10))
      };
      return $send($$$('::', 'Enumerator'), 'new', [], ($$11 = function(yielder){var self = $$11.$$s || this;

      
        
        if (yielder == null) {
          yielder = nil;
        };
        
        var previous = nil, accumulate = [];

        function releaseAccumulate() {
          if (accumulate.length > 0) {
            yielder.$yield(previous, accumulate)
          }
        }

        self.$each.$$p = function(value) {
          var key = Opal.yield1(block, value);

          if (key === nil) {
            releaseAccumulate();
            accumulate = [];
            previous = nil;
          } else {
            if (previous === nil || previous === key) {
              accumulate.push(value);
            } else {
              releaseAccumulate();
              accumulate = [value];
            }

            previous = key;
          }
        }

        self.$each();

        releaseAccumulate();
      ;}, $$11.$$s = self, $$11.$$arity = 1, $$11));
    }, $Enumerable_chunk$9.$$arity = 0);
    
    Opal.def(self, '$chunk_while', $Enumerable_chunk_while$12 = function $$chunk_while() {
      var $iter = $Enumerable_chunk_while$12.$$p, block = $iter || nil, $$13, self = this;

      if ($iter) $Enumerable_chunk_while$12.$$p = null;
      
      
      if ($iter) $Enumerable_chunk_while$12.$$p = null;;
      if ((block !== nil)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "no block given")
      };
      return $send(self, 'slice_when', [], ($$13 = function(before, after){var self = $$13.$$s || this;

      
        
        if (before == null) {
          before = nil;
        };
        
        if (after == null) {
          after = nil;
        };
        return Opal.yieldX(block, [before, after])['$!']();}, $$13.$$s = self, $$13.$$arity = 2, $$13));
    }, $Enumerable_chunk_while$12.$$arity = 0);
    
    Opal.def(self, '$collect', $Enumerable_collect$14 = function $$collect() {
      var $iter = $Enumerable_collect$14.$$p, block = $iter || nil, $$15, self = this;

      if ($iter) $Enumerable_collect$14.$$p = null;
      
      
      if ($iter) $Enumerable_collect$14.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect"], ($$15 = function(){var self = $$15.$$s || this;

        return self.$enumerator_size()}, $$15.$$s = self, $$15.$$arity = 0, $$15))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var value = Opal.yieldX(block, arguments);

        result.push(value);
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_collect$14.$$arity = 0);
    
    Opal.def(self, '$collect_concat', $Enumerable_collect_concat$16 = function $$collect_concat() {
      var $iter = $Enumerable_collect_concat$16.$$p, block = $iter || nil, $$17, $$18, self = this;

      if ($iter) $Enumerable_collect_concat$16.$$p = null;
      
      
      if ($iter) $Enumerable_collect_concat$16.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect_concat"], ($$17 = function(){var self = $$17.$$s || this;

        return self.$enumerator_size()}, $$17.$$s = self, $$17.$$arity = 0, $$17))
      };
      return $send(self, 'map', [], ($$18 = function(item){var self = $$18.$$s || this;

      
        
        if (item == null) {
          item = nil;
        };
        return Opal.yield1(block, item);;}, $$18.$$s = self, $$18.$$arity = 1, $$18)).$flatten(1);
    }, $Enumerable_collect_concat$16.$$arity = 0);
    
    Opal.def(self, '$count', $Enumerable_count$19 = function $$count(object) {
      var $iter = $Enumerable_count$19.$$p, block = $iter || nil, $$20, $$21, $$22, self = this, result = nil;

      if ($iter) $Enumerable_count$19.$$p = null;
      
      
      if ($iter) $Enumerable_count$19.$$p = null;;
      ;
      result = 0;
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      if ($truthy(object != null)) {
        block = $send(self, 'proc', [], ($$20 = function($a){var self = $$20.$$s || this, $post_args, args;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $$($nesting, 'Opal').$destructure(args)['$=='](object);}, $$20.$$s = self, $$20.$$arity = -1, $$20))
      } else if ($truthy(block['$nil?']())) {
        block = $send(self, 'proc', [], ($$21 = function(){var self = $$21.$$s || this;

        return true}, $$21.$$s = self, $$21.$$arity = 0, $$21))};
      $send(self, 'each', [], ($$22 = function($a){var self = $$22.$$s || this, $post_args, args;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        if ($truthy(Opal.yieldX(block, args))) {
          return result++;
        } else {
          return nil
        };}, $$22.$$s = self, $$22.$$arity = -1, $$22));
      return result;
    }, $Enumerable_count$19.$$arity = -1);
    
    Opal.def(self, '$cycle', $Enumerable_cycle$23 = function $$cycle(n) {
      var $iter = $Enumerable_cycle$23.$$p, block = $iter || nil, $$24, self = this;

      if ($iter) $Enumerable_cycle$23.$$p = null;
      
      
      if ($iter) $Enumerable_cycle$23.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["cycle", n], ($$24 = function(){var self = $$24.$$s || this;

        if ($truthy(n['$nil?']())) {
            if ($truthy(self['$respond_to?']("size"))) {
              return $$$($$($nesting, 'Float'), 'INFINITY')
            } else {
              return nil
            }
          } else {
            
            n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, $$24.$$s = self, $$24.$$arity = 0, $$24))
      };
      if ($truthy(n['$nil?']())) {
      } else {
        
        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
        if ($truthy(n <= 0)) {
          return nil};
      };
      
      var result,
          all = [], i, length, value;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        all.push(param);
      }

      self.$each();

      if (result !== undefined) {
        return result;
      }

      if (all.length === 0) {
        return nil;
      }

      if (n === nil) {
        while (true) {
          for (i = 0, length = all.length; i < length; i++) {
            value = Opal.yield1(block, all[i]);
          }
        }
      }
      else {
        while (n > 1) {
          for (i = 0, length = all.length; i < length; i++) {
            value = Opal.yield1(block, all[i]);
          }

          n--;
        }
      }
    ;
    }, $Enumerable_cycle$23.$$arity = -1);
    
    Opal.def(self, '$detect', $Enumerable_detect$25 = function $$detect(ifnone) {try {

      var $iter = $Enumerable_detect$25.$$p, block = $iter || nil, $$26, self = this;

      if ($iter) $Enumerable_detect$25.$$p = null;
      
      
      if ($iter) $Enumerable_detect$25.$$p = null;;
      ;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("detect", ifnone)
      };
      $send(self, 'each', [], ($$26 = function($a){var self = $$26.$$s || this, $post_args, args, value = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        value = $$($nesting, 'Opal').$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
          Opal.ret(value)
        } else {
          return nil
        };}, $$26.$$s = self, $$26.$$arity = -1, $$26));
      
      if (ifnone !== undefined) {
        if (typeof(ifnone) === 'function') {
          return ifnone();
        } else {
          return ifnone;
        }
      }
    ;
      return nil;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_detect$25.$$arity = -1);
    
    Opal.def(self, '$drop', $Enumerable_drop$27 = function $$drop(number) {
      var self = this;

      
      number = $$($nesting, 'Opal').$coerce_to(number, $$($nesting, 'Integer'), "to_int");
      if ($truthy(number < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "attempt to drop negative size")};
      
      var result  = [],
          current = 0;

      self.$each.$$p = function() {
        if (number <= current) {
          result.push($$($nesting, 'Opal').$destructure(arguments));
        }

        current++;
      };

      self.$each()

      return result;
    ;
    }, $Enumerable_drop$27.$$arity = 1);
    
    Opal.def(self, '$drop_while', $Enumerable_drop_while$28 = function $$drop_while() {
      var $iter = $Enumerable_drop_while$28.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_drop_while$28.$$p = null;
      
      
      if ($iter) $Enumerable_drop_while$28.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("drop_while")
      };
      
      var result   = [],
          dropping = true;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        if (dropping) {
          var value = Opal.yield1(block, param);

          if ($falsy(value)) {
            dropping = false;
            result.push(param);
          }
        }
        else {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_drop_while$28.$$arity = 0);
    
    Opal.def(self, '$each_cons', $Enumerable_each_cons$29 = function $$each_cons(n) {
      var $iter = $Enumerable_each_cons$29.$$p, block = $iter || nil, $$30, self = this;

      if ($iter) $Enumerable_each_cons$29.$$p = null;
      
      
      if ($iter) $Enumerable_each_cons$29.$$p = null;;
      if ($truthy(arguments.length != 1)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 1)")};
      n = $$($nesting, 'Opal').$try_convert(n, $$($nesting, 'Integer'), "to_int");
      if ($truthy(n <= 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "invalid size")};
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_cons", n], ($$30 = function(){var self = $$30.$$s || this, $a, enum_size = nil;

        
          enum_size = self.$enumerator_size();
          if ($truthy(enum_size['$nil?']())) {
            return nil
          } else if ($truthy(($truthy($a = enum_size['$=='](0)) ? $a : $rb_lt(enum_size, n)))) {
            return 0
          } else {
            return $rb_plus($rb_minus(enum_size, n), 1)
          };}, $$30.$$s = self, $$30.$$arity = 0, $$30))
      };
      
      var buffer = [], result = nil;

      self.$each.$$p = function() {
        var element = $$($nesting, 'Opal').$destructure(arguments);
        buffer.push(element);
        if (buffer.length > n) {
          buffer.shift();
        }
        if (buffer.length == n) {
          Opal.yield1(block, buffer.slice(0, n));
        }
      }

      self.$each();

      return result;
    ;
    }, $Enumerable_each_cons$29.$$arity = 1);
    
    Opal.def(self, '$each_entry', $Enumerable_each_entry$31 = function $$each_entry($a) {
      var $iter = $Enumerable_each_entry$31.$$p, block = $iter || nil, $post_args, data, $$32, self = this;

      if ($iter) $Enumerable_each_entry$31.$$p = null;
      
      
      if ($iter) $Enumerable_each_entry$31.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      data = $post_args;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'to_enum', ["each_entry"].concat(Opal.to_a(data)), ($$32 = function(){var self = $$32.$$s || this;

        return self.$enumerator_size()}, $$32.$$s = self, $$32.$$arity = 0, $$32))
      };
      
      self.$each.$$p = function() {
        var item = $$($nesting, 'Opal').$destructure(arguments);

        Opal.yield1(block, item);
      }

      self.$each.apply(self, data);

      return self;
    ;
    }, $Enumerable_each_entry$31.$$arity = -1);
    
    Opal.def(self, '$each_slice', $Enumerable_each_slice$33 = function $$each_slice(n) {
      var $iter = $Enumerable_each_slice$33.$$p, block = $iter || nil, $$34, self = this;

      if ($iter) $Enumerable_each_slice$33.$$p = null;
      
      
      if ($iter) $Enumerable_each_slice$33.$$p = null;;
      n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), "to_int");
      if ($truthy(n <= 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "invalid slice size")};
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_slice", n], ($$34 = function(){var self = $$34.$$s || this;

        if ($truthy(self['$respond_to?']("size"))) {
            return $rb_divide(self.$size(), n).$ceil()
          } else {
            return nil
          }}, $$34.$$s = self, $$34.$$arity = 0, $$34))
      };
      
      var result,
          slice = []

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        slice.push(param);

        if (slice.length === n) {
          Opal.yield1(block, slice);
          slice = [];
        }
      };

      self.$each();

      if (result !== undefined) {
        return result;
      }

      // our "last" group, if smaller than n then won't have been yielded
      if (slice.length > 0) {
        Opal.yield1(block, slice);
      }
    ;
      return nil;
    }, $Enumerable_each_slice$33.$$arity = 1);
    
    Opal.def(self, '$each_with_index', $Enumerable_each_with_index$35 = function $$each_with_index($a) {
      var $iter = $Enumerable_each_with_index$35.$$p, block = $iter || nil, $post_args, args, $$36, self = this;

      if ($iter) $Enumerable_each_with_index$35.$$p = null;
      
      
      if ($iter) $Enumerable_each_with_index$35.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_with_index"].concat(Opal.to_a(args)), ($$36 = function(){var self = $$36.$$s || this;

        return self.$enumerator_size()}, $$36.$$s = self, $$36.$$arity = 0, $$36))
      };
      
      var result,
          index = 0;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        block(param, index);

        index++;
      };

      self.$each.apply(self, args);

      if (result !== undefined) {
        return result;
      }
    ;
      return self;
    }, $Enumerable_each_with_index$35.$$arity = -1);
    
    Opal.def(self, '$each_with_object', $Enumerable_each_with_object$37 = function $$each_with_object(object) {
      var $iter = $Enumerable_each_with_object$37.$$p, block = $iter || nil, $$38, self = this;

      if ($iter) $Enumerable_each_with_object$37.$$p = null;
      
      
      if ($iter) $Enumerable_each_with_object$37.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_with_object", object], ($$38 = function(){var self = $$38.$$s || this;

        return self.$enumerator_size()}, $$38.$$s = self, $$38.$$arity = 0, $$38))
      };
      
      var result;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        block(param, object);
      };

      self.$each();

      if (result !== undefined) {
        return result;
      }
    ;
      return object;
    }, $Enumerable_each_with_object$37.$$arity = 1);
    
    Opal.def(self, '$entries', $Enumerable_entries$39 = function $$entries($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var result = [];

      self.$each.$$p = function() {
        result.push($$($nesting, 'Opal').$destructure(arguments));
      };

      self.$each.apply(self, args);

      return result;
    ;
    }, $Enumerable_entries$39.$$arity = -1);
    Opal.alias(self, "find", "detect");
    
    Opal.def(self, '$find_all', $Enumerable_find_all$40 = function $$find_all() {
      var $iter = $Enumerable_find_all$40.$$p, block = $iter || nil, $$41, self = this;

      if ($iter) $Enumerable_find_all$40.$$p = null;
      
      
      if ($iter) $Enumerable_find_all$40.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["find_all"], ($$41 = function(){var self = $$41.$$s || this;

        return self.$enumerator_size()}, $$41.$$s = self, $$41.$$arity = 0, $$41))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($truthy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_find_all$40.$$arity = 0);
    
    Opal.def(self, '$find_index', $Enumerable_find_index$42 = function $$find_index(object) {try {

      var $iter = $Enumerable_find_index$42.$$p, block = $iter || nil, $$43, $$44, self = this, index = nil;

      if ($iter) $Enumerable_find_index$42.$$p = null;
      
      
      if ($iter) $Enumerable_find_index$42.$$p = null;;
      ;
      if ($truthy(object === undefined && block === nil)) {
        return self.$enum_for("find_index")};
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      index = 0;
      if ($truthy(object != null)) {
        $send(self, 'each', [], ($$43 = function($a){var self = $$43.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($$($nesting, 'Opal').$destructure(value)['$=='](object)) {
            Opal.ret(index)};
          return index += 1;;}, $$43.$$s = self, $$43.$$arity = -1, $$43))
      } else {
        $send(self, 'each', [], ($$44 = function($a){var self = $$44.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(index)};
          return index += 1;;}, $$44.$$s = self, $$44.$$arity = -1, $$44))
      };
      return nil;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_find_index$42.$$arity = -1);
    
    Opal.def(self, '$first', $Enumerable_first$45 = function $$first(number) {try {

      var $$46, $$47, self = this, result = nil, current = nil;

      
      ;
      if ($truthy(number === undefined)) {
        return $send(self, 'each', [], ($$46 = function(value){var self = $$46.$$s || this;

        
          
          if (value == null) {
            value = nil;
          };
          Opal.ret(value);}, $$46.$$s = self, $$46.$$arity = 1, $$46))
      } else {
        
        result = [];
        number = $$($nesting, 'Opal').$coerce_to(number, $$($nesting, 'Integer'), "to_int");
        if ($truthy(number < 0)) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to take negative size")};
        if ($truthy(number == 0)) {
          return []};
        current = 0;
        $send(self, 'each', [], ($$47 = function($a){var self = $$47.$$s || this, $post_args, args;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          result.push($$($nesting, 'Opal').$destructure(args));
          if ($truthy(number <= ++current)) {
            Opal.ret(result)
          } else {
            return nil
          };}, $$47.$$s = self, $$47.$$arity = -1, $$47));
        return result;
      };
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_first$45.$$arity = -1);
    Opal.alias(self, "flat_map", "collect_concat");
    
    Opal.def(self, '$grep', $Enumerable_grep$48 = function $$grep(pattern) {
      var $iter = $Enumerable_grep$48.$$p, block = $iter || nil, $$49, self = this, result = nil;

      if ($iter) $Enumerable_grep$48.$$p = null;
      
      
      if ($iter) $Enumerable_grep$48.$$p = null;;
      result = [];
      $send(self, 'each', [], ($$49 = function($a){var self = $$49.$$s || this, $post_args, value, cmp = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        value = $post_args;;
        cmp = comparableForPattern(value);
        if ($truthy($send(pattern, '__send__', ["==="].concat(Opal.to_a(cmp))))) {
        } else {
          return nil;
        };
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]};
          value = Opal.yieldX(block, Opal.to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)};
        return result.$push(value);}, $$49.$$s = self, $$49.$$arity = -1, $$49));
      return result;
    }, $Enumerable_grep$48.$$arity = 1);
    
    Opal.def(self, '$grep_v', $Enumerable_grep_v$50 = function $$grep_v(pattern) {
      var $iter = $Enumerable_grep_v$50.$$p, block = $iter || nil, $$51, self = this, result = nil;

      if ($iter) $Enumerable_grep_v$50.$$p = null;
      
      
      if ($iter) $Enumerable_grep_v$50.$$p = null;;
      result = [];
      $send(self, 'each', [], ($$51 = function($a){var self = $$51.$$s || this, $post_args, value, cmp = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        value = $post_args;;
        cmp = comparableForPattern(value);
        if ($truthy($send(pattern, '__send__', ["==="].concat(Opal.to_a(cmp))))) {
          return nil;};
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]};
          value = Opal.yieldX(block, Opal.to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)};
        return result.$push(value);}, $$51.$$s = self, $$51.$$arity = -1, $$51));
      return result;
    }, $Enumerable_grep_v$50.$$arity = 1);
    
    Opal.def(self, '$group_by', $Enumerable_group_by$52 = function $$group_by() {
      var $iter = $Enumerable_group_by$52.$$p, block = $iter || nil, $$53, $a, self = this, hash = nil, $writer = nil;

      if ($iter) $Enumerable_group_by$52.$$p = null;
      
      
      if ($iter) $Enumerable_group_by$52.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["group_by"], ($$53 = function(){var self = $$53.$$s || this;

        return self.$enumerator_size()}, $$53.$$s = self, $$53.$$arity = 0, $$53))
      };
      hash = $hash2([], {});
      
      var result;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        ($truthy($a = hash['$[]'](value)) ? $a : (($writer = [value, []]), $send(hash, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))['$<<'](param);
      }

      self.$each();

      if (result !== undefined) {
        return result;
      }
    ;
      return hash;
    }, $Enumerable_group_by$52.$$arity = 0);
    
    Opal.def(self, '$include?', $Enumerable_include$ques$54 = function(obj) {try {

      var $$55, self = this;

      
      $send(self, 'each', [], ($$55 = function($a){var self = $$55.$$s || this, $post_args, args;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        if ($$($nesting, 'Opal').$destructure(args)['$=='](obj)) {
          Opal.ret(true)
        } else {
          return nil
        };}, $$55.$$s = self, $$55.$$arity = -1, $$55));
      return false;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_include$ques$54.$$arity = 1);
    
    Opal.def(self, '$inject', $Enumerable_inject$56 = function $$inject(object, sym) {
      var $iter = $Enumerable_inject$56.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_inject$56.$$p = null;
      
      
      if ($iter) $Enumerable_inject$56.$$p = null;;
      ;
      ;
      
      var result = object;

      if (block !== nil && sym === undefined) {
        self.$each.$$p = function() {
          var value = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          value = Opal.yieldX(block, [result, value]);

          result = value;
        };
      }
      else {
        if (sym === undefined) {
          if (!$$($nesting, 'Symbol')['$==='](object)) {
            self.$raise($$($nesting, 'TypeError'), "" + (object.$inspect()) + " is not a Symbol");
          }

          sym    = object;
          result = undefined;
        }

        self.$each.$$p = function() {
          var value = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          result = (result).$__send__(sym, value);
        };
      }

      self.$each();

      return result == undefined ? nil : result;
    ;
    }, $Enumerable_inject$56.$$arity = -1);
    
    Opal.def(self, '$lazy', $Enumerable_lazy$57 = function $$lazy() {
      var $$58, self = this;

      return $send($$$($$($nesting, 'Enumerator'), 'Lazy'), 'new', [self, self.$enumerator_size()], ($$58 = function(enum$, $a){var self = $$58.$$s || this, $post_args, args;

      
        
        if (enum$ == null) {
          enum$ = nil;
        };
        
        $post_args = Opal.slice.call(arguments, 1, arguments.length);
        
        args = $post_args;;
        return $send(enum$, 'yield', Opal.to_a(args));}, $$58.$$s = self, $$58.$$arity = -2, $$58))
    }, $Enumerable_lazy$57.$$arity = 0);
    
    Opal.def(self, '$enumerator_size', $Enumerable_enumerator_size$59 = function $$enumerator_size() {
      var self = this;

      if ($truthy(self['$respond_to?']("size"))) {
        return self.$size()
      } else {
        return nil
      }
    }, $Enumerable_enumerator_size$59.$$arity = 0);
    Opal.alias(self, "map", "collect");
    
    Opal.def(self, '$max', $Enumerable_max$60 = function $$max(n) {
      var $iter = $Enumerable_max$60.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_max$60.$$p = null;
      
      
      if ($iter) $Enumerable_max$60.$$p = null;;
      ;
      
      if (n === undefined || n === nil) {
        var result, value;

        self.$each.$$p = function() {
          var item = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = item;
            return;
          }

          if (block !== nil) {
            value = Opal.yieldX(block, [item, result]);
          } else {
            value = (item)['$<=>'](result);
          }

          if (value === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed");
          }

          if (value > 0) {
            result = item;
          }
        }

        self.$each();

        if (result === undefined) {
          return nil;
        } else {
          return result;
        }
      }
    ;
      n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), "to_int");
      return $send(self, 'sort', [], block.$to_proc()).$reverse().$first(n);
    }, $Enumerable_max$60.$$arity = -1);
    
    Opal.def(self, '$max_by', $Enumerable_max_by$61 = function $$max_by() {
      var $iter = $Enumerable_max_by$61.$$p, block = $iter || nil, $$62, self = this;

      if ($iter) $Enumerable_max_by$61.$$p = null;
      
      
      if ($iter) $Enumerable_max_by$61.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["max_by"], ($$62 = function(){var self = $$62.$$s || this;

        return self.$enumerator_size()}, $$62.$$s = self, $$62.$$arity = 0, $$62))
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) > 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, $Enumerable_max_by$61.$$arity = 0);
    Opal.alias(self, "member?", "include?");
    
    Opal.def(self, '$min', $Enumerable_min$63 = function $$min() {
      var $iter = $Enumerable_min$63.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_min$63.$$p = null;
      
      
      if ($iter) $Enumerable_min$63.$$p = null;;
      
      var result;

      if (block !== nil) {
        self.$each.$$p = function() {
          var param = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          var value = block(param, result);

          if (value === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed");
          }

          if (value < 0) {
            result = param;
          }
        };
      }
      else {
        self.$each.$$p = function() {
          var param = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          if ($$($nesting, 'Opal').$compare(param, result) < 0) {
            result = param;
          }
        };
      }

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, $Enumerable_min$63.$$arity = 0);
    
    Opal.def(self, '$min_by', $Enumerable_min_by$64 = function $$min_by() {
      var $iter = $Enumerable_min_by$64.$$p, block = $iter || nil, $$65, self = this;

      if ($iter) $Enumerable_min_by$64.$$p = null;
      
      
      if ($iter) $Enumerable_min_by$64.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["min_by"], ($$65 = function(){var self = $$65.$$s || this;

        return self.$enumerator_size()}, $$65.$$s = self, $$65.$$arity = 0, $$65))
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) < 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, $Enumerable_min_by$64.$$arity = 0);
    
    Opal.def(self, '$minmax', $Enumerable_minmax$66 = function $$minmax() {
      var $iter = $Enumerable_minmax$66.$$p, block = $iter || nil, $a, $$67, self = this;

      if ($iter) $Enumerable_minmax$66.$$p = null;
      
      
      if ($iter) $Enumerable_minmax$66.$$p = null;;
      block = ($truthy($a = block) ? $a : $send(self, 'proc', [], ($$67 = function(a, b){var self = $$67.$$s || this;

      
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return a['$<=>'](b);}, $$67.$$s = self, $$67.$$arity = 2, $$67)));
      
      var min = nil, max = nil, first_time = true;

      self.$each.$$p = function() {
        var element = $$($nesting, 'Opal').$destructure(arguments);
        if (first_time) {
          min = max = element;
          first_time = false;
        } else {
          var min_cmp = block.$call(min, element);

          if (min_cmp === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed")
          } else if (min_cmp > 0) {
            min = element;
          }

          var max_cmp = block.$call(max, element);

          if (max_cmp === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed")
          } else if (max_cmp < 0) {
            max = element;
          }
        }
      }

      self.$each();

      return [min, max];
    ;
    }, $Enumerable_minmax$66.$$arity = 0);
    
    Opal.def(self, '$minmax_by', $Enumerable_minmax_by$68 = function $$minmax_by() {
      var $iter = $Enumerable_minmax_by$68.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_minmax_by$68.$$p = null;
      
      
      if ($iter) $Enumerable_minmax_by$68.$$p = null;;
      return self.$raise($$($nesting, 'NotImplementedError'));
    }, $Enumerable_minmax_by$68.$$arity = 0);
    
    Opal.def(self, '$none?', $Enumerable_none$ques$69 = function(pattern) {try {

      var $iter = $Enumerable_none$ques$69.$$p, block = $iter || nil, $$70, $$71, $$72, self = this;

      if ($iter) $Enumerable_none$ques$69.$$p = null;
      
      
      if ($iter) $Enumerable_none$ques$69.$$p = null;;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$70 = function($a){var self = $$70.$$s || this, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$70.$$s = self, $$70.$$arity = -1, $$70))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$71 = function($a){var self = $$71.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$71.$$s = self, $$71.$$arity = -1, $$71))
      } else {
        $send(self, 'each', [], ($$72 = function($a){var self = $$72.$$s || this, $post_args, value, item = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          item = $$($nesting, 'Opal').$destructure(value);
          if ($truthy(item)) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$72.$$s = self, $$72.$$arity = -1, $$72))
      };
      return true;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_none$ques$69.$$arity = -1);
    
    Opal.def(self, '$one?', $Enumerable_one$ques$73 = function(pattern) {try {

      var $iter = $Enumerable_one$ques$73.$$p, block = $iter || nil, $$74, $$75, $$76, self = this, count = nil;

      if ($iter) $Enumerable_one$ques$73.$$p = null;
      
      
      if ($iter) $Enumerable_one$ques$73.$$p = null;;
      ;
      count = 0;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$74 = function($a){var self = $$74.$$s || this, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            
            count = $rb_plus(count, 1);
            if ($truthy($rb_gt(count, 1))) {
              Opal.ret(false)
            } else {
              return nil
            };
          } else {
            return nil
          };}, $$74.$$s = self, $$74.$$arity = -1, $$74))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$75 = function($a){var self = $$75.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
          } else {
            return nil;
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$75.$$s = self, $$75.$$arity = -1, $$75))
      } else {
        $send(self, 'each', [], ($$76 = function($a){var self = $$76.$$s || this, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy($$($nesting, 'Opal').$destructure(value))) {
          } else {
            return nil;
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$76.$$s = self, $$76.$$arity = -1, $$76))
      };
      return count['$=='](1);
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_one$ques$73.$$arity = -1);
    
    Opal.def(self, '$partition', $Enumerable_partition$77 = function $$partition() {
      var $iter = $Enumerable_partition$77.$$p, block = $iter || nil, $$78, self = this;

      if ($iter) $Enumerable_partition$77.$$p = null;
      
      
      if ($iter) $Enumerable_partition$77.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["partition"], ($$78 = function(){var self = $$78.$$s || this;

        return self.$enumerator_size()}, $$78.$$s = self, $$78.$$arity = 0, $$78))
      };
      
      var truthy = [], falsy = [], result;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($truthy(value)) {
          truthy.push(param);
        }
        else {
          falsy.push(param);
        }
      };

      self.$each();

      return [truthy, falsy];
    ;
    }, $Enumerable_partition$77.$$arity = 0);
    Opal.alias(self, "reduce", "inject");
    
    Opal.def(self, '$reject', $Enumerable_reject$79 = function $$reject() {
      var $iter = $Enumerable_reject$79.$$p, block = $iter || nil, $$80, self = this;

      if ($iter) $Enumerable_reject$79.$$p = null;
      
      
      if ($iter) $Enumerable_reject$79.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reject"], ($$80 = function(){var self = $$80.$$s || this;

        return self.$enumerator_size()}, $$80.$$s = self, $$80.$$arity = 0, $$80))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($falsy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_reject$79.$$arity = 0);
    
    Opal.def(self, '$reverse_each', $Enumerable_reverse_each$81 = function $$reverse_each() {
      var $iter = $Enumerable_reverse_each$81.$$p, block = $iter || nil, $$82, self = this;

      if ($iter) $Enumerable_reverse_each$81.$$p = null;
      
      
      if ($iter) $Enumerable_reverse_each$81.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reverse_each"], ($$82 = function(){var self = $$82.$$s || this;

        return self.$enumerator_size()}, $$82.$$s = self, $$82.$$arity = 0, $$82))
      };
      
      var result = [];

      self.$each.$$p = function() {
        result.push(arguments);
      };

      self.$each();

      for (var i = result.length - 1; i >= 0; i--) {
        Opal.yieldX(block, result[i]);
      }

      return result;
    ;
    }, $Enumerable_reverse_each$81.$$arity = 0);
    Opal.alias(self, "select", "find_all");
    
    Opal.def(self, '$slice_before', $Enumerable_slice_before$83 = function $$slice_before(pattern) {
      var $iter = $Enumerable_slice_before$83.$$p, block = $iter || nil, $$84, self = this;

      if ($iter) $Enumerable_slice_before$83.$$p = null;
      
      
      if ($iter) $Enumerable_slice_before$83.$$p = null;;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "both pattern and block are given")};
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " expected 1)")};
      return $send($$($nesting, 'Enumerator'), 'new', [], ($$84 = function(e){var self = $$84.$$s || this;

      
        
        if (e == null) {
          e = nil;
        };
        
        var slice = [];

        if (block !== nil) {
          if (pattern === undefined) {
            self.$each.$$p = function() {
              var param = $$($nesting, 'Opal').$destructure(arguments),
                  value = Opal.yield1(block, param);

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
          else {
            self.$each.$$p = function() {
              var param = $$($nesting, 'Opal').$destructure(arguments),
                  value = block(param, pattern.$dup());

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
        }
        else {
          self.$each.$$p = function() {
            var param = $$($nesting, 'Opal').$destructure(arguments),
                value = pattern['$==='](param);

            if ($truthy(value) && slice.length > 0) {
              e['$<<'](slice);
              slice = [];
            }

            slice.push(param);
          };
        }

        self.$each();

        if (slice.length > 0) {
          e['$<<'](slice);
        }
      ;}, $$84.$$s = self, $$84.$$arity = 1, $$84));
    }, $Enumerable_slice_before$83.$$arity = -1);
    
    Opal.def(self, '$slice_after', $Enumerable_slice_after$85 = function $$slice_after(pattern) {
      var $iter = $Enumerable_slice_after$85.$$p, block = $iter || nil, $$86, $$87, self = this;

      if ($iter) $Enumerable_slice_after$85.$$p = null;
      
      
      if ($iter) $Enumerable_slice_after$85.$$p = null;;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "both pattern and block are given")};
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " expected 1)")};
      if ($truthy(pattern !== undefined)) {
        block = $send(self, 'proc', [], ($$86 = function(e){var self = $$86.$$s || this;

        
          
          if (e == null) {
            e = nil;
          };
          return pattern['$==='](e);}, $$86.$$s = self, $$86.$$arity = 1, $$86))};
      return $send($$($nesting, 'Enumerator'), 'new', [], ($$87 = function(yielder){var self = $$87.$$s || this;

      
        
        if (yielder == null) {
          yielder = nil;
        };
        
        var accumulate;

        self.$each.$$p = function() {
          var element = $$($nesting, 'Opal').$destructure(arguments),
              end_chunk = Opal.yield1(block, element);

          if (accumulate == null) {
            accumulate = [];
          }

          if ($truthy(end_chunk)) {
            accumulate.push(element);
            yielder.$yield(accumulate);
            accumulate = null;
          } else {
            accumulate.push(element)
          }
        }

        self.$each();

        if (accumulate != null) {
          yielder.$yield(accumulate);
        }
      ;}, $$87.$$s = self, $$87.$$arity = 1, $$87));
    }, $Enumerable_slice_after$85.$$arity = -1);
    
    Opal.def(self, '$slice_when', $Enumerable_slice_when$88 = function $$slice_when() {
      var $iter = $Enumerable_slice_when$88.$$p, block = $iter || nil, $$89, self = this;

      if ($iter) $Enumerable_slice_when$88.$$p = null;
      
      
      if ($iter) $Enumerable_slice_when$88.$$p = null;;
      if ((block !== nil)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1)")
      };
      return $send($$($nesting, 'Enumerator'), 'new', [], ($$89 = function(yielder){var self = $$89.$$s || this;

      
        
        if (yielder == null) {
          yielder = nil;
        };
        
        var slice = nil, last_after = nil;

        self.$each_cons.$$p = function() {
          var params = $$($nesting, 'Opal').$destructure(arguments),
              before = params[0],
              after = params[1],
              match = Opal.yieldX(block, [before, after]);

          last_after = after;

          if (slice === nil) {
            slice = [];
          }

          if ($truthy(match)) {
            slice.push(before);
            yielder.$yield(slice);
            slice = [];
          } else {
            slice.push(before);
          }
        }

        self.$each_cons(2);

        if (slice !== nil) {
          slice.push(last_after);
          yielder.$yield(slice);
        }
      ;}, $$89.$$s = self, $$89.$$arity = 1, $$89));
    }, $Enumerable_slice_when$88.$$arity = 0);
    
    Opal.def(self, '$sort', $Enumerable_sort$90 = function $$sort() {
      var $iter = $Enumerable_sort$90.$$p, block = $iter || nil, $$91, self = this, ary = nil;

      if ($iter) $Enumerable_sort$90.$$p = null;
      
      
      if ($iter) $Enumerable_sort$90.$$p = null;;
      ary = self.$to_a();
      if ((block !== nil)) {
      } else {
        block = $lambda(($$91 = function(a, b){var self = $$91.$$s || this;

        
          
          if (a == null) {
            a = nil;
          };
          
          if (b == null) {
            b = nil;
          };
          return a['$<=>'](b);}, $$91.$$s = self, $$91.$$arity = 2, $$91))
      };
      return $send(ary, 'sort', [], block.$to_proc());
    }, $Enumerable_sort$90.$$arity = 0);
    
    Opal.def(self, '$sort_by', $Enumerable_sort_by$92 = function $$sort_by() {
      var $iter = $Enumerable_sort_by$92.$$p, block = $iter || nil, $$93, $$94, $$95, $$96, self = this, dup = nil;

      if ($iter) $Enumerable_sort_by$92.$$p = null;
      
      
      if ($iter) $Enumerable_sort_by$92.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["sort_by"], ($$93 = function(){var self = $$93.$$s || this;

        return self.$enumerator_size()}, $$93.$$s = self, $$93.$$arity = 0, $$93))
      };
      dup = $send(self, 'map', [], ($$94 = function(){var self = $$94.$$s || this, arg = nil;

      
        arg = $$($nesting, 'Opal').$destructure(arguments);
        return [Opal.yield1(block, arg), arg];}, $$94.$$s = self, $$94.$$arity = 0, $$94));
      $send(dup, 'sort!', [], ($$95 = function(a, b){var self = $$95.$$s || this;

      
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return (a[0])['$<=>'](b[0]);}, $$95.$$s = self, $$95.$$arity = 2, $$95));
      return $send(dup, 'map!', [], ($$96 = function(i){var self = $$96.$$s || this;

      
        
        if (i == null) {
          i = nil;
        };
        return i[1];;}, $$96.$$s = self, $$96.$$arity = 1, $$96));
    }, $Enumerable_sort_by$92.$$arity = 0);
    
    Opal.def(self, '$sum', $Enumerable_sum$97 = function $$sum(initial) {
      var $$98, $iter = $Enumerable_sum$97.$$p, $yield = $iter || nil, self = this, result = nil;

      if ($iter) $Enumerable_sum$97.$$p = null;
      
      
      if (initial == null) {
        initial = 0;
      };
      result = initial;
      $send(self, 'each', [], ($$98 = function($a){var self = $$98.$$s || this, $post_args, args, item = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        item = (function() {if (($yield !== nil)) {
          return Opal.yieldX($yield, Opal.to_a(args));
        } else {
          return $$($nesting, 'Opal').$destructure(args)
        }; return nil; })();
        return (result = $rb_plus(result, item));}, $$98.$$s = self, $$98.$$arity = -1, $$98));
      return result;
    }, $Enumerable_sum$97.$$arity = -1);
    
    Opal.def(self, '$take', $Enumerable_take$99 = function $$take(num) {
      var self = this;

      return self.$first(num)
    }, $Enumerable_take$99.$$arity = 1);
    
    Opal.def(self, '$take_while', $Enumerable_take_while$100 = function $$take_while() {try {

      var $iter = $Enumerable_take_while$100.$$p, block = $iter || nil, $$101, self = this, result = nil;

      if ($iter) $Enumerable_take_while$100.$$p = null;
      
      
      if ($iter) $Enumerable_take_while$100.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$enum_for("take_while")
      };
      result = [];
      return $send(self, 'each', [], ($$101 = function($a){var self = $$101.$$s || this, $post_args, args, value = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        value = $$($nesting, 'Opal').$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
        } else {
          Opal.ret(result)
        };
        return result.push(value);;}, $$101.$$s = self, $$101.$$arity = -1, $$101));
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_take_while$100.$$arity = 0);
    
    Opal.def(self, '$uniq', $Enumerable_uniq$102 = function $$uniq() {
      var $iter = $Enumerable_uniq$102.$$p, block = $iter || nil, $$103, self = this, hash = nil;

      if ($iter) $Enumerable_uniq$102.$$p = null;
      
      
      if ($iter) $Enumerable_uniq$102.$$p = null;;
      hash = $hash2([], {});
      $send(self, 'each', [], ($$103 = function($a){var self = $$103.$$s || this, $post_args, args, value = nil, produced = nil, $writer = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        value = $$($nesting, 'Opal').$destructure(args);
        produced = (function() {if ((block !== nil)) {
          return Opal.yield1(block, value);
        } else {
          return value
        }; return nil; })();
        if ($truthy(hash['$key?'](produced))) {
          return nil
        } else {
          
          $writer = [produced, value];
          $send(hash, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        };}, $$103.$$s = self, $$103.$$arity = -1, $$103));
      return hash.$values();
    }, $Enumerable_uniq$102.$$arity = 0);
    Opal.alias(self, "to_a", "entries");
    
    Opal.def(self, '$zip', $Enumerable_zip$104 = function $$zip($a) {
      var $iter = $Enumerable_zip$104.$$p, block = $iter || nil, $post_args, others, self = this;

      if ($iter) $Enumerable_zip$104.$$p = null;
      
      
      if ($iter) $Enumerable_zip$104.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      return $send(self.$to_a(), 'zip', Opal.to_a(others));
    }, $Enumerable_zip$104.$$arity = -1);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/enumerator"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $falsy = Opal.falsy;

  Opal.add_stubs(['$require', '$include', '$allocate', '$new', '$to_proc', '$coerce_to', '$nil?', '$empty?', '$+', '$class', '$__send__', '$===', '$call', '$enum_for', '$size', '$destructure', '$inspect', '$any?', '$[]', '$raise', '$yield', '$each', '$enumerator_size', '$respond_to?', '$try_convert', '$<', '$for']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting), $Enumerator_for$1, $Enumerator_initialize$2, $Enumerator_each$3, $Enumerator_size$4, $Enumerator_with_index$5, $Enumerator_inspect$7;

    self.$$prototype.size = self.$$prototype.args = self.$$prototype.object = self.$$prototype.method = nil;
    
    self.$include($$($nesting, 'Enumerable'));
    self.$$prototype.$$is_enumerator = true;
    Opal.defs(self, '$for', $Enumerator_for$1 = function(object, $a, $b) {
      var $iter = $Enumerator_for$1.$$p, block = $iter || nil, $post_args, method, args, self = this;

      if ($iter) $Enumerator_for$1.$$p = null;
      
      
      if ($iter) $Enumerator_for$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      if ($post_args.length > 0) {
        method = $post_args[0];
        $post_args.splice(0, 1);
      }
      if (method == null) {
        method = "each";
      };
      
      args = $post_args;;
      
      var obj = self.$allocate();

      obj.object = object;
      obj.size   = block;
      obj.method = method;
      obj.args   = args;

      return obj;
    ;
    }, $Enumerator_for$1.$$arity = -2);
    
    Opal.def(self, '$initialize', $Enumerator_initialize$2 = function $$initialize($a) {
      var $iter = $Enumerator_initialize$2.$$p, block = $iter || nil, $post_args, self = this;

      if ($iter) $Enumerator_initialize$2.$$p = null;
      
      
      if ($iter) $Enumerator_initialize$2.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      if ($truthy(block)) {
        
        self.object = $send($$($nesting, 'Generator'), 'new', [], block.$to_proc());
        self.method = "each";
        self.args = [];
        self.size = arguments[0] || nil;
        if ($truthy(self.size)) {
          return (self.size = $$($nesting, 'Opal').$coerce_to(self.size, $$($nesting, 'Integer'), "to_int"))
        } else {
          return nil
        };
      } else {
        
        self.object = arguments[0];
        self.method = arguments[1] || "each";
        self.args = $slice.call(arguments, 2);
        return (self.size = nil);
      };
    }, $Enumerator_initialize$2.$$arity = -1);
    
    Opal.def(self, '$each', $Enumerator_each$3 = function $$each($a) {
      var $iter = $Enumerator_each$3.$$p, block = $iter || nil, $post_args, args, $b, self = this;

      if ($iter) $Enumerator_each$3.$$p = null;
      
      
      if ($iter) $Enumerator_each$3.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(($truthy($b = block['$nil?']()) ? args['$empty?']() : $b))) {
        return self};
      args = $rb_plus(self.args, args);
      if ($truthy(block['$nil?']())) {
        return $send(self.$class(), 'new', [self.object, self.method].concat(Opal.to_a(args)))};
      return $send(self.object, '__send__', [self.method].concat(Opal.to_a(args)), block.$to_proc());
    }, $Enumerator_each$3.$$arity = -1);
    
    Opal.def(self, '$size', $Enumerator_size$4 = function $$size() {
      var self = this;

      if ($truthy($$($nesting, 'Proc')['$==='](self.size))) {
        return $send(self.size, 'call', Opal.to_a(self.args))
      } else {
        return self.size
      }
    }, $Enumerator_size$4.$$arity = 0);
    
    Opal.def(self, '$with_index', $Enumerator_with_index$5 = function $$with_index(offset) {
      var $iter = $Enumerator_with_index$5.$$p, block = $iter || nil, $$6, self = this;

      if ($iter) $Enumerator_with_index$5.$$p = null;
      
      
      if ($iter) $Enumerator_with_index$5.$$p = null;;
      
      if (offset == null) {
        offset = 0;
      };
      offset = (function() {if ($truthy(offset)) {
        return $$($nesting, 'Opal').$coerce_to(offset, $$($nesting, 'Integer'), "to_int")
      } else {
        return 0
      }; return nil; })();
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["with_index", offset], ($$6 = function(){var self = $$6.$$s || this;

        return self.$size()}, $$6.$$s = self, $$6.$$arity = 0, $$6))
      };
      
      var result, index = offset;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = block(param, index);

        index++;

        return value;
      }

      return self.$each();
    ;
    }, $Enumerator_with_index$5.$$arity = -1);
    Opal.alias(self, "with_object", "each_with_object");
    
    Opal.def(self, '$inspect', $Enumerator_inspect$7 = function $$inspect() {
      var self = this, result = nil;

      
      result = "" + "#<" + (self.$class()) + ": " + (self.object.$inspect()) + ":" + (self.method);
      if ($truthy(self.args['$any?']())) {
        result = $rb_plus(result, "" + "(" + (self.args.$inspect()['$[]']($$($nesting, 'Range').$new(1, -2))) + ")")};
      return $rb_plus(result, ">");
    }, $Enumerator_inspect$7.$$arity = 0);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Generator');

      var $nesting = [self].concat($parent_nesting), $Generator_initialize$8, $Generator_each$9;

      self.$$prototype.block = nil;
      
      self.$include($$($nesting, 'Enumerable'));
      
      Opal.def(self, '$initialize', $Generator_initialize$8 = function $$initialize() {
        var $iter = $Generator_initialize$8.$$p, block = $iter || nil, self = this;

        if ($iter) $Generator_initialize$8.$$p = null;
        
        
        if ($iter) $Generator_initialize$8.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'LocalJumpError'), "no block given")
        };
        return (self.block = block);
      }, $Generator_initialize$8.$$arity = 0);
      return (Opal.def(self, '$each', $Generator_each$9 = function $$each($a) {
        var $iter = $Generator_each$9.$$p, block = $iter || nil, $post_args, args, self = this, yielder = nil;

        if ($iter) $Generator_each$9.$$p = null;
        
        
        if ($iter) $Generator_each$9.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        yielder = $send($$($nesting, 'Yielder'), 'new', [], block.$to_proc());
        
        try {
          args.unshift(yielder);

          Opal.yieldX(self.block, args);
        }
        catch (e) {
          if (e === $breaker) {
            return $breaker.$v;
          }
          else {
            throw e;
          }
        }
      ;
        return self;
      }, $Generator_each$9.$$arity = -1), nil) && 'each';
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Yielder');

      var $nesting = [self].concat($parent_nesting), $Yielder_initialize$10, $Yielder_yield$11, $Yielder_$lt$lt$12;

      self.$$prototype.block = nil;
      
      
      Opal.def(self, '$initialize', $Yielder_initialize$10 = function $$initialize() {
        var $iter = $Yielder_initialize$10.$$p, block = $iter || nil, self = this;

        if ($iter) $Yielder_initialize$10.$$p = null;
        
        
        if ($iter) $Yielder_initialize$10.$$p = null;;
        return (self.block = block);
      }, $Yielder_initialize$10.$$arity = 0);
      
      Opal.def(self, '$yield', $Yielder_yield$11 = function($a) {
        var $post_args, values, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        values = $post_args;;
        
        var value = Opal.yieldX(self.block, values);

        if (value === $breaker) {
          throw $breaker;
        }

        return value;
      ;
      }, $Yielder_yield$11.$$arity = -1);
      return (Opal.def(self, '$<<', $Yielder_$lt$lt$12 = function($a) {
        var $post_args, values, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        values = $post_args;;
        $send(self, 'yield', Opal.to_a(values));
        return self;
      }, $Yielder_$lt$lt$12.$$arity = -1), nil) && '<<';
    })($nesting[0], null, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Lazy');

      var $nesting = [self].concat($parent_nesting), $Lazy_initialize$13, $Lazy_lazy$16, $Lazy_collect$17, $Lazy_collect_concat$19, $Lazy_drop$23, $Lazy_drop_while$25, $Lazy_enum_for$27, $Lazy_find_all$28, $Lazy_grep$30, $Lazy_reject$33, $Lazy_take$35, $Lazy_take_while$37, $Lazy_inspect$39;

      self.$$prototype.enumerator = nil;
      
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'StopLazyError');

        var $nesting = [self].concat($parent_nesting);

        return nil
      })($nesting[0], $$($nesting, 'Exception'), $nesting);
      
      Opal.def(self, '$initialize', $Lazy_initialize$13 = function $$initialize(object, size) {
        var $iter = $Lazy_initialize$13.$$p, block = $iter || nil, $$14, self = this;

        if ($iter) $Lazy_initialize$13.$$p = null;
        
        
        if ($iter) $Lazy_initialize$13.$$p = null;;
        
        if (size == null) {
          size = nil;
        };
        if ((block !== nil)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy new without a block")
        };
        self.enumerator = object;
        return $send(self, Opal.find_super_dispatcher(self, 'initialize', $Lazy_initialize$13, false), [size], ($$14 = function(yielder, $a){var self = $$14.$$s || this, $post_args, each_args, $$15;

        
          
          if (yielder == null) {
            yielder = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          each_args = $post_args;;
          try {
            return $send(object, 'each', Opal.to_a(each_args), ($$15 = function($b){var self = $$15.$$s || this, $post_args, args;

            
              
              $post_args = Opal.slice.call(arguments, 0, arguments.length);
              
              args = $post_args;;
              
            args.unshift(yielder);

            Opal.yieldX(block, args);
          ;}, $$15.$$s = self, $$15.$$arity = -1, $$15))
          } catch ($err) {
            if (Opal.rescue($err, [$$($nesting, 'Exception')])) {
              try {
                return nil
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          };}, $$14.$$s = self, $$14.$$arity = -2, $$14));
      }, $Lazy_initialize$13.$$arity = -2);
      Opal.alias(self, "force", "to_a");
      
      Opal.def(self, '$lazy', $Lazy_lazy$16 = function $$lazy() {
        var self = this;

        return self
      }, $Lazy_lazy$16.$$arity = 0);
      
      Opal.def(self, '$collect', $Lazy_collect$17 = function $$collect() {
        var $iter = $Lazy_collect$17.$$p, block = $iter || nil, $$18, self = this;

        if ($iter) $Lazy_collect$17.$$p = null;
        
        
        if ($iter) $Lazy_collect$17.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, self.$enumerator_size()], ($$18 = function(enum$, $a){var self = $$18.$$s || this, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          enum$.$yield(value);
        ;}, $$18.$$s = self, $$18.$$arity = -2, $$18));
      }, $Lazy_collect$17.$$arity = 0);
      
      Opal.def(self, '$collect_concat', $Lazy_collect_concat$19 = function $$collect_concat() {
        var $iter = $Lazy_collect_concat$19.$$p, block = $iter || nil, $$20, self = this;

        if ($iter) $Lazy_collect_concat$19.$$p = null;
        
        
        if ($iter) $Lazy_collect_concat$19.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$20 = function(enum$, $a){var self = $$20.$$s || this, $post_args, args, $$21, $$22;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ((value)['$respond_to?']("force") && (value)['$respond_to?']("each")) {
            $send((value), 'each', [], ($$21 = function(v){var self = $$21.$$s || this;

          
            
            if (v == null) {
              v = nil;
            };
            return enum$.$yield(v);}, $$21.$$s = self, $$21.$$arity = 1, $$21))
          }
          else {
            var array = $$($nesting, 'Opal').$try_convert(value, $$($nesting, 'Array'), "to_ary");

            if (array === nil) {
              enum$.$yield(value);
            }
            else {
              $send((value), 'each', [], ($$22 = function(v){var self = $$22.$$s || this;

          
            
            if (v == null) {
              v = nil;
            };
            return enum$.$yield(v);}, $$22.$$s = self, $$22.$$arity = 1, $$22));
            }
          }
        ;}, $$20.$$s = self, $$20.$$arity = -2, $$20));
      }, $Lazy_collect_concat$19.$$arity = 0);
      
      Opal.def(self, '$drop', $Lazy_drop$23 = function $$drop(n) {
        var $$24, self = this, current_size = nil, set_size = nil, dropped = nil;

        
        n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), "to_int");
        if ($truthy($rb_lt(n, 0))) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to drop negative size")};
        current_size = self.$enumerator_size();
        set_size = (function() {if ($truthy($$($nesting, 'Integer')['$==='](current_size))) {
          if ($truthy($rb_lt(n, current_size))) {
            return n
          } else {
            return current_size
          }
        } else {
          return current_size
        }; return nil; })();
        dropped = 0;
        return $send($$($nesting, 'Lazy'), 'new', [self, set_size], ($$24 = function(enum$, $a){var self = $$24.$$s || this, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy($rb_lt(dropped, n))) {
            return (dropped = $rb_plus(dropped, 1))
          } else {
            return $send(enum$, 'yield', Opal.to_a(args))
          };}, $$24.$$s = self, $$24.$$arity = -2, $$24));
      }, $Lazy_drop$23.$$arity = 1);
      
      Opal.def(self, '$drop_while', $Lazy_drop_while$25 = function $$drop_while() {
        var $iter = $Lazy_drop_while$25.$$p, block = $iter || nil, $$26, self = this, succeeding = nil;

        if ($iter) $Lazy_drop_while$25.$$p = null;
        
        
        if ($iter) $Lazy_drop_while$25.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy drop_while without a block")
        };
        succeeding = true;
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$26 = function(enum$, $a){var self = $$26.$$s || this, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy(succeeding)) {
            
            var value = Opal.yieldX(block, args);

            if ($falsy(value)) {
              succeeding = false;

              $send(enum$, 'yield', Opal.to_a(args));
            }
          
          } else {
            return $send(enum$, 'yield', Opal.to_a(args))
          };}, $$26.$$s = self, $$26.$$arity = -2, $$26));
      }, $Lazy_drop_while$25.$$arity = 0);
      
      Opal.def(self, '$enum_for', $Lazy_enum_for$27 = function $$enum_for($a, $b) {
        var $iter = $Lazy_enum_for$27.$$p, block = $iter || nil, $post_args, method, args, self = this;

        if ($iter) $Lazy_enum_for$27.$$p = null;
        
        
        if ($iter) $Lazy_enum_for$27.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        if ($post_args.length > 0) {
          method = $post_args[0];
          $post_args.splice(0, 1);
        }
        if (method == null) {
          method = "each";
        };
        
        args = $post_args;;
        return $send(self.$class(), 'for', [self, method].concat(Opal.to_a(args)), block.$to_proc());
      }, $Lazy_enum_for$27.$$arity = -1);
      
      Opal.def(self, '$find_all', $Lazy_find_all$28 = function $$find_all() {
        var $iter = $Lazy_find_all$28.$$p, block = $iter || nil, $$29, self = this;

        if ($iter) $Lazy_find_all$28.$$p = null;
        
        
        if ($iter) $Lazy_find_all$28.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy select without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$29 = function(enum$, $a){var self = $$29.$$s || this, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
        ;}, $$29.$$s = self, $$29.$$arity = -2, $$29));
      }, $Lazy_find_all$28.$$arity = 0);
      Opal.alias(self, "flat_map", "collect_concat");
      
      Opal.def(self, '$grep', $Lazy_grep$30 = function $$grep(pattern) {
        var $iter = $Lazy_grep$30.$$p, block = $iter || nil, $$31, $$32, self = this;

        if ($iter) $Lazy_grep$30.$$p = null;
        
        
        if ($iter) $Lazy_grep$30.$$p = null;;
        if ($truthy(block)) {
          return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$31 = function(enum$, $a){var self = $$31.$$s || this, $post_args, args;

          
            
            if (enum$ == null) {
              enum$ = nil;
            };
            
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            
            args = $post_args;;
            
            var param = $$($nesting, 'Opal').$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              value = Opal.yield1(block, param);

              enum$.$yield(Opal.yield1(block, param));
            }
          ;}, $$31.$$s = self, $$31.$$arity = -2, $$31))
        } else {
          return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$32 = function(enum$, $a){var self = $$32.$$s || this, $post_args, args;

          
            
            if (enum$ == null) {
              enum$ = nil;
            };
            
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            
            args = $post_args;;
            
            var param = $$($nesting, 'Opal').$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              enum$.$yield(param);
            }
          ;}, $$32.$$s = self, $$32.$$arity = -2, $$32))
        };
      }, $Lazy_grep$30.$$arity = 1);
      Opal.alias(self, "map", "collect");
      Opal.alias(self, "select", "find_all");
      
      Opal.def(self, '$reject', $Lazy_reject$33 = function $$reject() {
        var $iter = $Lazy_reject$33.$$p, block = $iter || nil, $$34, self = this;

        if ($iter) $Lazy_reject$33.$$p = null;
        
        
        if ($iter) $Lazy_reject$33.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy reject without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$34 = function(enum$, $a){var self = $$34.$$s || this, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($falsy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
        ;}, $$34.$$s = self, $$34.$$arity = -2, $$34));
      }, $Lazy_reject$33.$$arity = 0);
      
      Opal.def(self, '$take', $Lazy_take$35 = function $$take(n) {
        var $$36, self = this, current_size = nil, set_size = nil, taken = nil;

        
        n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), "to_int");
        if ($truthy($rb_lt(n, 0))) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to take negative size")};
        current_size = self.$enumerator_size();
        set_size = (function() {if ($truthy($$($nesting, 'Integer')['$==='](current_size))) {
          if ($truthy($rb_lt(n, current_size))) {
            return n
          } else {
            return current_size
          }
        } else {
          return current_size
        }; return nil; })();
        taken = 0;
        return $send($$($nesting, 'Lazy'), 'new', [self, set_size], ($$36 = function(enum$, $a){var self = $$36.$$s || this, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy($rb_lt(taken, n))) {
            
            $send(enum$, 'yield', Opal.to_a(args));
            return (taken = $rb_plus(taken, 1));
          } else {
            return self.$raise($$($nesting, 'StopLazyError'))
          };}, $$36.$$s = self, $$36.$$arity = -2, $$36));
      }, $Lazy_take$35.$$arity = 1);
      
      Opal.def(self, '$take_while', $Lazy_take_while$37 = function $$take_while() {
        var $iter = $Lazy_take_while$37.$$p, block = $iter || nil, $$38, self = this;

        if ($iter) $Lazy_take_while$37.$$p = null;
        
        
        if ($iter) $Lazy_take_while$37.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy take_while without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$38 = function(enum$, $a){var self = $$38.$$s || this, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
          else {
            self.$raise($$($nesting, 'StopLazyError'));
          }
        ;}, $$38.$$s = self, $$38.$$arity = -2, $$38));
      }, $Lazy_take_while$37.$$arity = 0);
      Opal.alias(self, "to_enum", "enum_for");
      return (Opal.def(self, '$inspect', $Lazy_inspect$39 = function $$inspect() {
        var self = this;

        return "" + "#<" + (self.$class()) + ": " + (self.enumerator.$inspect()) + ">"
      }, $Lazy_inspect$39.$$arity = 0), nil) && 'inspect';
    })($nesting[0], self, $nesting);
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/numeric"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$include', '$instance_of?', '$class', '$Float', '$respond_to?', '$coerce', '$__send__', '$===', '$raise', '$equal?', '$-', '$*', '$div', '$<', '$-@', '$ceil', '$to_f', '$denominator', '$to_r', '$==', '$floor', '$/', '$%', '$Complex', '$zero?', '$numerator', '$abs', '$arg', '$coerce_to!', '$round', '$to_i', '$truncate', '$>']);
  
  self.$require("corelib/comparable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Numeric');

    var $nesting = [self].concat($parent_nesting), $Numeric_coerce$1, $Numeric___coerced__$2, $Numeric_$lt_eq_gt$3, $Numeric_$plus$$4, $Numeric_$minus$$5, $Numeric_$percent$6, $Numeric_abs$7, $Numeric_abs2$8, $Numeric_angle$9, $Numeric_ceil$10, $Numeric_conj$11, $Numeric_denominator$12, $Numeric_div$13, $Numeric_divmod$14, $Numeric_fdiv$15, $Numeric_floor$16, $Numeric_i$17, $Numeric_imag$18, $Numeric_integer$ques$19, $Numeric_nonzero$ques$20, $Numeric_numerator$21, $Numeric_polar$22, $Numeric_quo$23, $Numeric_real$24, $Numeric_real$ques$25, $Numeric_rect$26, $Numeric_round$27, $Numeric_to_c$28, $Numeric_to_int$29, $Numeric_truncate$30, $Numeric_zero$ques$31, $Numeric_positive$ques$32, $Numeric_negative$ques$33, $Numeric_dup$34, $Numeric_clone$35, $Numeric_finite$ques$36, $Numeric_infinite$ques$37;

    
    self.$include($$($nesting, 'Comparable'));
    
    Opal.def(self, '$coerce', $Numeric_coerce$1 = function $$coerce(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
        return [other, self]};
      return [self.$Float(other), self.$Float(self)];
    }, $Numeric_coerce$1.$$arity = 1);
    
    Opal.def(self, '$__coerced__', $Numeric___coerced__$2 = function $$__coerced__(method, other) {
      var $a, $b, self = this, a = nil, b = nil, $case = nil;

      if ($truthy(other['$respond_to?']("coerce"))) {
        
        $b = other.$coerce(self), $a = Opal.to_ary($b), (a = ($a[0] == null ? nil : $a[0])), (b = ($a[1] == null ? nil : $a[1])), $b;
        return a.$__send__(method, b);
      } else {
        return (function() {$case = method;
        if ("+"['$===']($case) || "-"['$===']($case) || "*"['$===']($case) || "/"['$===']($case) || "%"['$===']($case) || "&"['$===']($case) || "|"['$===']($case) || "^"['$===']($case) || "**"['$===']($case)) {return self.$raise($$($nesting, 'TypeError'), "" + (other.$class()) + " can't be coerced into Numeric")}
        else if (">"['$===']($case) || ">="['$===']($case) || "<"['$===']($case) || "<="['$===']($case) || "<=>"['$===']($case)) {return self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")}
        else { return nil }})()
      }
    }, $Numeric___coerced__$2.$$arity = 2);
    
    Opal.def(self, '$<=>', $Numeric_$lt_eq_gt$3 = function(other) {
      var self = this;

      
      if ($truthy(self['$equal?'](other))) {
        return 0};
      return nil;
    }, $Numeric_$lt_eq_gt$3.$$arity = 1);
    
    Opal.def(self, '$+@', $Numeric_$plus$$4 = function() {
      var self = this;

      return self
    }, $Numeric_$plus$$4.$$arity = 0);
    
    Opal.def(self, '$-@', $Numeric_$minus$$5 = function() {
      var self = this;

      return $rb_minus(0, self)
    }, $Numeric_$minus$$5.$$arity = 0);
    
    Opal.def(self, '$%', $Numeric_$percent$6 = function(other) {
      var self = this;

      return $rb_minus(self, $rb_times(other, self.$div(other)))
    }, $Numeric_$percent$6.$$arity = 1);
    
    Opal.def(self, '$abs', $Numeric_abs$7 = function $$abs() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return self['$-@']()
      } else {
        return self
      }
    }, $Numeric_abs$7.$$arity = 0);
    
    Opal.def(self, '$abs2', $Numeric_abs2$8 = function $$abs2() {
      var self = this;

      return $rb_times(self, self)
    }, $Numeric_abs2$8.$$arity = 0);
    
    Opal.def(self, '$angle', $Numeric_angle$9 = function $$angle() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return $$$($$($nesting, 'Math'), 'PI')
      } else {
        return 0
      }
    }, $Numeric_angle$9.$$arity = 0);
    Opal.alias(self, "arg", "angle");
    
    Opal.def(self, '$ceil', $Numeric_ceil$10 = function $$ceil(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      return self.$to_f().$ceil(ndigits);
    }, $Numeric_ceil$10.$$arity = -1);
    
    Opal.def(self, '$conj', $Numeric_conj$11 = function $$conj() {
      var self = this;

      return self
    }, $Numeric_conj$11.$$arity = 0);
    Opal.alias(self, "conjugate", "conj");
    
    Opal.def(self, '$denominator', $Numeric_denominator$12 = function $$denominator() {
      var self = this;

      return self.$to_r().$denominator()
    }, $Numeric_denominator$12.$$arity = 0);
    
    Opal.def(self, '$div', $Numeric_div$13 = function $$div(other) {
      var self = this;

      
      if (other['$=='](0)) {
        self.$raise($$($nesting, 'ZeroDivisionError'), "divided by o")};
      return $rb_divide(self, other).$floor();
    }, $Numeric_div$13.$$arity = 1);
    
    Opal.def(self, '$divmod', $Numeric_divmod$14 = function $$divmod(other) {
      var self = this;

      return [self.$div(other), self['$%'](other)]
    }, $Numeric_divmod$14.$$arity = 1);
    
    Opal.def(self, '$fdiv', $Numeric_fdiv$15 = function $$fdiv(other) {
      var self = this;

      return $rb_divide(self.$to_f(), other)
    }, $Numeric_fdiv$15.$$arity = 1);
    
    Opal.def(self, '$floor', $Numeric_floor$16 = function $$floor(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      return self.$to_f().$floor(ndigits);
    }, $Numeric_floor$16.$$arity = -1);
    
    Opal.def(self, '$i', $Numeric_i$17 = function $$i() {
      var self = this;

      return self.$Complex(0, self)
    }, $Numeric_i$17.$$arity = 0);
    
    Opal.def(self, '$imag', $Numeric_imag$18 = function $$imag() {
      var self = this;

      return 0
    }, $Numeric_imag$18.$$arity = 0);
    Opal.alias(self, "imaginary", "imag");
    
    Opal.def(self, '$integer?', $Numeric_integer$ques$19 = function() {
      var self = this;

      return false
    }, $Numeric_integer$ques$19.$$arity = 0);
    Opal.alias(self, "magnitude", "abs");
    Opal.alias(self, "modulo", "%");
    
    Opal.def(self, '$nonzero?', $Numeric_nonzero$ques$20 = function() {
      var self = this;

      if ($truthy(self['$zero?']())) {
        return nil
      } else {
        return self
      }
    }, $Numeric_nonzero$ques$20.$$arity = 0);
    
    Opal.def(self, '$numerator', $Numeric_numerator$21 = function $$numerator() {
      var self = this;

      return self.$to_r().$numerator()
    }, $Numeric_numerator$21.$$arity = 0);
    Opal.alias(self, "phase", "arg");
    
    Opal.def(self, '$polar', $Numeric_polar$22 = function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, $Numeric_polar$22.$$arity = 0);
    
    Opal.def(self, '$quo', $Numeric_quo$23 = function $$quo(other) {
      var self = this;

      return $rb_divide($$($nesting, 'Opal')['$coerce_to!'](self, $$($nesting, 'Rational'), "to_r"), other)
    }, $Numeric_quo$23.$$arity = 1);
    
    Opal.def(self, '$real', $Numeric_real$24 = function $$real() {
      var self = this;

      return self
    }, $Numeric_real$24.$$arity = 0);
    
    Opal.def(self, '$real?', $Numeric_real$ques$25 = function() {
      var self = this;

      return true
    }, $Numeric_real$ques$25.$$arity = 0);
    
    Opal.def(self, '$rect', $Numeric_rect$26 = function $$rect() {
      var self = this;

      return [self, 0]
    }, $Numeric_rect$26.$$arity = 0);
    Opal.alias(self, "rectangular", "rect");
    
    Opal.def(self, '$round', $Numeric_round$27 = function $$round(digits) {
      var self = this;

      
      ;
      return self.$to_f().$round(digits);
    }, $Numeric_round$27.$$arity = -1);
    
    Opal.def(self, '$to_c', $Numeric_to_c$28 = function $$to_c() {
      var self = this;

      return self.$Complex(self, 0)
    }, $Numeric_to_c$28.$$arity = 0);
    
    Opal.def(self, '$to_int', $Numeric_to_int$29 = function $$to_int() {
      var self = this;

      return self.$to_i()
    }, $Numeric_to_int$29.$$arity = 0);
    
    Opal.def(self, '$truncate', $Numeric_truncate$30 = function $$truncate(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      return self.$to_f().$truncate(ndigits);
    }, $Numeric_truncate$30.$$arity = -1);
    
    Opal.def(self, '$zero?', $Numeric_zero$ques$31 = function() {
      var self = this;

      return self['$=='](0)
    }, $Numeric_zero$ques$31.$$arity = 0);
    
    Opal.def(self, '$positive?', $Numeric_positive$ques$32 = function() {
      var self = this;

      return $rb_gt(self, 0)
    }, $Numeric_positive$ques$32.$$arity = 0);
    
    Opal.def(self, '$negative?', $Numeric_negative$ques$33 = function() {
      var self = this;

      return $rb_lt(self, 0)
    }, $Numeric_negative$ques$33.$$arity = 0);
    
    Opal.def(self, '$dup', $Numeric_dup$34 = function $$dup() {
      var self = this;

      return self
    }, $Numeric_dup$34.$$arity = 0);
    
    Opal.def(self, '$clone', $Numeric_clone$35 = function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      return self;
    }, $Numeric_clone$35.$$arity = -1);
    
    Opal.def(self, '$finite?', $Numeric_finite$ques$36 = function() {
      var self = this;

      return true
    }, $Numeric_finite$ques$36.$$arity = 0);
    return (Opal.def(self, '$infinite?', $Numeric_infinite$ques$37 = function() {
      var self = this;

      return nil
    }, $Numeric_infinite$ques$37.$$arity = 0), nil) && 'infinite?';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/array"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send, $gvars = Opal.gvars;

  Opal.add_stubs(['$require', '$include', '$to_a', '$warn', '$raise', '$replace', '$respond_to?', '$to_ary', '$coerce_to', '$coerce_to?', '$===', '$join', '$to_str', '$class', '$hash', '$<=>', '$==', '$object_id', '$inspect', '$enum_for', '$bsearch_index', '$to_proc', '$nil?', '$coerce_to!', '$>', '$*', '$enumerator_size', '$empty?', '$size', '$map', '$equal?', '$dup', '$each', '$[]', '$dig', '$eql?', '$length', '$begin', '$end', '$exclude_end?', '$flatten', '$__id__', '$to_s', '$new', '$max', '$min', '$!', '$>=', '$**', '$delete_if', '$reverse', '$rotate', '$rand', '$at', '$keep_if', '$shuffle!', '$<', '$sort', '$sort_by', '$!=', '$times', '$[]=', '$-', '$<<', '$values', '$is_a?', '$last', '$first', '$upto', '$reject', '$pristine', '$singleton_class']);
  
  self.$require("corelib/enumerable");
  self.$require("corelib/numeric");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $Array_$$$1, $Array_initialize$2, $Array_try_convert$3, $Array_$$4, $Array_$$5, $Array_$$6, $Array_$plus$7, $Array_$minus$8, $Array_$lt$lt$9, $Array_$lt_eq_gt$10, $Array_$eq_eq$11, $Array_$$$12, $Array_$$$eq$13, $Array_any$ques$14, $Array_assoc$15, $Array_at$16, $Array_bsearch_index$17, $Array_bsearch$18, $Array_cycle$19, $Array_clear$21, $Array_count$22, $Array_initialize_copy$23, $Array_collect$24, $Array_collect$excl$26, $Array_combination$28, $Array_repeated_combination$30, $Array_compact$32, $Array_compact$excl$33, $Array_concat$34, $Array_delete$37, $Array_delete_at$38, $Array_delete_if$39, $Array_dig$41, $Array_drop$42, $Array_dup$43, $Array_each$44, $Array_each_index$46, $Array_empty$ques$48, $Array_eql$ques$49, $Array_fetch$50, $Array_fill$51, $Array_first$52, $Array_flatten$53, $Array_flatten$excl$54, $Array_hash$55, $Array_include$ques$56, $Array_index$57, $Array_insert$58, $Array_inspect$59, $Array_join$60, $Array_keep_if$61, $Array_last$63, $Array_length$64, $Array_max$65, $Array_min$66, $Array_permutation$67, $Array_repeated_permutation$69, $Array_pop$71, $Array_product$72, $Array_push$73, $Array_rassoc$74, $Array_reject$75, $Array_reject$excl$77, $Array_replace$79, $Array_reverse$80, $Array_reverse$excl$81, $Array_reverse_each$82, $Array_rindex$84, $Array_rotate$85, $Array_rotate$excl$86, $Array_sample$89, $Array_select$90, $Array_select$excl$92, $Array_shift$94, $Array_shuffle$95, $Array_shuffle$excl$96, $Array_slice$excl$97, $Array_sort$98, $Array_sort$excl$99, $Array_sort_by$excl$100, $Array_take$102, $Array_take_while$103, $Array_to_a$104, $Array_to_h$105, $Array_transpose$106, $Array_uniq$109, $Array_uniq$excl$110, $Array_unshift$111, $Array_values_at$112, $Array_zip$115, $Array_inherited$116, $Array_instance_variables$117, $Array_pack$119;

    
    self.$include($$($nesting, 'Enumerable'));
    Opal.defineProperty(self.$$prototype, '$$is_array', true);
    
    // Recent versions of V8 (> 7.1) only use an optimized implementation when Array.prototype is unmodified.
    // For instance, "array-splice.tq" has a "fast path" (ExtractFastJSArray, defined in "src/codegen/code-stub-assembler.cc")
    // but it's only enabled when "IsPrototypeInitialArrayPrototype()" is true.
    //
    // Older versions of V8 were using relatively fast JS-with-extensions code even when Array.prototype is modified:
    // https://github.com/v8/v8/blob/7.0.1/src/js/array.js#L599-L642
    //
    // In short, Array operations are slow in recent versions of V8 when the Array.prototype has been tampered.
    // So, when possible, we are using faster open-coded version to boost the performance.

    // As of V8 8.4, depending on the size of the array, this is up to ~25x times faster than Array#shift()
    // Implementation is heavily inspired by: https://github.com/nodejs/node/blob/ba684805b6c0eded76e5cd89ee00328ac7a59365/lib/internal/util.js#L341-L347
    function shiftNoArg(list) {
      var r = list[0];
      var index = 1;
      var length = list.length;
      for (; index < length; index++) {
        list[index - 1] = list[index];
      }
      list.pop();
      return r;
    }

    function toArraySubclass(obj, klass) {
      if (klass.$$name === Opal.Array) {
        return obj;
      } else {
        return klass.$allocate().$replace((obj).$to_a());
      }
    }
  ;
    Opal.defs(self, '$[]', $Array_$$$1 = function($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      objects = $post_args;;
      return toArraySubclass(objects, self);;
    }, $Array_$$$1.$$arity = -1);
    
    Opal.def(self, '$initialize', $Array_initialize$2 = function $$initialize(size, obj) {
      var $iter = $Array_initialize$2.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_initialize$2.$$p = null;
      
      
      if ($iter) $Array_initialize$2.$$p = null;;
      
      if (size == null) {
        size = nil;
      };
      
      if (obj == null) {
        obj = nil;
      };
      
      if (obj !== nil && block !== nil) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (size > $$$($$($nesting, 'Integer'), 'MAX')) {
        self.$raise($$($nesting, 'ArgumentError'), "array size too big")
      }

      if (arguments.length > 2) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..2)")
      }

      if (arguments.length === 0) {
        self.splice(0, self.length);
        return self;
      }

      if (arguments.length === 1) {
        if (size.$$is_array) {
          self.$replace(size.$to_a())
          return self;
        } else if (size['$respond_to?']("to_ary")) {
          self.$replace(size.$to_ary())
          return self;
        }
      }

      size = $$($nesting, 'Opal').$coerce_to(size, $$($nesting, 'Integer'), "to_int")

      if (size < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size")
      }

      self.splice(0, self.length);
      var i, value;

      if (block === nil) {
        for (i = 0; i < size; i++) {
          self.push(obj);
        }
      }
      else {
        for (i = 0, value; i < size; i++) {
          value = block(i);
          self[i] = value;
        }
      }

      return self;
    ;
    }, $Array_initialize$2.$$arity = -1);
    Opal.defs(self, '$try_convert', $Array_try_convert$3 = function $$try_convert(obj) {
      var self = this;

      return $$($nesting, 'Opal')['$coerce_to?'](obj, $$($nesting, 'Array'), "to_ary")
    }, $Array_try_convert$3.$$arity = 1);
    
    Opal.def(self, '$&', $Array_$$4 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), "to_ary").$to_a()
      }; return nil; })();
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        Opal.hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if (Opal.hash_delete(hash, item) !== undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, $Array_$$4.$$arity = 1);
    
    Opal.def(self, '$|', $Array_$$5 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), "to_ary").$to_a()
      }; return nil; })();
      
      var hash = $hash2([], {}), i, length, item;

      for (i = 0, length = self.length; i < length; i++) {
        Opal.hash_put(hash, self[i], true);
      }

      for (i = 0, length = other.length; i < length; i++) {
        Opal.hash_put(hash, other[i], true);
      }

      return hash.$keys();
    ;
    }, $Array_$$5.$$arity = 1);
    
    Opal.def(self, '$*', $Array_$$6 = function(other) {
      var self = this;

      
      if ($truthy(other['$respond_to?']("to_str"))) {
        return self.$join(other.$to_str())};
      other = $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Integer'), "to_int");
      if ($truthy(other < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "negative argument")};
      
      var result = [],
          converted = self.$to_a();

      for (var i = 0; i < other; i++) {
        result = result.concat(converted);
      }

      return toArraySubclass(result, self.$class());
    ;
    }, $Array_$$6.$$arity = 1);
    
    Opal.def(self, '$+', $Array_$plus$7 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), "to_ary").$to_a()
      }; return nil; })();
      return self.concat(other);;
    }, $Array_$plus$7.$$arity = 1);
    
    Opal.def(self, '$-', $Array_$minus$8 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), "to_ary").$to_a()
      }; return nil; })();
      if ($truthy(self.length === 0)) {
        return []};
      if ($truthy(other.length === 0)) {
        return self.slice()};
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        Opal.hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if (Opal.hash_get(hash, item) === undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, $Array_$minus$8.$$arity = 1);
    
    Opal.def(self, '$<<', $Array_$lt$lt$9 = function(object) {
      var self = this;

      
      self.push(object);
      return self;
    }, $Array_$lt$lt$9.$$arity = 1);
    
    Opal.def(self, '$<=>', $Array_$lt_eq_gt$10 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Array')['$==='](other))) {
        other = other.$to_a()
      } else if ($truthy(other['$respond_to?']("to_ary"))) {
        other = other.$to_ary().$to_a()
      } else {
        return nil
      };
      
      if (self.$hash() === other.$hash()) {
        return 0;
      }

      var count = Math.min(self.length, other.length);

      for (var i = 0; i < count; i++) {
        var tmp = (self[i])['$<=>'](other[i]);

        if (tmp !== 0) {
          return tmp;
        }
      }

      return (self.length)['$<=>'](other.length);
    ;
    }, $Array_$lt_eq_gt$10.$$arity = 1);
    
    Opal.def(self, '$==', $Array_$eq_eq$11 = function(other) {
      var self = this;

      
      var recursed = {};

      function _eqeq(array, other) {
        var i, length, a, b;

        if (array === other)
          return true;

        if (!other.$$is_array) {
          if ($$($nesting, 'Opal')['$respond_to?'](other, "to_ary")) {
            return (other)['$=='](array);
          } else {
            return false;
          }
        }

        if (array.$$constructor !== Array)
          array = (array).$to_a();
        if (other.$$constructor !== Array)
          other = (other).$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    
    }, $Array_$eq_eq$11.$$arity = 1);
    
    function $array_slice_range(self, index) {
      var size = self.length,
          exclude, from, to, result;

      exclude = index.excl;
      from    = Opal.Opal.$coerce_to(index.begin, Opal.Integer, 'to_int');
      to      = Opal.Opal.$coerce_to(index.end, Opal.Integer, 'to_int');

      if (from < 0) {
        from += size;

        if (from < 0) {
          return nil;
        }
      }

      if (from > size) {
        return nil;
      }

      if (to < 0) {
        to += size;

        if (to < 0) {
          return [];
        }
      }

      if (!exclude) {
        to += 1;
      }

      result = self.slice(from, to);
      return toArraySubclass(result, self.$class());
    }

    function $array_slice_index_length(self, index, length) {
      var size = self.length,
          exclude, from, to, result;

      index = Opal.Opal.$coerce_to(index, Opal.Integer, 'to_int');

      if (index < 0) {
        index += size;

        if (index < 0) {
          return nil;
        }
      }

      if (length === undefined) {
        if (index >= size || index < 0) {
          return nil;
        }

        return self[index];
      }
      else {
        length = Opal.Opal.$coerce_to(length, Opal.Integer, 'to_int');

        if (length < 0 || index > size || index < 0) {
          return nil;
        }

        result = self.slice(index, index + length);
      }
      return toArraySubclass(result, self.$class());
    }
  ;
    
    Opal.def(self, '$[]', $Array_$$$12 = function(index, length) {
      var self = this;

      
      ;
      
      if (index.$$is_range) {
        return $array_slice_range(self, index);
      }
      else {
        return $array_slice_index_length(self, index, length);
      }
    ;
    }, $Array_$$$12.$$arity = -2);
    
    Opal.def(self, '$[]=', $Array_$$$eq$13 = function(index, value, extra) {
      var self = this, data = nil, length = nil;

      
      ;
            var i, size = self.length;;
      if ($truthy($$($nesting, 'Range')['$==='](index))) {
        
        data = (function() {if ($truthy($$($nesting, 'Array')['$==='](value))) {
          return value.$to_a()
        } else if ($truthy(value['$respond_to?']("to_ary"))) {
          return value.$to_ary().$to_a()
        } else {
          return [value]
        }; return nil; })();
        
        var exclude = index.excl,
            from    = $$($nesting, 'Opal').$coerce_to(index.begin, $$($nesting, 'Integer'), "to_int"),
            to      = $$($nesting, 'Opal').$coerce_to(index.end, $$($nesting, 'Integer'), "to_int");

        if (from < 0) {
          from += size;

          if (from < 0) {
            self.$raise($$($nesting, 'RangeError'), "" + (index.$inspect()) + " out of range");
          }
        }

        if (to < 0) {
          to += size;
        }

        if (!exclude) {
          to += 1;
        }

        if (from > size) {
          for (i = size; i < from; i++) {
            self[i] = nil;
          }
        }

        if (to < 0) {
          self.splice.apply(self, [from, 0].concat(data));
        }
        else {
          self.splice.apply(self, [from, to - from].concat(data));
        }

        return value;
      ;
      } else {
        
        if ($truthy(extra === undefined)) {
          length = 1
        } else {
          
          length = value;
          value = extra;
          data = (function() {if ($truthy($$($nesting, 'Array')['$==='](value))) {
            return value.$to_a()
          } else if ($truthy(value['$respond_to?']("to_ary"))) {
            return value.$to_ary().$to_a()
          } else {
            return [value]
          }; return nil; })();
        };
        
        var old;

        index  = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");
        length = $$($nesting, 'Opal').$coerce_to(length, $$($nesting, 'Integer'), "to_int");

        if (index < 0) {
          old    = index;
          index += size;

          if (index < 0) {
            self.$raise($$($nesting, 'IndexError'), "" + "index " + (old) + " too small for array; minimum " + (-self.length));
          }
        }

        if (length < 0) {
          self.$raise($$($nesting, 'IndexError'), "" + "negative length (" + (length) + ")")
        }

        if (index > size) {
          for (i = size; i < index; i++) {
            self[i] = nil;
          }
        }

        if (extra === undefined) {
          self[index] = value;
        }
        else {
          self.splice.apply(self, [index, length].concat(data));
        }

        return value;
      ;
      };
    }, $Array_$$$eq$13.$$arity = -3);
    
    Opal.def(self, '$any?', $Array_any$ques$14 = function(pattern) {
      var $iter = $Array_any$ques$14.$$p, block = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_any$ques$14.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Array_any$ques$14.$$p = null;;
      ;
      if (self.length === 0) return false;
      return $send(self, Opal.find_super_dispatcher(self, 'any?', $Array_any$ques$14, false), $zuper, $iter);
    }, $Array_any$ques$14.$$arity = -1);
    
    Opal.def(self, '$assoc', $Array_assoc$15 = function $$assoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        if (item = self[i], item.length && (item[0])['$=='](object)) {
          return item;
        }
      }

      return nil;
    
    }, $Array_assoc$15.$$arity = 1);
    
    Opal.def(self, '$at', $Array_at$16 = function $$at(index) {
      var self = this;

      
      index = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");
      
      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      return self[index];
    ;
    }, $Array_at$16.$$arity = 1);
    
    Opal.def(self, '$bsearch_index', $Array_bsearch_index$17 = function $$bsearch_index() {
      var $iter = $Array_bsearch_index$17.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_bsearch_index$17.$$p = null;
      
      
      if ($iter) $Array_bsearch_index$17.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("bsearch_index")
      };
      
      var min = 0,
          max = self.length,
          mid,
          val,
          ret,
          smaller = false,
          satisfied = nil;

      while (min < max) {
        mid = min + Math.floor((max - min) / 2);
        val = self[mid];
        ret = Opal.yield1(block, val);

        if (ret === true) {
          satisfied = mid;
          smaller = true;
        }
        else if (ret === false || ret === nil) {
          smaller = false;
        }
        else if (ret.$$is_number) {
          if (ret === 0) { return mid; }
          smaller = (ret < 0);
        }
        else {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((ret).$class()) + " (must be numeric, true, false or nil)")
        }

        if (smaller) { max = mid; } else { min = mid + 1; }
      }

      return satisfied;
    ;
    }, $Array_bsearch_index$17.$$arity = 0);
    
    Opal.def(self, '$bsearch', $Array_bsearch$18 = function $$bsearch() {
      var $iter = $Array_bsearch$18.$$p, block = $iter || nil, self = this, index = nil;

      if ($iter) $Array_bsearch$18.$$p = null;
      
      
      if ($iter) $Array_bsearch$18.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("bsearch")
      };
      index = $send(self, 'bsearch_index', [], block.$to_proc());
      
      if (index != null && index.$$is_number) {
        return self[index];
      } else {
        return index;
      }
    ;
    }, $Array_bsearch$18.$$arity = 0);
    
    Opal.def(self, '$cycle', $Array_cycle$19 = function $$cycle(n) {
      var $iter = $Array_cycle$19.$$p, block = $iter || nil, $$20, $a, self = this;

      if ($iter) $Array_cycle$19.$$p = null;
      
      
      if ($iter) $Array_cycle$19.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["cycle", n], ($$20 = function(){var self = $$20.$$s || this;

        if ($truthy(n['$nil?']())) {
            return $$$($$($nesting, 'Float'), 'INFINITY')
          } else {
            
            n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, $$20.$$s = self, $$20.$$arity = 0, $$20))
      };
      if ($truthy(($truthy($a = self['$empty?']()) ? $a : n['$=='](0)))) {
        return nil};
      
      var i, length, value;

      if (n === nil) {
        while (true) {
          for (i = 0, length = self.length; i < length; i++) {
            value = Opal.yield1(block, self[i]);
          }
        }
      }
      else {
        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
        if (n <= 0) {
          return self;
        }

        while (n > 0) {
          for (i = 0, length = self.length; i < length; i++) {
            value = Opal.yield1(block, self[i]);
          }

          n--;
        }
      }
    ;
      return self;
    }, $Array_cycle$19.$$arity = -1);
    
    Opal.def(self, '$clear', $Array_clear$21 = function $$clear() {
      var self = this;

      
      self.splice(0, self.length);
      return self;
    }, $Array_clear$21.$$arity = 0);
    
    Opal.def(self, '$count', $Array_count$22 = function $$count(object) {
      var $iter = $Array_count$22.$$p, block = $iter || nil, $a, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_count$22.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Array_count$22.$$p = null;;
      
      if (object == null) {
        object = nil;
      };
      if ($truthy(($truthy($a = object) ? $a : block))) {
        return $send(self, Opal.find_super_dispatcher(self, 'count', $Array_count$22, false), $zuper, $iter)
      } else {
        return self.$size()
      };
    }, $Array_count$22.$$arity = -1);
    
    Opal.def(self, '$initialize_copy', $Array_initialize_copy$23 = function $$initialize_copy(other) {
      var self = this;

      return self.$replace(other)
    }, $Array_initialize_copy$23.$$arity = 1);
    
    Opal.def(self, '$collect', $Array_collect$24 = function $$collect() {
      var $iter = $Array_collect$24.$$p, block = $iter || nil, $$25, self = this;

      if ($iter) $Array_collect$24.$$p = null;
      
      
      if ($iter) $Array_collect$24.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect"], ($$25 = function(){var self = $$25.$$s || this;

        return self.$size()}, $$25.$$s = self, $$25.$$arity = 0, $$25))
      };
      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var value = Opal.yield1(block, self[i]);
        result.push(value);
      }

      return result;
    ;
    }, $Array_collect$24.$$arity = 0);
    
    Opal.def(self, '$collect!', $Array_collect$excl$26 = function() {
      var $iter = $Array_collect$excl$26.$$p, block = $iter || nil, $$27, self = this;

      if ($iter) $Array_collect$excl$26.$$p = null;
      
      
      if ($iter) $Array_collect$excl$26.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect!"], ($$27 = function(){var self = $$27.$$s || this;

        return self.$size()}, $$27.$$s = self, $$27.$$arity = 0, $$27))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = Opal.yield1(block, self[i]);
        self[i] = value;
      }
    ;
      return self;
    }, $Array_collect$excl$26.$$arity = 0);
    
    function binomial_coefficient(n, k) {
      if (n === k || k === 0) {
        return 1;
      }

      if (k > 0 && n > k) {
        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k);
      }

      return 0;
    }
  ;
    
    Opal.def(self, '$combination', $Array_combination$28 = function $$combination(n) {
      var $$29, $iter = $Array_combination$28.$$p, $yield = $iter || nil, self = this, num = nil;

      if ($iter) $Array_combination$28.$$p = null;
      
      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["combination", num], ($$29 = function(){var self = $$29.$$s || this;

        return binomial_coefficient(self.length, num)}, $$29.$$s = self, $$29.$$arity = 0, $$29))
      };
      
      var i, length, stack, chosen, lev, done, next;

      if (num === 0) {
        Opal.yield1($yield, [])
      } else if (num === 1) {
        for (i = 0, length = self.length; i < length; i++) {
          Opal.yield1($yield, [self[i]])
        }
      }
      else if (num === self.length) {
        Opal.yield1($yield, self.slice())
      }
      else if (num >= 0 && num < self.length) {
        stack = [];
        for (i = 0; i <= num + 1; i++) {
          stack.push(0);
        }

        chosen = [];
        lev = 0;
        done = false;
        stack[0] = -1;

        while (!done) {
          chosen[lev] = self[stack[lev+1]];
          while (lev < num - 1) {
            lev++;
            next = stack[lev+1] = stack[lev] + 1;
            chosen[lev] = self[next];
          }
          Opal.yield1($yield, chosen.slice())
          lev++;
          do {
            done = (lev === 0);
            stack[lev]++;
            lev--;
          } while ( stack[lev+1] + num === self.length + lev + 1 );
        }
      }
    ;
      return self;
    }, $Array_combination$28.$$arity = 1);
    
    Opal.def(self, '$repeated_combination', $Array_repeated_combination$30 = function $$repeated_combination(n) {
      var $$31, $iter = $Array_repeated_combination$30.$$p, $yield = $iter || nil, self = this, num = nil;

      if ($iter) $Array_repeated_combination$30.$$p = null;
      
      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["repeated_combination", num], ($$31 = function(){var self = $$31.$$s || this;

        return binomial_coefficient(self.length + num - 1, num);}, $$31.$$s = self, $$31.$$arity = 0, $$31))
      };
      
      function iterate(max, from, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = from; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, i, buffer, self);
          buffer.pop();
        }
      }

      if (num >= 0) {
        iterate(num, 0, [], self);
      }
    ;
      return self;
    }, $Array_repeated_combination$30.$$arity = 1);
    
    Opal.def(self, '$compact', $Array_compact$32 = function $$compact() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length, item; i < length; i++) {
        if ((item = self[i]) !== nil) {
          result.push(item);
        }
      }

      return result;
    
    }, $Array_compact$32.$$arity = 0);
    
    Opal.def(self, '$compact!', $Array_compact$excl$33 = function() {
      var self = this;

      
      var original = self.length;

      for (var i = 0, length = self.length; i < length; i++) {
        if (self[i] === nil) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      return self.length === original ? nil : self;
    
    }, $Array_compact$excl$33.$$arity = 0);
    
    Opal.def(self, '$concat', $Array_concat$34 = function $$concat($a) {
      var $post_args, others, $$35, $$36, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      others = $send(others, 'map', [], ($$35 = function(other){var self = $$35.$$s || this;

      
        
        if (other == null) {
          other = nil;
        };
        other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
          return other.$to_a()
        } else {
          return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), "to_ary").$to_a()
        }; return nil; })();
        if ($truthy(other['$equal?'](self))) {
          other = other.$dup()};
        return other;}, $$35.$$s = self, $$35.$$arity = 1, $$35));
      $send(others, 'each', [], ($$36 = function(other){var self = $$36.$$s || this;

      
        
        if (other == null) {
          other = nil;
        };
        
        for (var i = 0, length = other.length; i < length; i++) {
          self.push(other[i]);
        }
      ;}, $$36.$$s = self, $$36.$$arity = 1, $$36));
      return self;
    }, $Array_concat$34.$$arity = -1);
    
    Opal.def(self, '$delete', $Array_delete$37 = function(object) {
      var $iter = $Array_delete$37.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Array_delete$37.$$p = null;
      
      var original = self.length;

      for (var i = 0, length = original; i < length; i++) {
        if ((self[i])['$=='](object)) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      if (self.length === original) {
        if (($yield !== nil)) {
          return Opal.yieldX($yield, []);
        }
        return nil;
      }
      return object;
    
    }, $Array_delete$37.$$arity = 1);
    
    Opal.def(self, '$delete_at', $Array_delete_at$38 = function $$delete_at(index) {
      var self = this;

      
      index = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      var result = self[index];

      self.splice(index, 1);

      return result;
    
    }, $Array_delete_at$38.$$arity = 1);
    
    Opal.def(self, '$delete_if', $Array_delete_if$39 = function $$delete_if() {
      var $iter = $Array_delete_if$39.$$p, block = $iter || nil, $$40, self = this;

      if ($iter) $Array_delete_if$39.$$p = null;
      
      
      if ($iter) $Array_delete_if$39.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["delete_if"], ($$40 = function(){var self = $$40.$$s || this;

        return self.$size()}, $$40.$$s = self, $$40.$$arity = 0, $$40))
      };
      
      for (var i = 0, length = self.length, value; i < length; i++) {
        value = block(self[i]);

        if (value !== false && value !== nil) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }
    ;
      return self;
    }, $Array_delete_if$39.$$arity = 0);
    
    Opal.def(self, '$dig', $Array_dig$41 = function $$dig(idx, $a) {
      var $post_args, idxs, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      idxs = $post_args;;
      item = self['$[]'](idx);
      
      if (item === nil || idxs.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(idxs));
    }, $Array_dig$41.$$arity = -2);
    
    Opal.def(self, '$drop', $Array_drop$42 = function $$drop(number) {
      var self = this;

      
      if (number < 0) {
        self.$raise($$($nesting, 'ArgumentError'))
      }

      return self.slice(number);
    
    }, $Array_drop$42.$$arity = 1);
    
    Opal.def(self, '$dup', $Array_dup$43 = function $$dup() {
      var $iter = $Array_dup$43.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_dup$43.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if (self.$$class === Opal.Array &&
          self.$$class.$allocate.$$pristine &&
          self.$copy_instance_variables.$$pristine &&
          self.$initialize_dup.$$pristine) {
        return self.slice(0);
      }
    ;
      return $send(self, Opal.find_super_dispatcher(self, 'dup', $Array_dup$43, false), $zuper, $iter);
    }, $Array_dup$43.$$arity = 0);
    
    Opal.def(self, '$each', $Array_each$44 = function $$each() {
      var $iter = $Array_each$44.$$p, block = $iter || nil, $$45, self = this;

      if ($iter) $Array_each$44.$$p = null;
      
      
      if ($iter) $Array_each$44.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$45 = function(){var self = $$45.$$s || this;

        return self.$size()}, $$45.$$s = self, $$45.$$arity = 0, $$45))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = Opal.yield1(block, self[i]);
      }
    ;
      return self;
    }, $Array_each$44.$$arity = 0);
    
    Opal.def(self, '$each_index', $Array_each_index$46 = function $$each_index() {
      var $iter = $Array_each_index$46.$$p, block = $iter || nil, $$47, self = this;

      if ($iter) $Array_each_index$46.$$p = null;
      
      
      if ($iter) $Array_each_index$46.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_index"], ($$47 = function(){var self = $$47.$$s || this;

        return self.$size()}, $$47.$$s = self, $$47.$$arity = 0, $$47))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = Opal.yield1(block, i);
      }
    ;
      return self;
    }, $Array_each_index$46.$$arity = 0);
    
    Opal.def(self, '$empty?', $Array_empty$ques$48 = function() {
      var self = this;

      return self.length === 0;
    }, $Array_empty$ques$48.$$arity = 0);
    
    Opal.def(self, '$eql?', $Array_eql$ques$49 = function(other) {
      var self = this;

      
      var recursed = {};

      function _eql(array, other) {
        var i, length, a, b;

        if (!other.$$is_array) {
          return false;
        }

        other = other.$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eql(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eql(self, other);
    
    }, $Array_eql$ques$49.$$arity = 1);
    
    Opal.def(self, '$fetch', $Array_fetch$50 = function $$fetch(index, defaults) {
      var $iter = $Array_fetch$50.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_fetch$50.$$p = null;
      
      
      if ($iter) $Array_fetch$50.$$p = null;;
      ;
      
      var original = index;

      index = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");

      if (index < 0) {
        index += self.length;
      }

      if (index >= 0 && index < self.length) {
        return self[index];
      }

      if (block !== nil && defaults != null) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (block !== nil) {
        return block(original);
      }

      if (defaults != null) {
        return defaults;
      }

      if (self.length === 0) {
        self.$raise($$($nesting, 'IndexError'), "" + "index " + (original) + " outside of array bounds: 0...0")
      }
      else {
        self.$raise($$($nesting, 'IndexError'), "" + "index " + (original) + " outside of array bounds: -" + (self.length) + "..." + (self.length));
      }
    ;
    }, $Array_fetch$50.$$arity = -2);
    
    Opal.def(self, '$fill', $Array_fill$51 = function $$fill($a) {
      var $iter = $Array_fill$51.$$p, block = $iter || nil, $post_args, args, $b, $c, self = this, one = nil, two = nil, obj = nil, left = nil, right = nil;

      if ($iter) $Array_fill$51.$$p = null;
      
      
      if ($iter) $Array_fill$51.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
            var i, length, value;;
      if ($truthy(block)) {
        
        if ($truthy(args.length > 2)) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (args.$length()) + " for 0..2)")};
        $c = args, $b = Opal.to_ary($c), (one = ($b[0] == null ? nil : $b[0])), (two = ($b[1] == null ? nil : $b[1])), $c;
      } else {
        
        if ($truthy(args.length == 0)) {
          self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        } else if ($truthy(args.length > 3)) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (args.$length()) + " for 1..3)")};
        $c = args, $b = Opal.to_ary($c), (obj = ($b[0] == null ? nil : $b[0])), (one = ($b[1] == null ? nil : $b[1])), (two = ($b[2] == null ? nil : $b[2])), $c;
      };
      if ($truthy($$($nesting, 'Range')['$==='](one))) {
        
        if ($truthy(two)) {
          self.$raise($$($nesting, 'TypeError'), "length invalid with range")};
        left = $$($nesting, 'Opal').$coerce_to(one.$begin(), $$($nesting, 'Integer'), "to_int");
        if ($truthy(left < 0)) {
          left += this.length};
        if ($truthy(left < 0)) {
          self.$raise($$($nesting, 'RangeError'), "" + (one.$inspect()) + " out of range")};
        right = $$($nesting, 'Opal').$coerce_to(one.$end(), $$($nesting, 'Integer'), "to_int");
        if ($truthy(right < 0)) {
          right += this.length};
        if ($truthy(one['$exclude_end?']())) {
        } else {
          right += 1
        };
        if ($truthy(right <= left)) {
          return self};
      } else if ($truthy(one)) {
        
        left = $$($nesting, 'Opal').$coerce_to(one, $$($nesting, 'Integer'), "to_int");
        if ($truthy(left < 0)) {
          left += this.length};
        if ($truthy(left < 0)) {
          left = 0};
        if ($truthy(two)) {
          
          right = $$($nesting, 'Opal').$coerce_to(two, $$($nesting, 'Integer'), "to_int");
          if ($truthy(right == 0)) {
            return self};
          right += left;
        } else {
          right = this.length
        };
      } else {
        
        left = 0;
        right = this.length;
      };
      if ($truthy(left > this.length)) {
        
        for (i = this.length; i < right; i++) {
          self[i] = nil;
        }
      };
      if ($truthy(right > this.length)) {
        this.length = right};
      if ($truthy(block)) {
        
        for (length = this.length; left < right; left++) {
          value = block(left);
          self[left] = value;
        }
      
      } else {
        
        for (length = this.length; left < right; left++) {
          self[left] = obj;
        }
      
      };
      return self;
    }, $Array_fill$51.$$arity = -1);
    
    Opal.def(self, '$first', $Array_first$52 = function $$first(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[0];
      }

      count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), "to_int");

      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size");
      }

      return self.slice(0, count);
    ;
    }, $Array_first$52.$$arity = -1);
    
    Opal.def(self, '$flatten', $Array_flatten$53 = function $$flatten(level) {
      var self = this;

      
      ;
      
      function _flatten(array, level) {
        var result = [],
            i, length,
            item, ary;

        array = (array).$to_a();

        for (i = 0, length = array.length; i < length; i++) {
          item = array[i];

          if (!$$($nesting, 'Opal')['$respond_to?'](item, "to_ary", true)) {
            result.push(item);
            continue;
          }

          ary = (item).$to_ary();

          if (ary === nil) {
            result.push(item);
            continue;
          }

          if (!ary.$$is_array) {
            self.$raise($$($nesting, 'TypeError'));
          }

          if (ary === self) {
            self.$raise($$($nesting, 'ArgumentError'));
          }

          switch (level) {
          case undefined:
            result = result.concat(_flatten(ary));
            break;
          case 0:
            result.push(ary);
            break;
          default:
            result.push.apply(result, _flatten(ary, level - 1));
          }
        }
        return result;
      }

      if (level !== undefined) {
        level = $$($nesting, 'Opal').$coerce_to(level, $$($nesting, 'Integer'), "to_int");
      }

      return toArraySubclass(_flatten(self, level), self.$class());
    ;
    }, $Array_flatten$53.$$arity = -1);
    
    Opal.def(self, '$flatten!', $Array_flatten$excl$54 = function(level) {
      var self = this;

      
      ;
      
      var flattened = self.$flatten(level);

      if (self.length == flattened.length) {
        for (var i = 0, length = self.length; i < length; i++) {
          if (self[i] !== flattened[i]) {
            break;
          }
        }

        if (i == length) {
          return nil;
        }
      }

      self.$replace(flattened);
    ;
      return self;
    }, $Array_flatten$excl$54.$$arity = -1);
    
    Opal.def(self, '$hash', $Array_hash$55 = function $$hash() {
      var self = this;

      
      var top = (Opal.hash_ids === undefined),
          result = ['A'],
          hash_id = self.$object_id(),
          item, i, key;

      try {
        if (top) {
          Opal.hash_ids = Object.create(null);
        }

        // return early for recursive structures
        if (Opal.hash_ids[hash_id]) {
          return 'self';
        }

        for (key in Opal.hash_ids) {
          item = Opal.hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        Opal.hash_ids[hash_id] = self;

        for (i = 0; i < self.length; i++) {
          item = self[i];
          result.push(item.$hash());
        }

        return result.join(',');
      } finally {
        if (top) {
          Opal.hash_ids = undefined;
        }
      }
    
    }, $Array_hash$55.$$arity = 0);
    
    Opal.def(self, '$include?', $Array_include$ques$56 = function(member) {
      var self = this;

      
      for (var i = 0, length = self.length; i < length; i++) {
        if ((self[i])['$=='](member)) {
          return true;
        }
      }

      return false;
    
    }, $Array_include$ques$56.$$arity = 1);
    
    Opal.def(self, '$index', $Array_index$57 = function $$index(object) {
      var $iter = $Array_index$57.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_index$57.$$p = null;
      
      
      if ($iter) $Array_index$57.$$p = null;;
      ;
      
      var i, length, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = 0, length = self.length; i < length; i++) {
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = 0, length = self.length; i < length; i++) {
          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else {
        return self.$enum_for("index");
      }

      return nil;
    ;
    }, $Array_index$57.$$arity = -1);
    
    Opal.def(self, '$insert', $Array_insert$58 = function $$insert(index, $a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      objects = $post_args;;
      
      index = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");

      if (objects.length > 0) {
        if (index < 0) {
          index += self.length + 1;

          if (index < 0) {
            self.$raise($$($nesting, 'IndexError'), "" + (index) + " is out of bounds");
          }
        }
        if (index > self.length) {
          for (var i = self.length; i < index; i++) {
            self.push(nil);
          }
        }

        self.splice.apply(self, [index, 0].concat(objects));
      }
    ;
      return self;
    }, $Array_insert$58.$$arity = -2);
    
    Opal.def(self, '$inspect', $Array_inspect$59 = function $$inspect() {
      var self = this;

      
      var result = [],
          id     = self.$__id__();

      for (var i = 0, length = self.length; i < length; i++) {
        var item = self['$[]'](i);

        if ((item).$__id__() === id) {
          result.push('[...]');
        }
        else {
          result.push((item).$inspect());
        }
      }

      return '[' + result.join(', ') + ']';
    
    }, $Array_inspect$59.$$arity = 0);
    
    Opal.def(self, '$join', $Array_join$60 = function $$join(sep) {
      var self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      
      
      if (sep == null) {
        sep = nil;
      };
      if ($truthy(self.length === 0)) {
        return ""};
      if ($truthy(sep === nil)) {
        sep = $gvars[","]};
      
      var result = [];
      var i, length, item, tmp;

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];

        if ($$($nesting, 'Opal')['$respond_to?'](item, "to_str")) {
          tmp = (item).$to_str();

          if (tmp !== nil) {
            result.push((tmp).$to_s());

            continue;
          }
        }

        if ($$($nesting, 'Opal')['$respond_to?'](item, "to_ary")) {
          tmp = (item).$to_ary();

          if (tmp === self) {
            self.$raise($$($nesting, 'ArgumentError'));
          }

          if (tmp !== nil) {
            result.push((tmp).$join(sep));

            continue;
          }
        }

        if ($$($nesting, 'Opal')['$respond_to?'](item, "to_s")) {
          tmp = (item).$to_s();

          if (tmp !== nil) {
            result.push(tmp);

            continue;
          }
        }

        self.$raise($$($nesting, 'NoMethodError').$new("" + (Opal.inspect(item)) + " doesn't respond to #to_str, #to_ary or #to_s", "to_str"));
      }

      if (sep === nil) {
        return result.join('');
      }
      else {
        return result.join($$($nesting, 'Opal')['$coerce_to!'](sep, $$($nesting, 'String'), "to_str").$to_s());
      }
    ;
    }, $Array_join$60.$$arity = -1);
    
    Opal.def(self, '$keep_if', $Array_keep_if$61 = function $$keep_if() {
      var $iter = $Array_keep_if$61.$$p, block = $iter || nil, $$62, self = this;

      if ($iter) $Array_keep_if$61.$$p = null;
      
      
      if ($iter) $Array_keep_if$61.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["keep_if"], ($$62 = function(){var self = $$62.$$s || this;

        return self.$size()}, $$62.$$s = self, $$62.$$arity = 0, $$62))
      };
      
      for (var i = 0, length = self.length, value; i < length; i++) {
        value = block(self[i]);

        if (value === false || value === nil) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }
    ;
      return self;
    }, $Array_keep_if$61.$$arity = 0);
    
    Opal.def(self, '$last', $Array_last$63 = function $$last(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[self.length - 1];
      }

      count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), "to_int");

      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size");
      }

      if (count > self.length) {
        count = self.length;
      }

      return self.slice(self.length - count, self.length);
    ;
    }, $Array_last$63.$$arity = -1);
    
    Opal.def(self, '$length', $Array_length$64 = function $$length() {
      var self = this;

      return self.length;
    }, $Array_length$64.$$arity = 0);
    Opal.alias(self, "map", "collect");
    Opal.alias(self, "map!", "collect!");
    
    Opal.def(self, '$max', $Array_max$65 = function $$max(n) {
      var $iter = $Array_max$65.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_max$65.$$p = null;
      
      
      if ($iter) $Array_max$65.$$p = null;;
      ;
      return $send(self.$each(), 'max', [n], block.$to_proc());
    }, $Array_max$65.$$arity = -1);
    
    Opal.def(self, '$min', $Array_min$66 = function $$min() {
      var $iter = $Array_min$66.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_min$66.$$p = null;
      
      
      if ($iter) $Array_min$66.$$p = null;;
      return $send(self.$each(), 'min', [], block.$to_proc());
    }, $Array_min$66.$$arity = 0);
    
    // Returns the product of from, from-1, ..., from - how_many + 1.
    function descending_factorial(from, how_many) {
      var count = how_many >= 0 ? 1 : 0;
      while (how_many) {
        count *= from;
        from--;
        how_many--;
      }
      return count;
    }
  ;
    
    Opal.def(self, '$permutation', $Array_permutation$67 = function $$permutation(num) {
      var $iter = $Array_permutation$67.$$p, block = $iter || nil, $$68, self = this, perm = nil, used = nil;

      if ($iter) $Array_permutation$67.$$p = null;
      
      
      if ($iter) $Array_permutation$67.$$p = null;;
      ;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["permutation", num], ($$68 = function(){var self = $$68.$$s || this;

        return descending_factorial(self.length, num === undefined ? self.length : num);}, $$68.$$s = self, $$68.$$arity = 0, $$68))
      };
      
      var permute, offensive, output;

      if (num === undefined) {
        num = self.length;
      }
      else {
        num = $$($nesting, 'Opal').$coerce_to(num, $$($nesting, 'Integer'), "to_int")
      }

      if (num < 0 || self.length < num) {
        // no permutations, yield nothing
      }
      else if (num === 0) {
        // exactly one permutation: the zero-length array
        Opal.yield1(block, [])
      }
      else if (num === 1) {
        // this is a special, easy case
        for (var i = 0; i < self.length; i++) {
          Opal.yield1(block, [self[i]])
        }
      }
      else {
        // this is the general case
        (perm = $$($nesting, 'Array').$new(num));
        (used = $$($nesting, 'Array').$new(self.length, false));

        permute = function(num, perm, index, used, blk) {
          self = this;
          for(var i = 0; i < self.length; i++){
            if(used['$[]'](i)['$!']()) {
              perm[index] = i;
              if(index < num - 1) {
                used[i] = true;
                permute.call(self, num, perm, index + 1, used, blk);
                used[i] = false;
              }
              else {
                output = [];
                for (var j = 0; j < perm.length; j++) {
                  output.push(self[perm[j]]);
                }
                Opal.yield1(blk, output);
              }
            }
          }
        }

        if ((block !== nil)) {
          // offensive (both definitions) copy.
          offensive = self.slice();
          permute.call(offensive, num, perm, 0, used, block);
        }
        else {
          permute.call(self, num, perm, 0, used, block);
        }
      }
    ;
      return self;
    }, $Array_permutation$67.$$arity = -1);
    
    Opal.def(self, '$repeated_permutation', $Array_repeated_permutation$69 = function $$repeated_permutation(n) {
      var $$70, $iter = $Array_repeated_permutation$69.$$p, $yield = $iter || nil, self = this, num = nil;

      if ($iter) $Array_repeated_permutation$69.$$p = null;
      
      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["repeated_permutation", num], ($$70 = function(){var self = $$70.$$s || this;

        if ($truthy($rb_ge(num, 0))) {
            return self.$size()['$**'](num)
          } else {
            return 0
          }}, $$70.$$s = self, $$70.$$arity = 0, $$70))
      };
      
      function iterate(max, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = 0; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, buffer, self);
          buffer.pop();
        }
      }

      iterate(num, [], self.slice());
    ;
      return self;
    }, $Array_repeated_permutation$69.$$arity = 1);
    
    Opal.def(self, '$pop', $Array_pop$71 = function $$pop(count) {
      var self = this;

      
      ;
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil};
        return self.pop();};
      count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), "to_int");
      if ($truthy(count < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size")};
      if ($truthy(self.length === 0)) {
        return []};
      if ($truthy(count > self.length)) {
        return self.splice(0, self.length);
      } else {
        return self.splice(self.length - count, self.length);
      };
    }, $Array_pop$71.$$arity = -1);
    
    Opal.def(self, '$product', $Array_product$72 = function $$product($a) {
      var $iter = $Array_product$72.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Array_product$72.$$p = null;
      
      
      if ($iter) $Array_product$72.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var result = (block !== nil) ? null : [],
          n = args.length + 1,
          counters = new Array(n),
          lengths  = new Array(n),
          arrays   = new Array(n),
          i, m, subarray, len, resultlen = 1;

      arrays[0] = self;
      for (i = 1; i < n; i++) {
        arrays[i] = $$($nesting, 'Opal').$coerce_to(args[i - 1], $$($nesting, 'Array'), "to_ary");
      }

      for (i = 0; i < n; i++) {
        len = arrays[i].length;
        if (len === 0) {
          return result || self;
        }
        resultlen *= len;
        if (resultlen > 2147483647) {
          self.$raise($$($nesting, 'RangeError'), "too big to product")
        }
        lengths[i] = len;
        counters[i] = 0;
      }

      outer_loop: for (;;) {
        subarray = [];
        for (i = 0; i < n; i++) {
          subarray.push(arrays[i][counters[i]]);
        }
        if (result) {
          result.push(subarray);
        } else {
          Opal.yield1(block, subarray)
        }
        m = n - 1;
        counters[m]++;
        while (counters[m] === lengths[m]) {
          counters[m] = 0;
          if (--m < 0) break outer_loop;
          counters[m]++;
        }
      }

      return result || self;
    ;
    }, $Array_product$72.$$arity = -1);
    
    Opal.def(self, '$push', $Array_push$73 = function $$push($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      objects = $post_args;;
      
      for (var i = 0, length = objects.length; i < length; i++) {
        self.push(objects[i]);
      }
    ;
      return self;
    }, $Array_push$73.$$arity = -1);
    Opal.alias(self, "append", "push");
    
    Opal.def(self, '$rassoc', $Array_rassoc$74 = function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        item = self[i];

        if (item.length && item[1] !== undefined) {
          if ((item[1])['$=='](object)) {
            return item;
          }
        }
      }

      return nil;
    
    }, $Array_rassoc$74.$$arity = 1);
    
    Opal.def(self, '$reject', $Array_reject$75 = function $$reject() {
      var $iter = $Array_reject$75.$$p, block = $iter || nil, $$76, self = this;

      if ($iter) $Array_reject$75.$$p = null;
      
      
      if ($iter) $Array_reject$75.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reject"], ($$76 = function(){var self = $$76.$$s || this;

        return self.$size()}, $$76.$$s = self, $$76.$$arity = 0, $$76))
      };
      
      var result = [];

      for (var i = 0, length = self.length, value; i < length; i++) {
        value = block(self[i]);

        if (value === false || value === nil) {
          result.push(self[i]);
        }
      }
      return result;
    ;
    }, $Array_reject$75.$$arity = 0);
    
    Opal.def(self, '$reject!', $Array_reject$excl$77 = function() {
      var $iter = $Array_reject$excl$77.$$p, block = $iter || nil, $$78, self = this, original = nil;

      if ($iter) $Array_reject$excl$77.$$p = null;
      
      
      if ($iter) $Array_reject$excl$77.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reject!"], ($$78 = function(){var self = $$78.$$s || this;

        return self.$size()}, $$78.$$s = self, $$78.$$arity = 0, $$78))
      };
      original = self.$length();
      $send(self, 'delete_if', [], block.$to_proc());
      if (self.$length()['$=='](original)) {
        return nil
      } else {
        return self
      };
    }, $Array_reject$excl$77.$$arity = 0);
    
    Opal.def(self, '$replace', $Array_replace$79 = function $$replace(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return $$($nesting, 'Opal').$coerce_to(other, $$($nesting, 'Array'), "to_ary").$to_a()
      }; return nil; })();
      
      self.splice(0, self.length);
      self.push.apply(self, other);
    ;
      return self;
    }, $Array_replace$79.$$arity = 1);
    
    Opal.def(self, '$reverse', $Array_reverse$80 = function $$reverse() {
      var self = this;

      return self.slice(0).reverse();
    }, $Array_reverse$80.$$arity = 0);
    
    Opal.def(self, '$reverse!', $Array_reverse$excl$81 = function() {
      var self = this;

      return self.reverse();
    }, $Array_reverse$excl$81.$$arity = 0);
    
    Opal.def(self, '$reverse_each', $Array_reverse_each$82 = function $$reverse_each() {
      var $iter = $Array_reverse_each$82.$$p, block = $iter || nil, $$83, self = this;

      if ($iter) $Array_reverse_each$82.$$p = null;
      
      
      if ($iter) $Array_reverse_each$82.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reverse_each"], ($$83 = function(){var self = $$83.$$s || this;

        return self.$size()}, $$83.$$s = self, $$83.$$arity = 0, $$83))
      };
      $send(self.$reverse(), 'each', [], block.$to_proc());
      return self;
    }, $Array_reverse_each$82.$$arity = 0);
    
    Opal.def(self, '$rindex', $Array_rindex$84 = function $$rindex(object) {
      var $iter = $Array_rindex$84.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_rindex$84.$$p = null;
      
      
      if ($iter) $Array_rindex$84.$$p = null;;
      ;
      
      var i, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }

          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else if (object == null) {
        return self.$enum_for("rindex");
      }

      return nil;
    ;
    }, $Array_rindex$84.$$arity = -1);
    
    Opal.def(self, '$rotate', $Array_rotate$85 = function $$rotate(n) {
      var self = this;

      
      
      if (n == null) {
        n = 1;
      };
      n = $$($nesting, 'Opal').$coerce_to(n, $$($nesting, 'Integer'), "to_int");
      
      var ary, idx, firstPart, lastPart;

      if (self.length === 1) {
        return self.slice();
      }
      if (self.length === 0) {
        return [];
      }

      ary = self.slice();
      idx = n % ary.length;

      firstPart = ary.slice(idx);
      lastPart = ary.slice(0, idx);
      return firstPart.concat(lastPart);
    ;
    }, $Array_rotate$85.$$arity = -1);
    
    Opal.def(self, '$rotate!', $Array_rotate$excl$86 = function(cnt) {
      var self = this, ary = nil;

      
      
      if (cnt == null) {
        cnt = 1;
      };
      
      if (self.length === 0 || self.length === 1) {
        return self;
      }
    ;
      cnt = $$($nesting, 'Opal').$coerce_to(cnt, $$($nesting, 'Integer'), "to_int");
      ary = self.$rotate(cnt);
      return self.$replace(ary);
    }, $Array_rotate$excl$86.$$arity = -1);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'SampleRandom');

      var $nesting = [self].concat($parent_nesting), $SampleRandom_initialize$87, $SampleRandom_rand$88;

      self.$$prototype.rng = nil;
      
      
      Opal.def(self, '$initialize', $SampleRandom_initialize$87 = function $$initialize(rng) {
        var self = this;

        return (self.rng = rng)
      }, $SampleRandom_initialize$87.$$arity = 1);
      return (Opal.def(self, '$rand', $SampleRandom_rand$88 = function $$rand(size) {
        var self = this, random = nil;

        
        random = $$($nesting, 'Opal').$coerce_to(self.rng.$rand(size), $$($nesting, 'Integer'), "to_int");
        if ($truthy(random < 0)) {
          self.$raise($$($nesting, 'RangeError'), "random value must be >= 0")};
        if ($truthy(random < size)) {
        } else {
          self.$raise($$($nesting, 'RangeError'), "random value must be less than Array size")
        };
        return random;
      }, $SampleRandom_rand$88.$$arity = 1), nil) && 'rand';
    })($nesting[0], null, $nesting);
    
    Opal.def(self, '$sample', $Array_sample$89 = function $$sample(count, options) {
      var $a, self = this, o = nil, rng = nil;

      
      ;
      ;
      if ($truthy(count === undefined)) {
        return self.$at($$($nesting, 'Kernel').$rand(self.length))};
      if ($truthy(options === undefined)) {
        if ($truthy((o = $$($nesting, 'Opal')['$coerce_to?'](count, $$($nesting, 'Hash'), "to_hash")))) {
          
          options = o;
          count = nil;
        } else {
          
          options = nil;
          count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), "to_int");
        }
      } else {
        
        count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), "to_int");
        options = $$($nesting, 'Opal').$coerce_to(options, $$($nesting, 'Hash'), "to_hash");
      };
      if ($truthy(($truthy($a = count) ? count < 0 : $a))) {
        self.$raise($$($nesting, 'ArgumentError'), "count must be greater than 0")};
      if ($truthy(options)) {
        rng = options['$[]']("random")};
      rng = (function() {if ($truthy(($truthy($a = rng) ? rng['$respond_to?']("rand") : $a))) {
        return $$($nesting, 'SampleRandom').$new(rng)
      } else {
        return $$($nesting, 'Kernel')
      }; return nil; })();
      if ($truthy(count)) {
      } else {
        return self[rng.$rand(self.length)]
      };
      

      var abandon, spin, result, i, j, k, targetIndex, oldValue;

      if (count > self.length) {
        count = self.length;
      }

      switch (count) {
        case 0:
          return [];
          break;
        case 1:
          return [self[rng.$rand(self.length)]];
          break;
        case 2:
          i = rng.$rand(self.length);
          j = rng.$rand(self.length);
          if (i === j) {
            j = i === 0 ? i + 1 : i - 1;
          }
          return [self[i], self[j]];
          break;
        default:
          if (self.length / count > 3) {
            abandon = false;
            spin = 0;

            result = $$($nesting, 'Array').$new(count);
            i = 1;

            result[0] = rng.$rand(self.length);
            while (i < count) {
              k = rng.$rand(self.length);
              j = 0;

              while (j < i) {
                while (k === result[j]) {
                  spin++;
                  if (spin > 100) {
                    abandon = true;
                    break;
                  }
                  k = rng.$rand(self.length);
                }
                if (abandon) { break; }

                j++;
              }

              if (abandon) { break; }

              result[i] = k;

              i++;
            }

            if (!abandon) {
              i = 0;
              while (i < count) {
                result[i] = self[result[i]];
                i++;
              }

              return result;
            }
          }

          result = self.slice();

          for (var c = 0; c < count; c++) {
            targetIndex = rng.$rand(self.length);
            oldValue = result[c];
            result[c] = result[targetIndex];
            result[targetIndex] = oldValue;
          }

          return count === self.length ? result : (result)['$[]'](0, count);
      }
    ;
    }, $Array_sample$89.$$arity = -1);
    
    Opal.def(self, '$select', $Array_select$90 = function $$select() {
      var $iter = $Array_select$90.$$p, block = $iter || nil, $$91, self = this;

      if ($iter) $Array_select$90.$$p = null;
      
      
      if ($iter) $Array_select$90.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["select"], ($$91 = function(){var self = $$91.$$s || this;

        return self.$size()}, $$91.$$s = self, $$91.$$arity = 0, $$91))
      };
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = Opal.yield1(block, item);

        if (Opal.truthy(value)) {
          result.push(item);
        }
      }

      return result;
    ;
    }, $Array_select$90.$$arity = 0);
    
    Opal.def(self, '$select!', $Array_select$excl$92 = function() {
      var $iter = $Array_select$excl$92.$$p, block = $iter || nil, $$93, self = this;

      if ($iter) $Array_select$excl$92.$$p = null;
      
      
      if ($iter) $Array_select$excl$92.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["select!"], ($$93 = function(){var self = $$93.$$s || this;

        return self.$size()}, $$93.$$s = self, $$93.$$arity = 0, $$93))
      };
      
      var original = self.length;
      $send(self, 'keep_if', [], block.$to_proc());
      return self.length === original ? nil : self;
    ;
    }, $Array_select$excl$92.$$arity = 0);
    
    Opal.def(self, '$shift', $Array_shift$94 = function $$shift(count) {
      var self = this;

      
      ;
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil};
        return shiftNoArg(self);};
      count = $$($nesting, 'Opal').$coerce_to(count, $$($nesting, 'Integer'), "to_int");
      if ($truthy(count < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size")};
      if ($truthy(self.length === 0)) {
        return []};
      return self.splice(0, count);;
    }, $Array_shift$94.$$arity = -1);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$shuffle', $Array_shuffle$95 = function $$shuffle(rng) {
      var self = this;

      
      ;
      return self.$dup().$to_a()['$shuffle!'](rng);
    }, $Array_shuffle$95.$$arity = -1);
    
    Opal.def(self, '$shuffle!', $Array_shuffle$excl$96 = function(rng) {
      var self = this;

      
      ;
      
      var randgen, i = self.length, j, tmp;

      if (rng !== undefined) {
        rng = $$($nesting, 'Opal')['$coerce_to?'](rng, $$($nesting, 'Hash'), "to_hash");

        if (rng !== nil) {
          rng = rng['$[]']("random");

          if (rng !== nil && rng['$respond_to?']("rand")) {
            randgen = rng;
          }
        }
      }

      while (i) {
        if (randgen) {
          j = randgen.$rand(i).$to_int();

          if (j < 0) {
            self.$raise($$($nesting, 'RangeError'), "" + "random number too small " + (j))
          }

          if (j >= i) {
            self.$raise($$($nesting, 'RangeError'), "" + "random number too big " + (j))
          }
        }
        else {
          j = self.$rand(i);
        }

        tmp = self[--i];
        self[i] = self[j];
        self[j] = tmp;
      }

      return self;
    ;
    }, $Array_shuffle$excl$96.$$arity = -1);
    Opal.alias(self, "slice", "[]");
    
    Opal.def(self, '$slice!', $Array_slice$excl$97 = function(index, length) {
      var self = this, result = nil, range = nil, range_start = nil, range_end = nil, start = nil;

      
      ;
      result = nil;
      if ($truthy(length === undefined)) {
        if ($truthy($$($nesting, 'Range')['$==='](index))) {
          
          range = index;
          result = self['$[]'](range);
          range_start = $$($nesting, 'Opal').$coerce_to(range.$begin(), $$($nesting, 'Integer'), "to_int");
          range_end = $$($nesting, 'Opal').$coerce_to(range.$end(), $$($nesting, 'Integer'), "to_int");
          
          if (range_start < 0) {
            range_start += self.length;
          }

          if (range_end < 0) {
            range_end += self.length;
          } else if (range_end >= self.length) {
            range_end = self.length - 1;
            if (range.excl) {
              range_end += 1;
            }
          }

          var range_length = range_end - range_start;
          if (range.excl) {
            range_end -= 1;
          } else {
            range_length += 1;
          }

          if (range_start < self.length && range_start >= 0 && range_end < self.length && range_end >= 0 && range_length > 0) {
            self.splice(range_start, range_length);
          }
        ;
        } else {
          
          start = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");
          
          if (start < 0) {
            start += self.length;
          }

          if (start < 0 || start >= self.length) {
            return nil;
          }

          result = self[start];

          if (start === 0) {
            self.shift();
          } else {
            self.splice(start, 1);
          }
        ;
        }
      } else {
        
        start = $$($nesting, 'Opal').$coerce_to(index, $$($nesting, 'Integer'), "to_int");
        length = $$($nesting, 'Opal').$coerce_to(length, $$($nesting, 'Integer'), "to_int");
        
        if (length < 0) {
          return nil;
        }

        var end = start + length;

        result = self['$[]'](start, length);

        if (start < 0) {
          start += self.length;
        }

        if (start + length > self.length) {
          length = self.length - start;
        }

        if (start < self.length && start >= 0) {
          self.splice(start, length);
        }
      ;
      };
      return result;
    }, $Array_slice$excl$97.$$arity = -2);
    
    Opal.def(self, '$sort', $Array_sort$98 = function $$sort() {
      var $iter = $Array_sort$98.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_sort$98.$$p = null;
      
      
      if ($iter) $Array_sort$98.$$p = null;;
      if ($truthy(self.length > 1)) {
      } else {
        return self
      };
      
      if (block === nil) {
        block = function(a, b) {
          return (a)['$<=>'](b);
        };
      }

      return self.slice().sort(function(x, y) {
        var ret = block(x, y);

        if (ret === nil) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + ((x).$inspect()) + " with " + ((y).$inspect()) + " failed");
        }

        return $rb_gt(ret, 0) ? 1 : ($rb_lt(ret, 0) ? -1 : 0);
      });
    ;
    }, $Array_sort$98.$$arity = 0);
    
    Opal.def(self, '$sort!', $Array_sort$excl$99 = function() {
      var $iter = $Array_sort$excl$99.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_sort$excl$99.$$p = null;
      
      
      if ($iter) $Array_sort$excl$99.$$p = null;;
      
      var result;

      if ((block !== nil)) {
        result = $send((self.slice()), 'sort', [], block.$to_proc());
      }
      else {
        result = (self.slice()).$sort();
      }

      self.length = 0;
      for(var i = 0, length = result.length; i < length; i++) {
        self.push(result[i]);
      }

      return self;
    ;
    }, $Array_sort$excl$99.$$arity = 0);
    
    Opal.def(self, '$sort_by!', $Array_sort_by$excl$100 = function() {
      var $iter = $Array_sort_by$excl$100.$$p, block = $iter || nil, $$101, self = this;

      if ($iter) $Array_sort_by$excl$100.$$p = null;
      
      
      if ($iter) $Array_sort_by$excl$100.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["sort_by!"], ($$101 = function(){var self = $$101.$$s || this;

        return self.$size()}, $$101.$$s = self, $$101.$$arity = 0, $$101))
      };
      return self.$replace($send(self, 'sort_by', [], block.$to_proc()));
    }, $Array_sort_by$excl$100.$$arity = 0);
    
    Opal.def(self, '$take', $Array_take$102 = function $$take(count) {
      var self = this;

      
      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'));
      }

      return self.slice(0, count);
    
    }, $Array_take$102.$$arity = 1);
    
    Opal.def(self, '$take_while', $Array_take_while$103 = function $$take_while() {
      var $iter = $Array_take_while$103.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_take_while$103.$$p = null;
      
      
      if ($iter) $Array_take_while$103.$$p = null;;
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = block(item);

        if (value === false || value === nil) {
          return result;
        }

        result.push(item);
      }

      return result;
    ;
    }, $Array_take_while$103.$$arity = 0);
    
    Opal.def(self, '$to_a', $Array_to_a$104 = function $$to_a() {
      var self = this;

      return self
    }, $Array_to_a$104.$$arity = 0);
    Opal.alias(self, "to_ary", "to_a");
    
    Opal.def(self, '$to_h', $Array_to_h$105 = function $$to_h() {
      var self = this;

      
      var i, len = self.length, ary, key, val, hash = $hash2([], {});

      for (i = 0; i < len; i++) {
        ary = $$($nesting, 'Opal')['$coerce_to?'](self[i], $$($nesting, 'Array'), "to_ary");
        if (!ary.$$is_array) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong element type " + ((ary).$class()) + " at " + (i) + " (expected array)")
        }
        if (ary.length !== 2) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong array length at " + (i) + " (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];
        Opal.hash_put(hash, key, val);
      }

      return hash;
    
    }, $Array_to_h$105.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$transpose', $Array_transpose$106 = function $$transpose() {
      var $$107, self = this, result = nil, max = nil;

      
      if ($truthy(self['$empty?']())) {
        return []};
      result = [];
      max = nil;
      $send(self, 'each', [], ($$107 = function(row){var self = $$107.$$s || this, $a, $$108;

      
        
        if (row == null) {
          row = nil;
        };
        row = (function() {if ($truthy($$($nesting, 'Array')['$==='](row))) {
          return row.$to_a()
        } else {
          return $$($nesting, 'Opal').$coerce_to(row, $$($nesting, 'Array'), "to_ary").$to_a()
        }; return nil; })();
        max = ($truthy($a = max) ? $a : row.length);
        if ($truthy((row.length)['$!='](max))) {
          self.$raise($$($nesting, 'IndexError'), "" + "element size differs (" + (row.length) + " should be " + (max) + ")")};
        return $send((row.length), 'times', [], ($$108 = function(i){var self = $$108.$$s || this, $b, entry = nil, $writer = nil;

        
          
          if (i == null) {
            i = nil;
          };
          entry = ($truthy($b = result['$[]'](i)) ? $b : (($writer = [i, []]), $send(result, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]));
          return entry['$<<'](row.$at(i));}, $$108.$$s = self, $$108.$$arity = 1, $$108));}, $$107.$$s = self, $$107.$$arity = 1, $$107));
      return result;
    }, $Array_transpose$106.$$arity = 0);
    
    Opal.def(self, '$uniq', $Array_uniq$109 = function $$uniq() {
      var $iter = $Array_uniq$109.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_uniq$109.$$p = null;
      
      
      if ($iter) $Array_uniq$109.$$p = null;;
      
      var hash = $hash2([], {}), i, length, item, key;

      if (block === nil) {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          if (Opal.hash_get(hash, item) === undefined) {
            Opal.hash_put(hash, item, item);
          }
        }
      }
      else {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          key = Opal.yield1(block, item);
          if (Opal.hash_get(hash, key) === undefined) {
            Opal.hash_put(hash, key, item);
          }
        }
      }

      return toArraySubclass((hash).$values(), self.$class());
    ;
    }, $Array_uniq$109.$$arity = 0);
    
    Opal.def(self, '$uniq!', $Array_uniq$excl$110 = function() {
      var $iter = $Array_uniq$excl$110.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_uniq$excl$110.$$p = null;
      
      
      if ($iter) $Array_uniq$excl$110.$$p = null;;
      
      var original_length = self.length, hash = $hash2([], {}), i, length, item, key;

      for (i = 0, length = original_length; i < length; i++) {
        item = self[i];
        key = (block === nil ? item : Opal.yield1(block, item));

        if (Opal.hash_get(hash, key) === undefined) {
          Opal.hash_put(hash, key, item);
          continue;
        }

        self.splice(i, 1);
        length--;
        i--;
      }

      return self.length === original_length ? nil : self;
    ;
    }, $Array_uniq$excl$110.$$arity = 0);
    
    Opal.def(self, '$unshift', $Array_unshift$111 = function $$unshift($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      objects = $post_args;;
      
      for (var i = objects.length - 1; i >= 0; i--) {
        self.unshift(objects[i]);
      }
    ;
      return self;
    }, $Array_unshift$111.$$arity = -1);
    Opal.alias(self, "prepend", "unshift");
    
    Opal.def(self, '$values_at', $Array_values_at$112 = function $$values_at($a) {
      var $post_args, args, $$113, self = this, out = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      out = [];
      $send(args, 'each', [], ($$113 = function(elem){var self = $$113.$$s || this, $$114, finish = nil, start = nil, i = nil;

      
        
        if (elem == null) {
          elem = nil;
        };
        if ($truthy(elem['$is_a?']($$($nesting, 'Range')))) {
          
          finish = $$($nesting, 'Opal').$coerce_to(elem.$last(), $$($nesting, 'Integer'), "to_int");
          start = $$($nesting, 'Opal').$coerce_to(elem.$first(), $$($nesting, 'Integer'), "to_int");
          
          if (start < 0) {
            start = start + self.length;
            return nil;;
          }
        ;
          
          if (finish < 0) {
            finish = finish + self.length;
          }
          if (elem['$exclude_end?']()) {
            finish--;
          }
          if (finish < start) {
            return nil;;
          }
        ;
          return $send(start, 'upto', [finish], ($$114 = function(i){var self = $$114.$$s || this;

          
            
            if (i == null) {
              i = nil;
            };
            return out['$<<'](self.$at(i));}, $$114.$$s = self, $$114.$$arity = 1, $$114));
        } else {
          
          i = $$($nesting, 'Opal').$coerce_to(elem, $$($nesting, 'Integer'), "to_int");
          return out['$<<'](self.$at(i));
        };}, $$113.$$s = self, $$113.$$arity = 1, $$113));
      return out;
    }, $Array_values_at$112.$$arity = -1);
    
    Opal.def(self, '$zip', $Array_zip$115 = function $$zip($a) {
      var $iter = $Array_zip$115.$$p, block = $iter || nil, $post_args, others, $b, self = this;

      if ($iter) $Array_zip$115.$$p = null;
      
      
      if ($iter) $Array_zip$115.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      
      var result = [], size = self.length, part, o, i, j, jj;

      for (j = 0, jj = others.length; j < jj; j++) {
        o = others[j];
        if (o.$$is_array) {
          continue;
        }
        if (o.$$is_enumerator) {
          if (o.$size() === Infinity) {
            others[j] = o.$take(size);
          } else {
            others[j] = o.$to_a();
          }
          continue;
        }
        others[j] = ($truthy($b = $$($nesting, 'Opal')['$coerce_to?'](o, $$($nesting, 'Array'), "to_ary")) ? $b : $$($nesting, 'Opal')['$coerce_to!'](o, $$($nesting, 'Enumerator'), "each")).$to_a();
      }

      for (i = 0; i < size; i++) {
        part = [self[i]];

        for (j = 0, jj = others.length; j < jj; j++) {
          o = others[j][i];

          if (o == null) {
            o = nil;
          }

          part[j + 1] = o;
        }

        result[i] = part;
      }

      if (block !== nil) {
        for (i = 0; i < size; i++) {
          block(result[i]);
        }

        return nil;
      }

      return result;
    ;
    }, $Array_zip$115.$$arity = -1);
    Opal.defs(self, '$inherited', $Array_inherited$116 = function $$inherited(klass) {
      var self = this;

      
      klass.$$prototype.$to_a = function() {
        return this.slice(0, this.length);
      }
    
    }, $Array_inherited$116.$$arity = 1);
    
    Opal.def(self, '$instance_variables', $Array_instance_variables$117 = function $$instance_variables() {
      var $$118, $iter = $Array_instance_variables$117.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_instance_variables$117.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      return $send($send(self, Opal.find_super_dispatcher(self, 'instance_variables', $Array_instance_variables$117, false), $zuper, $iter), 'reject', [], ($$118 = function(ivar){var self = $$118.$$s || this, $a;

      
        
        if (ivar == null) {
          ivar = nil;
        };
        return ($truthy($a = /^@\d+$/.test(ivar)) ? $a : ivar['$==']("@length"));}, $$118.$$s = self, $$118.$$arity = 1, $$118))
    }, $Array_instance_variables$117.$$arity = 0);
    $$($nesting, 'Opal').$pristine(self.$singleton_class(), "allocate");
    $$($nesting, 'Opal').$pristine(self, "copy_instance_variables", "initialize_dup");
    return (Opal.def(self, '$pack', $Array_pack$119 = function $$pack($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self.$raise("To use Array#pack, you must first require 'corelib/array/pack'.");
    }, $Array_pack$119.$$arity = -1), nil) && 'pack';
  })($nesting[0], Array, $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/hash"] = function(Opal) {
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$require', '$include', '$coerce_to?', '$[]', '$merge!', '$allocate', '$raise', '$coerce_to!', '$each', '$fetch', '$>=', '$>', '$==', '$compare_by_identity', '$lambda?', '$abs', '$arity', '$enum_for', '$size', '$respond_to?', '$class', '$dig', '$new', '$inspect', '$map', '$to_proc', '$flatten', '$eql?', '$default', '$dup', '$default_proc', '$default_proc=', '$-', '$default=', '$proc']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $Hash_$$$1, $Hash_allocate$2, $Hash_try_convert$3, $Hash_initialize$4, $Hash_$eq_eq$5, $Hash_$gt_eq$6, $Hash_$gt$8, $Hash_$lt$9, $Hash_$lt_eq$10, $Hash_$$$11, $Hash_$$$eq$12, $Hash_assoc$13, $Hash_clear$14, $Hash_clone$15, $Hash_compact$16, $Hash_compact$excl$17, $Hash_compare_by_identity$18, $Hash_compare_by_identity$ques$19, $Hash_default$20, $Hash_default$eq$21, $Hash_default_proc$22, $Hash_default_proc$eq$23, $Hash_delete$24, $Hash_delete_if$25, $Hash_dig$27, $Hash_each$28, $Hash_each_key$30, $Hash_each_value$32, $Hash_empty$ques$34, $Hash_fetch$35, $Hash_fetch_values$36, $Hash_flatten$38, $Hash_has_key$ques$39, $Hash_has_value$ques$40, $Hash_hash$41, $Hash_index$42, $Hash_indexes$43, $Hash_inspect$44, $Hash_invert$45, $Hash_keep_if$46, $Hash_keys$48, $Hash_length$49, $Hash_merge$50, $Hash_merge$excl$51, $Hash_rassoc$52, $Hash_rehash$53, $Hash_reject$54, $Hash_reject$excl$56, $Hash_replace$58, $Hash_select$59, $Hash_select$excl$61, $Hash_shift$63, $Hash_slice$64, $Hash_to_a$65, $Hash_to_h$66, $Hash_to_hash$67, $Hash_to_proc$68, $Hash_transform_keys$70, $Hash_transform_keys$excl$72, $Hash_transform_values$74, $Hash_transform_values$excl$76, $Hash_values$78;

    
    self.$include($$($nesting, 'Enumerable'));
    self.$$prototype.$$is_hash = true;
    Opal.defs(self, '$[]', $Hash_$$$1 = function($a) {
      var $post_args, argv, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      argv = $post_args;;
      
      var hash, argc = argv.length, i;

      if (argc === 1) {
        hash = $$($nesting, 'Opal')['$coerce_to?'](argv['$[]'](0), $$($nesting, 'Hash'), "to_hash");
        if (hash !== nil) {
          return self.$allocate()['$merge!'](hash);
        }

        argv = $$($nesting, 'Opal')['$coerce_to?'](argv['$[]'](0), $$($nesting, 'Array'), "to_ary");
        if (argv === nil) {
          self.$raise($$($nesting, 'ArgumentError'), "odd number of arguments for Hash")
        }

        argc = argv.length;
        hash = self.$allocate();

        for (i = 0; i < argc; i++) {
          if (!argv[i].$$is_array) continue;
          switch(argv[i].length) {
          case 1:
            hash.$store(argv[i][0], nil);
            break;
          case 2:
            hash.$store(argv[i][0], argv[i][1]);
            break;
          default:
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid number of elements (" + (argv[i].length) + " for 1..2)")
          }
        }

        return hash;
      }

      if (argc % 2 !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "odd number of arguments for Hash")
      }

      hash = self.$allocate();

      for (i = 0; i < argc; i += 2) {
        hash.$store(argv[i], argv[i + 1]);
      }

      return hash;
    ;
    }, $Hash_$$$1.$$arity = -1);
    Opal.defs(self, '$allocate', $Hash_allocate$2 = function $$allocate() {
      var self = this;

      
      var hash = new self.$$constructor();

      Opal.hash_init(hash);

      hash.$$none = nil;
      hash.$$proc = nil;

      return hash;
    
    }, $Hash_allocate$2.$$arity = 0);
    Opal.defs(self, '$try_convert', $Hash_try_convert$3 = function $$try_convert(obj) {
      var self = this;

      return $$($nesting, 'Opal')['$coerce_to?'](obj, $$($nesting, 'Hash'), "to_hash")
    }, $Hash_try_convert$3.$$arity = 1);
    
    Opal.def(self, '$initialize', $Hash_initialize$4 = function $$initialize(defaults) {
      var $iter = $Hash_initialize$4.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_initialize$4.$$p = null;
      
      
      if ($iter) $Hash_initialize$4.$$p = null;;
      ;
      
      if (defaults !== undefined && block !== nil) {
        self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (1 for 0)")
      }
      self.$$none = (defaults === undefined ? nil : defaults);
      self.$$proc = block;

      return self;
    ;
    }, $Hash_initialize$4.$$arity = -1);
    
    Opal.def(self, '$==', $Hash_$eq_eq$5 = function(other) {
      var self = this;

      
      if (self === other) {
        return true;
      }

      if (!other.$$is_hash) {
        return false;
      }

      if (self.$$keys.length !== other.$$keys.length) {
        return false;
      }

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, other_value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
          other_value = other.$$smap[key];
        } else {
          value = key.value;
          other_value = Opal.hash_get(other, key.key);
        }

        if (other_value === undefined || !value['$eql?'](other_value)) {
          return false;
        }
      }

      return true;
    
    }, $Hash_$eq_eq$5.$$arity = 1);
    
    Opal.def(self, '$>=', $Hash_$gt_eq$6 = function(other) {
      var $$7, self = this, result = nil;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      
      if (self.$$keys.length < other.$$keys.length) {
        return false
      }
    ;
      result = true;
      $send(other, 'each', [], ($$7 = function(other_key, other_val){var self = $$7.$$s || this, val = nil;

      
        
        if (other_key == null) {
          other_key = nil;
        };
        
        if (other_val == null) {
          other_val = nil;
        };
        val = self.$fetch(other_key, null);
        
        if (val == null || val !== other_val) {
          result = false;
          return;
        }
      ;}, $$7.$$s = self, $$7.$$arity = 2, $$7));
      return result;
    }, $Hash_$gt_eq$6.$$arity = 1);
    
    Opal.def(self, '$>', $Hash_$gt$8 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      
      if (self.$$keys.length <= other.$$keys.length) {
        return false
      }
    ;
      return $rb_ge(self, other);
    }, $Hash_$gt$8.$$arity = 1);
    
    Opal.def(self, '$<', $Hash_$lt$9 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      return $rb_gt(other, self);
    }, $Hash_$lt$9.$$arity = 1);
    
    Opal.def(self, '$<=', $Hash_$lt_eq$10 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      return $rb_ge(other, self);
    }, $Hash_$lt_eq$10.$$arity = 1);
    
    Opal.def(self, '$[]', $Hash_$$$11 = function(key) {
      var self = this;

      
      var value = Opal.hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      return self.$default(key);
    
    }, $Hash_$$$11.$$arity = 1);
    
    Opal.def(self, '$[]=', $Hash_$$$eq$12 = function(key, value) {
      var self = this;

      
      Opal.hash_put(self, key, value);
      return value;
    
    }, $Hash_$$$eq$12.$$arity = 2);
    
    Opal.def(self, '$assoc', $Hash_assoc$13 = function $$assoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          if ((key)['$=='](object)) {
            return [key, self.$$smap[key]];
          }
        } else {
          if ((key.key)['$=='](object)) {
            return [key.key, key.value];
          }
        }
      }

      return nil;
    
    }, $Hash_assoc$13.$$arity = 1);
    
    Opal.def(self, '$clear', $Hash_clear$14 = function $$clear() {
      var self = this;

      
      Opal.hash_init(self);
      return self;
    
    }, $Hash_clear$14.$$arity = 0);
    
    Opal.def(self, '$clone', $Hash_clone$15 = function $$clone() {
      var self = this;

      
      var hash = new self.$$class();

      Opal.hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    
    }, $Hash_clone$15.$$arity = 0);
    
    Opal.def(self, '$compact', $Hash_compact$16 = function $$compact() {
      var self = this;

      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value !== nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    
    }, $Hash_compact$16.$$arity = 0);
    
    Opal.def(self, '$compact!', $Hash_compact$excl$17 = function() {
      var self = this;

      
      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    
    }, $Hash_compact$excl$17.$$arity = 0);
    
    Opal.def(self, '$compare_by_identity', $Hash_compare_by_identity$18 = function $$compare_by_identity() {
      var self = this;

      
      var i, ii, key, keys = self.$$keys, identity_hash;

      if (self.$$by_identity) return self;
      if (self.$$keys.length === 0) {
        self.$$by_identity = true
        return self;
      }

      identity_hash = $hash2([], {}).$compare_by_identity();
      for(i = 0, ii = keys.length; i < ii; i++) {
        key = keys[i];
        if (!key.$$is_string) key = key.key;
        Opal.hash_put(identity_hash, key, Opal.hash_get(self, key));
      }

      self.$$by_identity = true;
      self.$$map = identity_hash.$$map;
      self.$$smap = identity_hash.$$smap;
      return self;
    
    }, $Hash_compare_by_identity$18.$$arity = 0);
    
    Opal.def(self, '$compare_by_identity?', $Hash_compare_by_identity$ques$19 = function() {
      var self = this;

      return self.$$by_identity === true;
    }, $Hash_compare_by_identity$ques$19.$$arity = 0);
    
    Opal.def(self, '$default', $Hash_default$20 = function(key) {
      var self = this;

      
      ;
      
      if (key !== undefined && self.$$proc !== nil && self.$$proc !== undefined) {
        return self.$$proc.$call(self, key);
      }
      if (self.$$none === undefined) {
        return nil;
      }
      return self.$$none;
    ;
    }, $Hash_default$20.$$arity = -1);
    
    Opal.def(self, '$default=', $Hash_default$eq$21 = function(object) {
      var self = this;

      
      self.$$proc = nil;
      self.$$none = object;

      return object;
    
    }, $Hash_default$eq$21.$$arity = 1);
    
    Opal.def(self, '$default_proc', $Hash_default_proc$22 = function $$default_proc() {
      var self = this;

      
      if (self.$$proc !== undefined) {
        return self.$$proc;
      }
      return nil;
    
    }, $Hash_default_proc$22.$$arity = 0);
    
    Opal.def(self, '$default_proc=', $Hash_default_proc$eq$23 = function(default_proc) {
      var self = this;

      
      var proc = default_proc;

      if (proc !== nil) {
        proc = $$($nesting, 'Opal')['$coerce_to!'](proc, $$($nesting, 'Proc'), "to_proc");

        if ((proc)['$lambda?']() && (proc).$arity().$abs() !== 2) {
          self.$raise($$($nesting, 'TypeError'), "default_proc takes two arguments");
        }
      }

      self.$$none = nil;
      self.$$proc = proc;

      return default_proc;
    
    }, $Hash_default_proc$eq$23.$$arity = 1);
    
    Opal.def(self, '$delete', $Hash_delete$24 = function(key) {
      var $iter = $Hash_delete$24.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_delete$24.$$p = null;
      
      
      if ($iter) $Hash_delete$24.$$p = null;;
      
      var value = Opal.hash_delete(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return Opal.yield1(block, key);
      }

      return nil;
    ;
    }, $Hash_delete$24.$$arity = 1);
    
    Opal.def(self, '$delete_if', $Hash_delete_if$25 = function $$delete_if() {
      var $iter = $Hash_delete_if$25.$$p, block = $iter || nil, $$26, self = this;

      if ($iter) $Hash_delete_if$25.$$p = null;
      
      
      if ($iter) $Hash_delete_if$25.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["delete_if"], ($$26 = function(){var self = $$26.$$s || this;

        return self.$size()}, $$26.$$s = self, $$26.$$arity = 0, $$26))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, $Hash_delete_if$25.$$arity = 0);
    Opal.alias(self, "dup", "clone");
    
    Opal.def(self, '$dig', $Hash_dig$27 = function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      keys = $post_args;;
      item = self['$[]'](key);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(keys));
    }, $Hash_dig$27.$$arity = -2);
    
    Opal.def(self, '$each', $Hash_each$28 = function $$each() {
      var $iter = $Hash_each$28.$$p, block = $iter || nil, $$29, self = this;

      if ($iter) $Hash_each$28.$$p = null;
      
      
      if ($iter) $Hash_each$28.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$29 = function(){var self = $$29.$$s || this;

        return self.$size()}, $$29.$$s = self, $$29.$$arity = 0, $$29))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        Opal.yield1(block, [key, value]);
      }

      return self;
    ;
    }, $Hash_each$28.$$arity = 0);
    
    Opal.def(self, '$each_key', $Hash_each_key$30 = function $$each_key() {
      var $iter = $Hash_each_key$30.$$p, block = $iter || nil, $$31, self = this;

      if ($iter) $Hash_each_key$30.$$p = null;
      
      
      if ($iter) $Hash_each_key$30.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["each_key"], ($$31 = function(){var self = $$31.$$s || this;

        return self.$size()}, $$31.$$s = self, $$31.$$arity = 0, $$31))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? key : key.key);
      }

      return self;
    ;
    }, $Hash_each_key$30.$$arity = 0);
    Opal.alias(self, "each_pair", "each");
    
    Opal.def(self, '$each_value', $Hash_each_value$32 = function $$each_value() {
      var $iter = $Hash_each_value$32.$$p, block = $iter || nil, $$33, self = this;

      if ($iter) $Hash_each_value$32.$$p = null;
      
      
      if ($iter) $Hash_each_value$32.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["each_value"], ($$33 = function(){var self = $$33.$$s || this;

        return self.$size()}, $$33.$$s = self, $$33.$$arity = 0, $$33))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? self.$$smap[key] : key.value);
      }

      return self;
    ;
    }, $Hash_each_value$32.$$arity = 0);
    
    Opal.def(self, '$empty?', $Hash_empty$ques$34 = function() {
      var self = this;

      return self.$$keys.length === 0;
    }, $Hash_empty$ques$34.$$arity = 0);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$fetch', $Hash_fetch$35 = function $$fetch(key, defaults) {
      var $iter = $Hash_fetch$35.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_fetch$35.$$p = null;
      
      
      if ($iter) $Hash_fetch$35.$$p = null;;
      ;
      
      var value = Opal.hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return block(key);
      }

      if (defaults !== undefined) {
        return defaults;
      }
    ;
      return self.$raise($$($nesting, 'KeyError').$new("" + "key not found: " + (key.$inspect()), $hash2(["key", "receiver"], {"key": key, "receiver": self})));
    }, $Hash_fetch$35.$$arity = -2);
    
    Opal.def(self, '$fetch_values', $Hash_fetch_values$36 = function $$fetch_values($a) {
      var $iter = $Hash_fetch_values$36.$$p, block = $iter || nil, $post_args, keys, $$37, self = this;

      if ($iter) $Hash_fetch_values$36.$$p = null;
      
      
      if ($iter) $Hash_fetch_values$36.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      keys = $post_args;;
      return $send(keys, 'map', [], ($$37 = function(key){var self = $$37.$$s || this;

      
        
        if (key == null) {
          key = nil;
        };
        return $send(self, 'fetch', [key], block.$to_proc());}, $$37.$$s = self, $$37.$$arity = 1, $$37));
    }, $Hash_fetch_values$36.$$arity = -1);
    
    Opal.def(self, '$flatten', $Hash_flatten$38 = function $$flatten(level) {
      var self = this;

      
      
      if (level == null) {
        level = 1;
      };
      level = $$($nesting, 'Opal')['$coerce_to!'](level, $$($nesting, 'Integer'), "to_int");
      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push(key);

        if (value.$$is_array) {
          if (level === 1) {
            result.push(value);
            continue;
          }

          result = result.concat((value).$flatten(level - 2));
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, $Hash_flatten$38.$$arity = -1);
    
    Opal.def(self, '$has_key?', $Hash_has_key$ques$39 = function(key) {
      var self = this;

      return Opal.hash_get(self, key) !== undefined;
    }, $Hash_has_key$ques$39.$$arity = 1);
    
    Opal.def(self, '$has_value?', $Hash_has_value$ques$40 = function(value) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (((key.$$is_string ? self.$$smap[key] : key.value))['$=='](value)) {
          return true;
        }
      }

      return false;
    
    }, $Hash_has_value$ques$40.$$arity = 1);
    
    Opal.def(self, '$hash', $Hash_hash$41 = function $$hash() {
      var self = this;

      
      var top = (Opal.hash_ids === undefined),
          hash_id = self.$object_id(),
          result = ['Hash'],
          key, item;

      try {
        if (top) {
          Opal.hash_ids = Object.create(null);
        }

        if (Opal[hash_id]) {
          return 'self';
        }

        for (key in Opal.hash_ids) {
          item = Opal.hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        Opal.hash_ids[hash_id] = self;

        for (var i = 0, keys = self.$$keys, length = keys.length; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            result.push([key, self.$$smap[key].$hash()]);
          } else {
            result.push([key.key_hash, key.value.$hash()]);
          }
        }

        return result.sort().join();

      } finally {
        if (top) {
          Opal.hash_ids = undefined;
        }
      }
    
    }, $Hash_hash$41.$$arity = 0);
    Opal.alias(self, "include?", "has_key?");
    
    Opal.def(self, '$index', $Hash_index$42 = function $$index(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return key;
        }
      }

      return nil;
    
    }, $Hash_index$42.$$arity = 1);
    
    Opal.def(self, '$indexes', $Hash_indexes$43 = function $$indexes($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var result = [];

      for (var i = 0, length = args.length, key, value; i < length; i++) {
        key = args[i];
        value = Opal.hash_get(self, key);

        if (value === undefined) {
          result.push(self.$default());
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, $Hash_indexes$43.$$arity = -1);
    Opal.alias(self, "indices", "indexes");
    var inspect_ids;
    
    Opal.def(self, '$inspect', $Hash_inspect$44 = function $$inspect() {
      var self = this;

      
      var top = (inspect_ids === undefined),
          hash_id = self.$object_id(),
          result = [];

      try {
        if (top) {
          inspect_ids = {};
        }

        if (inspect_ids.hasOwnProperty(hash_id)) {
          return '{...}';
        }

        inspect_ids[hash_id] = true;

        for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          result.push(key.$inspect() + '=>' + value.$inspect());
        }

        return '{' + result.join(', ') + '}';

      } finally {
        if (top) {
          inspect_ids = undefined;
        }
      }
    
    }, $Hash_inspect$44.$$arity = 0);
    
    Opal.def(self, '$invert', $Hash_invert$45 = function $$invert() {
      var self = this;

      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        Opal.hash_put(hash, value, key);
      }

      return hash;
    
    }, $Hash_invert$45.$$arity = 0);
    
    Opal.def(self, '$keep_if', $Hash_keep_if$46 = function $$keep_if() {
      var $iter = $Hash_keep_if$46.$$p, block = $iter || nil, $$47, self = this;

      if ($iter) $Hash_keep_if$46.$$p = null;
      
      
      if ($iter) $Hash_keep_if$46.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["keep_if"], ($$47 = function(){var self = $$47.$$s || this;

        return self.$size()}, $$47.$$s = self, $$47.$$arity = 0, $$47))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, $Hash_keep_if$46.$$arity = 0);
    Opal.alias(self, "key", "index");
    Opal.alias(self, "key?", "has_key?");
    
    Opal.def(self, '$keys', $Hash_keys$48 = function $$keys() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(key);
        } else {
          result.push(key.key);
        }
      }

      return result;
    
    }, $Hash_keys$48.$$arity = 0);
    
    Opal.def(self, '$length', $Hash_length$49 = function $$length() {
      var self = this;

      return self.$$keys.length;
    }, $Hash_length$49.$$arity = 0);
    Opal.alias(self, "member?", "has_key?");
    
    Opal.def(self, '$merge', $Hash_merge$50 = function $$merge(other) {
      var $iter = $Hash_merge$50.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_merge$50.$$p = null;
      
      
      if ($iter) $Hash_merge$50.$$p = null;;
      return $send(self.$dup(), 'merge!', [other], block.$to_proc());
    }, $Hash_merge$50.$$arity = 1);
    
    Opal.def(self, '$merge!', $Hash_merge$excl$51 = function(other) {
      var $iter = $Hash_merge$excl$51.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_merge$excl$51.$$p = null;
      
      
      if ($iter) $Hash_merge$excl$51.$$p = null;;
      
      if (!other.$$is_hash) {
        other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      }

      var i, other_keys = other.$$keys, length = other_keys.length, key, value, other_value;

      if (block === nil) {
        for (i = 0; i < length; i++) {
          key = other_keys[i];

          if (key.$$is_string) {
            other_value = other.$$smap[key];
          } else {
            other_value = key.value;
            key = key.key;
          }

          Opal.hash_put(self, key, other_value);
        }

        return self;
      }

      for (i = 0; i < length; i++) {
        key = other_keys[i];

        if (key.$$is_string) {
          other_value = other.$$smap[key];
        } else {
          other_value = key.value;
          key = key.key;
        }

        value = Opal.hash_get(self, key);

        if (value === undefined) {
          Opal.hash_put(self, key, other_value);
          continue;
        }

        Opal.hash_put(self, key, block(key, value, other_value));
      }

      return self;
    ;
    }, $Hash_merge$excl$51.$$arity = 1);
    
    Opal.def(self, '$rassoc', $Hash_rassoc$52 = function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return [key, value];
        }
      }

      return nil;
    
    }, $Hash_rassoc$52.$$arity = 1);
    
    Opal.def(self, '$rehash', $Hash_rehash$53 = function $$rehash() {
      var self = this;

      
      Opal.hash_rehash(self);
      return self;
    
    }, $Hash_rehash$53.$$arity = 0);
    
    Opal.def(self, '$reject', $Hash_reject$54 = function $$reject() {
      var $iter = $Hash_reject$54.$$p, block = $iter || nil, $$55, self = this;

      if ($iter) $Hash_reject$54.$$p = null;
      
      
      if ($iter) $Hash_reject$54.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["reject"], ($$55 = function(){var self = $$55.$$s || this;

        return self.$size()}, $$55.$$s = self, $$55.$$arity = 0, $$55))
      };
      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, $Hash_reject$54.$$arity = 0);
    
    Opal.def(self, '$reject!', $Hash_reject$excl$56 = function() {
      var $iter = $Hash_reject$excl$56.$$p, block = $iter || nil, $$57, self = this;

      if ($iter) $Hash_reject$excl$56.$$p = null;
      
      
      if ($iter) $Hash_reject$excl$56.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["reject!"], ($$57 = function(){var self = $$57.$$s || this;

        return self.$size()}, $$57.$$s = self, $$57.$$arity = 0, $$57))
      };
      
      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    ;
    }, $Hash_reject$excl$56.$$arity = 0);
    
    Opal.def(self, '$replace', $Hash_replace$58 = function $$replace(other) {
      var self = this, $writer = nil;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      
      Opal.hash_init(self);

      for (var i = 0, other_keys = other.$$keys, length = other_keys.length, key, value, other_value; i < length; i++) {
        key = other_keys[i];

        if (key.$$is_string) {
          other_value = other.$$smap[key];
        } else {
          other_value = key.value;
          key = key.key;
        }

        Opal.hash_put(self, key, other_value);
      }
    ;
      if ($truthy(other.$default_proc())) {
        
        $writer = [other.$default_proc()];
        $send(self, 'default_proc=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      } else {
        
        $writer = [other.$default()];
        $send(self, 'default=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      };
      return self;
    }, $Hash_replace$58.$$arity = 1);
    
    Opal.def(self, '$select', $Hash_select$59 = function $$select() {
      var $iter = $Hash_select$59.$$p, block = $iter || nil, $$60, self = this;

      if ($iter) $Hash_select$59.$$p = null;
      
      
      if ($iter) $Hash_select$59.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["select"], ($$60 = function(){var self = $$60.$$s || this;

        return self.$size()}, $$60.$$s = self, $$60.$$arity = 0, $$60))
      };
      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, $Hash_select$59.$$arity = 0);
    
    Opal.def(self, '$select!', $Hash_select$excl$61 = function() {
      var $iter = $Hash_select$excl$61.$$p, block = $iter || nil, $$62, self = this;

      if ($iter) $Hash_select$excl$61.$$p = null;
      
      
      if ($iter) $Hash_select$excl$61.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["select!"], ($$62 = function(){var self = $$62.$$s || this;

        return self.$size()}, $$62.$$s = self, $$62.$$arity = 0, $$62))
      };
      
      var result = nil;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
          result = self;
        }
      }

      return result;
    ;
    }, $Hash_select$excl$61.$$arity = 0);
    
    Opal.def(self, '$shift', $Hash_shift$63 = function $$shift() {
      var self = this;

      
      var keys = self.$$keys,
          key;

      if (keys.length > 0) {
        key = keys[0];

        key = key.$$is_string ? key : key.key;

        return [key, Opal.hash_delete(self, key)];
      }

      return self.$default(nil);
    
    }, $Hash_shift$63.$$arity = 0);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$slice', $Hash_slice$64 = function $$slice($a) {
      var $post_args, keys, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      keys = $post_args;;
      
      var result = Opal.hash();

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i], value = Opal.hash_get(self, key);

        if (value !== undefined) {
          Opal.hash_put(result, key, value);
        }
      }

      return result;
    ;
    }, $Hash_slice$64.$$arity = -1);
    Opal.alias(self, "store", "[]=");
    
    Opal.def(self, '$to_a', $Hash_to_a$65 = function $$to_a() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push([key, value]);
      }

      return result;
    
    }, $Hash_to_a$65.$$arity = 0);
    
    Opal.def(self, '$to_h', $Hash_to_h$66 = function $$to_h() {
      var self = this;

      
      if (self.$$class === Opal.Hash) {
        return self;
      }

      var hash = new Opal.Hash();

      Opal.hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    
    }, $Hash_to_h$66.$$arity = 0);
    
    Opal.def(self, '$to_hash', $Hash_to_hash$67 = function $$to_hash() {
      var self = this;

      return self
    }, $Hash_to_hash$67.$$arity = 0);
    
    Opal.def(self, '$to_proc', $Hash_to_proc$68 = function $$to_proc() {
      var $$69, self = this;

      return $send(self, 'proc', [], ($$69 = function(key){var self = $$69.$$s || this;

      
        ;
        
        if (key == null) {
          self.$raise($$($nesting, 'ArgumentError'), "no key given")
        }
      ;
        return self['$[]'](key);}, $$69.$$s = self, $$69.$$arity = -1, $$69))
    }, $Hash_to_proc$68.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$transform_keys', $Hash_transform_keys$70 = function $$transform_keys() {
      var $iter = $Hash_transform_keys$70.$$p, block = $iter || nil, $$71, self = this;

      if ($iter) $Hash_transform_keys$70.$$p = null;
      
      
      if ($iter) $Hash_transform_keys$70.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_keys"], ($$71 = function(){var self = $$71.$$s || this;

        return self.$size()}, $$71.$$s = self, $$71.$$arity = 0, $$71))
      };
      
      var result = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        key = Opal.yield1(block, key);

        Opal.hash_put(result, key, value);
      }

      return result;
    ;
    }, $Hash_transform_keys$70.$$arity = 0);
    
    Opal.def(self, '$transform_keys!', $Hash_transform_keys$excl$72 = function() {
      var $iter = $Hash_transform_keys$excl$72.$$p, block = $iter || nil, $$73, self = this;

      if ($iter) $Hash_transform_keys$excl$72.$$p = null;
      
      
      if ($iter) $Hash_transform_keys$excl$72.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_keys!"], ($$73 = function(){var self = $$73.$$s || this;

        return self.$size()}, $$73.$$s = self, $$73.$$arity = 0, $$73))
      };
      
      var keys = Opal.slice.call(self.$$keys),
          i, length = keys.length, key, value, new_key;

      for (i = 0; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        new_key = Opal.yield1(block, key);

        Opal.hash_delete(self, key);
        Opal.hash_put(self, new_key, value);
      }

      return self;
    ;
    }, $Hash_transform_keys$excl$72.$$arity = 0);
    
    Opal.def(self, '$transform_values', $Hash_transform_values$74 = function $$transform_values() {
      var $iter = $Hash_transform_values$74.$$p, block = $iter || nil, $$75, self = this;

      if ($iter) $Hash_transform_values$74.$$p = null;
      
      
      if ($iter) $Hash_transform_values$74.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_values"], ($$75 = function(){var self = $$75.$$s || this;

        return self.$size()}, $$75.$$s = self, $$75.$$arity = 0, $$75))
      };
      
      var result = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = Opal.yield1(block, value);

        Opal.hash_put(result, key, value);
      }

      return result;
    ;
    }, $Hash_transform_values$74.$$arity = 0);
    
    Opal.def(self, '$transform_values!', $Hash_transform_values$excl$76 = function() {
      var $iter = $Hash_transform_values$excl$76.$$p, block = $iter || nil, $$77, self = this;

      if ($iter) $Hash_transform_values$excl$76.$$p = null;
      
      
      if ($iter) $Hash_transform_values$excl$76.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_values!"], ($$77 = function(){var self = $$77.$$s || this;

        return self.$size()}, $$77.$$s = self, $$77.$$arity = 0, $$77))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = Opal.yield1(block, value);

        Opal.hash_put(self, key, value);
      }

      return self;
    ;
    }, $Hash_transform_values$excl$76.$$arity = 0);
    Opal.alias(self, "update", "merge!");
    Opal.alias(self, "value?", "has_value?");
    Opal.alias(self, "values_at", "indexes");
    return (Opal.def(self, '$values', $Hash_values$78 = function $$values() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(self.$$smap[key]);
        } else {
          result.push(key.value);
        }
      }

      return result;
    
    }, $Hash_values$78.$$arity = 0), nil) && 'values';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/number"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2;

  Opal.add_stubs(['$require', '$bridge', '$raise', '$name', '$class', '$Float', '$respond_to?', '$coerce_to!', '$__coerced__', '$===', '$!', '$>', '$**', '$new', '$<', '$to_f', '$==', '$nan?', '$infinite?', '$enum_for', '$+', '$-', '$gcd', '$lcm', '$%', '$/', '$frexp', '$to_i', '$ldexp', '$rationalize', '$*', '$<<', '$to_r', '$truncate', '$-@', '$size', '$<=', '$>=', '$<=>', '$compare', '$any?']);
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Number');

    var $nesting = [self].concat($parent_nesting), $Number_coerce$2, $Number___id__$3, $Number_$plus$4, $Number_$minus$5, $Number_$$6, $Number_$slash$7, $Number_$percent$8, $Number_$$9, $Number_$$10, $Number_$$11, $Number_$lt$12, $Number_$lt_eq$13, $Number_$gt$14, $Number_$gt_eq$15, $Number_$lt_eq_gt$16, $Number_$lt$lt$17, $Number_$gt$gt$18, $Number_$$$19, $Number_$plus$$20, $Number_$minus$$21, $Number_$$22, $Number_$$$23, $Number_$eq_eq_eq$24, $Number_$eq_eq$25, $Number_abs$26, $Number_abs2$27, $Number_allbits$ques$28, $Number_anybits$ques$29, $Number_angle$30, $Number_bit_length$31, $Number_ceil$32, $Number_chr$33, $Number_denominator$34, $Number_downto$35, $Number_equal$ques$37, $Number_even$ques$38, $Number_floor$39, $Number_gcd$40, $Number_gcdlcm$41, $Number_integer$ques$42, $Number_is_a$ques$43, $Number_instance_of$ques$44, $Number_lcm$45, $Number_next$46, $Number_nobits$ques$47, $Number_nonzero$ques$48, $Number_numerator$49, $Number_odd$ques$50, $Number_ord$51, $Number_pow$52, $Number_pred$53, $Number_quo$54, $Number_rationalize$55, $Number_remainder$56, $Number_round$57, $Number_step$58, $Number_times$60, $Number_to_f$62, $Number_to_i$63, $Number_to_r$64, $Number_to_s$65, $Number_truncate$66, $Number_digits$67, $Number_divmod$68, $Number_upto$69, $Number_zero$ques$71, $Number_size$72, $Number_nan$ques$73, $Number_finite$ques$74, $Number_infinite$ques$75, $Number_positive$ques$76, $Number_negative$ques$77;

    
    $$($nesting, 'Opal').$bridge(Number, self);
    Opal.defineProperty(self.$$prototype, '$$is_number', true);
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$coerce', $Number_coerce$2 = function $$coerce(other) {
      var self = this;

      
      if (other === nil) {
        self.$raise($$($nesting, 'TypeError'), "" + "can't convert " + (other.$class()) + " into Float");
      }
      else if (other.$$is_string) {
        return [self.$Float(other), self];
      }
      else if (other['$respond_to?']("to_f")) {
        return [$$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Float'), "to_f"), self];
      }
      else if (other.$$is_number) {
        return [other, self];
      }
      else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't convert " + (other.$class()) + " into Float");
      }
    
    }, $Number_coerce$2.$$arity = 1);
    
    Opal.def(self, '$__id__', $Number___id__$3 = function $$__id__() {
      var self = this;

      return (self * 2) + 1;
    }, $Number___id__$3.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    
    Opal.def(self, '$+', $Number_$plus$4 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self + other;
      }
      else {
        return self.$__coerced__("+", other);
      }
    
    }, $Number_$plus$4.$$arity = 1);
    
    Opal.def(self, '$-', $Number_$minus$5 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self - other;
      }
      else {
        return self.$__coerced__("-", other);
      }
    
    }, $Number_$minus$5.$$arity = 1);
    
    Opal.def(self, '$*', $Number_$$6 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self * other;
      }
      else {
        return self.$__coerced__("*", other);
      }
    
    }, $Number_$$6.$$arity = 1);
    
    Opal.def(self, '$/', $Number_$slash$7 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self / other;
      }
      else {
        return self.$__coerced__("/", other);
      }
    
    }, $Number_$slash$7.$$arity = 1);
    Opal.alias(self, "fdiv", "/");
    
    Opal.def(self, '$%', $Number_$percent$8 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        if (other == -Infinity) {
          return other;
        }
        else if (other == 0) {
          self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0");
        }
        else if (other < 0 || self < 0) {
          return (self % other + other) % other;
        }
        else {
          return self % other;
        }
      }
      else {
        return self.$__coerced__("%", other);
      }
    
    }, $Number_$percent$8.$$arity = 1);
    
    Opal.def(self, '$&', $Number_$$9 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self & other;
      }
      else {
        return self.$__coerced__("&", other);
      }
    
    }, $Number_$$9.$$arity = 1);
    
    Opal.def(self, '$|', $Number_$$10 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self | other;
      }
      else {
        return self.$__coerced__("|", other);
      }
    
    }, $Number_$$10.$$arity = 1);
    
    Opal.def(self, '$^', $Number_$$11 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self ^ other;
      }
      else {
        return self.$__coerced__("^", other);
      }
    
    }, $Number_$$11.$$arity = 1);
    
    Opal.def(self, '$<', $Number_$lt$12 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self < other;
      }
      else {
        return self.$__coerced__("<", other);
      }
    
    }, $Number_$lt$12.$$arity = 1);
    
    Opal.def(self, '$<=', $Number_$lt_eq$13 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self <= other;
      }
      else {
        return self.$__coerced__("<=", other);
      }
    
    }, $Number_$lt_eq$13.$$arity = 1);
    
    Opal.def(self, '$>', $Number_$gt$14 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self > other;
      }
      else {
        return self.$__coerced__(">", other);
      }
    
    }, $Number_$gt$14.$$arity = 1);
    
    Opal.def(self, '$>=', $Number_$gt_eq$15 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self >= other;
      }
      else {
        return self.$__coerced__(">=", other);
      }
    
    }, $Number_$gt_eq$15.$$arity = 1);
    
    var spaceship_operator = function(self, other) {
      if (other.$$is_number) {
        if (isNaN(self) || isNaN(other)) {
          return nil;
        }

        if (self > other) {
          return 1;
        } else if (self < other) {
          return -1;
        } else {
          return 0;
        }
      }
      else {
        return self.$__coerced__("<=>", other);
      }
    }
  ;
    
    Opal.def(self, '$<=>', $Number_$lt_eq_gt$16 = function(other) {
      var self = this;

      try {
        return spaceship_operator(self, other);
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {
          try {
            return nil
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Number_$lt_eq_gt$16.$$arity = 1);
    
    Opal.def(self, '$<<', $Number_$lt$lt$17 = function(count) {
      var self = this;

      
      count = $$($nesting, 'Opal')['$coerce_to!'](count, $$($nesting, 'Integer'), "to_int");
      return count > 0 ? self << count : self >> -count;
    }, $Number_$lt$lt$17.$$arity = 1);
    
    Opal.def(self, '$>>', $Number_$gt$gt$18 = function(count) {
      var self = this;

      
      count = $$($nesting, 'Opal')['$coerce_to!'](count, $$($nesting, 'Integer'), "to_int");
      return count > 0 ? self >> count : self << -count;
    }, $Number_$gt$gt$18.$$arity = 1);
    
    Opal.def(self, '$[]', $Number_$$$19 = function(bit) {
      var self = this;

      
      bit = $$($nesting, 'Opal')['$coerce_to!'](bit, $$($nesting, 'Integer'), "to_int");
      
      if (bit < 0) {
        return 0;
      }
      if (bit >= 32) {
        return self < 0 ? 1 : 0;
      }
      return (self >> bit) & 1;
    ;
    }, $Number_$$$19.$$arity = 1);
    
    Opal.def(self, '$+@', $Number_$plus$$20 = function() {
      var self = this;

      return +self;
    }, $Number_$plus$$20.$$arity = 0);
    
    Opal.def(self, '$-@', $Number_$minus$$21 = function() {
      var self = this;

      return -self;
    }, $Number_$minus$$21.$$arity = 0);
    
    Opal.def(self, '$~', $Number_$$22 = function() {
      var self = this;

      return ~self;
    }, $Number_$$22.$$arity = 0);
    
    Opal.def(self, '$**', $Number_$$$23 = function(other) {
      var $a, $b, self = this;

      if ($truthy($$($nesting, 'Integer')['$==='](other))) {
        if ($truthy(($truthy($a = $$($nesting, 'Integer')['$==='](self)['$!']()) ? $a : $rb_gt(other, 0)))) {
          return Math.pow(self, other);
        } else {
          return $$($nesting, 'Rational').$new(self, 1)['$**'](other)
        }
      } else if ($truthy((($a = $rb_lt(self, 0)) ? ($truthy($b = $$($nesting, 'Float')['$==='](other)) ? $b : $$($nesting, 'Rational')['$==='](other)) : $rb_lt(self, 0)))) {
        return $$($nesting, 'Complex').$new(self, 0)['$**'](other.$to_f())
      } else if ($truthy(other.$$is_number != null)) {
        return Math.pow(self, other);
      } else {
        return self.$__coerced__("**", other)
      }
    }, $Number_$$$23.$$arity = 1);
    
    Opal.def(self, '$===', $Number_$eq_eq_eq$24 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    }, $Number_$eq_eq_eq$24.$$arity = 1);
    
    Opal.def(self, '$==', $Number_$eq_eq$25 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    }, $Number_$eq_eq$25.$$arity = 1);
    
    Opal.def(self, '$abs', $Number_abs$26 = function $$abs() {
      var self = this;

      return Math.abs(self);
    }, $Number_abs$26.$$arity = 0);
    
    Opal.def(self, '$abs2', $Number_abs2$27 = function $$abs2() {
      var self = this;

      return Math.abs(self * self);
    }, $Number_abs2$27.$$arity = 0);
    
    Opal.def(self, '$allbits?', $Number_allbits$ques$28 = function(mask) {
      var self = this;

      
      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), "to_int");
      return (self & mask) == mask;;
    }, $Number_allbits$ques$28.$$arity = 1);
    
    Opal.def(self, '$anybits?', $Number_anybits$ques$29 = function(mask) {
      var self = this;

      
      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), "to_int");
      return (self & mask) !== 0;;
    }, $Number_anybits$ques$29.$$arity = 1);
    
    Opal.def(self, '$angle', $Number_angle$30 = function $$angle() {
      var self = this;

      
      if ($truthy(self['$nan?']())) {
        return self};
      
      if (self == 0) {
        if (1 / self > 0) {
          return 0;
        }
        else {
          return Math.PI;
        }
      }
      else if (self < 0) {
        return Math.PI;
      }
      else {
        return 0;
      }
    ;
    }, $Number_angle$30.$$arity = 0);
    Opal.alias(self, "arg", "angle");
    Opal.alias(self, "phase", "angle");
    
    Opal.def(self, '$bit_length', $Number_bit_length$31 = function $$bit_length() {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
      } else {
        self.$raise($$($nesting, 'NoMethodError').$new("" + "undefined method `bit_length` for " + (self) + ":Float", "bit_length"))
      };
      
      if (self === 0 || self === -1) {
        return 0;
      }

      var result = 0,
          value  = self < 0 ? ~self : self;

      while (value != 0) {
        result   += 1;
        value  >>>= 1;
      }

      return result;
    ;
    }, $Number_bit_length$31.$$arity = 0);
    
    Opal.def(self, '$ceil', $Number_ceil$32 = function $$ceil(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.ceil(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, $Number_ceil$32.$$arity = -1);
    
    Opal.def(self, '$chr', $Number_chr$33 = function $$chr(encoding) {
      var self = this;

      
      ;
      return String.fromCharCode(self);;
    }, $Number_chr$33.$$arity = -1);
    
    Opal.def(self, '$denominator', $Number_denominator$34 = function $$denominator() {
      var $a, $iter = $Number_denominator$34.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_denominator$34.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy(($truthy($a = self['$nan?']()) ? $a : self['$infinite?']()))) {
        return 1
      } else {
        return $send(self, Opal.find_super_dispatcher(self, 'denominator', $Number_denominator$34, false), $zuper, $iter)
      }
    }, $Number_denominator$34.$$arity = 0);
    
    Opal.def(self, '$downto', $Number_downto$35 = function $$downto(stop) {
      var $iter = $Number_downto$35.$$p, block = $iter || nil, $$36, self = this;

      if ($iter) $Number_downto$35.$$p = null;
      
      
      if ($iter) $Number_downto$35.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["downto", stop], ($$36 = function(){var self = $$36.$$s || this;

        
          if ($truthy($$($nesting, 'Numeric')['$==='](stop))) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_gt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(self, stop), 1)
          };}, $$36.$$s = self, $$36.$$arity = 0, $$36))
      };
      
      if (!stop.$$is_number) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i >= stop; i--) {
        block(i);
      }
    ;
      return self;
    }, $Number_downto$35.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$equal?', $Number_equal$ques$37 = function(other) {
      var $a, self = this;

      return ($truthy($a = self['$=='](other)) ? $a : isNaN(self) && isNaN(other))
    }, $Number_equal$ques$37.$$arity = 1);
    
    Opal.def(self, '$even?', $Number_even$ques$38 = function() {
      var self = this;

      return self % 2 === 0;
    }, $Number_even$ques$38.$$arity = 0);
    
    Opal.def(self, '$floor', $Number_floor$39 = function $$floor(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.floor(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, $Number_floor$39.$$arity = -1);
    
    Opal.def(self, '$gcd', $Number_gcd$40 = function $$gcd(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not an integer")
      };
      
      var min = Math.abs(self),
          max = Math.abs(other);

      while (min > 0) {
        var tmp = min;

        min = max % min;
        max = tmp;
      }

      return max;
    ;
    }, $Number_gcd$40.$$arity = 1);
    
    Opal.def(self, '$gcdlcm', $Number_gcdlcm$41 = function $$gcdlcm(other) {
      var self = this;

      return [self.$gcd(), self.$lcm()]
    }, $Number_gcdlcm$41.$$arity = 1);
    
    Opal.def(self, '$integer?', $Number_integer$ques$42 = function() {
      var self = this;

      return self % 1 === 0;
    }, $Number_integer$ques$42.$$arity = 0);
    
    Opal.def(self, '$is_a?', $Number_is_a$ques$43 = function(klass) {
      var $a, $iter = $Number_is_a$ques$43.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_is_a$ques$43.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      if ($truthy((($a = klass['$==']($$($nesting, 'Integer'))) ? $$($nesting, 'Integer')['$==='](self) : klass['$==']($$($nesting, 'Integer'))))) {
        return true};
      if ($truthy((($a = klass['$==']($$($nesting, 'Integer'))) ? $$($nesting, 'Integer')['$==='](self) : klass['$==']($$($nesting, 'Integer'))))) {
        return true};
      if ($truthy((($a = klass['$==']($$($nesting, 'Float'))) ? $$($nesting, 'Float')['$==='](self) : klass['$==']($$($nesting, 'Float'))))) {
        return true};
      return $send(self, Opal.find_super_dispatcher(self, 'is_a?', $Number_is_a$ques$43, false), $zuper, $iter);
    }, $Number_is_a$ques$43.$$arity = 1);
    Opal.alias(self, "kind_of?", "is_a?");
    
    Opal.def(self, '$instance_of?', $Number_instance_of$ques$44 = function(klass) {
      var $a, $iter = $Number_instance_of$ques$44.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_instance_of$ques$44.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      if ($truthy((($a = klass['$==']($$($nesting, 'Integer'))) ? $$($nesting, 'Integer')['$==='](self) : klass['$==']($$($nesting, 'Integer'))))) {
        return true};
      if ($truthy((($a = klass['$==']($$($nesting, 'Integer'))) ? $$($nesting, 'Integer')['$==='](self) : klass['$==']($$($nesting, 'Integer'))))) {
        return true};
      if ($truthy((($a = klass['$==']($$($nesting, 'Float'))) ? $$($nesting, 'Float')['$==='](self) : klass['$==']($$($nesting, 'Float'))))) {
        return true};
      return $send(self, Opal.find_super_dispatcher(self, 'instance_of?', $Number_instance_of$ques$44, false), $zuper, $iter);
    }, $Number_instance_of$ques$44.$$arity = 1);
    
    Opal.def(self, '$lcm', $Number_lcm$45 = function $$lcm(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not an integer")
      };
      
      if (self == 0 || other == 0) {
        return 0;
      }
      else {
        return Math.abs(self * other / self.$gcd(other));
      }
    ;
    }, $Number_lcm$45.$$arity = 1);
    Opal.alias(self, "magnitude", "abs");
    Opal.alias(self, "modulo", "%");
    
    Opal.def(self, '$next', $Number_next$46 = function $$next() {
      var self = this;

      return self + 1;
    }, $Number_next$46.$$arity = 0);
    
    Opal.def(self, '$nobits?', $Number_nobits$ques$47 = function(mask) {
      var self = this;

      
      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), "to_int");
      return (self & mask) == 0;;
    }, $Number_nobits$ques$47.$$arity = 1);
    
    Opal.def(self, '$nonzero?', $Number_nonzero$ques$48 = function() {
      var self = this;

      return self == 0 ? nil : self;
    }, $Number_nonzero$ques$48.$$arity = 0);
    
    Opal.def(self, '$numerator', $Number_numerator$49 = function $$numerator() {
      var $a, $iter = $Number_numerator$49.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_numerator$49.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy(($truthy($a = self['$nan?']()) ? $a : self['$infinite?']()))) {
        return self
      } else {
        return $send(self, Opal.find_super_dispatcher(self, 'numerator', $Number_numerator$49, false), $zuper, $iter)
      }
    }, $Number_numerator$49.$$arity = 0);
    
    Opal.def(self, '$odd?', $Number_odd$ques$50 = function() {
      var self = this;

      return self % 2 !== 0;
    }, $Number_odd$ques$50.$$arity = 0);
    
    Opal.def(self, '$ord', $Number_ord$51 = function $$ord() {
      var self = this;

      return self
    }, $Number_ord$51.$$arity = 0);
    
    Opal.def(self, '$pow', $Number_pow$52 = function $$pow(b, m) {
      var self = this;

      
      ;
      
      if (self == 0) {
        self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
      }

      if (m === undefined) {
        return self['$**'](b);
      } else {
        if (!($$($nesting, 'Integer')['$==='](b))) {
          self.$raise($$($nesting, 'TypeError'), "Integer#pow() 2nd argument not allowed unless a 1st argument is integer")
        }

        if (b < 0) {
          self.$raise($$($nesting, 'TypeError'), "Integer#pow() 1st argument cannot be negative when 2nd argument specified")
        }

        if (!($$($nesting, 'Integer')['$==='](m))) {
          self.$raise($$($nesting, 'TypeError'), "Integer#pow() 2nd argument not allowed unless all arguments are integers")
        }

        if (m === 0) {
          self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
        }

        return self['$**'](b)['$%'](m)
      }
    ;
    }, $Number_pow$52.$$arity = -2);
    
    Opal.def(self, '$pred', $Number_pred$53 = function $$pred() {
      var self = this;

      return self - 1;
    }, $Number_pred$53.$$arity = 0);
    
    Opal.def(self, '$quo', $Number_quo$54 = function $$quo(other) {
      var $iter = $Number_quo$54.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_quo$54.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        return $send(self, Opal.find_super_dispatcher(self, 'quo', $Number_quo$54, false), $zuper, $iter)
      } else {
        return $rb_divide(self, other)
      }
    }, $Number_quo$54.$$arity = 1);
    
    Opal.def(self, '$rationalize', $Number_rationalize$55 = function $$rationalize(eps) {
      var $a, $b, self = this, f = nil, n = nil;

      
      ;
      
      if (arguments.length > 1) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        return $$($nesting, 'Rational').$new(self, 1)
      } else if ($truthy(self['$infinite?']())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "Infinity")
      } else if ($truthy(self['$nan?']())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "NaN")
      } else if ($truthy(eps == null)) {
        
        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (n = ($a[1] == null ? nil : $a[1])), $b;
        f = $$($nesting, 'Math').$ldexp(f, $$$($$($nesting, 'Float'), 'MANT_DIG')).$to_i();
        n = $rb_minus(n, $$$($$($nesting, 'Float'), 'MANT_DIG'));
        return $$($nesting, 'Rational').$new($rb_times(2, f), (1)['$<<']($rb_minus(1, n))).$rationalize($$($nesting, 'Rational').$new(1, (1)['$<<']($rb_minus(1, n))));
      } else {
        return self.$to_r().$rationalize(eps)
      };
    }, $Number_rationalize$55.$$arity = -1);
    
    Opal.def(self, '$remainder', $Number_remainder$56 = function $$remainder(y) {
      var self = this;

      return $rb_minus(self, $rb_times(y, $rb_divide(self, y).$truncate()))
    }, $Number_remainder$56.$$arity = 1);
    
    Opal.def(self, '$round', $Number_round$57 = function $$round(ndigits) {
      var $a, $b, self = this, _ = nil, exp = nil;

      
      ;
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        
        if ($truthy(ndigits == null)) {
          return self};
        if ($truthy(($truthy($a = $$($nesting, 'Float')['$==='](ndigits)) ? ndigits['$infinite?']() : $a))) {
          self.$raise($$($nesting, 'RangeError'), "Infinity")};
        ndigits = $$($nesting, 'Opal')['$coerce_to!'](ndigits, $$($nesting, 'Integer'), "to_int");
        if ($truthy($rb_lt(ndigits, $$$($$($nesting, 'Integer'), 'MIN')))) {
          self.$raise($$($nesting, 'RangeError'), "out of bounds")};
        if ($truthy(ndigits >= 0)) {
          return self};
        ndigits = ndigits['$-@']();
        
        if (0.415241 * ndigits - 0.125 > self.$size()) {
          return 0;
        }

        var f = Math.pow(10, ndigits),
            x = Math.floor((Math.abs(x) + f / 2) / f) * f;

        return self < 0 ? -x : x;
      ;
      } else {
        
        if ($truthy(($truthy($a = self['$nan?']()) ? ndigits == null : $a))) {
          self.$raise($$($nesting, 'FloatDomainError'), "NaN")};
        ndigits = $$($nesting, 'Opal')['$coerce_to!'](ndigits || 0, $$($nesting, 'Integer'), "to_int");
        if ($truthy($rb_le(ndigits, 0))) {
          if ($truthy(self['$nan?']())) {
            self.$raise($$($nesting, 'RangeError'), "NaN")
          } else if ($truthy(self['$infinite?']())) {
            self.$raise($$($nesting, 'FloatDomainError'), "Infinity")}
        } else if (ndigits['$=='](0)) {
          return Math.round(self)
        } else if ($truthy(($truthy($a = self['$nan?']()) ? $a : self['$infinite?']()))) {
          return self};
        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (exp = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy($rb_ge(ndigits, $rb_minus($rb_plus($$$($$($nesting, 'Float'), 'DIG'), 2), (function() {if ($truthy($rb_gt(exp, 0))) {
          return $rb_divide(exp, 4)
        } else {
          return $rb_minus($rb_divide(exp, 3), 1)
        }; return nil; })())))) {
          return self};
        if ($truthy($rb_lt(ndigits, (function() {if ($truthy($rb_gt(exp, 0))) {
          return $rb_plus($rb_divide(exp, 3), 1)
        } else {
          return $rb_divide(exp, 4)
        }; return nil; })()['$-@']()))) {
          return 0};
        return Math.round(self * Math.pow(10, ndigits)) / Math.pow(10, ndigits);;
      };
    }, $Number_round$57.$$arity = -1);
    
    Opal.def(self, '$step', $Number_step$58 = function $$step($a, $b, $c) {
      var $iter = $Number_step$58.$$p, block = $iter || nil, $post_args, $kwargs, limit, step, to, by, $$59, self = this, positional_args = nil, keyword_args = nil;

      if ($iter) $Number_step$58.$$p = null;
      
      
      if ($iter) $Number_step$58.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      if ($post_args.length > 0) {
        limit = $post_args[0];
        $post_args.splice(0, 1);
      };
      
      if ($post_args.length > 0) {
        step = $post_args[0];
        $post_args.splice(0, 1);
      };
      
      to = $kwargs.$$smap["to"];;
      
      by = $kwargs.$$smap["by"];;
      
      if (limit !== undefined && to !== undefined) {
        self.$raise($$($nesting, 'ArgumentError'), "to is given twice")
      }

      if (step !== undefined && by !== undefined) {
        self.$raise($$($nesting, 'ArgumentError'), "step is given twice")
      }

      function validateParameters() {
        if (to !== undefined) {
          limit = to;
        }

        if (limit === undefined) {
          limit = nil;
        }

        if (step === nil) {
          self.$raise($$($nesting, 'TypeError'), "step must be numeric")
        }

        if (step === 0) {
          self.$raise($$($nesting, 'ArgumentError'), "step can't be 0")
        }

        if (by !== undefined) {
          step = by;
        }

        if (step === nil || step == null) {
          step = 1;
        }

        var sign = step['$<=>'](0);

        if (sign === nil) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "0 can't be coerced into " + (step.$class()))
        }

        if (limit === nil || limit == null) {
          limit = sign > 0 ? $$$($$($nesting, 'Float'), 'INFINITY') : $$$($$($nesting, 'Float'), 'INFINITY')['$-@']();
        }

        $$($nesting, 'Opal').$compare(self, limit)
      }

      function stepFloatSize() {
        if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else if (step === Infinity || step === -Infinity) {
          return 1;
        } else {
          var abs = Math.abs, floor = Math.floor,
              err = (abs(self) + abs(limit) + abs(limit - self)) / abs(step) * $$$($$($nesting, 'Float'), 'EPSILON');

          if (err === Infinity || err === -Infinity) {
            return 0;
          } else {
            if (err > 0.5) {
              err = 0.5;
            }

            return floor((limit - self) / step + err) + 1
          }
        }
      }

      function stepSize() {
        validateParameters();

        if (step === 0) {
          return Infinity;
        }

        if (step % 1 !== 0) {
          return stepFloatSize();
        } else if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else {
          var ceil = Math.ceil, abs = Math.abs,
              lhs = abs(self - limit) + 1,
              rhs = abs(step);

          return ceil(lhs / rhs);
        }
      }
    ;
      if ((block !== nil)) {
      } else {
        
        positional_args = [];
        keyword_args = $hash2([], {});
        
        if (limit !== undefined) {
          positional_args.push(limit);
        }

        if (step !== undefined) {
          positional_args.push(step);
        }

        if (to !== undefined) {
          Opal.hash_put(keyword_args, "to", to);
        }

        if (by !== undefined) {
          Opal.hash_put(keyword_args, "by", by);
        }

        if (keyword_args['$any?']()) {
          positional_args.push(keyword_args);
        }
      ;
        return $send(self, 'enum_for', ["step"].concat(Opal.to_a(positional_args)), ($$59 = function(){var self = $$59.$$s || this;

        return stepSize();}, $$59.$$s = self, $$59.$$arity = 0, $$59));
      };
      
      validateParameters();

      if (step === 0) {
        while (true) {
          block(self);
        }
      }

      if (self % 1 !== 0 || limit % 1 !== 0 || step % 1 !== 0) {
        var n = stepFloatSize();

        if (n > 0) {
          if (step === Infinity || step === -Infinity) {
            block(self);
          } else {
            var i = 0, d;

            if (step > 0) {
              while (i < n) {
                d = i * step + self;
                if (limit < d) {
                  d = limit;
                }
                block(d);
                i += 1;
              }
            } else {
              while (i < n) {
                d = i * step + self;
                if (limit > d) {
                  d = limit;
                }
                block(d);
                i += 1
              }
            }
          }
        }
      } else {
        var value = self;

        if (step > 0) {
          while (value <= limit) {
            block(value);
            value += step;
          }
        } else {
          while (value >= limit) {
            block(value);
            value += step
          }
        }
      }

      return self;
    ;
    }, $Number_step$58.$$arity = -1);
    Opal.alias(self, "succ", "next");
    
    Opal.def(self, '$times', $Number_times$60 = function $$times() {
      var $iter = $Number_times$60.$$p, block = $iter || nil, $$61, self = this;

      if ($iter) $Number_times$60.$$p = null;
      
      
      if ($iter) $Number_times$60.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["times"], ($$61 = function(){var self = $$61.$$s || this;

        return self}, $$61.$$s = self, $$61.$$arity = 0, $$61))
      };
      
      for (var i = 0; i < self; i++) {
        block(i);
      }
    ;
      return self;
    }, $Number_times$60.$$arity = 0);
    
    Opal.def(self, '$to_f', $Number_to_f$62 = function $$to_f() {
      var self = this;

      return self
    }, $Number_to_f$62.$$arity = 0);
    
    Opal.def(self, '$to_i', $Number_to_i$63 = function $$to_i() {
      var self = this;

      return parseInt(self, 10);
    }, $Number_to_i$63.$$arity = 0);
    Opal.alias(self, "to_int", "to_i");
    
    Opal.def(self, '$to_r', $Number_to_r$64 = function $$to_r() {
      var $a, $b, self = this, f = nil, e = nil;

      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        return $$($nesting, 'Rational').$new(self, 1)
      } else {
        
        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (e = ($a[1] == null ? nil : $a[1])), $b;
        f = $$($nesting, 'Math').$ldexp(f, $$$($$($nesting, 'Float'), 'MANT_DIG')).$to_i();
        e = $rb_minus(e, $$$($$($nesting, 'Float'), 'MANT_DIG'));
        return $rb_times(f, $$$($$($nesting, 'Float'), 'RADIX')['$**'](e)).$to_r();
      }
    }, $Number_to_r$64.$$arity = 0);
    
    Opal.def(self, '$to_s', $Number_to_s$65 = function $$to_s(base) {
      var $a, self = this;

      
      
      if (base == null) {
        base = 10;
      };
      base = $$($nesting, 'Opal')['$coerce_to!'](base, $$($nesting, 'Integer'), "to_int");
      if ($truthy(($truthy($a = $rb_lt(base, 2)) ? $a : $rb_gt(base, 36)))) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (base))};
      return self.toString(base);;
    }, $Number_to_s$65.$$arity = -1);
    
    Opal.def(self, '$truncate', $Number_truncate$66 = function $$truncate(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = parseInt(f * factor, 10) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, $Number_truncate$66.$$arity = -1);
    Opal.alias(self, "inspect", "to_s");
    
    Opal.def(self, '$digits', $Number_digits$67 = function $$digits(base) {
      var self = this;

      
      
      if (base == null) {
        base = 10;
      };
      if ($rb_lt(self, 0)) {
        self.$raise($$$($$($nesting, 'Math'), 'DomainError'), "out of domain")};
      base = $$($nesting, 'Opal')['$coerce_to!'](base, $$($nesting, 'Integer'), "to_int");
      if ($truthy($rb_lt(base, 2))) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (base))};
      
      var value = self, result = [];

      while (value !== 0) {
        result.push(value % base);
        value = parseInt(value / base, 10);
      }

      return result;
    ;
    }, $Number_digits$67.$$arity = -1);
    
    Opal.def(self, '$divmod', $Number_divmod$68 = function $$divmod(other) {
      var $a, $iter = $Number_divmod$68.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_divmod$68.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy(($truthy($a = self['$nan?']()) ? $a : other['$nan?']()))) {
        return self.$raise($$($nesting, 'FloatDomainError'), "NaN")
      } else if ($truthy(self['$infinite?']())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "Infinity")
      } else {
        return $send(self, Opal.find_super_dispatcher(self, 'divmod', $Number_divmod$68, false), $zuper, $iter)
      }
    }, $Number_divmod$68.$$arity = 1);
    
    Opal.def(self, '$upto', $Number_upto$69 = function $$upto(stop) {
      var $iter = $Number_upto$69.$$p, block = $iter || nil, $$70, self = this;

      if ($iter) $Number_upto$69.$$p = null;
      
      
      if ($iter) $Number_upto$69.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["upto", stop], ($$70 = function(){var self = $$70.$$s || this;

        
          if ($truthy($$($nesting, 'Numeric')['$==='](stop))) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_lt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(stop, self), 1)
          };}, $$70.$$s = self, $$70.$$arity = 0, $$70))
      };
      
      if (!stop.$$is_number) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i <= stop; i++) {
        block(i);
      }
    ;
      return self;
    }, $Number_upto$69.$$arity = 1);
    
    Opal.def(self, '$zero?', $Number_zero$ques$71 = function() {
      var self = this;

      return self == 0;
    }, $Number_zero$ques$71.$$arity = 0);
    
    Opal.def(self, '$size', $Number_size$72 = function $$size() {
      var self = this;

      return 4
    }, $Number_size$72.$$arity = 0);
    
    Opal.def(self, '$nan?', $Number_nan$ques$73 = function() {
      var self = this;

      return isNaN(self);
    }, $Number_nan$ques$73.$$arity = 0);
    
    Opal.def(self, '$finite?', $Number_finite$ques$74 = function() {
      var self = this;

      return self != Infinity && self != -Infinity && !isNaN(self);
    }, $Number_finite$ques$74.$$arity = 0);
    
    Opal.def(self, '$infinite?', $Number_infinite$ques$75 = function() {
      var self = this;

      
      if (self == Infinity) {
        return +1;
      }
      else if (self == -Infinity) {
        return -1;
      }
      else {
        return nil;
      }
    
    }, $Number_infinite$ques$75.$$arity = 0);
    
    Opal.def(self, '$positive?', $Number_positive$ques$76 = function() {
      var self = this;

      return self != 0 && (self == Infinity || 1 / self > 0);
    }, $Number_positive$ques$76.$$arity = 0);
    return (Opal.def(self, '$negative?', $Number_negative$ques$77 = function() {
      var self = this;

      return self == -Infinity || 1 / self < 0;
    }, $Number_negative$ques$77.$$arity = 0), nil) && 'negative?';
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  Opal.const_set($nesting[0], 'Fixnum', $$($nesting, 'Number'));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Integer');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$78, $eq_eq_eq$79, $sqrt$80;

      
      
      Opal.def(self, '$allocate', $allocate$78 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$78.$$arity = 0);
      
      Opal.udef(self, '$' + "new");;
      
      Opal.def(self, '$===', $eq_eq_eq$79 = function(other) {
        var self = this;

        
        if (!other.$$is_number) {
          return false;
        }

        return (other % 1) === 0;
      
      }, $eq_eq_eq$79.$$arity = 1);
      return (Opal.def(self, '$sqrt', $sqrt$80 = function $$sqrt(n) {
        var self = this;

        
        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
        
        if (n < 0) {
          self.$raise($$$($$($nesting, 'Math'), 'DomainError'), "Numerical argument is out of domain - \"isqrt\"")
        }

        return parseInt(Math.sqrt(n), 10);
      ;
      }, $sqrt$80.$$arity = 1), nil) && 'sqrt';
    })(Opal.get_singleton_class(self), $nesting);
    Opal.const_set($nesting[0], 'MAX', Math.pow(2, 30) - 1);
    return Opal.const_set($nesting[0], 'MIN', -Math.pow(2, 30));
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Float');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$81, $eq_eq_eq$82;

      
      
      Opal.def(self, '$allocate', $allocate$81 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$81.$$arity = 0);
      
      Opal.udef(self, '$' + "new");;
      return (Opal.def(self, '$===', $eq_eq_eq$82 = function(other) {
        var self = this;

        return !!other.$$is_number;
      }, $eq_eq_eq$82.$$arity = 1), nil) && '===';
    })(Opal.get_singleton_class(self), $nesting);
    Opal.const_set($nesting[0], 'INFINITY', Infinity);
    Opal.const_set($nesting[0], 'MAX', Number.MAX_VALUE);
    Opal.const_set($nesting[0], 'MIN', Number.MIN_VALUE);
    Opal.const_set($nesting[0], 'NAN', NaN);
    Opal.const_set($nesting[0], 'DIG', 15);
    Opal.const_set($nesting[0], 'MANT_DIG', 53);
    Opal.const_set($nesting[0], 'RADIX', 2);
    return Opal.const_set($nesting[0], 'EPSILON', Number.EPSILON || 2.2204460492503130808472633361816E-16);
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/range"] = function(Opal) {
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$include', '$attr_reader', '$raise', '$<=>', '$include?', '$<=', '$<', '$enum_for', '$upto', '$to_proc', '$respond_to?', '$class', '$succ', '$!', '$==', '$===', '$exclude_end?', '$eql?', '$begin', '$end', '$last', '$to_a', '$>', '$-', '$abs', '$to_i', '$coerce_to!', '$ceil', '$/', '$size', '$loop', '$+', '$*', '$>=', '$each_with_index', '$%', '$bsearch', '$inspect', '$[]', '$hash']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Range');

    var $nesting = [self].concat($parent_nesting), $Range_initialize$1, $Range_$eq_eq$2, $Range_$eq_eq_eq$3, $Range_cover$ques$4, $Range_each$5, $Range_eql$ques$6, $Range_exclude_end$ques$7, $Range_first$8, $Range_last$9, $Range_max$10, $Range_min$11, $Range_size$12, $Range_step$13, $Range_bsearch$17, $Range_to_s$18, $Range_inspect$19, $Range_marshal_load$20, $Range_hash$21;

    self.$$prototype.begin = self.$$prototype.end = self.$$prototype.excl = nil;
    
    self.$include($$($nesting, 'Enumerable'));
    self.$$prototype.$$is_range = true;
    self.$attr_reader("begin", "end");
    
    Opal.def(self, '$initialize', $Range_initialize$1 = function $$initialize(first, last, exclude) {
      var self = this;

      
      
      if (exclude == null) {
        exclude = false;
      };
      if ($truthy(self.begin)) {
        self.$raise($$($nesting, 'NameError'), "'initialize' called twice")};
      if ($truthy(first['$<=>'](last))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "bad value for range")
      };
      self.begin = first;
      self.end = last;
      return (self.excl = exclude);
    }, $Range_initialize$1.$$arity = -3);
    
    Opal.def(self, '$==', $Range_$eq_eq$2 = function(other) {
      var self = this;

      
      if (!other.$$is_range) {
        return false;
      }

      return self.excl  === other.excl &&
             self.begin ==  other.begin &&
             self.end   ==  other.end;
    
    }, $Range_$eq_eq$2.$$arity = 1);
    
    Opal.def(self, '$===', $Range_$eq_eq_eq$3 = function(value) {
      var self = this;

      return self['$include?'](value)
    }, $Range_$eq_eq_eq$3.$$arity = 1);
    
    Opal.def(self, '$cover?', $Range_cover$ques$4 = function(value) {
      var $a, self = this, beg_cmp = nil, end_cmp = nil;

      
      beg_cmp = self.begin['$<=>'](value);
      if ($truthy(($truthy($a = beg_cmp) ? $rb_le(beg_cmp, 0) : $a))) {
      } else {
        return false
      };
      end_cmp = value['$<=>'](self.end);
      if ($truthy(self.excl)) {
        return ($truthy($a = end_cmp) ? $rb_lt(end_cmp, 0) : $a)
      } else {
        return ($truthy($a = end_cmp) ? $rb_le(end_cmp, 0) : $a)
      };
    }, $Range_cover$ques$4.$$arity = 1);
    
    Opal.def(self, '$each', $Range_each$5 = function $$each() {
      var $iter = $Range_each$5.$$p, block = $iter || nil, $a, self = this, current = nil, last = nil;

      if ($iter) $Range_each$5.$$p = null;
      
      
      if ($iter) $Range_each$5.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each")
      };
      
      var i, limit;

      if (self.begin.$$is_number && self.end.$$is_number) {
        if (self.begin % 1 !== 0 || self.end % 1 !== 0) {
          self.$raise($$($nesting, 'TypeError'), "can't iterate from Float")
        }

        for (i = self.begin, limit = self.end + (function() {if ($truthy(self.excl)) {
        return 0
      } else {
        return 1
      }; return nil; })(); i < limit; i++) {
          block(i);
        }

        return self;
      }

      if (self.begin.$$is_string && self.end.$$is_string) {
        $send(self.begin, 'upto', [self.end, self.excl], block.$to_proc())
        return self;
      }
    ;
      current = self.begin;
      last = self.end;
      if ($truthy(current['$respond_to?']("succ"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't iterate from " + (current.$class()))
      };
      while ($truthy($rb_lt(current['$<=>'](last), 0))) {
        
        Opal.yield1(block, current);
        current = current.$succ();
      };
      if ($truthy(($truthy($a = self.excl['$!']()) ? current['$=='](last) : $a))) {
        Opal.yield1(block, current)};
      return self;
    }, $Range_each$5.$$arity = 0);
    
    Opal.def(self, '$eql?', $Range_eql$ques$6 = function(other) {
      var $a, $b, self = this;

      
      if ($truthy($$($nesting, 'Range')['$==='](other))) {
      } else {
        return false
      };
      return ($truthy($a = ($truthy($b = self.excl['$==='](other['$exclude_end?']())) ? self.begin['$eql?'](other.$begin()) : $b)) ? self.end['$eql?'](other.$end()) : $a);
    }, $Range_eql$ques$6.$$arity = 1);
    
    Opal.def(self, '$exclude_end?', $Range_exclude_end$ques$7 = function() {
      var self = this;

      return self.excl
    }, $Range_exclude_end$ques$7.$$arity = 0);
    
    Opal.def(self, '$first', $Range_first$8 = function $$first(n) {
      var $iter = $Range_first$8.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_first$8.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      ;
      if ($truthy(n == null)) {
        return self.begin};
      return $send(self, Opal.find_super_dispatcher(self, 'first', $Range_first$8, false), $zuper, $iter);
    }, $Range_first$8.$$arity = -1);
    Opal.alias(self, "include?", "cover?");
    
    Opal.def(self, '$last', $Range_last$9 = function $$last(n) {
      var self = this;

      
      ;
      if ($truthy(n == null)) {
        return self.end};
      return self.$to_a().$last(n);
    }, $Range_last$9.$$arity = -1);
    
    Opal.def(self, '$max', $Range_max$10 = function $$max() {
      var $a, $iter = $Range_max$10.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_max$10.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if (($yield !== nil)) {
        return $send(self, Opal.find_super_dispatcher(self, 'max', $Range_max$10, false), $zuper, $iter)
      } else if ($truthy($rb_gt(self.begin, self.end))) {
        return nil
      } else if ($truthy(($truthy($a = self.excl) ? self.begin['$=='](self.end) : $a))) {
        return nil
      } else {
        return self.excl ? self.end - 1 : self.end
      }
    }, $Range_max$10.$$arity = 0);
    Opal.alias(self, "member?", "cover?");
    
    Opal.def(self, '$min', $Range_min$11 = function $$min() {
      var $a, $iter = $Range_min$11.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_min$11.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if (($yield !== nil)) {
        return $send(self, Opal.find_super_dispatcher(self, 'min', $Range_min$11, false), $zuper, $iter)
      } else if ($truthy($rb_gt(self.begin, self.end))) {
        return nil
      } else if ($truthy(($truthy($a = self.excl) ? self.begin['$=='](self.end) : $a))) {
        return nil
      } else {
        return self.begin
      }
    }, $Range_min$11.$$arity = 0);
    
    Opal.def(self, '$size', $Range_size$12 = function $$size() {
      var $a, self = this, range_begin = nil, range_end = nil, infinity = nil;

      
      range_begin = self.begin;
      range_end = self.end;
      if ($truthy(self.excl)) {
        range_end = $rb_minus(range_end, 1)};
      if ($truthy(($truthy($a = $$($nesting, 'Numeric')['$==='](range_begin)) ? $$($nesting, 'Numeric')['$==='](range_end) : $a))) {
      } else {
        return nil
      };
      if ($truthy($rb_lt(range_end, range_begin))) {
        return 0};
      infinity = $$$($$($nesting, 'Float'), 'INFINITY');
      if ($truthy([range_begin.$abs(), range_end.$abs()]['$include?'](infinity))) {
        return infinity};
      return (Math.abs(range_end - range_begin) + 1).$to_i();
    }, $Range_size$12.$$arity = 0);
    
    Opal.def(self, '$step', $Range_step$13 = function $$step(n) {
      var $$14, $$15, $$16, $iter = $Range_step$13.$$p, $yield = $iter || nil, self = this, i = nil;

      if ($iter) $Range_step$13.$$p = null;
      
      
      if (n == null) {
        n = 1;
      };
      
      function coerceStepSize() {
        if (!n.$$is_number) {
          n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int")
        }

        if (n < 0) {
          self.$raise($$($nesting, 'ArgumentError'), "step can't be negative")
        } else if (n === 0) {
          self.$raise($$($nesting, 'ArgumentError'), "step can't be 0")
        }
      }

      function enumeratorSize() {
        if (!self.begin['$respond_to?']("succ")) {
          return nil;
        }

        if (self.begin.$$is_string && self.end.$$is_string) {
          return nil;
        }

        if (n % 1 === 0) {
          return $rb_divide(self.$size(), n).$ceil();
        } else {
          // n is a float
          var begin = self.begin, end = self.end,
              abs = Math.abs, floor = Math.floor,
              err = (abs(begin) + abs(end) + abs(end - begin)) / abs(n) * $$$($$($nesting, 'Float'), 'EPSILON'),
              size;

          if (err > 0.5) {
            err = 0.5;
          }

          if (self.excl) {
            size = floor((end - begin) / n - err);
            if (size * n + begin < end) {
              size++;
            }
          } else {
            size = floor((end - begin) / n + err) + 1
          }

          return size;
        }
      }
    ;
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["step", n], ($$14 = function(){var self = $$14.$$s || this;

        
          coerceStepSize();
          return enumeratorSize();
        }, $$14.$$s = self, $$14.$$arity = 0, $$14))
      };
      coerceStepSize();
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
        
        i = 0;
        (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], ($$15 = function(){var self = $$15.$$s || this, current = nil;
          if (self.begin == null) self.begin = nil;
          if (self.excl == null) self.excl = nil;
          if (self.end == null) self.end = nil;

        
          current = $rb_plus(self.begin, $rb_times(i, n));
          if ($truthy(self.excl)) {
            if ($truthy($rb_ge(current, self.end))) {
              
              Opal.brk(nil, $brk)}
          } else if ($truthy($rb_gt(current, self.end))) {
            
            Opal.brk(nil, $brk)};
          Opal.yield1($yield, current);
          return (i = $rb_plus(i, 1));}, $$15.$$s = self, $$15.$$brk = $brk, $$15.$$arity = 0, $$15))
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
      } else {
        
        
        if (self.begin.$$is_string && self.end.$$is_string && n % 1 !== 0) {
          self.$raise($$($nesting, 'TypeError'), "no implicit conversion to float from string")
        }
      ;
        $send(self, 'each_with_index', [], ($$16 = function(value, idx){var self = $$16.$$s || this;

        
          
          if (value == null) {
            value = nil;
          };
          
          if (idx == null) {
            idx = nil;
          };
          if (idx['$%'](n)['$=='](0)) {
            return Opal.yield1($yield, value);
          } else {
            return nil
          };}, $$16.$$s = self, $$16.$$arity = 2, $$16));
      };
      return self;
    }, $Range_step$13.$$arity = -1);
    
    Opal.def(self, '$bsearch', $Range_bsearch$17 = function $$bsearch() {
      var $iter = $Range_bsearch$17.$$p, block = $iter || nil, self = this;

      if ($iter) $Range_bsearch$17.$$p = null;
      
      
      if ($iter) $Range_bsearch$17.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("bsearch")
      };
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't do binary search for " + (self.begin.$class()))
      };
      return $send(self.$to_a(), 'bsearch', [], block.$to_proc());
    }, $Range_bsearch$17.$$arity = 0);
    
    Opal.def(self, '$to_s', $Range_to_s$18 = function $$to_s() {
      var self = this;

      return "" + (self.begin) + ((function() {if ($truthy(self.excl)) {
        return "..."
      } else {
        return ".."
      }; return nil; })()) + (self.end)
    }, $Range_to_s$18.$$arity = 0);
    
    Opal.def(self, '$inspect', $Range_inspect$19 = function $$inspect() {
      var self = this;

      return "" + (self.begin.$inspect()) + ((function() {if ($truthy(self.excl)) {
        return "..."
      } else {
        return ".."
      }; return nil; })()) + (self.end.$inspect())
    }, $Range_inspect$19.$$arity = 0);
    
    Opal.def(self, '$marshal_load', $Range_marshal_load$20 = function $$marshal_load(args) {
      var self = this;

      
      self.begin = args['$[]']("begin");
      self.end = args['$[]']("end");
      return (self.excl = args['$[]']("excl"));
    }, $Range_marshal_load$20.$$arity = 1);
    return (Opal.def(self, '$hash', $Range_hash$21 = function $$hash() {
      var self = this;

      return [self.begin, self.end, self.excl].$hash()
    }, $Range_hash$21.$$arity = 0), nil) && 'hash';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/proc"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$raise', '$coerce_to!']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Proc');

    var $nesting = [self].concat($parent_nesting), $Proc_new$1, $Proc_call$2, $Proc_to_proc$3, $Proc_lambda$ques$4, $Proc_arity$5, $Proc_source_location$6, $Proc_binding$7, $Proc_parameters$8, $Proc_curry$9, $Proc_dup$10;

    
    Opal.defineProperty(self.$$prototype, '$$is_proc', true);
    Opal.defineProperty(self.$$prototype, '$$is_lambda', false);
    Opal.defs(self, '$new', $Proc_new$1 = function() {
      var $iter = $Proc_new$1.$$p, block = $iter || nil, self = this;

      if ($iter) $Proc_new$1.$$p = null;
      
      
      if ($iter) $Proc_new$1.$$p = null;;
      if ($truthy(block)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "tried to create a Proc object without a block")
      };
      return block;
    }, $Proc_new$1.$$arity = 0);
    
    Opal.def(self, '$call', $Proc_call$2 = function $$call($a) {
      var $iter = $Proc_call$2.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Proc_call$2.$$p = null;
      
      
      if ($iter) $Proc_call$2.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      if (block !== nil) {
        self.$$p = block;
      }

      var result, $brk = self.$$brk;

      if ($brk) {
        try {
          if (self.$$is_lambda) {
            result = self.apply(null, args);
          }
          else {
            result = Opal.yieldX(self, args);
          }
        } catch (err) {
          if (err === $brk) {
            return $brk.$v
          }
          else {
            throw err
          }
        }
      }
      else {
        if (self.$$is_lambda) {
          result = self.apply(null, args);
        }
        else {
          result = Opal.yieldX(self, args);
        }
      }

      return result;
    ;
    }, $Proc_call$2.$$arity = -1);
    Opal.alias(self, "[]", "call");
    Opal.alias(self, "===", "call");
    Opal.alias(self, "yield", "call");
    
    Opal.def(self, '$to_proc', $Proc_to_proc$3 = function $$to_proc() {
      var self = this;

      return self
    }, $Proc_to_proc$3.$$arity = 0);
    
    Opal.def(self, '$lambda?', $Proc_lambda$ques$4 = function() {
      var self = this;

      return !!self.$$is_lambda;
    }, $Proc_lambda$ques$4.$$arity = 0);
    
    Opal.def(self, '$arity', $Proc_arity$5 = function $$arity() {
      var self = this;

      
      if (self.$$is_curried) {
        return -1;
      } else {
        return self.$$arity;
      }
    
    }, $Proc_arity$5.$$arity = 0);
    
    Opal.def(self, '$source_location', $Proc_source_location$6 = function $$source_location() {
      var self = this;

      
      if (self.$$is_curried) { return nil; };
      return nil;
    }, $Proc_source_location$6.$$arity = 0);
    
    Opal.def(self, '$binding', $Proc_binding$7 = function $$binding() {
      var self = this;

      
      if (self.$$is_curried) { self.$raise($$($nesting, 'ArgumentError'), "Can't create Binding") };
      return nil;
    }, $Proc_binding$7.$$arity = 0);
    
    Opal.def(self, '$parameters', $Proc_parameters$8 = function $$parameters() {
      var self = this;

      
      if (self.$$is_curried) {
        return [["rest"]];
      } else if (self.$$parameters) {
        if (self.$$is_lambda) {
          return self.$$parameters;
        } else {
          var result = [], i, length;

          for (i = 0, length = self.$$parameters.length; i < length; i++) {
            var parameter = self.$$parameters[i];

            if (parameter[0] === 'req') {
              // required arguments always have name
              parameter = ['opt', parameter[1]];
            }

            result.push(parameter);
          }

          return result;
        }
      } else {
        return [];
      }
    
    }, $Proc_parameters$8.$$arity = 0);
    
    Opal.def(self, '$curry', $Proc_curry$9 = function $$curry(arity) {
      var self = this;

      
      ;
      
      if (arity === undefined) {
        arity = self.length;
      }
      else {
        arity = $$($nesting, 'Opal')['$coerce_to!'](arity, $$($nesting, 'Integer'), "to_int");
        if (self.$$is_lambda && arity !== self.length) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arity) + " for " + (self.length) + ")")
        }
      }

      function curried () {
        var args = $slice.call(arguments),
            length = args.length,
            result;

        if (length > arity && self.$$is_lambda && !self.$$is_curried) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (length) + " for " + (arity) + ")")
        }

        if (length >= arity) {
          return self.$call.apply(self, args);
        }

        result = function () {
          return curried.apply(null,
            args.concat($slice.call(arguments)));
        }
        result.$$is_lambda = self.$$is_lambda;
        result.$$is_curried = true;

        return result;
      };

      curried.$$is_lambda = self.$$is_lambda;
      curried.$$is_curried = true;
      return curried;
    ;
    }, $Proc_curry$9.$$arity = -1);
    
    Opal.def(self, '$dup', $Proc_dup$10 = function $$dup() {
      var self = this;

      
      var original_proc = self.$$original_proc || self,
          proc = function () {
            return original_proc.apply(this, arguments);
          };

      for (var prop in self) {
        if (self.hasOwnProperty(prop)) {
          proc[prop] = self[prop];
        }
      }

      return proc;
    
    }, $Proc_dup$10.$$arity = 0);
    return Opal.alias(self, "clone", "dup");
  })($nesting[0], Function, $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/method"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_reader', '$arity', '$new', '$class', '$join', '$source_location', '$raise']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Method');

    var $nesting = [self].concat($parent_nesting), $Method_initialize$1, $Method_arity$2, $Method_parameters$3, $Method_source_location$4, $Method_comments$5, $Method_call$6, $Method_unbind$7, $Method_to_proc$8, $Method_inspect$9;

    self.$$prototype.method = self.$$prototype.receiver = self.$$prototype.owner = self.$$prototype.name = nil;
    
    self.$attr_reader("owner", "receiver", "name");
    
    Opal.def(self, '$initialize', $Method_initialize$1 = function $$initialize(receiver, owner, method, name) {
      var self = this;

      
      self.receiver = receiver;
      self.owner = owner;
      self.name = name;
      return (self.method = method);
    }, $Method_initialize$1.$$arity = 4);
    
    Opal.def(self, '$arity', $Method_arity$2 = function $$arity() {
      var self = this;

      return self.method.$arity()
    }, $Method_arity$2.$$arity = 0);
    
    Opal.def(self, '$parameters', $Method_parameters$3 = function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, $Method_parameters$3.$$arity = 0);
    
    Opal.def(self, '$source_location', $Method_source_location$4 = function $$source_location() {
      var $a, self = this;

      return ($truthy($a = self.method.$$source_location) ? $a : ["(eval)", 0])
    }, $Method_source_location$4.$$arity = 0);
    
    Opal.def(self, '$comments', $Method_comments$5 = function $$comments() {
      var $a, self = this;

      return ($truthy($a = self.method.$$comments) ? $a : [])
    }, $Method_comments$5.$$arity = 0);
    
    Opal.def(self, '$call', $Method_call$6 = function $$call($a) {
      var $iter = $Method_call$6.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Method_call$6.$$p = null;
      
      
      if ($iter) $Method_call$6.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      self.method.$$p = block;

      return self.method.apply(self.receiver, args);
    ;
    }, $Method_call$6.$$arity = -1);
    Opal.alias(self, "[]", "call");
    
    Opal.def(self, '$unbind', $Method_unbind$7 = function $$unbind() {
      var self = this;

      return $$($nesting, 'UnboundMethod').$new(self.receiver.$class(), self.owner, self.method, self.name)
    }, $Method_unbind$7.$$arity = 0);
    
    Opal.def(self, '$to_proc', $Method_to_proc$8 = function $$to_proc() {
      var self = this;

      
      var proc = self.$call.bind(self);
      proc.$$unbound = self.method;
      proc.$$is_lambda = true;
      proc.$$arity = self.method.$$arity;
      proc.$$parameters = self.method.$$parameters;
      return proc;
    
    }, $Method_to_proc$8.$$arity = 0);
    return (Opal.def(self, '$inspect', $Method_inspect$9 = function $$inspect() {
      var self = this;

      return "" + "#<" + (self.$class()) + ": " + (self.receiver.$class()) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, $Method_inspect$9.$$arity = 0), nil) && 'inspect';
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'UnboundMethod');

    var $nesting = [self].concat($parent_nesting), $UnboundMethod_initialize$10, $UnboundMethod_arity$11, $UnboundMethod_parameters$12, $UnboundMethod_source_location$13, $UnboundMethod_comments$14, $UnboundMethod_bind$15, $UnboundMethod_inspect$16;

    self.$$prototype.method = self.$$prototype.owner = self.$$prototype.name = self.$$prototype.source = nil;
    
    self.$attr_reader("source", "owner", "name");
    
    Opal.def(self, '$initialize', $UnboundMethod_initialize$10 = function $$initialize(source, owner, method, name) {
      var self = this;

      
      self.source = source;
      self.owner = owner;
      self.method = method;
      return (self.name = name);
    }, $UnboundMethod_initialize$10.$$arity = 4);
    
    Opal.def(self, '$arity', $UnboundMethod_arity$11 = function $$arity() {
      var self = this;

      return self.method.$arity()
    }, $UnboundMethod_arity$11.$$arity = 0);
    
    Opal.def(self, '$parameters', $UnboundMethod_parameters$12 = function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, $UnboundMethod_parameters$12.$$arity = 0);
    
    Opal.def(self, '$source_location', $UnboundMethod_source_location$13 = function $$source_location() {
      var $a, self = this;

      return ($truthy($a = self.method.$$source_location) ? $a : ["(eval)", 0])
    }, $UnboundMethod_source_location$13.$$arity = 0);
    
    Opal.def(self, '$comments', $UnboundMethod_comments$14 = function $$comments() {
      var $a, self = this;

      return ($truthy($a = self.method.$$comments) ? $a : [])
    }, $UnboundMethod_comments$14.$$arity = 0);
    
    Opal.def(self, '$bind', $UnboundMethod_bind$15 = function $$bind(object) {
      var self = this;

      
      if (self.owner.$$is_module || Opal.is_a(object, self.owner)) {
        return $$($nesting, 'Method').$new(object, self.owner, self.method, self.name);
      }
      else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't bind singleton method to a different class (expected " + (object) + ".kind_of?(" + (self.owner) + " to be true)");
      }
    
    }, $UnboundMethod_bind$15.$$arity = 1);
    return (Opal.def(self, '$inspect', $UnboundMethod_inspect$16 = function $$inspect() {
      var self = this;

      return "" + "#<" + (self.$class()) + ": " + (self.source) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, $UnboundMethod_inspect$16.$$arity = 0), nil) && 'inspect';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/variables"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $gvars = Opal.gvars, $hash2 = Opal.hash2;

  Opal.add_stubs(['$new']);
  
  $gvars['&'] = $gvars['~'] = $gvars['`'] = $gvars["'"] = nil;
  $gvars.LOADED_FEATURES = ($gvars["\""] = Opal.loaded_features);
  $gvars.LOAD_PATH = ($gvars[":"] = []);
  $gvars["/"] = "\n";
  $gvars[","] = nil;
  Opal.const_set($nesting[0], 'ARGV', []);
  Opal.const_set($nesting[0], 'ARGF', $$($nesting, 'Object').$new());
  Opal.const_set($nesting[0], 'ENV', $hash2([], {}));
  $gvars.VERBOSE = false;
  $gvars.DEBUG = false;
  return ($gvars.SAFE = 0);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["opal/regexp_anchors"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module;

  Opal.add_stubs(['$==', '$new']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    
    Opal.const_set($nesting[0], 'REGEXP_START', (function() {if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
      return "^"
    } else {
      return nil
    }; return nil; })());
    Opal.const_set($nesting[0], 'REGEXP_END', (function() {if ($$($nesting, 'RUBY_ENGINE')['$==']("opal")) {
      return "$"
    } else {
      return nil
    }; return nil; })());
    Opal.const_set($nesting[0], 'FORBIDDEN_STARTING_IDENTIFIER_CHARS', "\\u0001-\\u002F\\u003A-\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    Opal.const_set($nesting[0], 'FORBIDDEN_ENDING_IDENTIFIER_CHARS', "\\u0001-\\u0020\\u0022-\\u002F\\u003A-\\u003E\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    Opal.const_set($nesting[0], 'INLINE_IDENTIFIER_REGEXP', $$($nesting, 'Regexp').$new("" + "[^" + ($$($nesting, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS')) + "]*[^" + ($$($nesting, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS')) + "]"));
    Opal.const_set($nesting[0], 'FORBIDDEN_CONST_NAME_CHARS', "\\u0001-\\u0020\\u0021-\\u002F\\u003B-\\u003F\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    Opal.const_set($nesting[0], 'CONST_NAME_REGEXP', $$($nesting, 'Regexp').$new("" + ($$($nesting, 'REGEXP_START')) + "(::)?[A-Z][^" + ($$($nesting, 'FORBIDDEN_CONST_NAME_CHARS')) + "]*" + ($$($nesting, 'REGEXP_END'))));
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["opal/mini"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$require']);
  
  self.$require("opal/base");
  self.$require("corelib/nil");
  self.$require("corelib/boolean");
  self.$require("corelib/string");
  self.$require("corelib/comparable");
  self.$require("corelib/enumerable");
  self.$require("corelib/enumerator");
  self.$require("corelib/array");
  self.$require("corelib/hash");
  self.$require("corelib/number");
  self.$require("corelib/range");
  self.$require("corelib/proc");
  self.$require("corelib/method");
  self.$require("corelib/regexp");
  self.$require("corelib/variables");
  return self.$require("opal/regexp_anchors");
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/string/encoding"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var $$11, $$14, $$17, $$20, $$23, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$+', '$[]', '$new', '$to_proc', '$each', '$const_set', '$sub', '$==', '$default_external', '$upcase', '$raise', '$attr_accessor', '$attr_reader', '$register', '$length', '$bytes', '$to_a', '$each_byte', '$dup', '$bytesize', '$enum_for', '$coerce_to!', '$find', '$<']);
  
  self.$require("corelib/string");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Encoding');

    var $nesting = [self].concat($parent_nesting), $Encoding_register$1, $Encoding_find$3, $Encoding_initialize$4, $Encoding_ascii_compatible$ques$5, $Encoding_dummy$ques$6, $Encoding_to_s$7, $Encoding_inspect$8, $Encoding_each_byte$9, $Encoding_bytesize$10;

    self.$$prototype.ascii = self.$$prototype.dummy = self.$$prototype.name = nil;
    
    Opal.defineProperty(self, '$$register', {});
    Opal.defs(self, '$register', $Encoding_register$1 = function $$register(name, options) {
      var $iter = $Encoding_register$1.$$p, block = $iter || nil, $a, $$2, self = this, names = nil, encoding = nil, register = nil;

      if ($iter) $Encoding_register$1.$$p = null;
      
      
      if ($iter) $Encoding_register$1.$$p = null;;
      
      if (options == null) {
        options = $hash2([], {});
      };
      names = $rb_plus([name], ($truthy($a = options['$[]']("aliases")) ? $a : []));
      encoding = $send($$($nesting, 'Class'), 'new', [self], block.$to_proc()).$new(name, names, ($truthy($a = options['$[]']("ascii")) ? $a : false), ($truthy($a = options['$[]']("dummy")) ? $a : false));
      register = self["$$register"];
      return $send(names, 'each', [], ($$2 = function(encoding_name){var self = $$2.$$s || this;

      
        
        if (encoding_name == null) {
          encoding_name = nil;
        };
        self.$const_set(encoding_name.$sub("-", "_"), encoding);
        return register["" + "$$" + (encoding_name)] = encoding;}, $$2.$$s = self, $$2.$$arity = 1, $$2));
    }, $Encoding_register$1.$$arity = -2);
    Opal.defs(self, '$find', $Encoding_find$3 = function $$find(name) {
      var $a, self = this, register = nil, encoding = nil;

      
      if (name['$==']("default_external")) {
        return self.$default_external()};
      register = self["$$register"];
      encoding = ($truthy($a = register["" + "$$" + (name)]) ? $a : register["" + "$$" + (name.$upcase())]);
      if ($truthy(encoding)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "unknown encoding name - " + (name))
      };
      return encoding;
    }, $Encoding_find$3.$$arity = 1);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      return self.$attr_accessor("default_external")
    })(Opal.get_singleton_class(self), $nesting);
    self.$attr_reader("name", "names");
    
    Opal.def(self, '$initialize', $Encoding_initialize$4 = function $$initialize(name, names, ascii, dummy) {
      var self = this;

      
      self.name = name;
      self.names = names;
      self.ascii = ascii;
      return (self.dummy = dummy);
    }, $Encoding_initialize$4.$$arity = 4);
    
    Opal.def(self, '$ascii_compatible?', $Encoding_ascii_compatible$ques$5 = function() {
      var self = this;

      return self.ascii
    }, $Encoding_ascii_compatible$ques$5.$$arity = 0);
    
    Opal.def(self, '$dummy?', $Encoding_dummy$ques$6 = function() {
      var self = this;

      return self.dummy
    }, $Encoding_dummy$ques$6.$$arity = 0);
    
    Opal.def(self, '$to_s', $Encoding_to_s$7 = function $$to_s() {
      var self = this;

      return self.name
    }, $Encoding_to_s$7.$$arity = 0);
    
    Opal.def(self, '$inspect', $Encoding_inspect$8 = function $$inspect() {
      var self = this;

      return "" + "#<Encoding:" + (self.name) + ((function() {if ($truthy(self.dummy)) {
        return " (dummy)"
      } else {
        return nil
      }; return nil; })()) + ">"
    }, $Encoding_inspect$8.$$arity = 0);
    
    Opal.def(self, '$each_byte', $Encoding_each_byte$9 = function $$each_byte($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'));
    }, $Encoding_each_byte$9.$$arity = -1);
    
    Opal.def(self, '$bytesize', $Encoding_bytesize$10 = function $$bytesize($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'));
    }, $Encoding_bytesize$10.$$arity = -1);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'EncodingError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'StandardError'), $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CompatibilityError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'EncodingError'), $nesting);
  })($nesting[0], null, $nesting);
  $send($$($nesting, 'Encoding'), 'register', ["UTF-8", $hash2(["aliases", "ascii"], {"aliases": ["CP65001"], "ascii": true})], ($$11 = function(){var self = $$11.$$s || this, $each_byte$12, $bytesize$13;

  
    
    Opal.def(self, '$each_byte', $each_byte$12 = function $$each_byte(string) {
      var $iter = $each_byte$12.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$12.$$p = null;
      
      
      if ($iter) $each_byte$12.$$p = null;;
      
      var units = Infinity
      var codePoint
      var length = string.length
      var leadSurrogate = null

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i)

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue
            }

            // valid lead
            leadSurrogate = codePoint

            continue
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) {
              Opal.yield1(block, 0xEF);
              Opal.yield1(block, 0xBF);
              Opal.yield1(block, 0xBD);
            }
            leadSurrogate = codePoint
            continue
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) {
            Opal.yield1(block, 0xEF);
            Opal.yield1(block, 0xBF);
            Opal.yield1(block, 0xBD);
          }
        }

        leadSurrogate = null

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          Opal.yield1(block, codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          Opal.yield1(block, codePoint >> 0x6 | 0xC0);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          Opal.yield1(block, codePoint >> 0xC | 0xE0);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          Opal.yield1(block, codePoint >> 0x12 | 0xF0);
          Opal.yield1(block, codePoint >> 0xC & 0x3F | 0x80);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else {
          // Invalid code point
        }
      }
    ;
    }, $each_byte$12.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$13 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$13.$$arity = 1), nil) && 'bytesize';}, $$11.$$s = self, $$11.$$arity = 0, $$11));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-16LE"], ($$14 = function(){var self = $$14.$$s || this, $each_byte$15, $bytesize$16;

  
    
    Opal.def(self, '$each_byte', $each_byte$15 = function $$each_byte(string) {
      var $iter = $each_byte$15.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$15.$$p = null;
      
      
      if ($iter) $each_byte$15.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    }, $each_byte$15.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$16 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$16.$$arity = 1), nil) && 'bytesize';}, $$14.$$s = self, $$14.$$arity = 0, $$14));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-16BE"], ($$17 = function(){var self = $$17.$$s || this, $each_byte$18, $bytesize$19;

  
    
    Opal.def(self, '$each_byte', $each_byte$18 = function $$each_byte(string) {
      var $iter = $each_byte$18.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$18.$$p = null;
      
      
      if ($iter) $each_byte$18.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, $each_byte$18.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$19 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$19.$$arity = 1), nil) && 'bytesize';}, $$17.$$s = self, $$17.$$arity = 0, $$17));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-32LE"], ($$20 = function(){var self = $$20.$$s || this, $each_byte$21, $bytesize$22;

  
    
    Opal.def(self, '$each_byte', $each_byte$21 = function $$each_byte(string) {
      var $iter = $each_byte$21.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$21.$$p = null;
      
      
      if ($iter) $each_byte$21.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    }, $each_byte$21.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$22 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$22.$$arity = 1), nil) && 'bytesize';}, $$20.$$s = self, $$20.$$arity = 0, $$20));
  $send($$($nesting, 'Encoding'), 'register', ["ASCII-8BIT", $hash2(["aliases", "ascii", "dummy"], {"aliases": ["BINARY", "US-ASCII", "ASCII"], "ascii": true, "dummy": true})], ($$23 = function(){var self = $$23.$$s || this, $each_byte$24, $bytesize$25;

  
    
    Opal.def(self, '$each_byte', $each_byte$24 = function $$each_byte(string) {
      var $iter = $each_byte$24.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$24.$$p = null;
      
      
      if ($iter) $each_byte$24.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);
        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    }, $each_byte$24.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$25 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$25.$$arity = 1), nil) && 'bytesize';}, $$23.$$s = self, $$23.$$arity = 0, $$23));
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_bytes$26, $String_bytesize$27, $String_each_byte$28, $String_encode$29, $String_force_encoding$30, $String_getbyte$31, $String_valid_encoding$ques$32;

    self.$$prototype.bytes = self.$$prototype.internal_encoding = nil;
    
    self.$attr_reader("encoding");
    self.$attr_reader("internal_encoding");
    Opal.defineProperty(String.prototype, 'bytes', nil);
    Opal.defineProperty(String.prototype, 'encoding', $$$($$($nesting, 'Encoding'), 'UTF_8'));
    Opal.defineProperty(String.prototype, 'internal_encoding', $$$($$($nesting, 'Encoding'), 'UTF_8'));
    
    Opal.def(self, '$bytes', $String_bytes$26 = function $$bytes() {
      var $a, self = this;

      
      self.bytes = ($truthy($a = self.bytes) ? $a : self.$each_byte().$to_a());
      return self.bytes.$dup();
    }, $String_bytes$26.$$arity = 0);
    
    Opal.def(self, '$bytesize', $String_bytesize$27 = function $$bytesize() {
      var self = this;

      return self.internal_encoding.$bytesize(self)
    }, $String_bytesize$27.$$arity = 0);
    
    Opal.def(self, '$each_byte', $String_each_byte$28 = function $$each_byte() {
      var $iter = $String_each_byte$28.$$p, block = $iter || nil, self = this;

      if ($iter) $String_each_byte$28.$$p = null;
      
      
      if ($iter) $String_each_byte$28.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each_byte")
      };
      $send(self.internal_encoding, 'each_byte', [self], block.$to_proc());
      return self;
    }, $String_each_byte$28.$$arity = 0);
    
    Opal.def(self, '$encode', $String_encode$29 = function $$encode(encoding) {
      var self = this;

      return Opal.enc(self, encoding);
    }, $String_encode$29.$$arity = 1);
    
    Opal.def(self, '$force_encoding', $String_force_encoding$30 = function $$force_encoding(encoding) {
      var self = this;

      
      if (encoding === self.encoding) { return self; }

      encoding = $$($nesting, 'Opal')['$coerce_to!'](encoding, $$($nesting, 'String'), "to_s");
      encoding = $$($nesting, 'Encoding').$find(encoding);

      if (encoding === self.encoding) { return self; }

      self.encoding = encoding;
      return self;
    
    }, $String_force_encoding$30.$$arity = 1);
    
    Opal.def(self, '$getbyte', $String_getbyte$31 = function $$getbyte(idx) {
      var self = this, string_bytes = nil;

      
      string_bytes = self.$bytes();
      idx = $$($nesting, 'Opal')['$coerce_to!'](idx, $$($nesting, 'Integer'), "to_int");
      if ($truthy($rb_lt(string_bytes.$length(), idx))) {
        return nil};
      return string_bytes['$[]'](idx);
    }, $String_getbyte$31.$$arity = 1);
    return (Opal.def(self, '$valid_encoding?', $String_valid_encoding$ques$32 = function() {
      var self = this;

      return true
    }, $String_valid_encoding$ques$32.$$arity = 0), nil) && 'valid_encoding?';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/struct"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$include', '$const_name!', '$unshift', '$map', '$coerce_to!', '$new', '$each', '$define_struct_attribute', '$allocate', '$initialize', '$alias_method', '$module_eval', '$to_proc', '$const_set', '$==', '$raise', '$<<', '$members', '$define_method', '$instance_eval', '$class', '$last', '$>', '$length', '$-', '$keys', '$any?', '$join', '$[]', '$[]=', '$each_with_index', '$hash', '$===', '$<', '$-@', '$size', '$>=', '$include?', '$to_sym', '$instance_of?', '$__id__', '$eql?', '$enum_for', '$name', '$+', '$each_pair', '$inspect', '$each_with_object', '$flatten', '$to_a', '$respond_to?', '$dig']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $Struct_new$1, $Struct_define_struct_attribute$6, $Struct_members$9, $Struct_inherited$10, $Struct_initialize$12, $Struct_members$15, $Struct_hash$16, $Struct_$$$17, $Struct_$$$eq$18, $Struct_$eq_eq$19, $Struct_eql$ques$20, $Struct_each$21, $Struct_each_pair$24, $Struct_length$27, $Struct_to_a$28, $Struct_inspect$30, $Struct_to_h$32, $Struct_values_at$34, $Struct_dig$36;

    
    self.$include($$($nesting, 'Enumerable'));
    Opal.defs(self, '$new', $Struct_new$1 = function(const_name, $a, $b) {
      var $iter = $Struct_new$1.$$p, block = $iter || nil, $post_args, $kwargs, args, keyword_init, $$2, $$3, self = this, klass = nil;

      if ($iter) $Struct_new$1.$$p = null;
      
      
      if ($iter) $Struct_new$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      args = $post_args;;
      
      keyword_init = $kwargs.$$smap["keyword_init"];
      if (keyword_init == null) {
        keyword_init = false
      };
      if ($truthy(const_name)) {
        
        try {
          const_name = $$($nesting, 'Opal')['$const_name!'](const_name)
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, 'TypeError'), $$($nesting, 'NameError')])) {
            try {
              
              args.$unshift(const_name);
              const_name = nil;
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };};
      $send(args, 'map', [], ($$2 = function(arg){var self = $$2.$$s || this;

      
        
        if (arg == null) {
          arg = nil;
        };
        return $$($nesting, 'Opal')['$coerce_to!'](arg, $$($nesting, 'String'), "to_str");}, $$2.$$s = self, $$2.$$arity = 1, $$2));
      klass = $send($$($nesting, 'Class'), 'new', [self], ($$3 = function(){var self = $$3.$$s || this, $$4;

      
        $send(args, 'each', [], ($$4 = function(arg){var self = $$4.$$s || this;

        
          
          if (arg == null) {
            arg = nil;
          };
          return self.$define_struct_attribute(arg);}, $$4.$$s = self, $$4.$$arity = 1, $$4));
        return (function(self, $parent_nesting) {
          var $nesting = [self].concat($parent_nesting), $new$5;

          
          
          Opal.def(self, '$new', $new$5 = function($a) {
            var $post_args, args, self = this, instance = nil;

            
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            instance = self.$allocate();
            instance.$$data = {};
            $send(instance, 'initialize', Opal.to_a(args));
            return instance;
          }, $new$5.$$arity = -1);
          return self.$alias_method("[]", "new");
        })(Opal.get_singleton_class(self), $nesting);}, $$3.$$s = self, $$3.$$arity = 0, $$3));
      if ($truthy(block)) {
        $send(klass, 'module_eval', [], block.$to_proc())};
      klass.$$keyword_init = keyword_init;
      if ($truthy(const_name)) {
        $$($nesting, 'Struct').$const_set(const_name, klass)};
      return klass;
    }, $Struct_new$1.$$arity = -2);
    Opal.defs(self, '$define_struct_attribute', $Struct_define_struct_attribute$6 = function $$define_struct_attribute(name) {
      var $$7, $$8, self = this;

      
      if (self['$==']($$($nesting, 'Struct'))) {
        self.$raise($$($nesting, 'ArgumentError'), "you cannot define attributes to the Struct class")};
      self.$members()['$<<'](name);
      $send(self, 'define_method', [name], ($$7 = function(){var self = $$7.$$s || this;

      return self.$$data[name];}, $$7.$$s = self, $$7.$$arity = 0, $$7));
      return $send(self, 'define_method', ["" + (name) + "="], ($$8 = function(value){var self = $$8.$$s || this;

      
        
        if (value == null) {
          value = nil;
        };
        return self.$$data[name] = value;;}, $$8.$$s = self, $$8.$$arity = 1, $$8));
    }, $Struct_define_struct_attribute$6.$$arity = 1);
    Opal.defs(self, '$members', $Struct_members$9 = function $$members() {
      var $a, self = this;
      if (self.members == null) self.members = nil;

      
      if (self['$==']($$($nesting, 'Struct'))) {
        self.$raise($$($nesting, 'ArgumentError'), "the Struct class has no members")};
      return (self.members = ($truthy($a = self.members) ? $a : []));
    }, $Struct_members$9.$$arity = 0);
    Opal.defs(self, '$inherited', $Struct_inherited$10 = function $$inherited(klass) {
      var $$11, self = this, members = nil;
      if (self.members == null) self.members = nil;

      
      members = self.members;
      return $send(klass, 'instance_eval', [], ($$11 = function(){var self = $$11.$$s || this;

      return (self.members = members)}, $$11.$$s = self, $$11.$$arity = 0, $$11));
    }, $Struct_inherited$10.$$arity = 1);
    
    Opal.def(self, '$initialize', $Struct_initialize$12 = function $$initialize($a) {
      var $post_args, args, $b, $$13, $$14, self = this, kwargs = nil, extra = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(self.$class().$$keyword_init)) {
        
        kwargs = ($truthy($b = args.$last()) ? $b : $hash2([], {}));
        if ($truthy(($truthy($b = $rb_gt(args.$length(), 1)) ? $b : (args.length === 1 && !kwargs.$$is_hash)))) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (given " + (args.$length()) + ", expected 0)")};
        extra = $rb_minus(kwargs.$keys(), self.$class().$members());
        if ($truthy(extra['$any?']())) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "unknown keywords: " + (extra.$join(", ")))};
        return $send(self.$class().$members(), 'each', [], ($$13 = function(name){var self = $$13.$$s || this, $writer = nil;

        
          
          if (name == null) {
            name = nil;
          };
          $writer = [name, kwargs['$[]'](name)];
          $send(self, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$13.$$s = self, $$13.$$arity = 1, $$13));
      } else {
        
        if ($truthy($rb_gt(args.$length(), self.$class().$members().$length()))) {
          self.$raise($$($nesting, 'ArgumentError'), "struct size differs")};
        return $send(self.$class().$members(), 'each_with_index', [], ($$14 = function(name, index){var self = $$14.$$s || this, $writer = nil;

        
          
          if (name == null) {
            name = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          $writer = [name, args['$[]'](index)];
          $send(self, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$14.$$s = self, $$14.$$arity = 2, $$14));
      };
    }, $Struct_initialize$12.$$arity = -1);
    
    Opal.def(self, '$members', $Struct_members$15 = function $$members() {
      var self = this;

      return self.$class().$members()
    }, $Struct_members$15.$$arity = 0);
    
    Opal.def(self, '$hash', $Struct_hash$16 = function $$hash() {
      var self = this;

      return $$($nesting, 'Hash').$new(self.$$data).$hash()
    }, $Struct_hash$16.$$arity = 0);
    
    Opal.def(self, '$[]', $Struct_$$$17 = function(name) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](name))) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")};
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")};
        name = self.$class().$members()['$[]'](name);
      } else if ($truthy($$($nesting, 'String')['$==='](name))) {
        
        if(!self.$$data.hasOwnProperty(name)) {
          self.$raise($$($nesting, 'NameError').$new("" + "no member '" + (name) + "' in struct", name))
        }
      
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      return self.$$data[name];;
    }, $Struct_$$$17.$$arity = 1);
    
    Opal.def(self, '$[]=', $Struct_$$$eq$18 = function(name, value) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](name))) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")};
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")};
        name = self.$class().$members()['$[]'](name);
      } else if ($truthy($$($nesting, 'String')['$==='](name))) {
        if ($truthy(self.$class().$members()['$include?'](name.$to_sym()))) {
        } else {
          self.$raise($$($nesting, 'NameError').$new("" + "no member '" + (name) + "' in struct", name))
        }
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      return self.$$data[name] = value;;
    }, $Struct_$$$eq$18.$$arity = 2);
    
    Opal.def(self, '$==', $Struct_$eq_eq$19 = function(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
      } else {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$($nesting, 'Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, $Struct_$eq_eq$19.$$arity = 1);
    
    Opal.def(self, '$eql?', $Struct_eql$ques$20 = function(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
      } else {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$($nesting, 'Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, $Struct_eql$ques$20.$$arity = 1);
    
    Opal.def(self, '$each', $Struct_each$21 = function $$each() {
      var $$22, $$23, $iter = $Struct_each$21.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Struct_each$21.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$22 = function(){var self = $$22.$$s || this;

        return self.$size()}, $$22.$$s = self, $$22.$$arity = 0, $$22))
      };
      $send(self.$class().$members(), 'each', [], ($$23 = function(name){var self = $$23.$$s || this;

      
        
        if (name == null) {
          name = nil;
        };
        return Opal.yield1($yield, self['$[]'](name));;}, $$23.$$s = self, $$23.$$arity = 1, $$23));
      return self;
    }, $Struct_each$21.$$arity = 0);
    
    Opal.def(self, '$each_pair', $Struct_each_pair$24 = function $$each_pair() {
      var $$25, $$26, $iter = $Struct_each_pair$24.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Struct_each_pair$24.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_pair"], ($$25 = function(){var self = $$25.$$s || this;

        return self.$size()}, $$25.$$s = self, $$25.$$arity = 0, $$25))
      };
      $send(self.$class().$members(), 'each', [], ($$26 = function(name){var self = $$26.$$s || this;

      
        
        if (name == null) {
          name = nil;
        };
        return Opal.yield1($yield, [name, self['$[]'](name)]);;}, $$26.$$s = self, $$26.$$arity = 1, $$26));
      return self;
    }, $Struct_each_pair$24.$$arity = 0);
    
    Opal.def(self, '$length', $Struct_length$27 = function $$length() {
      var self = this;

      return self.$class().$members().$length()
    }, $Struct_length$27.$$arity = 0);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$to_a', $Struct_to_a$28 = function $$to_a() {
      var $$29, self = this;

      return $send(self.$class().$members(), 'map', [], ($$29 = function(name){var self = $$29.$$s || this;

      
        
        if (name == null) {
          name = nil;
        };
        return self['$[]'](name);}, $$29.$$s = self, $$29.$$arity = 1, $$29))
    }, $Struct_to_a$28.$$arity = 0);
    Opal.alias(self, "values", "to_a");
    
    Opal.def(self, '$inspect', $Struct_inspect$30 = function $$inspect() {
      var $a, $$31, self = this, result = nil;

      
      result = "#<struct ";
      if ($truthy(($truthy($a = $$($nesting, 'Struct')['$==='](self)) ? self.$class().$name() : $a))) {
        result = $rb_plus(result, "" + (self.$class()) + " ")};
      result = $rb_plus(result, $send(self.$each_pair(), 'map', [], ($$31 = function(name, value){var self = $$31.$$s || this;

      
        
        if (name == null) {
          name = nil;
        };
        
        if (value == null) {
          value = nil;
        };
        return "" + (name) + "=" + (value.$inspect());}, $$31.$$s = self, $$31.$$arity = 2, $$31)).$join(", "));
      result = $rb_plus(result, ">");
      return result;
    }, $Struct_inspect$30.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$to_h', $Struct_to_h$32 = function $$to_h() {
      var $$33, self = this;

      return $send(self.$class().$members(), 'each_with_object', [$hash2([], {})], ($$33 = function(name, h){var self = $$33.$$s || this, $writer = nil;

      
        
        if (name == null) {
          name = nil;
        };
        
        if (h == null) {
          h = nil;
        };
        $writer = [name, self['$[]'](name)];
        $send(h, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];}, $$33.$$s = self, $$33.$$arity = 2, $$33))
    }, $Struct_to_h$32.$$arity = 0);
    
    Opal.def(self, '$values_at', $Struct_values_at$34 = function $$values_at($a) {
      var $post_args, args, $$35, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      args = $send(args, 'map', [], ($$35 = function(arg){var self = $$35.$$s || this;

      
        
        if (arg == null) {
          arg = nil;
        };
        return arg.$$is_range ? arg.$to_a() : arg;}, $$35.$$s = self, $$35.$$arity = 1, $$35)).$flatten();
      
      var result = [];
      for (var i = 0, len = args.length; i < len; i++) {
        if (!args[i].$$is_number) {
          self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + ((args[i]).$class()) + " into Integer")
        }
        result.push(self['$[]'](args[i]));
      }
      return result;
    ;
    }, $Struct_values_at$34.$$arity = -1);
    return (Opal.def(self, '$dig', $Struct_dig$36 = function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      keys = $post_args;;
      item = (function() {if ($truthy(key.$$is_string && self.$$data.hasOwnProperty(key))) {
        return self.$$data[key] || nil;
      } else {
        return nil
      }; return nil; })();
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(keys));
    }, $Struct_dig$36.$$arity = -2), nil) && 'dig';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/io"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $module = Opal.module, $send = Opal.send, $gvars = Opal.gvars, $truthy = Opal.truthy, $writer = nil;

  Opal.add_stubs(['$attr_accessor', '$size', '$write', '$join', '$map', '$String', '$empty?', '$concat', '$chomp', '$getbyte', '$getc', '$raise', '$new', '$write_proc=', '$-', '$extend']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IO');

    var $nesting = [self].concat($parent_nesting), $IO_tty$ques$1, $IO_closed$ques$2, $IO_write$3, $IO_flush$4;

    self.$$prototype.tty = self.$$prototype.closed = nil;
    
    Opal.const_set($nesting[0], 'SEEK_SET', 0);
    Opal.const_set($nesting[0], 'SEEK_CUR', 1);
    Opal.const_set($nesting[0], 'SEEK_END', 2);
    
    Opal.def(self, '$tty?', $IO_tty$ques$1 = function() {
      var self = this;

      return self.tty
    }, $IO_tty$ques$1.$$arity = 0);
    
    Opal.def(self, '$closed?', $IO_closed$ques$2 = function() {
      var self = this;

      return self.closed
    }, $IO_closed$ques$2.$$arity = 0);
    self.$attr_accessor("write_proc");
    
    Opal.def(self, '$write', $IO_write$3 = function $$write(string) {
      var self = this;

      
      self.write_proc(string);
      return string.$size();
    }, $IO_write$3.$$arity = 1);
    self.$attr_accessor("sync", "tty");
    
    Opal.def(self, '$flush', $IO_flush$4 = function $$flush() {
      var self = this;

      return nil
    }, $IO_flush$4.$$arity = 0);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Writable');

      var $nesting = [self].concat($parent_nesting), $Writable_$lt$lt$5, $Writable_print$6, $Writable_puts$8;

      
      
      Opal.def(self, '$<<', $Writable_$lt$lt$5 = function(string) {
        var self = this;

        
        self.$write(string);
        return self;
      }, $Writable_$lt$lt$5.$$arity = 1);
      
      Opal.def(self, '$print', $Writable_print$6 = function $$print($a) {
        var $post_args, args, $$7, self = this;
        if ($gvars[","] == null) $gvars[","] = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        self.$write($send(args, 'map', [], ($$7 = function(arg){var self = $$7.$$s || this;

        
          
          if (arg == null) {
            arg = nil;
          };
          return self.$String(arg);}, $$7.$$s = self, $$7.$$arity = 1, $$7)).$join($gvars[","]));
        return nil;
      }, $Writable_print$6.$$arity = -1);
      
      Opal.def(self, '$puts', $Writable_puts$8 = function $$puts($a) {
        var $post_args, args, $$9, self = this, newline = nil;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        newline = $gvars["/"];
        if ($truthy(args['$empty?']())) {
          self.$write($gvars["/"])
        } else {
          self.$write($send(args, 'map', [], ($$9 = function(arg){var self = $$9.$$s || this;

          
            
            if (arg == null) {
              arg = nil;
            };
            return self.$String(arg).$chomp();}, $$9.$$s = self, $$9.$$arity = 1, $$9)).$concat([nil]).$join(newline))
        };
        return nil;
      }, $Writable_puts$8.$$arity = -1);
    })($nesting[0], $nesting);
    return (function($base, $parent_nesting) {
      var self = $module($base, 'Readable');

      var $nesting = [self].concat($parent_nesting), $Readable_readbyte$10, $Readable_readchar$11, $Readable_readline$12, $Readable_readpartial$13;

      
      
      Opal.def(self, '$readbyte', $Readable_readbyte$10 = function $$readbyte() {
        var self = this;

        return self.$getbyte()
      }, $Readable_readbyte$10.$$arity = 0);
      
      Opal.def(self, '$readchar', $Readable_readchar$11 = function $$readchar() {
        var self = this;

        return self.$getc()
      }, $Readable_readchar$11.$$arity = 0);
      
      Opal.def(self, '$readline', $Readable_readline$12 = function $$readline(sep) {
        var self = this;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        
        
        if (sep == null) {
          sep = $gvars["/"];
        };
        return self.$raise($$($nesting, 'NotImplementedError'));
      }, $Readable_readline$12.$$arity = -1);
      
      Opal.def(self, '$readpartial', $Readable_readpartial$13 = function $$readpartial(integer, outbuf) {
        var self = this;

        
        
        if (outbuf == null) {
          outbuf = nil;
        };
        return self.$raise($$($nesting, 'NotImplementedError'));
      }, $Readable_readpartial$13.$$arity = -2);
    })($nesting[0], $nesting);
  })($nesting[0], null, $nesting);
  Opal.const_set($nesting[0], 'STDERR', ($gvars.stderr = $$($nesting, 'IO').$new()));
  Opal.const_set($nesting[0], 'STDIN', ($gvars.stdin = $$($nesting, 'IO').$new()));
  Opal.const_set($nesting[0], 'STDOUT', ($gvars.stdout = $$($nesting, 'IO').$new()));
  var console = Opal.global.console;
  
  $writer = [typeof(process) === 'object' && typeof(process.stdout) === 'object' ? function(s){process.stdout.write(s)} : function(s){console.log(s)}];
  $send($$($nesting, 'STDOUT'), 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [typeof(process) === 'object' && typeof(process.stderr) === 'object' ? function(s){process.stderr.write(s)} : function(s){console.warn(s)}];
  $send($$($nesting, 'STDERR'), 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  $$($nesting, 'STDOUT').$extend($$$($$($nesting, 'IO'), 'Writable'));
  return $$($nesting, 'STDERR').$extend($$$($$($nesting, 'IO'), 'Writable'));
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/main"] = function(Opal) {
  var $to_s$1, $include$2, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$include']);
  
  Opal.defs(self, '$to_s', $to_s$1 = function $$to_s() {
    var self = this;

    return "main"
  }, $to_s$1.$$arity = 0);
  return (Opal.defs(self, '$include', $include$2 = function $$include(mod) {
    var self = this;

    return $$($nesting, 'Object').$include(mod)
  }, $include$2.$$arity = 1), nil) && 'include';
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/dir"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$[]']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Dir');

    var $nesting = [self].concat($parent_nesting);

    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $chdir$1, $pwd$2, $home$3;

      
      
      Opal.def(self, '$chdir', $chdir$1 = function $$chdir(dir) {
        var $iter = $chdir$1.$$p, $yield = $iter || nil, self = this, prev_cwd = nil;

        if ($iter) $chdir$1.$$p = null;
        return (function() { try {
        
        prev_cwd = Opal.current_dir;
        Opal.current_dir = dir;
        return Opal.yieldX($yield, []);;
        } finally {
          Opal.current_dir = prev_cwd
        }; })()
      }, $chdir$1.$$arity = 1);
      
      Opal.def(self, '$pwd', $pwd$2 = function $$pwd() {
        var self = this;

        return Opal.current_dir || '.';
      }, $pwd$2.$$arity = 0);
      Opal.alias(self, "getwd", "pwd");
      return (Opal.def(self, '$home', $home$3 = function $$home() {
        var $a, self = this;

        return ($truthy($a = $$($nesting, 'ENV')['$[]']("HOME")) ? $a : ".")
      }, $home$3.$$arity = 0), nil) && 'home';
    })(Opal.get_singleton_class(self), $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/file"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range, $send = Opal.send;

  Opal.add_stubs(['$respond_to?', '$to_path', '$pwd', '$split', '$sub', '$+', '$unshift', '$join', '$home', '$raise', '$start_with?', '$absolute_path', '$coerce_to!', '$basename', '$empty?', '$rindex', '$[]', '$nil?', '$==', '$-', '$length', '$gsub', '$find', '$=~', '$map', '$each_with_index', '$flatten', '$reject', '$to_proc', '$end_with?']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), windows_root_rx = nil;

    
    Opal.const_set($nesting[0], 'Separator', Opal.const_set($nesting[0], 'SEPARATOR', "/"));
    Opal.const_set($nesting[0], 'ALT_SEPARATOR', nil);
    Opal.const_set($nesting[0], 'PATH_SEPARATOR', ":");
    Opal.const_set($nesting[0], 'FNM_SYSCASE', 0);
    windows_root_rx = /^[a-zA-Z]:(?:\\|\/)/;
    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $absolute_path$1, $expand_path$2, $dirname$3, $basename$4, $extname$5, $exist$ques$6, $directory$ques$7, $join$9, $split$12;

      
      
      Opal.def(self, '$absolute_path', $absolute_path$1 = function $$absolute_path(path, basedir) {
        var $a, self = this, sep = nil, sep_chars = nil, new_parts = nil, path_abs = nil, basedir_abs = nil, parts = nil, leading_sep = nil, abs = nil, new_path = nil;

        
        
        if (basedir == null) {
          basedir = nil;
        };
        sep = $$($nesting, 'SEPARATOR');
        sep_chars = $sep_chars();
        new_parts = [];
        path = (function() {if ($truthy(path['$respond_to?']("to_path"))) {
          return path.$to_path()
        } else {
          return path
        }; return nil; })();
        basedir = ($truthy($a = basedir) ? $a : $$($nesting, 'Dir').$pwd());
        path_abs = path.substr(0, sep.length) === sep || windows_root_rx.test(path);
        basedir_abs = basedir.substr(0, sep.length) === sep || windows_root_rx.test(basedir);
        if ($truthy(path_abs)) {
          
          parts = path.$split(new RegExp("" + "[" + (sep_chars) + "]"));
          leading_sep = windows_root_rx.test(path) ? '' : path.$sub(new RegExp("" + "^([" + (sep_chars) + "]+).*$"), "\\1");
          abs = true;
        } else {
          
          parts = $rb_plus(basedir.$split(new RegExp("" + "[" + (sep_chars) + "]")), path.$split(new RegExp("" + "[" + (sep_chars) + "]")));
          leading_sep = windows_root_rx.test(basedir) ? '' : basedir.$sub(new RegExp("" + "^([" + (sep_chars) + "]+).*$"), "\\1");
          abs = basedir_abs;
        };
        
        var part;
        for (var i = 0, ii = parts.length; i < ii; i++) {
          part = parts[i];

          if (
            (part === nil) ||
            (part === ''  && ((new_parts.length === 0) || abs)) ||
            (part === '.' && ((new_parts.length === 0) || abs))
          ) {
            continue;
          }
          if (part === '..') {
            new_parts.pop();
          } else {
            new_parts.push(part);
          }
        }

        if (!abs && parts[0] !== '.') {
          new_parts.$unshift(".")
        }
      ;
        new_path = new_parts.$join(sep);
        if ($truthy(abs)) {
          new_path = $rb_plus(leading_sep, new_path)};
        return new_path;
      }, $absolute_path$1.$$arity = -2);
      
      Opal.def(self, '$expand_path', $expand_path$2 = function $$expand_path(path, basedir) {
        var self = this, sep = nil, sep_chars = nil, home = nil, leading_sep = nil, home_path_regexp = nil;

        
        
        if (basedir == null) {
          basedir = nil;
        };
        sep = $$($nesting, 'SEPARATOR');
        sep_chars = $sep_chars();
        if ($truthy(path[0] === '~' || (basedir && basedir[0] === '~'))) {
          
          home = $$($nesting, 'Dir').$home();
          if ($truthy(home)) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "couldn't find HOME environment -- expanding `~'")
          };
          leading_sep = windows_root_rx.test(home) ? '' : home.$sub(new RegExp("" + "^([" + (sep_chars) + "]+).*$"), "\\1");
          if ($truthy(home['$start_with?'](leading_sep))) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "non-absolute home")
          };
          home = $rb_plus(home, sep);
          home_path_regexp = new RegExp("" + "^\\~(?:" + (sep) + "|$)");
          path = path.$sub(home_path_regexp, home);
          if ($truthy(basedir)) {
            basedir = basedir.$sub(home_path_regexp, home)};};
        return self.$absolute_path(path, basedir);
      }, $expand_path$2.$$arity = -2);
      Opal.alias(self, "realpath", "expand_path");
      
      // Coerce a given path to a path string using #to_path and #to_str
      function $coerce_to_path(path) {
        if ($truthy((path)['$respond_to?']("to_path"))) {
          path = path.$to_path();
        }

        path = $$($nesting, 'Opal')['$coerce_to!'](path, $$($nesting, 'String'), "to_str");

        return path;
      }

      // Return a RegExp compatible char class
      function $sep_chars() {
        if ($$($nesting, 'ALT_SEPARATOR') === nil) {
          return Opal.escape_regexp($$($nesting, 'SEPARATOR'));
        } else {
          return Opal.escape_regexp($rb_plus($$($nesting, 'SEPARATOR'), $$($nesting, 'ALT_SEPARATOR')));
        }
      }
    ;
      
      Opal.def(self, '$dirname', $dirname$3 = function $$dirname(path) {
        var self = this, sep_chars = nil;

        
        sep_chars = $sep_chars();
        path = $coerce_to_path(path);
        
        var absolute = path.match(new RegExp("" + "^[" + (sep_chars) + "]"));

        path = path.replace(new RegExp("" + "[" + (sep_chars) + "]+$"), ''); // remove trailing separators
        path = path.replace(new RegExp("" + "[^" + (sep_chars) + "]+$"), ''); // remove trailing basename
        path = path.replace(new RegExp("" + "[" + (sep_chars) + "]+$"), ''); // remove final trailing separators

        if (path === '') {
          return absolute ? '/' : '.';
        }

        return path;
      ;
      }, $dirname$3.$$arity = 1);
      
      Opal.def(self, '$basename', $basename$4 = function $$basename(name, suffix) {
        var self = this, sep_chars = nil;

        
        
        if (suffix == null) {
          suffix = nil;
        };
        sep_chars = $sep_chars();
        name = $coerce_to_path(name);
        
        if (name.length == 0) {
          return name;
        }

        if (suffix !== nil) {
          suffix = $$($nesting, 'Opal')['$coerce_to!'](suffix, $$($nesting, 'String'), "to_str")
        } else {
          suffix = null;
        }

        name = name.replace(new RegExp("" + "(.)[" + (sep_chars) + "]*$"), '$1');
        name = name.replace(new RegExp("" + "^(?:.*[" + (sep_chars) + "])?([^" + (sep_chars) + "]+)$"), '$1');

        if (suffix === ".*") {
          name = name.replace(/\.[^\.]+$/, '');
        } else if(suffix !== null) {
          suffix = Opal.escape_regexp(suffix);
          name = name.replace(new RegExp("" + (suffix) + "$"), '');
        }

        return name;
      ;
      }, $basename$4.$$arity = -2);
      
      Opal.def(self, '$extname', $extname$5 = function $$extname(path) {
        var $a, self = this, filename = nil, last_dot_idx = nil;

        
        path = $coerce_to_path(path);
        filename = self.$basename(path);
        if ($truthy(filename['$empty?']())) {
          return ""};
        last_dot_idx = filename['$[]']($range(1, -1, false)).$rindex(".");
        if ($truthy(($truthy($a = last_dot_idx['$nil?']()) ? $a : $rb_plus(last_dot_idx, 1)['$==']($rb_minus(filename.$length(), 1))))) {
          return ""
        } else {
          return filename['$[]'](Opal.Range.$new($rb_plus(last_dot_idx, 1), -1, false))
        };
      }, $extname$5.$$arity = 1);
      
      Opal.def(self, '$exist?', $exist$ques$6 = function(path) {
        var self = this;

        return Opal.modules[path] != null
      }, $exist$ques$6.$$arity = 1);
      Opal.alias(self, "exists?", "exist?");
      
      Opal.def(self, '$directory?', $directory$ques$7 = function(path) {
        var $$8, self = this, files = nil, file = nil;

        
        files = [];
        
        for (var key in Opal.modules) {
          files.push(key)
        }
      ;
        path = path.$gsub(new RegExp("" + "(^." + ($$($nesting, 'SEPARATOR')) + "+|" + ($$($nesting, 'SEPARATOR')) + "+$)"));
        file = $send(files, 'find', [], ($$8 = function(f){var self = $$8.$$s || this;

        
          
          if (f == null) {
            f = nil;
          };
          return f['$=~'](new RegExp("" + "^" + (path)));}, $$8.$$s = self, $$8.$$arity = 1, $$8));
        return file;
      }, $directory$ques$7.$$arity = 1);
      
      Opal.def(self, '$join', $join$9 = function $$join($a) {
        var $post_args, paths, $$10, $$11, self = this, result = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        paths = $post_args;;
        if ($truthy(paths['$empty?']())) {
          return ""};
        result = "";
        paths = $send(paths.$flatten().$each_with_index(), 'map', [], ($$10 = function(item, index){var self = $$10.$$s || this, $b;

        
          
          if (item == null) {
            item = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          if ($truthy((($b = index['$=='](0)) ? item['$empty?']() : index['$=='](0)))) {
            return $$($nesting, 'SEPARATOR')
          } else if ($truthy((($b = paths.$length()['$==']($rb_plus(index, 1))) ? item['$empty?']() : paths.$length()['$==']($rb_plus(index, 1))))) {
            return $$($nesting, 'SEPARATOR')
          } else {
            return item
          };}, $$10.$$s = self, $$10.$$arity = 2, $$10));
        paths = $send(paths, 'reject', [], "empty?".$to_proc());
        $send(paths, 'each_with_index', [], ($$11 = function(item, index){var self = $$11.$$s || this, $b, next_item = nil;

        
          
          if (item == null) {
            item = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          next_item = paths['$[]']($rb_plus(index, 1));
          if ($truthy(next_item['$nil?']())) {
            return (result = "" + (result) + (item))
          } else {
            
            if ($truthy(($truthy($b = item['$end_with?']($$($nesting, 'SEPARATOR'))) ? next_item['$start_with?']($$($nesting, 'SEPARATOR')) : $b))) {
              item = item.$sub(new RegExp("" + ($$($nesting, 'SEPARATOR')) + "+$"), "")};
            return (result = (function() {if ($truthy(($truthy($b = item['$end_with?']($$($nesting, 'SEPARATOR'))) ? $b : next_item['$start_with?']($$($nesting, 'SEPARATOR'))))) {
              return "" + (result) + (item)
            } else {
              return "" + (result) + (item) + ($$($nesting, 'SEPARATOR'))
            }; return nil; })());
          };}, $$11.$$s = self, $$11.$$arity = 2, $$11));
        return result;
      }, $join$9.$$arity = -1);
      return (Opal.def(self, '$split', $split$12 = function $$split(path) {
        var self = this;

        return path.$split($$($nesting, 'SEPARATOR'))
      }, $split$12.$$arity = 1), nil) && 'split';
    })(Opal.get_singleton_class(self), $nesting);
  })($nesting[0], $$($nesting, 'IO'), $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/process"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$const_set', '$size', '$<<', '$__register_clock__', '$to_f', '$now', '$new', '$[]', '$raise']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Process');

    var $nesting = [self].concat($parent_nesting), $Process___register_clock__$1, $Process_pid$2, $Process_times$3, $Process_clock_gettime$4, monotonic = nil;

    
    self.__clocks__ = [];
    Opal.defs(self, '$__register_clock__', $Process___register_clock__$1 = function $$__register_clock__(name, func) {
      var self = this;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      self.$const_set(name, self.__clocks__.$size());
      return self.__clocks__['$<<'](func);
    }, $Process___register_clock__$1.$$arity = 2);
    self.$__register_clock__("CLOCK_REALTIME", function() { return Date.now() });
    monotonic = false;
    
    if (Opal.global.performance) {
      monotonic = function() {
        return performance.now()
      };
    }
    else if (Opal.global.process && process.hrtime) {
      // let now be the base to get smaller numbers
      var hrtime_base = process.hrtime();

      monotonic = function() {
        var hrtime = process.hrtime(hrtime_base);
        var us = (hrtime[1] / 1000) | 0; // cut below microsecs;
        return ((hrtime[0] * 1000) + (us / 1000));
      };
    }
  ;
    if ($truthy(monotonic)) {
      self.$__register_clock__("CLOCK_MONOTONIC", monotonic)};
    Opal.defs(self, '$pid', $Process_pid$2 = function $$pid() {
      var self = this;

      return 0
    }, $Process_pid$2.$$arity = 0);
    Opal.defs(self, '$times', $Process_times$3 = function $$times() {
      var self = this, t = nil;

      
      t = $$($nesting, 'Time').$now().$to_f();
      return $$$($$($nesting, 'Benchmark'), 'Tms').$new(t, t, t, t, t);
    }, $Process_times$3.$$arity = 0);
    return (Opal.defs(self, '$clock_gettime', $Process_clock_gettime$4 = function $$clock_gettime(clock_id, unit) {
      var $a, self = this, clock = nil;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      
      if (unit == null) {
        unit = "float_second";
      };
      ($truthy($a = (clock = self.__clocks__['$[]'](clock_id))) ? $a : self.$raise($$$($$($nesting, 'Errno'), 'EINVAL'), "" + "clock_gettime(" + (clock_id) + ") " + (self.__clocks__['$[]'](clock_id))));
      
      var ms = clock();
      switch (unit) {
        case 'float_second':      return  (ms / 1000);         // number of seconds as a float (default)
        case 'float_millisecond': return  (ms / 1);            // number of milliseconds as a float
        case 'float_microsecond': return  (ms * 1000);         // number of microseconds as a float
        case 'second':            return ((ms / 1000)    | 0); // number of seconds as an integer
        case 'millisecond':       return ((ms / 1)       | 0); // number of milliseconds as an integer
        case 'microsecond':       return ((ms * 1000)    | 0); // number of microseconds as an integer
        case 'nanosecond':        return ((ms * 1000000) | 0); // number of nanoseconds as an integer
        default: self.$raise($$($nesting, 'ArgumentError'), "" + "unexpected unit: " + (unit))
      }
    ;
    }, $Process_clock_gettime$4.$$arity = -2), nil) && 'clock_gettime';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Signal');

    var $nesting = [self].concat($parent_nesting), $Signal_trap$5;

    return (Opal.defs(self, '$trap', $Signal_trap$5 = function $$trap($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Signal_trap$5.$$arity = -1), nil) && 'trap'
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'GC');

    var $nesting = [self].concat($parent_nesting), $GC_start$6;

    return (Opal.defs(self, '$start', $GC_start$6 = function $$start() {
      var self = this;

      return nil
    }, $GC_start$6.$$arity = 0), nil) && 'start'
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/unsupported"] = function(Opal) {
  var $public$35, $private$36, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $module = Opal.module;

  Opal.add_stubs(['$raise', '$warn', '$%']);
  
  
  var warnings = {};

  function handle_unsupported_feature(message) {
    switch (Opal.config.unsupported_features_severity) {
    case 'error':
      $$($nesting, 'Kernel').$raise($$($nesting, 'NotImplementedError'), message)
      break;
    case 'warning':
      warn(message)
      break;
    default: // ignore
      // noop
    }
  }

  function warn(string) {
    if (warnings[string]) {
      return;
    }

    warnings[string] = true;
    self.$warn(string);
  }
;
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_$lt$lt$1, $String_capitalize$excl$2, $String_chomp$excl$3, $String_chop$excl$4, $String_downcase$excl$5, $String_gsub$excl$6, $String_lstrip$excl$7, $String_next$excl$8, $String_reverse$excl$9, $String_slice$excl$10, $String_squeeze$excl$11, $String_strip$excl$12, $String_sub$excl$13, $String_succ$excl$14, $String_swapcase$excl$15, $String_tr$excl$16, $String_tr_s$excl$17, $String_upcase$excl$18, $String_prepend$19, $String_$$$eq$20, $String_clear$21, $String_encode$excl$22, $String_unicode_normalize$excl$23;

    
    var ERROR = "String#%s not supported. Mutable String methods are not supported in Opal.";
    
    Opal.def(self, '$<<', $String_$lt$lt$1 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("<<"));
    }, $String_$lt$lt$1.$$arity = -1);
    
    Opal.def(self, '$capitalize!', $String_capitalize$excl$2 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("capitalize!"));
    }, $String_capitalize$excl$2.$$arity = -1);
    
    Opal.def(self, '$chomp!', $String_chomp$excl$3 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("chomp!"));
    }, $String_chomp$excl$3.$$arity = -1);
    
    Opal.def(self, '$chop!', $String_chop$excl$4 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("chop!"));
    }, $String_chop$excl$4.$$arity = -1);
    
    Opal.def(self, '$downcase!', $String_downcase$excl$5 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("downcase!"));
    }, $String_downcase$excl$5.$$arity = -1);
    
    Opal.def(self, '$gsub!', $String_gsub$excl$6 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("gsub!"));
    }, $String_gsub$excl$6.$$arity = -1);
    
    Opal.def(self, '$lstrip!', $String_lstrip$excl$7 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("lstrip!"));
    }, $String_lstrip$excl$7.$$arity = -1);
    
    Opal.def(self, '$next!', $String_next$excl$8 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("next!"));
    }, $String_next$excl$8.$$arity = -1);
    
    Opal.def(self, '$reverse!', $String_reverse$excl$9 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("reverse!"));
    }, $String_reverse$excl$9.$$arity = -1);
    
    Opal.def(self, '$slice!', $String_slice$excl$10 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("slice!"));
    }, $String_slice$excl$10.$$arity = -1);
    
    Opal.def(self, '$squeeze!', $String_squeeze$excl$11 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("squeeze!"));
    }, $String_squeeze$excl$11.$$arity = -1);
    
    Opal.def(self, '$strip!', $String_strip$excl$12 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("strip!"));
    }, $String_strip$excl$12.$$arity = -1);
    
    Opal.def(self, '$sub!', $String_sub$excl$13 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("sub!"));
    }, $String_sub$excl$13.$$arity = -1);
    
    Opal.def(self, '$succ!', $String_succ$excl$14 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("succ!"));
    }, $String_succ$excl$14.$$arity = -1);
    
    Opal.def(self, '$swapcase!', $String_swapcase$excl$15 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("swapcase!"));
    }, $String_swapcase$excl$15.$$arity = -1);
    
    Opal.def(self, '$tr!', $String_tr$excl$16 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("tr!"));
    }, $String_tr$excl$16.$$arity = -1);
    
    Opal.def(self, '$tr_s!', $String_tr_s$excl$17 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("tr_s!"));
    }, $String_tr_s$excl$17.$$arity = -1);
    
    Opal.def(self, '$upcase!', $String_upcase$excl$18 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("upcase!"));
    }, $String_upcase$excl$18.$$arity = -1);
    
    Opal.def(self, '$prepend', $String_prepend$19 = function $$prepend($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("prepend"));
    }, $String_prepend$19.$$arity = -1);
    
    Opal.def(self, '$[]=', $String_$$$eq$20 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("[]="));
    }, $String_$$$eq$20.$$arity = -1);
    
    Opal.def(self, '$clear', $String_clear$21 = function $$clear($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("clear"));
    }, $String_clear$21.$$arity = -1);
    
    Opal.def(self, '$encode!', $String_encode$excl$22 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("encode!"));
    }, $String_encode$excl$22.$$arity = -1);
    return (Opal.def(self, '$unicode_normalize!', $String_unicode_normalize$excl$23 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("unicode_normalize!"));
    }, $String_unicode_normalize$excl$23.$$arity = -1), nil) && 'unicode_normalize!';
  })($nesting[0], null, $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_freeze$24, $Kernel_frozen$ques$25;

    
    var ERROR = "Object freezing is not supported by Opal";
    
    Opal.def(self, '$freeze', $Kernel_freeze$24 = function $$freeze() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, $Kernel_freeze$24.$$arity = 0);
    
    Opal.def(self, '$frozen?', $Kernel_frozen$ques$25 = function() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return false;
    }, $Kernel_frozen$ques$25.$$arity = 0);
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_taint$26, $Kernel_untaint$27, $Kernel_tainted$ques$28;

    
    var ERROR = "Object tainting is not supported by Opal";
    
    Opal.def(self, '$taint', $Kernel_taint$26 = function $$taint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, $Kernel_taint$26.$$arity = 0);
    
    Opal.def(self, '$untaint', $Kernel_untaint$27 = function $$untaint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, $Kernel_untaint$27.$$arity = 0);
    
    Opal.def(self, '$tainted?', $Kernel_tainted$ques$28 = function() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return false;
    }, $Kernel_tainted$ques$28.$$arity = 0);
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $Module_public$29, $Module_private_class_method$30, $Module_private_method_defined$ques$31, $Module_private_constant$32;

    
    
    Opal.def(self, '$public', $Module_public$29 = function($a) {
      var $post_args, methods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      methods = $post_args;;
      
      if (methods.length === 0) {
        self.$$module_function = false;
      }

      return nil;
    ;
    }, $Module_public$29.$$arity = -1);
    Opal.alias(self, "private", "public");
    Opal.alias(self, "protected", "public");
    Opal.alias(self, "nesting", "public");
    
    Opal.def(self, '$private_class_method', $Module_private_class_method$30 = function $$private_class_method($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self;
    }, $Module_private_class_method$30.$$arity = -1);
    Opal.alias(self, "public_class_method", "private_class_method");
    
    Opal.def(self, '$private_method_defined?', $Module_private_method_defined$ques$31 = function(obj) {
      var self = this;

      return false
    }, $Module_private_method_defined$ques$31.$$arity = 1);
    
    Opal.def(self, '$private_constant', $Module_private_constant$32 = function $$private_constant($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_private_constant$32.$$arity = -1);
    Opal.alias(self, "protected_method_defined?", "private_method_defined?");
    Opal.alias(self, "public_instance_methods", "instance_methods");
    Opal.alias(self, "public_instance_method", "instance_method");
    return Opal.alias(self, "public_method_defined?", "method_defined?");
  })($nesting[0], null, $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_private_methods$33;

    
    
    Opal.def(self, '$private_methods', $Kernel_private_methods$33 = function $$private_methods($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return [];
    }, $Kernel_private_methods$33.$$arity = -1);
    Opal.alias(self, "private_instance_methods", "private_methods");
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_eval$34;

    
    Opal.def(self, '$eval', $Kernel_eval$34 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), "" + "To use Kernel#eval, you must first require 'opal-parser'. " + ("" + "See https://github.com/opal/opal/blob/" + ($$($nesting, 'RUBY_ENGINE_VERSION')) + "/docs/opal_parser.md for details."));
    }, $Kernel_eval$34.$$arity = -1)
  })($nesting[0], $nesting);
  Opal.defs(self, '$public', $public$35 = function($a) {
    var $post_args, self = this;

    
    
    $post_args = Opal.slice.call(arguments, 0, arguments.length);
    ;
    return nil;
  }, $public$35.$$arity = -1);
  return (Opal.defs(self, '$private', $private$36 = function($a) {
    var $post_args, self = this;

    
    
    $post_args = Opal.slice.call(arguments, 0, arguments.length);
    ;
    return nil;
  }, $private$36.$$arity = -1), nil) && 'private';
};

/* Generated by Opal 0.11.99.dev */
(function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;

  Opal.add_stubs(['$require']);
  
  self.$require("opal/base");
  self.$require("opal/mini");
  self.$require("corelib/string/encoding");
  self.$require("corelib/struct");
  self.$require("corelib/io");
  self.$require("corelib/main");
  self.$require("corelib/dir");
  self.$require("corelib/file");
  self.$require("corelib/process");
  return self.$require("corelib/unsupported");
})(Opal);


/***/ }),

/***/ 4007:
/***/ (() => {

/* Generated by Opal 0.11.99.dev */
Opal.modules["corelib/comparable"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$===', '$>', '$<', '$equal?', '$<=>', '$normalize', '$raise', '$class']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Comparable');

    var $nesting = [self].concat($parent_nesting), $Comparable_normalize$1, $Comparable_$eq_eq$2, $Comparable_$gt$3, $Comparable_$gt_eq$4, $Comparable_$lt$5, $Comparable_$lt_eq$6, $Comparable_between$ques$7, $Comparable_clamp$8;

    
    Opal.defs(self, '$normalize', $Comparable_normalize$1 = function $$normalize(what) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](what))) {
        return what};
      if ($truthy($rb_gt(what, 0))) {
        return 1};
      if ($truthy($rb_lt(what, 0))) {
        return -1};
      return 0;
    }, $Comparable_normalize$1.$$arity = 1);
    
    Opal.def(self, '$==', $Comparable_$eq_eq$2 = function(other) {
      var self = this, cmp = nil;

      try {
        
        if ($truthy(self['$equal?'](other))) {
          return true};
        
      if (self["$<=>"] == Opal.Kernel["$<=>"]) {
        return false;
      }

      // check for infinite recursion
      if (self.$$comparable) {
        delete self.$$comparable;
        return false;
      }
    ;
        if ($truthy((cmp = self['$<=>'](other)))) {
        } else {
          return false
        };
        return $$($nesting, 'Comparable').$normalize(cmp) == 0;
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'StandardError')])) {
          try {
            return false
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Comparable_$eq_eq$2.$$arity = 1);
    
    Opal.def(self, '$>', $Comparable_$gt$3 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
      };
      return $$($nesting, 'Comparable').$normalize(cmp) > 0;
    }, $Comparable_$gt$3.$$arity = 1);
    
    Opal.def(self, '$>=', $Comparable_$gt_eq$4 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
      };
      return $$($nesting, 'Comparable').$normalize(cmp) >= 0;
    }, $Comparable_$gt_eq$4.$$arity = 1);
    
    Opal.def(self, '$<', $Comparable_$lt$5 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
      };
      return $$($nesting, 'Comparable').$normalize(cmp) < 0;
    }, $Comparable_$lt$5.$$arity = 1);
    
    Opal.def(self, '$<=', $Comparable_$lt_eq$6 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")
      };
      return $$($nesting, 'Comparable').$normalize(cmp) <= 0;
    }, $Comparable_$lt_eq$6.$$arity = 1);
    
    Opal.def(self, '$between?', $Comparable_between$ques$7 = function(min, max) {
      var self = this;

      
      if ($rb_lt(self, min)) {
        return false};
      if ($rb_gt(self, max)) {
        return false};
      return true;
    }, $Comparable_between$ques$7.$$arity = 2);
    
    Opal.def(self, '$clamp', $Comparable_clamp$8 = function $$clamp(min, max) {
      var self = this, cmp = nil;

      
      cmp = min['$<=>'](max);
      if ($truthy(cmp)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (min.$class()) + " with " + (max.$class()) + " failed")
      };
      if ($truthy($rb_gt($$($nesting, 'Comparable').$normalize(cmp), 0))) {
        self.$raise($$($nesting, 'ArgumentError'), "min argument must be smaller than max argument")};
      if ($truthy($rb_lt($$($nesting, 'Comparable').$normalize(self['$<=>'](min)), 0))) {
        return min};
      if ($truthy($rb_gt($$($nesting, 'Comparable').$normalize(self['$<=>'](max)), 0))) {
        return max};
      return self;
    }, $Comparable_clamp$8.$$arity = 2);
  })($nesting[0], $nesting)
};

/* Generated by Opal 0.11.99.dev */
Opal.modules["pathname"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $module = Opal.module;

  Opal.add_stubs(['$require', '$include', '$quote', '$===', '$to_s', '$path', '$respond_to?', '$to_path', '$is_a?', '$nil?', '$raise', '$class', '$==', '$attr_reader', '$!', '$relative?', '$chop_basename', '$basename', '$=~', '$new', '$source', '$[]', '$rindex', '$sub', '$absolute?', '$expand_path', '$plus', '$unshift', '$length', '$!=', '$empty?', '$first', '$shift', '$+', '$join', '$dirname', '$pop', '$reverse_each', '$directory?', '$extname', '$<=>', '$nonzero?', '$proc', '$casecmp', '$cleanpath', '$inspect', '$include?', '$fill', '$map', '$entries']);
  
  self.$require("corelib/comparable");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Pathname');

    var $nesting = [self].concat($parent_nesting), $Pathname_initialize$1, $Pathname_$eq_eq$2, $Pathname_absolute$ques$3, $Pathname_relative$ques$4, $Pathname_chop_basename$5, $Pathname_root$ques$6, $Pathname_parent$7, $Pathname_sub$8, $Pathname_cleanpath$9, $Pathname_to_path$10, $Pathname_hash$11, $Pathname_expand_path$12, $Pathname_$plus$13, $Pathname_plus$14, $Pathname_join$15, $Pathname_split$17, $Pathname_dirname$18, $Pathname_basename$19, $Pathname_directory$ques$20, $Pathname_extname$21, $Pathname_$lt_eq_gt$22, $Pathname$23, $Pathname$24, $Pathname_relative_path_from$25, $Pathname_entries$26;

    self.$$prototype.path = nil;
    
    self.$include($$($nesting, 'Comparable'));
    Opal.const_set($nesting[0], 'SEPARATOR_PAT', new RegExp($$($nesting, 'Regexp').$quote($$$($$($nesting, 'File'), 'SEPARATOR'))));
    
    Opal.def(self, '$initialize', $Pathname_initialize$1 = function $$initialize(path) {
      var self = this;

      
      if ($truthy($$($nesting, 'Pathname')['$==='](path))) {
        self.path = path.$path().$to_s()
      } else if ($truthy(path['$respond_to?']("to_path"))) {
        self.path = path.$to_path()
      } else if ($truthy(path['$is_a?']($$($nesting, 'String')))) {
        self.path = path
      } else if ($truthy(path['$nil?']())) {
        self.$raise($$($nesting, 'TypeError'), "no implicit conversion of nil into String")
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + (path.$class()) + " into String")
      };
      if (self.path['$==']("\u0000")) {
        return self.$raise($$($nesting, 'ArgumentError'))
      } else {
        return nil
      };
    }, $Pathname_initialize$1.$$arity = 1);
    self.$attr_reader("path");
    
    Opal.def(self, '$==', $Pathname_$eq_eq$2 = function(other) {
      var self = this;

      return other.$path()['$=='](self.path)
    }, $Pathname_$eq_eq$2.$$arity = 1);
    
    Opal.def(self, '$absolute?', $Pathname_absolute$ques$3 = function() {
      var self = this;

      return self['$relative?']()['$!']()
    }, $Pathname_absolute$ques$3.$$arity = 0);
    
    Opal.def(self, '$relative?', $Pathname_relative$ques$4 = function() {
      var $a, $b, $c, self = this, path = nil, r = nil;

      
      path = self.path;
      while ($truthy((r = self.$chop_basename(path)))) {
        $c = r, $b = Opal.to_ary($c), (path = ($b[0] == null ? nil : $b[0])), $c
      };
      return path['$==']("");
    }, $Pathname_relative$ques$4.$$arity = 0);
    
    Opal.def(self, '$chop_basename', $Pathname_chop_basename$5 = function $$chop_basename(path) {
      var self = this, base = nil;

      
      base = $$($nesting, 'File').$basename(path);
      if ($truthy($$($nesting, 'Regexp').$new("" + "^" + ($$$($$($nesting, 'Pathname'), 'SEPARATOR_PAT').$source()) + "?$")['$=~'](base))) {
        return nil
      } else {
        return [path['$[]'](0, path.$rindex(base)), base]
      };
    }, $Pathname_chop_basename$5.$$arity = 1);
    
    Opal.def(self, '$root?', $Pathname_root$ques$6 = function() {
      var self = this;

      return self.path['$==']("/")
    }, $Pathname_root$ques$6.$$arity = 0);
    
    Opal.def(self, '$parent', $Pathname_parent$7 = function $$parent() {
      var self = this, new_path = nil;

      
      new_path = self.path.$sub(/\/([^\/]+\/?$)/, "");
      if (new_path['$==']("")) {
        new_path = (function() {if ($truthy(self['$absolute?']())) {
          return "/"
        } else {
          return "."
        }; return nil; })()};
      return $$($nesting, 'Pathname').$new(new_path);
    }, $Pathname_parent$7.$$arity = 0);
    
    Opal.def(self, '$sub', $Pathname_sub$8 = function $$sub($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $$($nesting, 'Pathname').$new($send(self.path, 'sub', Opal.to_a(args)));
    }, $Pathname_sub$8.$$arity = -1);
    
    Opal.def(self, '$cleanpath', $Pathname_cleanpath$9 = function $$cleanpath() {
      var self = this;

      return Opal.normalize(self.path)
    }, $Pathname_cleanpath$9.$$arity = 0);
    
    Opal.def(self, '$to_path', $Pathname_to_path$10 = function $$to_path() {
      var self = this;

      return self.path
    }, $Pathname_to_path$10.$$arity = 0);
    
    Opal.def(self, '$hash', $Pathname_hash$11 = function $$hash() {
      var self = this;

      return self.path
    }, $Pathname_hash$11.$$arity = 0);
    
    Opal.def(self, '$expand_path', $Pathname_expand_path$12 = function $$expand_path() {
      var self = this;

      return $$($nesting, 'Pathname').$new($$($nesting, 'File').$expand_path(self.path))
    }, $Pathname_expand_path$12.$$arity = 0);
    
    Opal.def(self, '$+', $Pathname_$plus$13 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Pathname')['$==='](other))) {
      } else {
        other = $$($nesting, 'Pathname').$new(other)
      };
      return $$($nesting, 'Pathname').$new(self.$plus(self.path, other.$to_s()));
    }, $Pathname_$plus$13.$$arity = 1);
    
    Opal.def(self, '$plus', $Pathname_plus$14 = function $$plus(path1, path2) {
      var $a, $b, $c, self = this, prefix2 = nil, index_list2 = nil, basename_list2 = nil, r2 = nil, basename2 = nil, prefix1 = nil, r1 = nil, basename1 = nil, suffix2 = nil;

      
      prefix2 = path2;
      index_list2 = [];
      basename_list2 = [];
      while ($truthy((r2 = self.$chop_basename(prefix2)))) {
        
        $c = r2, $b = Opal.to_ary($c), (prefix2 = ($b[0] == null ? nil : $b[0])), (basename2 = ($b[1] == null ? nil : $b[1])), $c;
        index_list2.$unshift(prefix2.$length());
        basename_list2.$unshift(basename2);
      };
      if ($truthy(prefix2['$!='](""))) {
        return path2};
      prefix1 = path1;
      while ($truthy(true)) {
        
        while ($truthy(($truthy($c = basename_list2['$empty?']()['$!']()) ? basename_list2.$first()['$=='](".") : $c))) {
          
          index_list2.$shift();
          basename_list2.$shift();
        };
        if ($truthy((r1 = self.$chop_basename(prefix1)))) {
        } else {
          break;
        };
        $c = r1, $b = Opal.to_ary($c), (prefix1 = ($b[0] == null ? nil : $b[0])), (basename1 = ($b[1] == null ? nil : $b[1])), $c;
        if (basename1['$=='](".")) {
          continue;};
        if ($truthy(($truthy($b = ($truthy($c = basename1['$==']("..")) ? $c : basename_list2['$empty?']())) ? $b : basename_list2.$first()['$!=']("..")))) {
          
          prefix1 = $rb_plus(prefix1, basename1);
          break;;};
        index_list2.$shift();
        basename_list2.$shift();
      };
      r1 = self.$chop_basename(prefix1);
      if ($truthy(($truthy($a = r1['$!']()) ? new RegExp($$($nesting, 'SEPARATOR_PAT'))['$=~']($$($nesting, 'File').$basename(prefix1)) : $a))) {
        while ($truthy(($truthy($b = basename_list2['$empty?']()['$!']()) ? basename_list2.$first()['$==']("..") : $b))) {
          
          index_list2.$shift();
          basename_list2.$shift();
        }};
      if ($truthy(basename_list2['$empty?']()['$!']())) {
        
        suffix2 = path2['$[]'](Opal.Range.$new(index_list2.$first(), -1, false));
        if ($truthy(r1)) {
          return $$($nesting, 'File').$join(prefix1, suffix2)
        } else {
          return $rb_plus(prefix1, suffix2)
        };
      } else if ($truthy(r1)) {
        return prefix1
      } else {
        return $$($nesting, 'File').$dirname(prefix1)
      };
    }, $Pathname_plus$14.$$arity = 2);
    
    Opal.def(self, '$join', $Pathname_join$15 = function $$join($a) {try {

      var $post_args, args, $$16, self = this, result = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(args['$empty?']())) {
        return self};
      result = args.$pop();
      if ($truthy($$($nesting, 'Pathname')['$==='](result))) {
      } else {
        result = $$($nesting, 'Pathname').$new(result)
      };
      if ($truthy(result['$absolute?']())) {
        return result};
      $send(args, 'reverse_each', [], ($$16 = function(arg){var self = $$16.$$s || this;

      
        
        if (arg == null) {
          arg = nil;
        };
        if ($truthy($$($nesting, 'Pathname')['$==='](arg))) {
        } else {
          arg = $$($nesting, 'Pathname').$new(arg)
        };
        result = $rb_plus(arg, result);
        if ($truthy(result['$absolute?']())) {
          Opal.ret(result)
        } else {
          return nil
        };}, $$16.$$s = self, $$16.$$arity = 1, $$16));
      return $rb_plus(self, result);
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Pathname_join$15.$$arity = -1);
    
    Opal.def(self, '$split', $Pathname_split$17 = function $$split() {
      var self = this;

      return [self.$dirname(), self.$basename()]
    }, $Pathname_split$17.$$arity = 0);
    
    Opal.def(self, '$dirname', $Pathname_dirname$18 = function $$dirname() {
      var self = this;

      return $$($nesting, 'Pathname').$new($$($nesting, 'File').$dirname(self.path))
    }, $Pathname_dirname$18.$$arity = 0);
    
    Opal.def(self, '$basename', $Pathname_basename$19 = function $$basename() {
      var self = this;

      return $$($nesting, 'Pathname').$new($$($nesting, 'File').$basename(self.path))
    }, $Pathname_basename$19.$$arity = 0);
    
    Opal.def(self, '$directory?', $Pathname_directory$ques$20 = function() {
      var self = this;

      return $$($nesting, 'File')['$directory?'](self.path)
    }, $Pathname_directory$ques$20.$$arity = 0);
    
    Opal.def(self, '$extname', $Pathname_extname$21 = function $$extname() {
      var self = this;

      return $$($nesting, 'File').$extname(self.path)
    }, $Pathname_extname$21.$$arity = 0);
    
    Opal.def(self, '$<=>', $Pathname_$lt_eq_gt$22 = function(other) {
      var self = this;

      return self.$path()['$<=>'](other.$path())
    }, $Pathname_$lt_eq_gt$22.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    Opal.alias(self, "===", "==");
    Opal.alias(self, "to_str", "to_path");
    Opal.alias(self, "to_s", "to_path");
    Opal.const_set($nesting[0], 'SAME_PATHS', (function() {if ($truthy($$$($$($nesting, 'File'), 'FNM_SYSCASE')['$nonzero?']())) {
      return $send(self, 'proc', [], ($Pathname$23 = function(a, b){var self = $Pathname$23.$$s || this;

      
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return a.$casecmp(b)['$=='](0);}, $Pathname$23.$$s = self, $Pathname$23.$$arity = 2, $Pathname$23))
    } else {
      return $send(self, 'proc', [], ($Pathname$24 = function(a, b){var self = $Pathname$24.$$s || this;

      
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return a['$=='](b);}, $Pathname$24.$$s = self, $Pathname$24.$$arity = 2, $Pathname$24))
    }; return nil; })());
    
    Opal.def(self, '$relative_path_from', $Pathname_relative_path_from$25 = function $$relative_path_from(base_directory) {
      var $a, $b, $c, self = this, dest_directory = nil, dest_prefix = nil, dest_names = nil, r = nil, basename = nil, base_prefix = nil, base_names = nil, relpath_names = nil;

      
      dest_directory = self.$cleanpath().$to_s();
      base_directory = base_directory.$cleanpath().$to_s();
      dest_prefix = dest_directory;
      dest_names = [];
      while ($truthy((r = self.$chop_basename(dest_prefix)))) {
        
        $c = r, $b = Opal.to_ary($c), (dest_prefix = ($b[0] == null ? nil : $b[0])), (basename = ($b[1] == null ? nil : $b[1])), $c;
        if ($truthy(basename['$!=']("."))) {
          dest_names.$unshift(basename)};
      };
      base_prefix = base_directory;
      base_names = [];
      while ($truthy((r = self.$chop_basename(base_prefix)))) {
        
        $c = r, $b = Opal.to_ary($c), (base_prefix = ($b[0] == null ? nil : $b[0])), (basename = ($b[1] == null ? nil : $b[1])), $c;
        if ($truthy(basename['$!=']("."))) {
          base_names.$unshift(basename)};
      };
      if ($truthy($$($nesting, 'SAME_PATHS')['$[]'](dest_prefix, base_prefix))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "different prefix: " + (dest_prefix.$inspect()) + " and " + (base_directory.$inspect()))
      };
      while ($truthy(($truthy($b = ($truthy($c = dest_names['$empty?']()['$!']()) ? base_names['$empty?']()['$!']() : $c)) ? $$($nesting, 'SAME_PATHS')['$[]'](dest_names.$first(), base_names.$first()) : $b))) {
        
        dest_names.$shift();
        base_names.$shift();
      };
      if ($truthy(base_names['$include?'](".."))) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "base_directory has ..: " + (base_directory.$inspect()))};
      base_names.$fill("..");
      relpath_names = $rb_plus(base_names, dest_names);
      if ($truthy(relpath_names['$empty?']())) {
        return $$($nesting, 'Pathname').$new(".")
      } else {
        return $$($nesting, 'Pathname').$new($send($$($nesting, 'File'), 'join', Opal.to_a(relpath_names)))
      };
    }, $Pathname_relative_path_from$25.$$arity = 1);
    return (Opal.def(self, '$entries', $Pathname_entries$26 = function $$entries() {
      var $$27, self = this;

      return $send($$($nesting, 'Dir').$entries(self.path), 'map', [], ($$27 = function(f){var self = $$27.$$s || this;

      
        
        if (f == null) {
          f = nil;
        };
        return self.$class().$new(f);}, $$27.$$s = self, $$27.$$arity = 1, $$27))
    }, $Pathname_entries$26.$$arity = 0), nil) && 'entries';
  })($nesting[0], null, $nesting);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_Pathname$28;

    
    Opal.def(self, '$Pathname', $Kernel_Pathname$28 = function $$Pathname(path) {
      var self = this;

      return $$($nesting, 'Pathname').$new(path)
    }, $Kernel_Pathname$28.$$arity = 1)
  })($nesting[0], $nesting);
};


/***/ }),

/***/ 9442:
/***/ (() => {

/* Generated by Opal 0.11.99.dev */
Opal.modules["stringio"] = function(Opal) {
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$include', '$new', '$call', '$close', '$attr_accessor', '$length', '$include?', '$!', '$check_readable', '$==', '$===', '$>=', '$raise', '$>', '$+', '$-', '$seek', '$enum_for', '$eof?', '$ord', '$[]', '$to_str', '$chomp', '$check_writable', '$String', '$write', '$closed_write?', '$closed_read?']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StringIO');

    var $nesting = [self].concat($parent_nesting), $StringIO_open$1, $StringIO_initialize$2, $StringIO_eof$ques$3, $StringIO_seek$4, $StringIO_tell$5, $StringIO_rewind$6, $StringIO_each_byte$7, $StringIO_each_char$8, $StringIO_each$9, $StringIO_write$10, $StringIO_read$11, $StringIO_close$12, $StringIO_close_read$13, $StringIO_close_write$14, $StringIO_closed$ques$15, $StringIO_closed_read$ques$16, $StringIO_closed_write$ques$17, $StringIO_check_writable$18, $StringIO_check_readable$19;

    self.$$prototype.position = self.$$prototype.string = self.$$prototype.closed = nil;
    
    self.$include($$$($$($nesting, 'IO'), 'Readable'));
    self.$include($$$($$($nesting, 'IO'), 'Writable'));
    Opal.defs(self, '$open', $StringIO_open$1 = function $$open(string, mode) {
      var $iter = $StringIO_open$1.$$p, block = $iter || nil, self = this, io = nil, res = nil;

      if ($iter) $StringIO_open$1.$$p = null;
      
      
      if ($iter) $StringIO_open$1.$$p = null;;
      
      if (string == null) {
        string = "";
      };
      
      if (mode == null) {
        mode = nil;
      };
      io = self.$new(string, mode);
      res = block.$call(io);
      io.$close();
      return res;
    }, $StringIO_open$1.$$arity = -1);
    self.$attr_accessor("string");
    
    Opal.def(self, '$initialize', $StringIO_initialize$2 = function $$initialize(string, mode) {
      var $a, self = this;

      
      
      if (string == null) {
        string = "";
      };
      
      if (mode == null) {
        mode = "rw";
      };
      self.string = string;
      self.position = string.$length();
      if ($truthy(($truthy($a = mode['$include?']("r")) ? mode['$include?']("w")['$!']() : $a))) {
        return (self.closed = "write")
      } else if ($truthy(($truthy($a = mode['$include?']("w")) ? mode['$include?']("r")['$!']() : $a))) {
        return (self.closed = "read")
      } else {
        return nil
      };
    }, $StringIO_initialize$2.$$arity = -1);
    
    Opal.def(self, '$eof?', $StringIO_eof$ques$3 = function() {
      var self = this;

      
      self.$check_readable();
      return self.position['$=='](self.string.$length());
    }, $StringIO_eof$ques$3.$$arity = 0);
    Opal.alias(self, "eof", "eof?");
    
    Opal.def(self, '$seek', $StringIO_seek$4 = function $$seek(pos, whence) {
      var self = this, $case = nil;

      
      
      if (whence == null) {
        whence = $$$($$($nesting, 'IO'), 'SEEK_SET');
      };
      $case = whence;
      if ($$$($$($nesting, 'IO'), 'SEEK_SET')['$===']($case)) {
      if ($truthy($rb_ge(pos, 0))) {
      } else {
        self.$raise($$$($$($nesting, 'Errno'), 'EINVAL'))
      };
      self.position = pos;}
      else if ($$$($$($nesting, 'IO'), 'SEEK_CUR')['$===']($case)) {if ($truthy($rb_gt($rb_plus(self.position, pos), self.string.$length()))) {
        self.position = self.string.$length()
      } else {
        self.position = $rb_plus(self.position, pos)
      }}
      else if ($$$($$($nesting, 'IO'), 'SEEK_END')['$===']($case)) {if ($truthy($rb_gt(pos, self.string.$length()))) {
        self.position = 0
      } else {
        self.position = $rb_minus(self.position, pos)
      }};
      return 0;
    }, $StringIO_seek$4.$$arity = -2);
    
    Opal.def(self, '$tell', $StringIO_tell$5 = function $$tell() {
      var self = this;

      return self.position
    }, $StringIO_tell$5.$$arity = 0);
    Opal.alias(self, "pos", "tell");
    Opal.alias(self, "pos=", "seek");
    
    Opal.def(self, '$rewind', $StringIO_rewind$6 = function $$rewind() {
      var self = this;

      return self.$seek(0)
    }, $StringIO_rewind$6.$$arity = 0);
    
    Opal.def(self, '$each_byte', $StringIO_each_byte$7 = function $$each_byte() {
      var $iter = $StringIO_each_byte$7.$$p, block = $iter || nil, $a, self = this, i = nil;

      if ($iter) $StringIO_each_byte$7.$$p = null;
      
      
      if ($iter) $StringIO_each_byte$7.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$enum_for("each_byte")
      };
      self.$check_readable();
      i = self.position;
      while (!($truthy(self['$eof?']()))) {
        
        block.$call(self.string['$[]'](i).$ord());
        i = $rb_plus(i, 1);
      };
      return self;
    }, $StringIO_each_byte$7.$$arity = 0);
    
    Opal.def(self, '$each_char', $StringIO_each_char$8 = function $$each_char() {
      var $iter = $StringIO_each_char$8.$$p, block = $iter || nil, $a, self = this, i = nil;

      if ($iter) $StringIO_each_char$8.$$p = null;
      
      
      if ($iter) $StringIO_each_char$8.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$enum_for("each_char")
      };
      self.$check_readable();
      i = self.position;
      while (!($truthy(self['$eof?']()))) {
        
        block.$call(self.string['$[]'](i));
        i = $rb_plus(i, 1);
      };
      return self;
    }, $StringIO_each_char$8.$$arity = 0);
    
    Opal.def(self, '$each', $StringIO_each$9 = function $$each(separator) {
      var $iter = $StringIO_each$9.$$p, $yield = $iter || nil, self = this, chomp_lines = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if ($iter) $StringIO_each$9.$$p = null;
      
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      if (($yield !== nil)) {
      } else {
        return self.$enum_for("each_line")
      };
      self.$check_readable();
      chomp_lines = false;
      if ($truthy($$$('::', 'Hash')['$==='](separator))) {
        separator = (function() {if ($truthy((chomp_lines = separator['$[]']("chomp")))) {
          return /\r?\n/
        } else {
          return $gvars["/"]
        }; return nil; })()
      } else if ($truthy(separator)) {
        separator = separator.$to_str()
      } else {
        separator = undefined
      };
      
      var str = self.string, stringLength = str.length;
      if (self.position < stringLength) str = str.substr(self.position);
      if (separator) {
        var chomped = (str).$chomp(), trailing = str.length !== chomped.length, splitted = chomped.split(separator);
        for (var i = 0, len = splitted.length; i < len; i++) {
          var line = chomp_lines ? splitted[i] : (i < len - 1 || trailing ? splitted[i] + separator : splitted[i]);
          Opal.yield1($yield, line);
        }
      } else if (separator === undefined) {
        Opal.yield1($yield, str);
      } else {
        var m, re = /(.+(?:\n\n|$))\n*/g;
        while ((m = re.exec(str))) Opal.yield1($yield, m[1]);
      }
      self.position = stringLength;
    ;
      return self;
    }, $StringIO_each$9.$$arity = -1);
    Opal.alias(self, "each_line", "each");
    
    Opal.def(self, '$write', $StringIO_write$10 = function $$write(string) {
      var self = this, before = nil, after = nil;

      
      self.$check_writable();
      string = self.$String(string);
      if (self.string.$length()['$=='](self.position)) {
        
        self.string = $rb_plus(self.string, string);
        return (self.position = $rb_plus(self.position, string.$length()));
      } else {
        
        before = self.string['$[]'](Opal.Range.$new(0, $rb_minus(self.position, 1), false));
        after = self.string['$[]'](Opal.Range.$new($rb_plus(self.position, string.$length()), -1, false));
        self.string = $rb_plus($rb_plus(before, string), after);
        return (self.position = $rb_plus(self.position, string.$length()));
      };
    }, $StringIO_write$10.$$arity = 1);
    
    Opal.def(self, '$read', $StringIO_read$11 = function $$read(length, outbuf) {
      var self = this, string = nil, str = nil;

      
      
      if (length == null) {
        length = nil;
      };
      
      if (outbuf == null) {
        outbuf = nil;
      };
      self.$check_readable();
      if ($truthy(self['$eof?']())) {
        return nil};
      string = (function() {if ($truthy(length)) {
        
        str = self.string['$[]'](self.position, length);
        self.position = $rb_plus(self.position, length);
        return str;
      } else {
        
        str = self.string['$[]'](Opal.Range.$new(self.position, -1, false));
        self.position = self.string.$length();
        return str;
      }; return nil; })();
      if ($truthy(outbuf)) {
        return outbuf.$write(string)
      } else {
        return string
      };
    }, $StringIO_read$11.$$arity = -1);
    
    Opal.def(self, '$close', $StringIO_close$12 = function $$close() {
      var self = this;

      return (self.closed = "both")
    }, $StringIO_close$12.$$arity = 0);
    
    Opal.def(self, '$close_read', $StringIO_close_read$13 = function $$close_read() {
      var self = this;

      if (self.closed['$==']("write")) {
        return (self.closed = "both")
      } else {
        return (self.closed = "read")
      }
    }, $StringIO_close_read$13.$$arity = 0);
    
    Opal.def(self, '$close_write', $StringIO_close_write$14 = function $$close_write() {
      var self = this;

      if (self.closed['$==']("read")) {
        return (self.closed = "both")
      } else {
        return (self.closed = "write")
      }
    }, $StringIO_close_write$14.$$arity = 0);
    
    Opal.def(self, '$closed?', $StringIO_closed$ques$15 = function() {
      var self = this;

      return self.closed['$==']("both")
    }, $StringIO_closed$ques$15.$$arity = 0);
    
    Opal.def(self, '$closed_read?', $StringIO_closed_read$ques$16 = function() {
      var $a, self = this;

      return ($truthy($a = self.closed['$==']("read")) ? $a : self.closed['$==']("both"))
    }, $StringIO_closed_read$ques$16.$$arity = 0);
    
    Opal.def(self, '$closed_write?', $StringIO_closed_write$ques$17 = function() {
      var $a, self = this;

      return ($truthy($a = self.closed['$==']("write")) ? $a : self.closed['$==']("both"))
    }, $StringIO_closed_write$ques$17.$$arity = 0);
    
    Opal.def(self, '$check_writable', $StringIO_check_writable$18 = function $$check_writable() {
      var self = this;

      if ($truthy(self['$closed_write?']())) {
        return self.$raise($$($nesting, 'IOError'), "not opened for writing")
      } else {
        return nil
      }
    }, $StringIO_check_writable$18.$$arity = 0);
    return (Opal.def(self, '$check_readable', $StringIO_check_readable$19 = function $$check_readable() {
      var self = this;

      if ($truthy(self['$closed_read?']())) {
        return self.$raise($$($nesting, 'IOError'), "not opened for reading")
      } else {
        return nil
      }
    }, $StringIO_check_readable$19.$$arity = 0), nil) && 'check_readable';
  })($nesting[0], $$($nesting, 'IO'), $nesting)
};


/***/ }),

/***/ 9417:
/***/ ((module) => {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    if(a===b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),

/***/ 3717:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var concatMap = __nccwpck_require__(6891);
var balanced = __nccwpck_require__(9417);

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}



/***/ }),

/***/ 6891:
/***/ ((module) => {

module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ 6323:
/***/ ((module) => {

"use strict";


var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
	return Array.isArray(val) ? [] : {}
}

function cloneUnlessOtherwiseSpecified(value, options) {
	return (options.clone !== false && options.isMergeableObject(value))
		? deepmerge(emptyTarget(value), value, options)
		: value
}

function defaultArrayMerge(target, source, options) {
	return target.concat(source).map(function(element) {
		return cloneUnlessOtherwiseSpecified(element, options)
	})
}

function getMergeFunction(key, options) {
	if (!options.customMerge) {
		return deepmerge
	}
	var customMerge = options.customMerge(key);
	return typeof customMerge === 'function' ? customMerge : deepmerge
}

function getEnumerableOwnPropertySymbols(target) {
	return Object.getOwnPropertySymbols
		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
			return target.propertyIsEnumerable(symbol)
		})
		: []
}

function getKeys(target) {
	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
}

function propertyIsOnObject(object, property) {
	try {
		return property in object
	} catch(_) {
		return false
	}
}

// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
}

function mergeObject(target, source, options) {
	var destination = {};
	if (options.isMergeableObject(target)) {
		getKeys(target).forEach(function(key) {
			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
		});
	}
	getKeys(source).forEach(function(key) {
		if (propertyIsUnsafe(target, key)) {
			return
		}

		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
		} else {
			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
		}
	});
	return destination
}

function deepmerge(target, source, options) {
	options = options || {};
	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
	// implementations can use it. The caller may not replace it.
	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

	var sourceIsArray = Array.isArray(source);
	var targetIsArray = Array.isArray(target);
	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	if (!sourceAndTargetTypesMatch) {
		return cloneUnlessOtherwiseSpecified(source, options)
	} else if (sourceIsArray) {
		return options.arrayMerge(target, source, options)
	} else {
		return mergeObject(target, source, options)
	}
}

deepmerge.all = function deepmergeAll(array, options) {
	if (!Array.isArray(array)) {
		throw new Error('first argument should be an array')
	}

	return array.reduce(function(prev, next) {
		return deepmerge(prev, next, options)
	}, {})
};

var deepmerge_1 = deepmerge;

module.exports = deepmerge_1;


/***/ }),

/***/ 4802:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.attributeNames = exports.elementNames = void 0;
exports.elementNames = new Map([
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath",
].map(function (val) { return [val.toLowerCase(), val]; }));
exports.attributeNames = new Map([
    "definitionURL",
    "attributeName",
    "attributeType",
    "baseFrequency",
    "baseProfile",
    "calcMode",
    "clipPathUnits",
    "diffuseConstant",
    "edgeMode",
    "filterUnits",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "kernelMatrix",
    "kernelUnitLength",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "limitingConeAngle",
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "maskContentUnits",
    "maskUnits",
    "numOctaves",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "refX",
    "refY",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "specularConstant",
    "specularExponent",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stitchTiles",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textLength",
    "viewBox",
    "viewTarget",
    "xChannelSelector",
    "yChannelSelector",
    "zoomAndPan",
].map(function (val) { return [val.toLowerCase(), val]; }));


/***/ }),

/***/ 8621:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.render = void 0;
/*
 * Module dependencies
 */
var ElementType = __importStar(__nccwpck_require__(3944));
var entities_1 = __nccwpck_require__(3000);
/**
 * Mixed-case SVG and MathML tags & attributes
 * recognized by the HTML parser.
 *
 * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
 */
var foreignNames_js_1 = __nccwpck_require__(4802);
var unencodedElements = new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript",
]);
function replaceQuotes(value) {
    return value.replace(/"/g, "&quot;");
}
/**
 * Format attributes
 */
function formatAttributes(attributes, opts) {
    var _a;
    if (!attributes)
        return;
    var encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false
        ? replaceQuotes
        : opts.xmlMode || opts.encodeEntities !== "utf8"
            ? entities_1.encodeXML
            : entities_1.escapeAttribute;
    return Object.keys(attributes)
        .map(function (key) {
        var _a, _b;
        var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
        if (opts.xmlMode === "foreign") {
            /* Fix up mixed-case attribute names */
            key = (_b = foreignNames_js_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
            return key;
        }
        return "".concat(key, "=\"").concat(encode(value), "\"");
    })
        .join(" ");
}
/**
 * Self-enclosing tags
 */
var singleTag = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr",
]);
/**
 * Renders a DOM node or an array of DOM nodes to a string.
 *
 * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
 *
 * @param node Node to be rendered.
 * @param options Changes serialization behavior
 */
function render(node, options) {
    if (options === void 0) { options = {}; }
    var nodes = "length" in node ? node : [node];
    var output = "";
    for (var i = 0; i < nodes.length; i++) {
        output += renderNode(nodes[i], options);
    }
    return output;
}
exports.render = render;
exports["default"] = render;
function renderNode(node, options) {
    switch (node.type) {
        case ElementType.Root:
            return render(node.children, options);
        // @ts-expect-error We don't use `Doctype` yet
        case ElementType.Doctype:
        case ElementType.Directive:
            return renderDirective(node);
        case ElementType.Comment:
            return renderComment(node);
        case ElementType.CDATA:
            return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
            return renderTag(node, options);
        case ElementType.Text:
            return renderText(node, options);
    }
}
var foreignModeIntegrationPoints = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title",
]);
var foreignElements = new Set(["svg", "math"]);
function renderTag(elem, opts) {
    var _a;
    // Handle SVG / MathML in HTML
    if (opts.xmlMode === "foreign") {
        /* Fix up mixed-case element names */
        elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        /* Exit foreign mode at integration points */
        if (elem.parent &&
            foreignModeIntegrationPoints.has(elem.parent.name)) {
            opts = __assign(__assign({}, opts), { xmlMode: false });
        }
    }
    if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
    }
    var tag = "<".concat(elem.name);
    var attribs = formatAttributes(elem.attribs, opts);
    if (attribs) {
        tag += " ".concat(attribs);
    }
    if (elem.children.length === 0 &&
        (opts.xmlMode
            ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
                opts.selfClosingTags !== false
            : // User explicitly asked for self-closing tags, even in HTML mode
                opts.selfClosingTags && singleTag.has(elem.name))) {
        if (!opts.xmlMode)
            tag += " ";
        tag += "/>";
    }
    else {
        tag += ">";
        if (elem.children.length > 0) {
            tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
            tag += "</".concat(elem.name, ">");
        }
    }
    return tag;
}
function renderDirective(elem) {
    return "<".concat(elem.data, ">");
}
function renderText(elem, opts) {
    var _a;
    var data = elem.data || "";
    // If entities weren't decoded, no need to encode them back
    if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false &&
        !(!opts.xmlMode &&
            elem.parent &&
            unencodedElements.has(elem.parent.name))) {
        data =
            opts.xmlMode || opts.encodeEntities !== "utf8"
                ? (0, entities_1.encodeXML)(data)
                : (0, entities_1.escapeText)(data);
    }
    return data;
}
function renderCdata(elem) {
    return "<![CDATA[".concat(elem.children[0].data, "]]>");
}
function renderComment(elem) {
    return "<!--".concat(elem.data, "-->");
}


/***/ }),

/***/ 3944:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
/** Types of elements found in htmlparser2's DOM */
var ElementType;
(function (ElementType) {
    /** Type for the root element of a document */
    ElementType["Root"] = "root";
    /** Type for Text */
    ElementType["Text"] = "text";
    /** Type for <? ... ?> */
    ElementType["Directive"] = "directive";
    /** Type for <!-- ... --> */
    ElementType["Comment"] = "comment";
    /** Type for <script> tags */
    ElementType["Script"] = "script";
    /** Type for <style> tags */
    ElementType["Style"] = "style";
    /** Type for Any tag */
    ElementType["Tag"] = "tag";
    /** Type for <![CDATA[ ... ]]> */
    ElementType["CDATA"] = "cdata";
    /** Type for <!doctype ...> */
    ElementType["Doctype"] = "doctype";
})(ElementType = exports.ElementType || (exports.ElementType = {}));
/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */
function isTag(elem) {
    return (elem.type === ElementType.Tag ||
        elem.type === ElementType.Script ||
        elem.type === ElementType.Style);
}
exports.isTag = isTag;
// Exports for backwards compatibility
/** Type for the root element of a document */
exports.Root = ElementType.Root;
/** Type for Text */
exports.Text = ElementType.Text;
/** Type for <? ... ?> */
exports.Directive = ElementType.Directive;
/** Type for <!-- ... --> */
exports.Comment = ElementType.Comment;
/** Type for <script> tags */
exports.Script = ElementType.Script;
/** Type for <style> tags */
exports.Style = ElementType.Style;
/** Type for Any tag */
exports.Tag = ElementType.Tag;
/** Type for <![CDATA[ ... ]]> */
exports.CDATA = ElementType.CDATA;
/** Type for <!doctype ...> */
exports.Doctype = ElementType.Doctype;


/***/ }),

/***/ 4038:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DomHandler = void 0;
var domelementtype_1 = __nccwpck_require__(3944);
var node_js_1 = __nccwpck_require__(7822);
__exportStar(__nccwpck_require__(7822), exports);
// Default options
var defaultOpts = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false,
};
var DomHandler = /** @class */ (function () {
    /**
     * @param callback Called once parsing has completed.
     * @param options Settings for the handler.
     * @param elementCB Callback whenever a tag is closed.
     */
    function DomHandler(callback, options, elementCB) {
        /** The elements of the DOM */
        this.dom = [];
        /** The root element for the DOM */
        this.root = new node_js_1.Document(this.dom);
        /** Indicated whether parsing has been completed. */
        this.done = false;
        /** Stack of open tags. */
        this.tagStack = [this.root];
        /** A data node that is still being written to. */
        this.lastNode = null;
        /** Reference to the parser instance. Used for location information. */
        this.parser = null;
        // Make it possible to skip arguments, for backwards-compatibility
        if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
        }
        if (typeof callback === "object") {
            options = callback;
            callback = undefined;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options !== null && options !== void 0 ? options : defaultOpts;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
    }
    DomHandler.prototype.onparserinit = function (parser) {
        this.parser = parser;
    };
    // Resets the handler back to starting state
    DomHandler.prototype.onreset = function () {
        this.dom = [];
        this.root = new node_js_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
    };
    // Signals the handler that parsing is done
    DomHandler.prototype.onend = function () {
        if (this.done)
            return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
    };
    DomHandler.prototype.onerror = function (error) {
        this.handleCallback(error);
    };
    DomHandler.prototype.onclosetag = function () {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
            this.elementCB(elem);
    };
    DomHandler.prototype.onopentag = function (name, attribs) {
        var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
        var element = new node_js_1.Element(name, attribs, undefined, type);
        this.addNode(element);
        this.tagStack.push(element);
    };
    DomHandler.prototype.ontext = function (data) {
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            lastNode.data += data;
            if (this.options.withEndIndices) {
                lastNode.endIndex = this.parser.endIndex;
            }
        }
        else {
            var node = new node_js_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
        }
    };
    DomHandler.prototype.oncomment = function (data) {
        if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
        }
        var node = new node_js_1.Comment(data);
        this.addNode(node);
        this.lastNode = node;
    };
    DomHandler.prototype.oncommentend = function () {
        this.lastNode = null;
    };
    DomHandler.prototype.oncdatastart = function () {
        var text = new node_js_1.Text("");
        var node = new node_js_1.CDATA([text]);
        this.addNode(node);
        text.parent = node;
        this.lastNode = text;
    };
    DomHandler.prototype.oncdataend = function () {
        this.lastNode = null;
    };
    DomHandler.prototype.onprocessinginstruction = function (name, data) {
        var node = new node_js_1.ProcessingInstruction(name, data);
        this.addNode(node);
    };
    DomHandler.prototype.handleCallback = function (error) {
        if (typeof this.callback === "function") {
            this.callback(error, this.dom);
        }
        else if (error) {
            throw error;
        }
    };
    DomHandler.prototype.addNode = function (node) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
        }
        parent.children.push(node);
        if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
        }
        node.parent = parent;
        this.lastNode = null;
    };
    return DomHandler;
}());
exports.DomHandler = DomHandler;
exports["default"] = DomHandler;


/***/ }),

/***/ 7822:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.CDATA = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;
var domelementtype_1 = __nccwpck_require__(3944);
/**
 * This object will be used as the prototype for Nodes when creating a
 * DOM-Level-1-compliant structure.
 */
var Node = /** @class */ (function () {
    function Node() {
        /** Parent of the node */
        this.parent = null;
        /** Previous sibling */
        this.prev = null;
        /** Next sibling */
        this.next = null;
        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
        this.startIndex = null;
        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
        this.endIndex = null;
    }
    Object.defineProperty(Node.prototype, "parentNode", {
        // Read-write aliases for properties
        /**
         * Same as {@link parent}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.parent;
        },
        set: function (parent) {
            this.parent = parent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "previousSibling", {
        /**
         * Same as {@link prev}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.prev;
        },
        set: function (prev) {
            this.prev = prev;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "nextSibling", {
        /**
         * Same as {@link next}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.next;
        },
        set: function (next) {
            this.next = next;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Clone this node, and optionally its children.
     *
     * @param recursive Clone child nodes as well.
     * @returns A clone of the node.
     */
    Node.prototype.cloneNode = function (recursive) {
        if (recursive === void 0) { recursive = false; }
        return cloneNode(this, recursive);
    };
    return Node;
}());
exports.Node = Node;
/**
 * A node that contains some data.
 */
var DataNode = /** @class */ (function (_super) {
    __extends(DataNode, _super);
    /**
     * @param data The content of the data node
     */
    function DataNode(data) {
        var _this = _super.call(this) || this;
        _this.data = data;
        return _this;
    }
    Object.defineProperty(DataNode.prototype, "nodeValue", {
        /**
         * Same as {@link data}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.data;
        },
        set: function (data) {
            this.data = data;
        },
        enumerable: false,
        configurable: true
    });
    return DataNode;
}(Node));
exports.DataNode = DataNode;
/**
 * Text within the document.
 */
var Text = /** @class */ (function (_super) {
    __extends(Text, _super);
    function Text() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.Text;
        return _this;
    }
    Object.defineProperty(Text.prototype, "nodeType", {
        get: function () {
            return 3;
        },
        enumerable: false,
        configurable: true
    });
    return Text;
}(DataNode));
exports.Text = Text;
/**
 * Comments within the document.
 */
var Comment = /** @class */ (function (_super) {
    __extends(Comment, _super);
    function Comment() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.Comment;
        return _this;
    }
    Object.defineProperty(Comment.prototype, "nodeType", {
        get: function () {
            return 8;
        },
        enumerable: false,
        configurable: true
    });
    return Comment;
}(DataNode));
exports.Comment = Comment;
/**
 * Processing instructions, including doc types.
 */
var ProcessingInstruction = /** @class */ (function (_super) {
    __extends(ProcessingInstruction, _super);
    function ProcessingInstruction(name, data) {
        var _this = _super.call(this, data) || this;
        _this.name = name;
        _this.type = domelementtype_1.ElementType.Directive;
        return _this;
    }
    Object.defineProperty(ProcessingInstruction.prototype, "nodeType", {
        get: function () {
            return 1;
        },
        enumerable: false,
        configurable: true
    });
    return ProcessingInstruction;
}(DataNode));
exports.ProcessingInstruction = ProcessingInstruction;
/**
 * A `Node` that can have children.
 */
var NodeWithChildren = /** @class */ (function (_super) {
    __extends(NodeWithChildren, _super);
    /**
     * @param children Children of the node. Only certain node types can have children.
     */
    function NodeWithChildren(children) {
        var _this = _super.call(this) || this;
        _this.children = children;
        return _this;
    }
    Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
        // Aliases
        /** First child of the node. */
        get: function () {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
        /** Last child of the node. */
        get: function () {
            return this.children.length > 0
                ? this.children[this.children.length - 1]
                : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
        /**
         * Same as {@link children}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.children;
        },
        set: function (children) {
            this.children = children;
        },
        enumerable: false,
        configurable: true
    });
    return NodeWithChildren;
}(Node));
exports.NodeWithChildren = NodeWithChildren;
var CDATA = /** @class */ (function (_super) {
    __extends(CDATA, _super);
    function CDATA() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.CDATA;
        return _this;
    }
    Object.defineProperty(CDATA.prototype, "nodeType", {
        get: function () {
            return 4;
        },
        enumerable: false,
        configurable: true
    });
    return CDATA;
}(NodeWithChildren));
exports.CDATA = CDATA;
/**
 * The root node of the document.
 */
var Document = /** @class */ (function (_super) {
    __extends(Document, _super);
    function Document() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = domelementtype_1.ElementType.Root;
        return _this;
    }
    Object.defineProperty(Document.prototype, "nodeType", {
        get: function () {
            return 9;
        },
        enumerable: false,
        configurable: true
    });
    return Document;
}(NodeWithChildren));
exports.Document = Document;
/**
 * An element within the DOM.
 */
var Element = /** @class */ (function (_super) {
    __extends(Element, _super);
    /**
     * @param name Name of the tag, eg. `div`, `span`.
     * @param attribs Object mapping attribute names to attribute values.
     * @param children Children of the node.
     */
    function Element(name, attribs, children, type) {
        if (children === void 0) { children = []; }
        if (type === void 0) { type = name === "script"
            ? domelementtype_1.ElementType.Script
            : name === "style"
                ? domelementtype_1.ElementType.Style
                : domelementtype_1.ElementType.Tag; }
        var _this = _super.call(this, children) || this;
        _this.name = name;
        _this.attribs = attribs;
        _this.type = type;
        return _this;
    }
    Object.defineProperty(Element.prototype, "nodeType", {
        get: function () {
            return 1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "tagName", {
        // DOM Level 1 aliases
        /**
         * Same as {@link name}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get: function () {
            return this.name;
        },
        set: function (name) {
            this.name = name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "attributes", {
        get: function () {
            var _this = this;
            return Object.keys(this.attribs).map(function (name) {
                var _a, _b;
                return ({
                    name: name,
                    value: _this.attribs[name],
                    namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                    prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name],
                });
            });
        },
        enumerable: false,
        configurable: true
    });
    return Element;
}(NodeWithChildren));
exports.Element = Element;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `Element`, `false` otherwise.
 */
function isTag(node) {
    return (0, domelementtype_1.isTag)(node);
}
exports.isTag = isTag;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
 */
function isCDATA(node) {
    return node.type === domelementtype_1.ElementType.CDATA;
}
exports.isCDATA = isCDATA;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Text`, `false` otherwise.
 */
function isText(node) {
    return node.type === domelementtype_1.ElementType.Text;
}
exports.isText = isText;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Comment`, `false` otherwise.
 */
function isComment(node) {
    return node.type === domelementtype_1.ElementType.Comment;
}
exports.isComment = isComment;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDirective(node) {
    return node.type === domelementtype_1.ElementType.Directive;
}
exports.isDirective = isDirective;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDocument(node) {
    return node.type === domelementtype_1.ElementType.Root;
}
exports.isDocument = isDocument;
/**
 * @param node Node to check.
 * @returns `true` if the node has children, `false` otherwise.
 */
function hasChildren(node) {
    return Object.prototype.hasOwnProperty.call(node, "children");
}
exports.hasChildren = hasChildren;
/**
 * Clone a node, and optionally its children.
 *
 * @param recursive Clone child nodes as well.
 * @returns A clone of the node.
 */
function cloneNode(node, recursive) {
    if (recursive === void 0) { recursive = false; }
    var result;
    if (isText(node)) {
        result = new Text(node.data);
    }
    else if (isComment(node)) {
        result = new Comment(node.data);
    }
    else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
        children.forEach(function (child) { return (child.parent = clone_1); });
        if (node.namespace != null) {
            clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
            clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
            clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
    }
    else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new CDATA(children);
        children.forEach(function (child) { return (child.parent = clone_2); });
        result = clone_2;
    }
    else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document(children);
        children.forEach(function (child) { return (child.parent = clone_3); });
        if (node["x-mode"]) {
            clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
    }
    else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
            instruction["x-name"] = node["x-name"];
            instruction["x-publicId"] = node["x-publicId"];
            instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
    }
    else {
        throw new Error("Not implemented yet: ".concat(node.type));
    }
    result.startIndex = node.startIndex;
    result.endIndex = node.endIndex;
    if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
    }
    return result;
}
exports.cloneNode = cloneNode;
function cloneChildren(childs) {
    var children = childs.map(function (child) { return cloneNode(child, true); });
    for (var i = 1; i < children.length; i++) {
        children[i].prev = children[i - 1];
        children[i - 1].next = children[i];
    }
    return children;
}


/***/ }),

/***/ 1503:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFeed = void 0;
var stringify_js_1 = __nccwpck_require__(9561);
var legacy_js_1 = __nccwpck_require__(2185);
/**
 * Get the feed object from the root of a DOM tree.
 *
 * @category Feeds
 * @param doc - The DOM to to extract the feed from.
 * @returns The feed.
 */
function getFeed(doc) {
    var feedRoot = getOneElement(isValidFeed, doc);
    return !feedRoot
        ? null
        : feedRoot.name === "feed"
            ? getAtomFeed(feedRoot)
            : getRssFeed(feedRoot);
}
exports.getFeed = getFeed;
/**
 * Parse an Atom feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */
function getAtomFeed(feedRoot) {
    var _a;
    var childs = feedRoot.children;
    var feed = {
        type: "atom",
        items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function (item) {
            var _a;
            var children = item.children;
            var entry = { media: getMediaElements(children) };
            addConditionally(entry, "id", "id", children);
            addConditionally(entry, "title", "title", children);
            var href = (_a = getOneElement("link", children)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
            if (href) {
                entry.link = href;
            }
            var description = fetch("summary", children) || fetch("content", children);
            if (description) {
                entry.description = description;
            }
            var pubDate = fetch("updated", children);
            if (pubDate) {
                entry.pubDate = new Date(pubDate);
            }
            return entry;
        }),
    };
    addConditionally(feed, "id", "id", childs);
    addConditionally(feed, "title", "title", childs);
    var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
    if (href) {
        feed.link = href;
    }
    addConditionally(feed, "description", "subtitle", childs);
    var updated = fetch("updated", childs);
    if (updated) {
        feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "email", childs, true);
    return feed;
}
/**
 * Parse a RSS feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */
function getRssFeed(feedRoot) {
    var _a, _b;
    var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
    var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function (item) {
            var children = item.children;
            var entry = { media: getMediaElements(children) };
            addConditionally(entry, "id", "guid", children);
            addConditionally(entry, "title", "title", children);
            addConditionally(entry, "link", "link", children);
            addConditionally(entry, "description", "description", children);
            var pubDate = fetch("pubDate", children);
            if (pubDate)
                entry.pubDate = new Date(pubDate);
            return entry;
        }),
    };
    addConditionally(feed, "title", "title", childs);
    addConditionally(feed, "link", "link", childs);
    addConditionally(feed, "description", "description", childs);
    var updated = fetch("lastBuildDate", childs);
    if (updated) {
        feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "managingEditor", childs, true);
    return feed;
}
var MEDIA_KEYS_STRING = ["url", "type", "lang"];
var MEDIA_KEYS_INT = [
    "fileSize",
    "bitrate",
    "framerate",
    "samplingrate",
    "channels",
    "duration",
    "height",
    "width",
];
/**
 * Get all media elements of a feed item.
 *
 * @param where Nodes to search in.
 * @returns Media elements.
 */
function getMediaElements(where) {
    return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(function (elem) {
        var attribs = elem.attribs;
        var media = {
            medium: attribs["medium"],
            isDefault: !!attribs["isDefault"],
        };
        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
            var attrib = MEDIA_KEYS_STRING_1[_i];
            if (attribs[attrib]) {
                media[attrib] = attribs[attrib];
            }
        }
        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
            var attrib = MEDIA_KEYS_INT_1[_a];
            if (attribs[attrib]) {
                media[attrib] = parseInt(attribs[attrib], 10);
            }
        }
        if (attribs["expression"]) {
            media.expression = attribs["expression"];
        }
        return media;
    });
}
/**
 * Get one element by tag name.
 *
 * @param tagName Tag name to look for
 * @param node Node to search in
 * @returns The element or null
 */
function getOneElement(tagName, node) {
    return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];
}
/**
 * Get the text content of an element with a certain tag name.
 *
 * @param tagName Tag name to look for.
 * @param where Node to search in.
 * @param recurse Whether to recurse into child nodes.
 * @returns The text content of the element.
 */
function fetch(tagName, where, recurse) {
    if (recurse === void 0) { recurse = false; }
    return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
}
/**
 * Adds a property to an object if it has a value.
 *
 * @param obj Object to be extended
 * @param prop Property name
 * @param tagName Tag name that contains the conditionally added property
 * @param where Element to search for the property
 * @param recurse Whether to recurse into child nodes.
 */
function addConditionally(obj, prop, tagName, where, recurse) {
    if (recurse === void 0) { recurse = false; }
    var val = fetch(tagName, where, recurse);
    if (val)
        obj[prop] = val;
}
/**
 * Checks if an element is a feed root node.
 *
 * @param value The name of the element to check.
 * @returns Whether an element is a feed root node.
 */
function isValidFeed(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
}
//# sourceMappingURL=feeds.js.map

/***/ }),

/***/ 1447:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uniqueSort = exports.compareDocumentPosition = exports.DocumentPosition = exports.removeSubsets = void 0;
var domhandler_1 = __nccwpck_require__(4038);
/**
 * Given an array of nodes, remove any member that is contained by another.
 *
 * @category Helpers
 * @param nodes Nodes to filter.
 * @returns Remaining nodes that aren't subtrees of each other.
 */
function removeSubsets(nodes) {
    var idx = nodes.length;
    /*
     * Check if each node (or one of its ancestors) is already contained in the
     * array.
     */
    while (--idx >= 0) {
        var node = nodes[idx];
        /*
         * Remove the node if it is not unique.
         * We are going through the array from the end, so we only
         * have to check nodes that preceed the node under consideration in the array.
         */
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
            nodes.splice(idx, 1);
            continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
            if (nodes.includes(ancestor)) {
                nodes.splice(idx, 1);
                break;
            }
        }
    }
    return nodes;
}
exports.removeSubsets = removeSubsets;
/**
 * @category Helpers
 * @see {@link http://dom.spec.whatwg.org/#dom-node-comparedocumentposition}
 */
var DocumentPosition;
(function (DocumentPosition) {
    DocumentPosition[DocumentPosition["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition[DocumentPosition["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition[DocumentPosition["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition[DocumentPosition["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition[DocumentPosition["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition = exports.DocumentPosition || (exports.DocumentPosition = {}));
/**
 * Compare the position of one node against another node in any other document.
 * The return value is a bitmask with the values from {@link DocumentPosition}.
 *
 * Document order:
 * > There is an ordering, document order, defined on all the nodes in the
 * > document corresponding to the order in which the first character of the
 * > XML representation of each node occurs in the XML representation of the
 * > document after expansion of general entities. Thus, the document element
 * > node will be the first node. Element nodes occur before their children.
 * > Thus, document order orders element nodes in order of the occurrence of
 * > their start-tag in the XML (after expansion of entities). The attribute
 * > nodes of an element occur after the element and before its children. The
 * > relative order of attribute nodes is implementation-dependent.
 *
 * Source:
 * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
 *
 * @category Helpers
 * @param nodeA The first node to use in the comparison
 * @param nodeB The second node to use in the comparison
 * @returns A bitmask describing the input nodes' relative position.
 *
 * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
 * a description of these values.
 */
function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
        return 0;
    }
    var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while (current) {
        aParents.unshift(current);
        current = current.parent;
    }
    current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while (current) {
        bParents.unshift(current);
        current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
    }
    if (idx === 0) {
        return DocumentPosition.DISCONNECTED;
    }
    var sharedParent = aParents[idx - 1];
    var siblings = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
            return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
        }
        return DocumentPosition.FOLLOWING;
    }
    if (sharedParent === nodeA) {
        return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
    }
    return DocumentPosition.PRECEDING;
}
exports.compareDocumentPosition = compareDocumentPosition;
/**
 * Sort an array of nodes based on their relative position in the document and
 * remove any duplicate nodes. If the array contains nodes that do not belong to
 * the same document, sort order is unspecified.
 *
 * @category Helpers
 * @param nodes Array of DOM nodes.
 * @returns Collection of unique nodes, sorted in document order.
 */
function uniqueSort(nodes) {
    nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });
    nodes.sort(function (a, b) {
        var relative = compareDocumentPosition(a, b);
        if (relative & DocumentPosition.PRECEDING) {
            return -1;
        }
        else if (relative & DocumentPosition.FOLLOWING) {
            return 1;
        }
        return 0;
    });
    return nodes;
}
exports.uniqueSort = uniqueSort;
//# sourceMappingURL=helpers.js.map

/***/ }),

/***/ 1754:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
__exportStar(__nccwpck_require__(9561), exports);
__exportStar(__nccwpck_require__(9228), exports);
__exportStar(__nccwpck_require__(177), exports);
__exportStar(__nccwpck_require__(9908), exports);
__exportStar(__nccwpck_require__(2185), exports);
__exportStar(__nccwpck_require__(1447), exports);
__exportStar(__nccwpck_require__(1503), exports);
/** @deprecated Use these methods from `domhandler` directly. */
var domhandler_1 = __nccwpck_require__(4038);
Object.defineProperty(exports, "isTag", ({ enumerable: true, get: function () { return domhandler_1.isTag; } }));
Object.defineProperty(exports, "isCDATA", ({ enumerable: true, get: function () { return domhandler_1.isCDATA; } }));
Object.defineProperty(exports, "isText", ({ enumerable: true, get: function () { return domhandler_1.isText; } }));
Object.defineProperty(exports, "isComment", ({ enumerable: true, get: function () { return domhandler_1.isComment; } }));
Object.defineProperty(exports, "isDocument", ({ enumerable: true, get: function () { return domhandler_1.isDocument; } }));
Object.defineProperty(exports, "hasChildren", ({ enumerable: true, get: function () { return domhandler_1.hasChildren; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 2185:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;
var domhandler_1 = __nccwpck_require__(4038);
var querying_js_1 = __nccwpck_require__(9908);
var Checks = {
    tag_name: function (name) {
        if (typeof name === "function") {
            return function (elem) { return (0, domhandler_1.isTag)(elem) && name(elem.name); };
        }
        else if (name === "*") {
            return domhandler_1.isTag;
        }
        return function (elem) { return (0, domhandler_1.isTag)(elem) && elem.name === name; };
    },
    tag_type: function (type) {
        if (typeof type === "function") {
            return function (elem) { return type(elem.type); };
        }
        return function (elem) { return elem.type === type; };
    },
    tag_contains: function (data) {
        if (typeof data === "function") {
            return function (elem) { return (0, domhandler_1.isText)(elem) && data(elem.data); };
        }
        return function (elem) { return (0, domhandler_1.isText)(elem) && elem.data === data; };
    },
};
/**
 * @param attrib Attribute to check.
 * @param value Attribute value to look for.
 * @returns A function to check whether the a node has an attribute with a
 *   particular value.
 */
function getAttribCheck(attrib, value) {
    if (typeof value === "function") {
        return function (elem) { return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]); };
    }
    return function (elem) { return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value; };
}
/**
 * @param a First function to combine.
 * @param b Second function to combine.
 * @returns A function taking a node and returning `true` if either of the input
 *   functions returns `true` for the node.
 */
function combineFuncs(a, b) {
    return function (elem) { return a(elem) || b(elem); };
}
/**
 * @param options An object describing nodes to look for.
 * @returns A function executing all checks in `options` and returning `true` if
 *   any of them match a node.
 */
function compileTest(options) {
    var funcs = Object.keys(options).map(function (key) {
        var value = options[key];
        return Object.prototype.hasOwnProperty.call(Checks, key)
            ? Checks[key](value)
            : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
/**
 * @category Legacy Query Functions
 * @param options An object describing nodes to look for.
 * @param node The element to test.
 * @returns Whether the element matches the description in `options`.
 */
function testElement(options, node) {
    var test = compileTest(options);
    return test ? test(node) : true;
}
exports.testElement = testElement;
/**
 * @category Legacy Query Functions
 * @param options An object describing nodes to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes that match `options`.
 */
function getElements(options, nodes, recurse, limit) {
    if (limit === void 0) { limit = Infinity; }
    var test = compileTest(options);
    return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];
}
exports.getElements = getElements;
/**
 * @category Legacy Query Functions
 * @param id The unique ID attribute value to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @returns The node with the supplied ID.
 */
function getElementById(id, nodes, recurse) {
    if (recurse === void 0) { recurse = true; }
    if (!Array.isArray(nodes))
        nodes = [nodes];
    return (0, querying_js_1.findOne)(getAttribCheck("id", id), nodes, recurse);
}
exports.getElementById = getElementById;
/**
 * @category Legacy Query Functions
 * @param tagName Tag name to search for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `tagName`.
 */
function getElementsByTagName(tagName, nodes, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    return (0, querying_js_1.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
}
exports.getElementsByTagName = getElementsByTagName;
/**
 * @category Legacy Query Functions
 * @param type Element type to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `type`.
 */
function getElementsByTagType(type, nodes, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    return (0, querying_js_1.filter)(Checks["tag_type"](type), nodes, recurse, limit);
}
exports.getElementsByTagType = getElementsByTagType;
//# sourceMappingURL=legacy.js.map

/***/ }),

/***/ 177:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;
/**
 * Remove an element from the dom
 *
 * @category Manipulation
 * @param elem The element to be removed
 */
function removeElement(elem) {
    if (elem.prev)
        elem.prev.next = elem.next;
    if (elem.next)
        elem.next.prev = elem.prev;
    if (elem.parent) {
        var childs = elem.parent.children;
        childs.splice(childs.lastIndexOf(elem), 1);
    }
}
exports.removeElement = removeElement;
/**
 * Replace an element in the dom
 *
 * @category Manipulation
 * @param elem The element to be replaced
 * @param replacement The element to be added
 */
function replaceElement(elem, replacement) {
    var prev = (replacement.prev = elem.prev);
    if (prev) {
        prev.next = replacement;
    }
    var next = (replacement.next = elem.next);
    if (next) {
        next.prev = replacement;
    }
    var parent = (replacement.parent = elem.parent);
    if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
        elem.parent = null;
    }
}
exports.replaceElement = replaceElement;
/**
 * Append a child to an element.
 *
 * @category Manipulation
 * @param elem The element to append to.
 * @param child The element to be added as a child.
 */
function appendChild(elem, child) {
    removeElement(child);
    child.next = null;
    child.parent = elem;
    if (elem.children.push(child) > 1) {
        var sibling = elem.children[elem.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
    }
    else {
        child.prev = null;
    }
}
exports.appendChild = appendChild;
/**
 * Append an element after another.
 *
 * @category Manipulation
 * @param elem The element to append after.
 * @param next The element be added.
 */
function append(elem, next) {
    removeElement(next);
    var parent = elem.parent;
    var currNext = elem.next;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;
    if (currNext) {
        currNext.prev = next;
        if (parent) {
            var childs = parent.children;
            childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
    }
    else if (parent) {
        parent.children.push(next);
    }
}
exports.append = append;
/**
 * Prepend a child to an element.
 *
 * @category Manipulation
 * @param elem The element to prepend before.
 * @param child The element to be added as a child.
 */
function prependChild(elem, child) {
    removeElement(child);
    child.parent = elem;
    child.prev = null;
    if (elem.children.unshift(child) !== 1) {
        var sibling = elem.children[1];
        sibling.prev = child;
        child.next = sibling;
    }
    else {
        child.next = null;
    }
}
exports.prependChild = prependChild;
/**
 * Prepend an element before another.
 *
 * @category Manipulation
 * @param elem The element to prepend before.
 * @param prev The element be added.
 */
function prepend(elem, prev) {
    removeElement(prev);
    var parent = elem.parent;
    if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
    }
    if (elem.prev) {
        elem.prev.next = prev;
    }
    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
}
exports.prepend = prepend;
//# sourceMappingURL=manipulation.js.map

/***/ }),

/***/ 9908:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;
var domhandler_1 = __nccwpck_require__(4038);
/**
 * Search a node and its children for nodes passing a test function.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param node Node to search. Will be included in the result set if it matches.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function filter(test, node, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    if (!Array.isArray(node))
        node = [node];
    return find(test, node, recurse, limit);
}
exports.filter = filter;
/**
 * Search an array of node and its children for nodes passing a test function.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function find(test, nodes, recurse, limit) {
    var result = [];
    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var elem = nodes_1[_i];
        if (test(elem)) {
            result.push(elem);
            if (--limit <= 0)
                break;
        }
        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
            var children = find(test, elem.children, recurse, limit);
            result.push.apply(result, children);
            limit -= children.length;
            if (limit <= 0)
                break;
        }
    }
    return result;
}
exports.find = find;
/**
 * Finds the first element inside of an array that matches a test function.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns The first node in the array that passes `test`.
 * @deprecated Use `Array.prototype.find` directly.
 */
function findOneChild(test, nodes) {
    return nodes.find(test);
}
exports.findOneChild = findOneChild;
/**
 * Finds one element in a tree that passes a test.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @returns The first child node that passes `test`.
 */
function findOne(test, nodes, recurse) {
    if (recurse === void 0) { recurse = true; }
    var elem = null;
    for (var i = 0; i < nodes.length && !elem; i++) {
        var checked = nodes[i];
        if (!(0, domhandler_1.isTag)(checked)) {
            continue;
        }
        else if (test(checked)) {
            elem = checked;
        }
        else if (recurse && checked.children.length > 0) {
            elem = findOne(test, checked.children, true);
        }
    }
    return elem;
}
exports.findOne = findOne;
/**
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns Whether a tree of nodes contains at least one node passing the test.
 */
function existsOne(test, nodes) {
    return nodes.some(function (checked) {
        return (0, domhandler_1.isTag)(checked) &&
            (test(checked) ||
                (checked.children.length > 0 &&
                    existsOne(test, checked.children)));
    });
}
exports.existsOne = existsOne;
/**
 * Search and array of nodes and its children for elements passing a test function.
 *
 * Same as `find`, but limited to elements and with less options, leading to reduced complexity.
 *
 * @category Querying
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns All nodes passing `test`.
 */
function findAll(test, nodes) {
    var _a;
    var result = [];
    var stack = nodes.filter(domhandler_1.isTag);
    var elem;
    while ((elem = stack.shift())) {
        var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(domhandler_1.isTag);
        if (children && children.length > 0) {
            stack.unshift.apply(stack, children);
        }
        if (test(elem))
            result.push(elem);
    }
    return result;
}
exports.findAll = findAll;
//# sourceMappingURL=querying.js.map

/***/ }),

/***/ 9561:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;
var domhandler_1 = __nccwpck_require__(4038);
var dom_serializer_1 = __importDefault(__nccwpck_require__(8621));
var domelementtype_1 = __nccwpck_require__(3944);
/**
 * @category Stringify
 * @deprecated Use the `dom-serializer` module directly.
 * @param node Node to get the outer HTML of.
 * @param options Options for serialization.
 * @returns `node`'s outer HTML.
 */
function getOuterHTML(node, options) {
    return (0, dom_serializer_1.default)(node, options);
}
exports.getOuterHTML = getOuterHTML;
/**
 * @category Stringify
 * @deprecated Use the `dom-serializer` module directly.
 * @param node Node to get the inner HTML of.
 * @param options Options for serialization.
 * @returns `node`'s inner HTML.
 */
function getInnerHTML(node, options) {
    return (0, domhandler_1.hasChildren)(node)
        ? node.children.map(function (node) { return getOuterHTML(node, options); }).join("")
        : "";
}
exports.getInnerHTML = getInnerHTML;
/**
 * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags.
 *
 * @category Stringify
 * @deprecated Use `textContent` instead.
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 */
function getText(node) {
    if (Array.isArray(node))
        return node.map(getText).join("");
    if ((0, domhandler_1.isTag)(node))
        return node.name === "br" ? "\n" : getText(node.children);
    if ((0, domhandler_1.isCDATA)(node))
        return getText(node.children);
    if ((0, domhandler_1.isText)(node))
        return node.data;
    return "";
}
exports.getText = getText;
/**
 * Get a node's text content.
 *
 * @category Stringify
 * @param node Node to get the text content of.
 * @returns `node`'s text content.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
 */
function textContent(node) {
    if (Array.isArray(node))
        return node.map(textContent).join("");
    if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
        return textContent(node.children);
    }
    if ((0, domhandler_1.isText)(node))
        return node.data;
    return "";
}
exports.textContent = textContent;
/**
 * Get a node's inner text.
 *
 * @category Stringify
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
 */
function innerText(node) {
    if (Array.isArray(node))
        return node.map(innerText).join("");
    if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
        return innerText(node.children);
    }
    if ((0, domhandler_1.isText)(node))
        return node.data;
    return "";
}
exports.innerText = innerText;
//# sourceMappingURL=stringify.js.map

/***/ }),

/***/ 9228:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;
var domhandler_1 = __nccwpck_require__(4038);
/**
 * Get a node's children.
 *
 * @category Traversal
 * @param elem Node to get the children of.
 * @returns `elem`'s children, or an empty array.
 */
function getChildren(elem) {
    return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
}
exports.getChildren = getChildren;
/**
 * Get a node's parent.
 *
 * @category Traversal
 * @param elem Node to get the parent of.
 * @returns `elem`'s parent node.
 */
function getParent(elem) {
    return elem.parent || null;
}
exports.getParent = getParent;
/**
 * Gets an elements siblings, including the element itself.
 *
 * Attempts to get the children through the element's parent first. If we don't
 * have a parent (the element is a root node), we walk the element's `prev` &
 * `next` to get all remaining nodes.
 *
 * @category Traversal
 * @param elem Element to get the siblings of.
 * @returns `elem`'s siblings.
 */
function getSiblings(elem) {
    var _a, _b;
    var parent = getParent(elem);
    if (parent != null)
        return getChildren(parent);
    var siblings = [elem];
    var prev = elem.prev, next = elem.next;
    while (prev != null) {
        siblings.unshift(prev);
        (_a = prev, prev = _a.prev);
    }
    while (next != null) {
        siblings.push(next);
        (_b = next, next = _b.next);
    }
    return siblings;
}
exports.getSiblings = getSiblings;
/**
 * Gets an attribute from an element.
 *
 * @category Traversal
 * @param elem Element to check.
 * @param name Attribute name to retrieve.
 * @returns The element's attribute value, or `undefined`.
 */
function getAttributeValue(elem, name) {
    var _a;
    return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
}
exports.getAttributeValue = getAttributeValue;
/**
 * Checks whether an element has an attribute.
 *
 * @category Traversal
 * @param elem Element to check.
 * @param name Attribute name to look for.
 * @returns Returns whether `elem` has the attribute `name`.
 */
function hasAttrib(elem, name) {
    return (elem.attribs != null &&
        Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
        elem.attribs[name] != null);
}
exports.hasAttrib = hasAttrib;
/**
 * Get the tag name of an element.
 *
 * @category Traversal
 * @param elem The element to get the name for.
 * @returns The tag name of `elem`.
 */
function getName(elem) {
    return elem.name;
}
exports.getName = getName;
/**
 * Returns the next element sibling of a node.
 *
 * @category Traversal
 * @param elem The element to get the next sibling of.
 * @returns `elem`'s next sibling that is a tag.
 */
function nextElementSibling(elem) {
    var _a;
    var next = elem.next;
    while (next !== null && !(0, domhandler_1.isTag)(next))
        (_a = next, next = _a.next);
    return next;
}
exports.nextElementSibling = nextElementSibling;
/**
 * Returns the previous element sibling of a node.
 *
 * @category Traversal
 * @param elem The element to get the previous sibling of.
 * @returns `elem`'s previous sibling that is a tag.
 */
function prevElementSibling(elem) {
    var _a;
    var prev = elem.prev;
    while (prev !== null && !(0, domhandler_1.isTag)(prev))
        (_a = prev, prev = _a.prev);
    return prev;
}
exports.prevElementSibling = prevElementSibling;
//# sourceMappingURL=traversal.js.map

/***/ }),

/***/ 5107:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTML = exports.determineBranch = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;
var decode_data_html_js_1 = __importDefault(__nccwpck_require__(6970));
exports.htmlDecodeTree = decode_data_html_js_1.default;
var decode_data_xml_js_1 = __importDefault(__nccwpck_require__(7359));
exports.xmlDecodeTree = decode_data_xml_js_1.default;
var decode_codepoint_js_1 = __importDefault(__nccwpck_require__(1227));
exports.decodeCodePoint = decode_codepoint_js_1.default;
var decode_codepoint_js_2 = __nccwpck_require__(1227);
Object.defineProperty(exports, "replaceCodePoint", ({ enumerable: true, get: function () { return decode_codepoint_js_2.replaceCodePoint; } }));
Object.defineProperty(exports, "fromCodePoint", ({ enumerable: true, get: function () { return decode_codepoint_js_2.fromCodePoint; } }));
var CharCodes;
(function (CharCodes) {
    CharCodes[CharCodes["NUM"] = 35] = "NUM";
    CharCodes[CharCodes["SEMI"] = 59] = "SEMI";
    CharCodes[CharCodes["ZERO"] = 48] = "ZERO";
    CharCodes[CharCodes["NINE"] = 57] = "NINE";
    CharCodes[CharCodes["LOWER_A"] = 97] = "LOWER_A";
    CharCodes[CharCodes["LOWER_F"] = 102] = "LOWER_F";
    CharCodes[CharCodes["LOWER_X"] = 120] = "LOWER_X";
    /** Bit that needs to be set to convert an upper case ASCII character to lower case */
    CharCodes[CharCodes["To_LOWER_BIT"] = 32] = "To_LOWER_BIT";
})(CharCodes || (CharCodes = {}));
var BinTrieFlags;
(function (BinTrieFlags) {
    BinTrieFlags[BinTrieFlags["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags[BinTrieFlags["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags[BinTrieFlags["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
function getDecoder(decodeTree) {
    return function decodeHTMLBinary(str, strict) {
        var ret = "";
        var lastIdx = 0;
        var strIdx = 0;
        while ((strIdx = str.indexOf("&", strIdx)) >= 0) {
            ret += str.slice(lastIdx, strIdx);
            lastIdx = strIdx;
            // Skip the "&"
            strIdx += 1;
            // If we have a numeric entity, handle this separately.
            if (str.charCodeAt(strIdx) === CharCodes.NUM) {
                // Skip the leading "&#". For hex entities, also skip the leading "x".
                var start = strIdx + 1;
                var base = 10;
                var cp = str.charCodeAt(start);
                if ((cp | CharCodes.To_LOWER_BIT) === CharCodes.LOWER_X) {
                    base = 16;
                    strIdx += 1;
                    start += 1;
                }
                do
                    cp = str.charCodeAt(++strIdx);
                while ((cp >= CharCodes.ZERO && cp <= CharCodes.NINE) ||
                    (base === 16 &&
                        (cp | CharCodes.To_LOWER_BIT) >= CharCodes.LOWER_A &&
                        (cp | CharCodes.To_LOWER_BIT) <= CharCodes.LOWER_F));
                if (start !== strIdx) {
                    var entity = str.substring(start, strIdx);
                    var parsed = parseInt(entity, base);
                    if (str.charCodeAt(strIdx) === CharCodes.SEMI) {
                        strIdx += 1;
                    }
                    else if (strict) {
                        continue;
                    }
                    ret += (0, decode_codepoint_js_1.default)(parsed);
                    lastIdx = strIdx;
                }
                continue;
            }
            var resultIdx = 0;
            var excess = 1;
            var treeIdx = 0;
            var current = decodeTree[treeIdx];
            for (; strIdx < str.length; strIdx++, excess++) {
                treeIdx = determineBranch(decodeTree, current, treeIdx + 1, str.charCodeAt(strIdx));
                if (treeIdx < 0)
                    break;
                current = decodeTree[treeIdx];
                var masked = current & BinTrieFlags.VALUE_LENGTH;
                // If the branch is a value, store it and continue
                if (masked) {
                    // If we have a legacy entity while parsing strictly, just skip the number of bytes
                    if (!strict || str.charCodeAt(strIdx) === CharCodes.SEMI) {
                        resultIdx = treeIdx;
                        excess = 0;
                    }
                    // The mask is the number of bytes of the value, including the current byte.
                    var valueLength = (masked >> 14) - 1;
                    if (valueLength === 0)
                        break;
                    treeIdx += valueLength;
                }
            }
            if (resultIdx !== 0) {
                var valueLength = (decodeTree[resultIdx] & BinTrieFlags.VALUE_LENGTH) >> 14;
                ret +=
                    valueLength === 1
                        ? String.fromCharCode(decodeTree[resultIdx] & ~BinTrieFlags.VALUE_LENGTH)
                        : valueLength === 2
                            ? String.fromCharCode(decodeTree[resultIdx + 1])
                            : String.fromCharCode(decodeTree[resultIdx + 1], decodeTree[resultIdx + 2]);
                lastIdx = strIdx - excess + 1;
            }
        }
        return ret + str.slice(lastIdx);
    };
}
function determineBranch(decodeTree, current, nodeIdx, char) {
    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    // Case 1: Single branch encoded in jump offset
    if (branchCount === 0) {
        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
    }
    // Case 2: Multiple branches encoded in jump table
    if (jumpOffset) {
        var value = char - jumpOffset;
        return value < 0 || value >= branchCount
            ? -1
            : decodeTree[nodeIdx + value] - 1;
    }
    // Case 3: Multiple branches encoded in dictionary
    // Binary search for the character.
    var lo = nodeIdx;
    var hi = lo + branchCount - 1;
    while (lo <= hi) {
        var mid = (lo + hi) >>> 1;
        var midVal = decodeTree[mid];
        if (midVal < char) {
            lo = mid + 1;
        }
        else if (midVal > char) {
            hi = mid - 1;
        }
        else {
            return decodeTree[mid + branchCount];
        }
    }
    return -1;
}
exports.determineBranch = determineBranch;
var htmlDecoder = getDecoder(decode_data_html_js_1.default);
var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
/**
 * Decodes an HTML string, allowing for entities not terminated by a semi-colon.
 *
 * @param str The string to decode.
 * @returns The decoded string.
 */
function decodeHTML(str) {
    return htmlDecoder(str, false);
}
exports.decodeHTML = decodeHTML;
/**
 * Decodes an HTML string, requiring all entities to be terminated by a semi-colon.
 *
 * @param str The string to decode.
 * @returns The decoded string.
 */
function decodeHTMLStrict(str) {
    return htmlDecoder(str, true);
}
exports.decodeHTMLStrict = decodeHTMLStrict;
/**
 * Decodes an XML string, requiring all entities to be terminated by a semi-colon.
 *
 * @param str The string to decode.
 * @returns The decoded string.
 */
function decodeXML(str) {
    return xmlDecoder(str, true);
}
exports.decodeXML = decodeXML;
//# sourceMappingURL=decode.js.map

/***/ }),

/***/ 1227:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.replaceCodePoint = exports.fromCodePoint = void 0;
var decodeMap = new Map([
    [0, 65533],
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376],
]);
exports.fromCodePoint = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
(_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function (codePoint) {
    var output = "";
    if (codePoint > 0xffff) {
        codePoint -= 0x10000;
        output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
        codePoint = 0xdc00 | (codePoint & 0x3ff);
    }
    output += String.fromCharCode(codePoint);
    return output;
};
function replaceCodePoint(codePoint) {
    var _a;
    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
        return 0xfffd;
    }
    return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;
}
exports.replaceCodePoint = replaceCodePoint;
function decodeCodePoint(codePoint) {
    return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
}
exports["default"] = decodeCodePoint;
//# sourceMappingURL=decode_codepoint.js.map

/***/ }),

/***/ 2006:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeNonAsciiHTML = exports.encodeHTML = void 0;
var encode_html_js_1 = __importDefault(__nccwpck_require__(8180));
var escape_js_1 = __nccwpck_require__(7654);
var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
/**
 * Encodes all characters in the input using HTML entities. This includes
 * characters that are valid ASCII characters in HTML documents, such as `#`.
 *
 * To get a more compact output, consider using the `encodeNonAsciiHTML`
 * function, which will only encode characters that are not valid in HTML
 * documents, as well as non-ASCII characters.
 *
 * If a character has no equivalent entity, a numeric hexadecimal reference
 * (eg. `&#xfc;`) will be used.
 */
function encodeHTML(data) {
    return encodeHTMLTrieRe(htmlReplacer, data);
}
exports.encodeHTML = encodeHTML;
/**
 * Encodes all non-ASCII characters, as well as characters not valid in HTML
 * documents using HTML entities. This function will not encode characters that
 * are valid in HTML documents, such as `#`.
 *
 * If a character has no equivalent entity, a numeric hexadecimal reference
 * (eg. `&#xfc;`) will be used.
 */
function encodeNonAsciiHTML(data) {
    return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
}
exports.encodeNonAsciiHTML = encodeNonAsciiHTML;
function encodeHTMLTrieRe(regExp, str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = regExp.exec(str)) !== null) {
        var i = match.index;
        ret += str.substring(lastIdx, i);
        var char = str.charCodeAt(i);
        var next = encode_html_js_1.default.get(char);
        if (typeof next === "object") {
            // We are in a branch. Try to match the next char.
            if (i + 1 < str.length) {
                var nextChar = str.charCodeAt(i + 1);
                var value = typeof next.n === "number"
                    ? next.n === nextChar
                        ? next.o
                        : undefined
                    : next.n.get(nextChar);
                if (value !== undefined) {
                    ret += value;
                    lastIdx = regExp.lastIndex += 1;
                    continue;
                }
            }
            next = next.v;
        }
        // We might have a tree node without a value; skip and use a numeric entitiy.
        if (next !== undefined) {
            ret += next;
            lastIdx = i + 1;
        }
        else {
            var cp = (0, escape_js_1.getCodePoint)(str, i);
            ret += "&#x".concat(cp.toString(16), ";");
            // Increase by 1 if we have a surrogate pair
            lastIdx = regExp.lastIndex += Number(cp !== char);
        }
    }
    return ret + str.substr(lastIdx);
}
//# sourceMappingURL=encode.js.map

/***/ }),

/***/ 7654:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.getCodePoint = exports.xmlReplacer = void 0;
exports.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
var xmlCodeMap = new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"],
]);
// For compatibility with node < 4, we wrap `codePointAt`
exports.getCodePoint = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.prototype.codePointAt != null
    ? function (str, index) { return str.codePointAt(index); }
    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        function (c, index) {
            return (c.charCodeAt(index) & 0xfc00) === 0xd800
                ? (c.charCodeAt(index) - 0xd800) * 0x400 +
                    c.charCodeAt(index + 1) -
                    0xdc00 +
                    0x10000
                : c.charCodeAt(index);
        };
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using XML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
function encodeXML(str) {
    var ret = "";
    var lastIdx = 0;
    var match;
    while ((match = exports.xmlReplacer.exec(str)) !== null) {
        var i = match.index;
        var char = str.charCodeAt(i);
        var next = xmlCodeMap.get(char);
        if (next !== undefined) {
            ret += str.substring(lastIdx, i) + next;
            lastIdx = i + 1;
        }
        else {
            ret += "".concat(str.substring(lastIdx, i), "&#x").concat((0, exports.getCodePoint)(str, i).toString(16), ";");
            // Increase by 1 if we have a surrogate pair
            lastIdx = exports.xmlReplacer.lastIndex += Number((char & 0xfc00) === 0xd800);
        }
    }
    return ret + str.substr(lastIdx);
}
exports.encodeXML = encodeXML;
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using numeric hexadecimal reference (eg. `&#xfc;`).
 *
 * Have a look at `escapeUTF8` if you want a more concise output at the expense
 * of reduced transportability.
 *
 * @param data String to escape.
 */
exports.escape = encodeXML;
function getEscaper(regex, map) {
    return function escape(data) {
        var match;
        var lastIdx = 0;
        var result = "";
        while ((match = regex.exec(data))) {
            if (lastIdx !== match.index) {
                result += data.substring(lastIdx, match.index);
            }
            // We know that this chararcter will be in the map.
            result += map.get(match[0].charCodeAt(0));
            // Every match will be of length 1
            lastIdx = match.index + 1;
        }
        return result + data.substring(lastIdx);
    };
}
/**
 * Encodes all characters not valid in XML documents using XML entities.
 *
 * Note that the output will be character-set dependent.
 *
 * @param data String to escape.
 */
exports.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
/**
 * Encodes all characters that have to be escaped in HTML attributes,
 * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
 *
 * @param data String to escape.
 */
exports.escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"],
]));
/**
 * Encodes all characters that have to be escaped in HTML text,
 * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
 *
 * @param data String to escape.
 */
exports.escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"],
]));
//# sourceMappingURL=escape.js.map

/***/ }),

/***/ 6970:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Generated using scripts/write-decode-map.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = new Uint16Array(
// prettier-ignore
"\u1d41<\xd5\u0131\u028a\u049d\u057b\u05d0\u0675\u06de\u07a2\u07d6\u080f\u0a4a\u0a91\u0da1\u0e6d\u0f09\u0f26\u10ca\u1228\u12e1\u1415\u149d\u14c3\u14df\u1525\0\0\0\0\0\0\u156b\u16cd\u198d\u1c12\u1ddd\u1f7e\u2060\u21b0\u228d\u23c0\u23fb\u2442\u2824\u2912\u2d08\u2e48\u2fce\u3016\u32ba\u3639\u37ac\u38fe\u3a28\u3a71\u3ae0\u3b2e\u0800EMabcfglmnoprstu\\bfms\x7f\x84\x8b\x90\x95\x98\xa6\xb3\xb9\xc8\xcflig\u803b\xc6\u40c6P\u803b&\u4026cute\u803b\xc1\u40c1reve;\u4102\u0100iyx}rc\u803b\xc2\u40c2;\u4410r;\uc000\ud835\udd04rave\u803b\xc0\u40c0pha;\u4391acr;\u4100d;\u6a53\u0100gp\x9d\xa1on;\u4104f;\uc000\ud835\udd38plyFunction;\u6061ing\u803b\xc5\u40c5\u0100cs\xbe\xc3r;\uc000\ud835\udc9cign;\u6254ilde\u803b\xc3\u40c3ml\u803b\xc4\u40c4\u0400aceforsu\xe5\xfb\xfe\u0117\u011c\u0122\u0127\u012a\u0100cr\xea\xf2kslash;\u6216\u0176\xf6\xf8;\u6ae7ed;\u6306y;\u4411\u0180crt\u0105\u010b\u0114ause;\u6235noullis;\u612ca;\u4392r;\uc000\ud835\udd05pf;\uc000\ud835\udd39eve;\u42d8c\xf2\u0113mpeq;\u624e\u0700HOacdefhilorsu\u014d\u0151\u0156\u0180\u019e\u01a2\u01b5\u01b7\u01ba\u01dc\u0215\u0273\u0278\u027ecy;\u4427PY\u803b\xa9\u40a9\u0180cpy\u015d\u0162\u017aute;\u4106\u0100;i\u0167\u0168\u62d2talDifferentialD;\u6145leys;\u612d\u0200aeio\u0189\u018e\u0194\u0198ron;\u410cdil\u803b\xc7\u40c7rc;\u4108nint;\u6230ot;\u410a\u0100dn\u01a7\u01adilla;\u40b8terDot;\u40b7\xf2\u017fi;\u43a7rcle\u0200DMPT\u01c7\u01cb\u01d1\u01d6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01e2\u01f8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020foubleQuote;\u601duote;\u6019\u0200lnpu\u021e\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6a74\u0180git\u022f\u0236\u023aruent;\u6261nt;\u622fourIntegral;\u622e\u0100fr\u024c\u024e;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6a2fcr;\uc000\ud835\udc9ep\u0100;C\u0284\u0285\u62d3ap;\u624d\u0580DJSZacefios\u02a0\u02ac\u02b0\u02b4\u02b8\u02cb\u02d7\u02e1\u02e6\u0333\u048d\u0100;o\u0179\u02a5trahd;\u6911cy;\u4402cy;\u4405cy;\u440f\u0180grs\u02bf\u02c4\u02c7ger;\u6021r;\u61a1hv;\u6ae4\u0100ay\u02d0\u02d5ron;\u410e;\u4414l\u0100;t\u02dd\u02de\u6207a;\u4394r;\uc000\ud835\udd07\u0100af\u02eb\u0327\u0100cm\u02f0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031ccute;\u40b4o\u0174\u030b\u030d;\u42d9bleAcute;\u42ddrave;\u4060ilde;\u42dcond;\u62c4ferentialD;\u6146\u0470\u033d\0\0\0\u0342\u0354\0\u0405f;\uc000\ud835\udd3b\u0180;DE\u0348\u0349\u034d\u40a8ot;\u60dcqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03cf\u03e2\u03f8ontourIntegra\xec\u0239o\u0274\u0379\0\0\u037b\xbb\u0349nArrow;\u61d3\u0100eo\u0387\u03a4ft\u0180ART\u0390\u0396\u03a1rrow;\u61d0ightArrow;\u61d4e\xe5\u02cang\u0100LR\u03ab\u03c4eft\u0100AR\u03b3\u03b9rrow;\u67f8ightArrow;\u67faightArrow;\u67f9ight\u0100AT\u03d8\u03derrow;\u61d2ee;\u62a8p\u0241\u03e9\0\0\u03efrrow;\u61d1ownArrow;\u61d5erticalBar;\u6225n\u0300ABLRTa\u0412\u042a\u0430\u045e\u047f\u037crrow\u0180;BU\u041d\u041e\u0422\u6193ar;\u6913pArrow;\u61f5reve;\u4311eft\u02d2\u043a\0\u0446\0\u0450ightVector;\u6950eeVector;\u695eector\u0100;B\u0459\u045a\u61bdar;\u6956ight\u01d4\u0467\0\u0471eeVector;\u695fector\u0100;B\u047a\u047b\u61c1ar;\u6957ee\u0100;A\u0486\u0487\u62a4rrow;\u61a7\u0100ct\u0492\u0497r;\uc000\ud835\udc9frok;\u4110\u0800NTacdfglmopqstux\u04bd\u04c0\u04c4\u04cb\u04de\u04e2\u04e7\u04ee\u04f5\u0521\u052f\u0536\u0552\u055d\u0560\u0565G;\u414aH\u803b\xd0\u40d0cute\u803b\xc9\u40c9\u0180aiy\u04d2\u04d7\u04dcron;\u411arc\u803b\xca\u40ca;\u442dot;\u4116r;\uc000\ud835\udd08rave\u803b\xc8\u40c8ement;\u6208\u0100ap\u04fa\u04fecr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65fberySmallSquare;\u65ab\u0100gp\u0526\u052aon;\u4118f;\uc000\ud835\udd3csilon;\u4395u\u0100ai\u053c\u0549l\u0100;T\u0542\u0543\u6a75ilde;\u6242librium;\u61cc\u0100ci\u0557\u055ar;\u6130m;\u6a73a;\u4397ml\u803b\xcb\u40cb\u0100ip\u056a\u056fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058d\u05b2\u05ccy;\u4424r;\uc000\ud835\udd09lled\u0253\u0597\0\0\u05a3mallSquare;\u65fcerySmallSquare;\u65aa\u0370\u05ba\0\u05bf\0\0\u05c4f;\uc000\ud835\udd3dAll;\u6200riertrf;\u6131c\xf2\u05cb\u0600JTabcdfgorst\u05e8\u05ec\u05ef\u05fa\u0600\u0612\u0616\u061b\u061d\u0623\u066c\u0672cy;\u4403\u803b>\u403emma\u0100;d\u05f7\u05f8\u4393;\u43dcreve;\u411e\u0180eiy\u0607\u060c\u0610dil;\u4122rc;\u411c;\u4413ot;\u4120r;\uc000\ud835\udd0a;\u62d9pf;\uc000\ud835\udd3eeater\u0300EFGLST\u0635\u0644\u064e\u0656\u065b\u0666qual\u0100;L\u063e\u063f\u6265ess;\u62dbullEqual;\u6267reater;\u6aa2ess;\u6277lantEqual;\u6a7eilde;\u6273cr;\uc000\ud835\udca2;\u626b\u0400Aacfiosu\u0685\u068b\u0696\u069b\u069e\u06aa\u06be\u06caRDcy;\u442a\u0100ct\u0690\u0694ek;\u42c7;\u405eirc;\u4124r;\u610clbertSpace;\u610b\u01f0\u06af\0\u06b2f;\u610dizontalLine;\u6500\u0100ct\u06c3\u06c5\xf2\u06a9rok;\u4126mp\u0144\u06d0\u06d8ownHum\xf0\u012fqual;\u624f\u0700EJOacdfgmnostu\u06fa\u06fe\u0703\u0707\u070e\u071a\u071e\u0721\u0728\u0744\u0778\u078b\u078f\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803b\xcd\u40cd\u0100iy\u0713\u0718rc\u803b\xce\u40ce;\u4418ot;\u4130r;\u6111rave\u803b\xcc\u40cc\u0180;ap\u0720\u072f\u073f\u0100cg\u0734\u0737r;\u412ainaryI;\u6148lie\xf3\u03dd\u01f4\u0749\0\u0762\u0100;e\u074d\u074e\u622c\u0100gr\u0753\u0758ral;\u622bsection;\u62c2isible\u0100CT\u076c\u0772omma;\u6063imes;\u6062\u0180gpt\u077f\u0783\u0788on;\u412ef;\uc000\ud835\udd40a;\u4399cr;\u6110ilde;\u4128\u01eb\u079a\0\u079ecy;\u4406l\u803b\xcf\u40cf\u0280cfosu\u07ac\u07b7\u07bc\u07c2\u07d0\u0100iy\u07b1\u07b5rc;\u4134;\u4419r;\uc000\ud835\udd0dpf;\uc000\ud835\udd41\u01e3\u07c7\0\u07ccr;\uc000\ud835\udca5rcy;\u4408kcy;\u4404\u0380HJacfos\u07e4\u07e8\u07ec\u07f1\u07fd\u0802\u0808cy;\u4425cy;\u440cppa;\u439a\u0100ey\u07f6\u07fbdil;\u4136;\u441ar;\uc000\ud835\udd0epf;\uc000\ud835\udd42cr;\uc000\ud835\udca6\u0580JTaceflmost\u0825\u0829\u082c\u0850\u0863\u09b3\u09b8\u09c7\u09cd\u0a37\u0a47cy;\u4409\u803b<\u403c\u0280cmnpr\u0837\u083c\u0841\u0844\u084dute;\u4139bda;\u439bg;\u67ealacetrf;\u6112r;\u619e\u0180aey\u0857\u085c\u0861ron;\u413ddil;\u413b;\u441b\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087e\u08a9\u08b1\u08e0\u08e6\u08fc\u092f\u095b\u0390\u096a\u0100nr\u0883\u088fgleBracket;\u67e8row\u0180;BR\u0899\u089a\u089e\u6190ar;\u61e4ightArrow;\u61c6eiling;\u6308o\u01f5\u08b7\0\u08c3bleBracket;\u67e6n\u01d4\u08c8\0\u08d2eeVector;\u6961ector\u0100;B\u08db\u08dc\u61c3ar;\u6959loor;\u630aight\u0100AV\u08ef\u08f5rrow;\u6194ector;\u694e\u0100er\u0901\u0917e\u0180;AV\u0909\u090a\u0910\u62a3rrow;\u61a4ector;\u695aiangle\u0180;BE\u0924\u0925\u0929\u62b2ar;\u69cfqual;\u62b4p\u0180DTV\u0937\u0942\u094cownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61bfar;\u6958ector\u0100;B\u0965\u0966\u61bcar;\u6952ight\xe1\u039cs\u0300EFGLST\u097e\u098b\u0995\u099d\u09a2\u09adqualGreater;\u62daullEqual;\u6266reater;\u6276ess;\u6aa1lantEqual;\u6a7dilde;\u6272r;\uc000\ud835\udd0f\u0100;e\u09bd\u09be\u62d8ftarrow;\u61daidot;\u413f\u0180npw\u09d4\u0a16\u0a1bg\u0200LRlr\u09de\u09f7\u0a02\u0a10eft\u0100AR\u09e6\u09ecrrow;\u67f5ightArrow;\u67f7ightArrow;\u67f6eft\u0100ar\u03b3\u0a0aight\xe1\u03bfight\xe1\u03caf;\uc000\ud835\udd43er\u0100LR\u0a22\u0a2ceftArrow;\u6199ightArrow;\u6198\u0180cht\u0a3e\u0a40\u0a42\xf2\u084c;\u61b0rok;\u4141;\u626a\u0400acefiosu\u0a5a\u0a5d\u0a60\u0a77\u0a7c\u0a85\u0a8b\u0a8ep;\u6905y;\u441c\u0100dl\u0a65\u0a6fiumSpace;\u605flintrf;\u6133r;\uc000\ud835\udd10nusPlus;\u6213pf;\uc000\ud835\udd44c\xf2\u0a76;\u439c\u0480Jacefostu\u0aa3\u0aa7\u0aad\u0ac0\u0b14\u0b19\u0d91\u0d97\u0d9ecy;\u440acute;\u4143\u0180aey\u0ab4\u0ab9\u0aberon;\u4147dil;\u4145;\u441d\u0180gsw\u0ac7\u0af0\u0b0eative\u0180MTV\u0ad3\u0adf\u0ae8ediumSpace;\u600bhi\u0100cn\u0ae6\u0ad8\xeb\u0ad9eryThi\xee\u0ad9ted\u0100GL\u0af8\u0b06reaterGreate\xf2\u0673essLes\xf3\u0a48Line;\u400ar;\uc000\ud835\udd11\u0200Bnpt\u0b22\u0b28\u0b37\u0b3areak;\u6060BreakingSpace;\u40a0f;\u6115\u0680;CDEGHLNPRSTV\u0b55\u0b56\u0b6a\u0b7c\u0ba1\u0beb\u0c04\u0c5e\u0c84\u0ca6\u0cd8\u0d61\u0d85\u6aec\u0100ou\u0b5b\u0b64ngruent;\u6262pCap;\u626doubleVerticalBar;\u6226\u0180lqx\u0b83\u0b8a\u0b9bement;\u6209ual\u0100;T\u0b92\u0b93\u6260ilde;\uc000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0bb6\u0bb7\u0bbd\u0bc9\u0bd3\u0bd8\u0be5\u626fqual;\u6271ullEqual;\uc000\u2267\u0338reater;\uc000\u226b\u0338ess;\u6279lantEqual;\uc000\u2a7e\u0338ilde;\u6275ump\u0144\u0bf2\u0bfdownHump;\uc000\u224e\u0338qual;\uc000\u224f\u0338e\u0100fs\u0c0a\u0c27tTriangle\u0180;BE\u0c1a\u0c1b\u0c21\u62eaar;\uc000\u29cf\u0338qual;\u62ecs\u0300;EGLST\u0c35\u0c36\u0c3c\u0c44\u0c4b\u0c58\u626equal;\u6270reater;\u6278ess;\uc000\u226a\u0338lantEqual;\uc000\u2a7d\u0338ilde;\u6274ested\u0100GL\u0c68\u0c79reaterGreater;\uc000\u2aa2\u0338essLess;\uc000\u2aa1\u0338recedes\u0180;ES\u0c92\u0c93\u0c9b\u6280qual;\uc000\u2aaf\u0338lantEqual;\u62e0\u0100ei\u0cab\u0cb9verseElement;\u620cghtTriangle\u0180;BE\u0ccb\u0ccc\u0cd2\u62ebar;\uc000\u29d0\u0338qual;\u62ed\u0100qu\u0cdd\u0d0cuareSu\u0100bp\u0ce8\u0cf9set\u0100;E\u0cf0\u0cf3\uc000\u228f\u0338qual;\u62e2erset\u0100;E\u0d03\u0d06\uc000\u2290\u0338qual;\u62e3\u0180bcp\u0d13\u0d24\u0d4eset\u0100;E\u0d1b\u0d1e\uc000\u2282\u20d2qual;\u6288ceeds\u0200;EST\u0d32\u0d33\u0d3b\u0d46\u6281qual;\uc000\u2ab0\u0338lantEqual;\u62e1ilde;\uc000\u227f\u0338erset\u0100;E\u0d58\u0d5b\uc000\u2283\u20d2qual;\u6289ilde\u0200;EFT\u0d6e\u0d6f\u0d75\u0d7f\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uc000\ud835\udca9ilde\u803b\xd1\u40d1;\u439d\u0700Eacdfgmoprstuv\u0dbd\u0dc2\u0dc9\u0dd5\u0ddb\u0de0\u0de7\u0dfc\u0e02\u0e20\u0e22\u0e32\u0e3f\u0e44lig;\u4152cute\u803b\xd3\u40d3\u0100iy\u0dce\u0dd3rc\u803b\xd4\u40d4;\u441eblac;\u4150r;\uc000\ud835\udd12rave\u803b\xd2\u40d2\u0180aei\u0dee\u0df2\u0df6cr;\u414cga;\u43a9cron;\u439fpf;\uc000\ud835\udd46enCurly\u0100DQ\u0e0e\u0e1aoubleQuote;\u601cuote;\u6018;\u6a54\u0100cl\u0e27\u0e2cr;\uc000\ud835\udcaaash\u803b\xd8\u40d8i\u016c\u0e37\u0e3cde\u803b\xd5\u40d5es;\u6a37ml\u803b\xd6\u40d6er\u0100BP\u0e4b\u0e60\u0100ar\u0e50\u0e53r;\u603eac\u0100ek\u0e5a\u0e5c;\u63deet;\u63b4arenthesis;\u63dc\u0480acfhilors\u0e7f\u0e87\u0e8a\u0e8f\u0e92\u0e94\u0e9d\u0eb0\u0efcrtialD;\u6202y;\u441fr;\uc000\ud835\udd13i;\u43a6;\u43a0usMinus;\u40b1\u0100ip\u0ea2\u0eadncareplan\xe5\u069df;\u6119\u0200;eio\u0eb9\u0eba\u0ee0\u0ee4\u6abbcedes\u0200;EST\u0ec8\u0ec9\u0ecf\u0eda\u627aqual;\u6aaflantEqual;\u627cilde;\u627eme;\u6033\u0100dp\u0ee9\u0eeeuct;\u620fortion\u0100;a\u0225\u0ef9l;\u621d\u0100ci\u0f01\u0f06r;\uc000\ud835\udcab;\u43a8\u0200Ufos\u0f11\u0f16\u0f1b\u0f1fOT\u803b\"\u4022r;\uc000\ud835\udd14pf;\u611acr;\uc000\ud835\udcac\u0600BEacefhiorsu\u0f3e\u0f43\u0f47\u0f60\u0f73\u0fa7\u0faa\u0fad\u1096\u10a9\u10b4\u10bearr;\u6910G\u803b\xae\u40ae\u0180cnr\u0f4e\u0f53\u0f56ute;\u4154g;\u67ebr\u0100;t\u0f5c\u0f5d\u61a0l;\u6916\u0180aey\u0f67\u0f6c\u0f71ron;\u4158dil;\u4156;\u4420\u0100;v\u0f78\u0f79\u611cerse\u0100EU\u0f82\u0f99\u0100lq\u0f87\u0f8eement;\u620builibrium;\u61cbpEquilibrium;\u696fr\xbb\u0f79o;\u43a1ght\u0400ACDFTUVa\u0fc1\u0feb\u0ff3\u1022\u1028\u105b\u1087\u03d8\u0100nr\u0fc6\u0fd2gleBracket;\u67e9row\u0180;BL\u0fdc\u0fdd\u0fe1\u6192ar;\u61e5eftArrow;\u61c4eiling;\u6309o\u01f5\u0ff9\0\u1005bleBracket;\u67e7n\u01d4\u100a\0\u1014eeVector;\u695dector\u0100;B\u101d\u101e\u61c2ar;\u6955loor;\u630b\u0100er\u102d\u1043e\u0180;AV\u1035\u1036\u103c\u62a2rrow;\u61a6ector;\u695biangle\u0180;BE\u1050\u1051\u1055\u62b3ar;\u69d0qual;\u62b5p\u0180DTV\u1063\u106e\u1078ownVector;\u694feeVector;\u695cector\u0100;B\u1082\u1083\u61bear;\u6954ector\u0100;B\u1091\u1092\u61c0ar;\u6953\u0100pu\u109b\u109ef;\u611dndImplies;\u6970ightarrow;\u61db\u0100ch\u10b9\u10bcr;\u611b;\u61b1leDelayed;\u69f4\u0680HOacfhimoqstu\u10e4\u10f1\u10f7\u10fd\u1119\u111e\u1151\u1156\u1161\u1167\u11b5\u11bb\u11bf\u0100Cc\u10e9\u10eeHcy;\u4429y;\u4428FTcy;\u442ccute;\u415a\u0280;aeiy\u1108\u1109\u110e\u1113\u1117\u6abcron;\u4160dil;\u415erc;\u415c;\u4421r;\uc000\ud835\udd16ort\u0200DLRU\u112a\u1134\u113e\u1149ownArrow\xbb\u041eeftArrow\xbb\u089aightArrow\xbb\u0fddpArrow;\u6191gma;\u43a3allCircle;\u6218pf;\uc000\ud835\udd4a\u0272\u116d\0\0\u1170t;\u621aare\u0200;ISU\u117b\u117c\u1189\u11af\u65a1ntersection;\u6293u\u0100bp\u118f\u119eset\u0100;E\u1197\u1198\u628fqual;\u6291erset\u0100;E\u11a8\u11a9\u6290qual;\u6292nion;\u6294cr;\uc000\ud835\udcaear;\u62c6\u0200bcmp\u11c8\u11db\u1209\u120b\u0100;s\u11cd\u11ce\u62d0et\u0100;E\u11cd\u11d5qual;\u6286\u0100ch\u11e0\u1205eeds\u0200;EST\u11ed\u11ee\u11f4\u11ff\u627bqual;\u6ab0lantEqual;\u627dilde;\u627fTh\xe1\u0f8c;\u6211\u0180;es\u1212\u1213\u1223\u62d1rset\u0100;E\u121c\u121d\u6283qual;\u6287et\xbb\u1213\u0580HRSacfhiors\u123e\u1244\u1249\u1255\u125e\u1271\u1276\u129f\u12c2\u12c8\u12d1ORN\u803b\xde\u40deADE;\u6122\u0100Hc\u124e\u1252cy;\u440by;\u4426\u0100bu\u125a\u125c;\u4009;\u43a4\u0180aey\u1265\u126a\u126fron;\u4164dil;\u4162;\u4422r;\uc000\ud835\udd17\u0100ei\u127b\u1289\u01f2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128e\u1298kSpace;\uc000\u205f\u200aSpace;\u6009lde\u0200;EFT\u12ab\u12ac\u12b2\u12bc\u623cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uc000\ud835\udd4bipleDot;\u60db\u0100ct\u12d6\u12dbr;\uc000\ud835\udcafrok;\u4166\u0ae1\u12f7\u130e\u131a\u1326\0\u132c\u1331\0\0\0\0\0\u1338\u133d\u1377\u1385\0\u13ff\u1404\u140a\u1410\u0100cr\u12fb\u1301ute\u803b\xda\u40dar\u0100;o\u1307\u1308\u619fcir;\u6949r\u01e3\u1313\0\u1316y;\u440eve;\u416c\u0100iy\u131e\u1323rc\u803b\xdb\u40db;\u4423blac;\u4170r;\uc000\ud835\udd18rave\u803b\xd9\u40d9acr;\u416a\u0100di\u1341\u1369er\u0100BP\u1348\u135d\u0100ar\u134d\u1350r;\u405fac\u0100ek\u1357\u1359;\u63dfet;\u63b5arenthesis;\u63ddon\u0100;P\u1370\u1371\u62c3lus;\u628e\u0100gp\u137b\u137fon;\u4172f;\uc000\ud835\udd4c\u0400ADETadps\u1395\u13ae\u13b8\u13c4\u03e8\u13d2\u13d7\u13f3rrow\u0180;BD\u1150\u13a0\u13a4ar;\u6912ownArrow;\u61c5ownArrow;\u6195quilibrium;\u696eee\u0100;A\u13cb\u13cc\u62a5rrow;\u61a5own\xe1\u03f3er\u0100LR\u13de\u13e8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13f9\u13fa\u43d2on;\u43a5ing;\u416ecr;\uc000\ud835\udcb0ilde;\u4168ml\u803b\xdc\u40dc\u0480Dbcdefosv\u1427\u142c\u1430\u1433\u143e\u1485\u148a\u1490\u1496ash;\u62abar;\u6aeby;\u4412ash\u0100;l\u143b\u143c\u62a9;\u6ae6\u0100er\u1443\u1445;\u62c1\u0180bty\u144c\u1450\u147aar;\u6016\u0100;i\u144f\u1455cal\u0200BLST\u1461\u1465\u146a\u1474ar;\u6223ine;\u407ceparator;\u6758ilde;\u6240ThinSpace;\u600ar;\uc000\ud835\udd19pf;\uc000\ud835\udd4dcr;\uc000\ud835\udcb1dash;\u62aa\u0280cefos\u14a7\u14ac\u14b1\u14b6\u14bcirc;\u4174dge;\u62c0r;\uc000\ud835\udd1apf;\uc000\ud835\udd4ecr;\uc000\ud835\udcb2\u0200fios\u14cb\u14d0\u14d2\u14d8r;\uc000\ud835\udd1b;\u439epf;\uc000\ud835\udd4fcr;\uc000\ud835\udcb3\u0480AIUacfosu\u14f1\u14f5\u14f9\u14fd\u1504\u150f\u1514\u151a\u1520cy;\u442fcy;\u4407cy;\u442ecute\u803b\xdd\u40dd\u0100iy\u1509\u150drc;\u4176;\u442br;\uc000\ud835\udd1cpf;\uc000\ud835\udd50cr;\uc000\ud835\udcb4ml;\u4178\u0400Hacdefos\u1535\u1539\u153f\u154b\u154f\u155d\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417d;\u4417ot;\u417b\u01f2\u1554\0\u155boWidt\xe8\u0ad9a;\u4396r;\u6128pf;\u6124cr;\uc000\ud835\udcb5\u0be1\u1583\u158a\u1590\0\u15b0\u15b6\u15bf\0\0\0\0\u15c6\u15db\u15eb\u165f\u166d\0\u1695\u169b\u16b2\u16b9\0\u16becute\u803b\xe1\u40e1reve;\u4103\u0300;Ediuy\u159c\u159d\u15a1\u15a3\u15a8\u15ad\u623e;\uc000\u223e\u0333;\u623frc\u803b\xe2\u40e2te\u80bb\xb4\u0306;\u4430lig\u803b\xe6\u40e6\u0100;r\xb2\u15ba;\uc000\ud835\udd1erave\u803b\xe0\u40e0\u0100ep\u15ca\u15d6\u0100fp\u15cf\u15d4sym;\u6135\xe8\u15d3ha;\u43b1\u0100ap\u15dfc\u0100cl\u15e4\u15e7r;\u4101g;\u6a3f\u0264\u15f0\0\0\u160a\u0280;adsv\u15fa\u15fb\u15ff\u1601\u1607\u6227nd;\u6a55;\u6a5clope;\u6a58;\u6a5a\u0380;elmrsz\u1618\u1619\u161b\u161e\u163f\u164f\u1659\u6220;\u69a4e\xbb\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163a\u163c\u163e;\u69a8;\u69a9;\u69aa;\u69ab;\u69ac;\u69ad;\u69ae;\u69aft\u0100;v\u1645\u1646\u621fb\u0100;d\u164c\u164d\u62be;\u699d\u0100pt\u1654\u1657h;\u6222\xbb\xb9arr;\u637c\u0100gp\u1663\u1667on;\u4105f;\uc000\ud835\udd52\u0380;Eaeiop\u12c1\u167b\u167d\u1682\u1684\u1687\u168a;\u6a70cir;\u6a6f;\u624ad;\u624bs;\u4027rox\u0100;e\u12c1\u1692\xf1\u1683ing\u803b\xe5\u40e5\u0180cty\u16a1\u16a6\u16a8r;\uc000\ud835\udcb6;\u402amp\u0100;e\u12c1\u16af\xf1\u0288ilde\u803b\xe3\u40e3ml\u803b\xe4\u40e4\u0100ci\u16c2\u16c8onin\xf4\u0272nt;\u6a11\u0800Nabcdefiklnoprsu\u16ed\u16f1\u1730\u173c\u1743\u1748\u1778\u177d\u17e0\u17e6\u1839\u1850\u170d\u193d\u1948\u1970ot;\u6aed\u0100cr\u16f6\u171ek\u0200ceps\u1700\u1705\u170d\u1713ong;\u624cpsilon;\u43f6rime;\u6035im\u0100;e\u171a\u171b\u623dq;\u62cd\u0176\u1722\u1726ee;\u62bded\u0100;g\u172c\u172d\u6305e\xbb\u172drk\u0100;t\u135c\u1737brk;\u63b6\u0100oy\u1701\u1741;\u4431quo;\u601e\u0280cmprt\u1753\u175b\u1761\u1764\u1768aus\u0100;e\u010a\u0109ptyv;\u69b0s\xe9\u170cno\xf5\u0113\u0180ahw\u176f\u1771\u1773;\u43b2;\u6136een;\u626cr;\uc000\ud835\udd1fg\u0380costuvw\u178d\u179d\u17b3\u17c1\u17d5\u17db\u17de\u0180aiu\u1794\u1796\u179a\xf0\u0760rc;\u65efp\xbb\u1371\u0180dpt\u17a4\u17a8\u17adot;\u6a00lus;\u6a01imes;\u6a02\u0271\u17b9\0\0\u17becup;\u6a06ar;\u6605riangle\u0100du\u17cd\u17d2own;\u65bdp;\u65b3plus;\u6a04e\xe5\u1444\xe5\u14adarow;\u690d\u0180ako\u17ed\u1826\u1835\u0100cn\u17f2\u1823k\u0180lst\u17fa\u05ab\u1802ozenge;\u69ebriangle\u0200;dlr\u1812\u1813\u1818\u181d\u65b4own;\u65beeft;\u65c2ight;\u65b8k;\u6423\u01b1\u182b\0\u1833\u01b2\u182f\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183e\u184d\u0100;q\u1843\u1846\uc000=\u20e5uiv;\uc000\u2261\u20e5t;\u6310\u0200ptwx\u1859\u185e\u1867\u186cf;\uc000\ud835\udd53\u0100;t\u13cb\u1863om\xbb\u13cctie;\u62c8\u0600DHUVbdhmptuv\u1885\u1896\u18aa\u18bb\u18d7\u18db\u18ec\u18ff\u1905\u190a\u1910\u1921\u0200LRlr\u188e\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18a1\u18a2\u18a4\u18a6\u18a8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18b3\u18b5\u18b7\u18b9;\u655d;\u655a;\u655c;\u6559\u0380;HLRhlr\u18ca\u18cb\u18cd\u18cf\u18d1\u18d3\u18d5\u6551;\u656c;\u6563;\u6560;\u656b;\u6562;\u655fox;\u69c9\u0200LRlr\u18e4\u18e6\u18e8\u18ea;\u6555;\u6552;\u6510;\u650c\u0280;DUdu\u06bd\u18f7\u18f9\u18fb\u18fd;\u6565;\u6568;\u652c;\u6534inus;\u629flus;\u629eimes;\u62a0\u0200LRlr\u1919\u191b\u191d\u191f;\u655b;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193b\u6502;\u656a;\u6561;\u655e;\u653c;\u6524;\u651c\u0100ev\u0123\u1942bar\u803b\xa6\u40a6\u0200ceio\u1951\u1956\u195a\u1960r;\uc000\ud835\udcb7mi;\u604fm\u0100;e\u171a\u171cl\u0180;bh\u1968\u1969\u196b\u405c;\u69c5sub;\u67c8\u016c\u1974\u197el\u0100;e\u1979\u197a\u6022t\xbb\u197ap\u0180;Ee\u012f\u1985\u1987;\u6aae\u0100;q\u06dc\u06db\u0ce1\u19a7\0\u19e8\u1a11\u1a15\u1a32\0\u1a37\u1a50\0\0\u1ab4\0\0\u1ac1\0\0\u1b21\u1b2e\u1b4d\u1b52\0\u1bfd\0\u1c0c\u0180cpr\u19ad\u19b2\u19ddute;\u4107\u0300;abcds\u19bf\u19c0\u19c4\u19ca\u19d5\u19d9\u6229nd;\u6a44rcup;\u6a49\u0100au\u19cf\u19d2p;\u6a4bp;\u6a47ot;\u6a40;\uc000\u2229\ufe00\u0100eo\u19e2\u19e5t;\u6041\xee\u0693\u0200aeiu\u19f0\u19fb\u1a01\u1a05\u01f0\u19f5\0\u19f8s;\u6a4don;\u410ddil\u803b\xe7\u40e7rc;\u4109ps\u0100;s\u1a0c\u1a0d\u6a4cm;\u6a50ot;\u410b\u0180dmn\u1a1b\u1a20\u1a26il\u80bb\xb8\u01adptyv;\u69b2t\u8100\xa2;e\u1a2d\u1a2e\u40a2r\xe4\u01b2r;\uc000\ud835\udd20\u0180cei\u1a3d\u1a40\u1a4dy;\u4447ck\u0100;m\u1a47\u1a48\u6713ark\xbb\u1a48;\u43c7r\u0380;Ecefms\u1a5f\u1a60\u1a62\u1a6b\u1aa4\u1aaa\u1aae\u65cb;\u69c3\u0180;el\u1a69\u1a6a\u1a6d\u42c6q;\u6257e\u0261\u1a74\0\0\u1a88rrow\u0100lr\u1a7c\u1a81eft;\u61baight;\u61bb\u0280RSacd\u1a92\u1a94\u1a96\u1a9a\u1a9f\xbb\u0f47;\u64c8st;\u629birc;\u629aash;\u629dnint;\u6a10id;\u6aefcir;\u69c2ubs\u0100;u\u1abb\u1abc\u6663it\xbb\u1abc\u02ec\u1ac7\u1ad4\u1afa\0\u1b0aon\u0100;e\u1acd\u1ace\u403a\u0100;q\xc7\xc6\u026d\u1ad9\0\0\u1ae2a\u0100;t\u1ade\u1adf\u402c;\u4040\u0180;fl\u1ae8\u1ae9\u1aeb\u6201\xee\u1160e\u0100mx\u1af1\u1af6ent\xbb\u1ae9e\xf3\u024d\u01e7\u1afe\0\u1b07\u0100;d\u12bb\u1b02ot;\u6a6dn\xf4\u0246\u0180fry\u1b10\u1b14\u1b17;\uc000\ud835\udd54o\xe4\u0254\u8100\xa9;s\u0155\u1b1dr;\u6117\u0100ao\u1b25\u1b29rr;\u61b5ss;\u6717\u0100cu\u1b32\u1b37r;\uc000\ud835\udcb8\u0100bp\u1b3c\u1b44\u0100;e\u1b41\u1b42\u6acf;\u6ad1\u0100;e\u1b49\u1b4a\u6ad0;\u6ad2dot;\u62ef\u0380delprvw\u1b60\u1b6c\u1b77\u1b82\u1bac\u1bd4\u1bf9arr\u0100lr\u1b68\u1b6a;\u6938;\u6935\u0270\u1b72\0\0\u1b75r;\u62dec;\u62dfarr\u0100;p\u1b7f\u1b80\u61b6;\u693d\u0300;bcdos\u1b8f\u1b90\u1b96\u1ba1\u1ba5\u1ba8\u622arcap;\u6a48\u0100au\u1b9b\u1b9ep;\u6a46p;\u6a4aot;\u628dr;\u6a45;\uc000\u222a\ufe00\u0200alrv\u1bb5\u1bbf\u1bde\u1be3rr\u0100;m\u1bbc\u1bbd\u61b7;\u693cy\u0180evw\u1bc7\u1bd4\u1bd8q\u0270\u1bce\0\0\u1bd2re\xe3\u1b73u\xe3\u1b75ee;\u62ceedge;\u62cfen\u803b\xa4\u40a4earrow\u0100lr\u1bee\u1bf3eft\xbb\u1b80ight\xbb\u1bbde\xe4\u1bdd\u0100ci\u1c01\u1c07onin\xf4\u01f7nt;\u6231lcty;\u632d\u0980AHabcdefhijlorstuwz\u1c38\u1c3b\u1c3f\u1c5d\u1c69\u1c75\u1c8a\u1c9e\u1cac\u1cb7\u1cfb\u1cff\u1d0d\u1d7b\u1d91\u1dab\u1dbb\u1dc6\u1dcdr\xf2\u0381ar;\u6965\u0200glrs\u1c48\u1c4d\u1c52\u1c54ger;\u6020eth;\u6138\xf2\u1133h\u0100;v\u1c5a\u1c5b\u6010\xbb\u090a\u016b\u1c61\u1c67arow;\u690fa\xe3\u0315\u0100ay\u1c6e\u1c73ron;\u410f;\u4434\u0180;ao\u0332\u1c7c\u1c84\u0100gr\u02bf\u1c81r;\u61catseq;\u6a77\u0180glm\u1c91\u1c94\u1c98\u803b\xb0\u40b0ta;\u43b4ptyv;\u69b1\u0100ir\u1ca3\u1ca8sht;\u697f;\uc000\ud835\udd21ar\u0100lr\u1cb3\u1cb5\xbb\u08dc\xbb\u101e\u0280aegsv\u1cc2\u0378\u1cd6\u1cdc\u1ce0m\u0180;os\u0326\u1cca\u1cd4nd\u0100;s\u0326\u1cd1uit;\u6666amma;\u43ddin;\u62f2\u0180;io\u1ce7\u1ce8\u1cf8\u40f7de\u8100\xf7;o\u1ce7\u1cf0ntimes;\u62c7n\xf8\u1cf7cy;\u4452c\u026f\u1d06\0\0\u1d0arn;\u631eop;\u630d\u0280lptuw\u1d18\u1d1d\u1d22\u1d49\u1d55lar;\u4024f;\uc000\ud835\udd55\u0280;emps\u030b\u1d2d\u1d37\u1d3d\u1d42q\u0100;d\u0352\u1d33ot;\u6251inus;\u6238lus;\u6214quare;\u62a1blebarwedg\xe5\xfan\u0180adh\u112e\u1d5d\u1d67ownarrow\xf3\u1c83arpoon\u0100lr\u1d72\u1d76ef\xf4\u1cb4igh\xf4\u1cb6\u0162\u1d7f\u1d85karo\xf7\u0f42\u026f\u1d8a\0\0\u1d8ern;\u631fop;\u630c\u0180cot\u1d98\u1da3\u1da6\u0100ry\u1d9d\u1da1;\uc000\ud835\udcb9;\u4455l;\u69f6rok;\u4111\u0100dr\u1db0\u1db4ot;\u62f1i\u0100;f\u1dba\u1816\u65bf\u0100ah\u1dc0\u1dc3r\xf2\u0429a\xf2\u0fa6angle;\u69a6\u0100ci\u1dd2\u1dd5y;\u445fgrarr;\u67ff\u0900Dacdefglmnopqrstux\u1e01\u1e09\u1e19\u1e38\u0578\u1e3c\u1e49\u1e61\u1e7e\u1ea5\u1eaf\u1ebd\u1ee1\u1f2a\u1f37\u1f44\u1f4e\u1f5a\u0100Do\u1e06\u1d34o\xf4\u1c89\u0100cs\u1e0e\u1e14ute\u803b\xe9\u40e9ter;\u6a6e\u0200aioy\u1e22\u1e27\u1e31\u1e36ron;\u411br\u0100;c\u1e2d\u1e2e\u6256\u803b\xea\u40ealon;\u6255;\u444dot;\u4117\u0100Dr\u1e41\u1e45ot;\u6252;\uc000\ud835\udd22\u0180;rs\u1e50\u1e51\u1e57\u6a9aave\u803b\xe8\u40e8\u0100;d\u1e5c\u1e5d\u6a96ot;\u6a98\u0200;ils\u1e6a\u1e6b\u1e72\u1e74\u6a99nters;\u63e7;\u6113\u0100;d\u1e79\u1e7a\u6a95ot;\u6a97\u0180aps\u1e85\u1e89\u1e97cr;\u4113ty\u0180;sv\u1e92\u1e93\u1e95\u6205et\xbb\u1e93p\u01001;\u1e9d\u1ea4\u0133\u1ea1\u1ea3;\u6004;\u6005\u6003\u0100gs\u1eaa\u1eac;\u414bp;\u6002\u0100gp\u1eb4\u1eb8on;\u4119f;\uc000\ud835\udd56\u0180als\u1ec4\u1ece\u1ed2r\u0100;s\u1eca\u1ecb\u62d5l;\u69e3us;\u6a71i\u0180;lv\u1eda\u1edb\u1edf\u43b5on\xbb\u1edb;\u43f5\u0200csuv\u1eea\u1ef3\u1f0b\u1f23\u0100io\u1eef\u1e31rc\xbb\u1e2e\u0269\u1ef9\0\0\u1efb\xed\u0548ant\u0100gl\u1f02\u1f06tr\xbb\u1e5dess\xbb\u1e7a\u0180aei\u1f12\u1f16\u1f1als;\u403dst;\u625fv\u0100;D\u0235\u1f20D;\u6a78parsl;\u69e5\u0100Da\u1f2f\u1f33ot;\u6253rr;\u6971\u0180cdi\u1f3e\u1f41\u1ef8r;\u612fo\xf4\u0352\u0100ah\u1f49\u1f4b;\u43b7\u803b\xf0\u40f0\u0100mr\u1f53\u1f57l\u803b\xeb\u40ebo;\u60ac\u0180cip\u1f61\u1f64\u1f67l;\u4021s\xf4\u056e\u0100eo\u1f6c\u1f74ctatio\xee\u0559nential\xe5\u0579\u09e1\u1f92\0\u1f9e\0\u1fa1\u1fa7\0\0\u1fc6\u1fcc\0\u1fd3\0\u1fe6\u1fea\u2000\0\u2008\u205allingdotse\xf1\u1e44y;\u4444male;\u6640\u0180ilr\u1fad\u1fb3\u1fc1lig;\u8000\ufb03\u0269\u1fb9\0\0\u1fbdg;\u8000\ufb00ig;\u8000\ufb04;\uc000\ud835\udd23lig;\u8000\ufb01lig;\uc000fj\u0180alt\u1fd9\u1fdc\u1fe1t;\u666dig;\u8000\ufb02ns;\u65b1of;\u4192\u01f0\u1fee\0\u1ff3f;\uc000\ud835\udd57\u0100ak\u05bf\u1ff7\u0100;v\u1ffc\u1ffd\u62d4;\u6ad9artint;\u6a0d\u0100ao\u200c\u2055\u0100cs\u2011\u2052\u03b1\u201a\u2030\u2038\u2045\u2048\0\u2050\u03b2\u2022\u2025\u2027\u202a\u202c\0\u202e\u803b\xbd\u40bd;\u6153\u803b\xbc\u40bc;\u6155;\u6159;\u615b\u01b3\u2034\0\u2036;\u6154;\u6156\u02b4\u203e\u2041\0\0\u2043\u803b\xbe\u40be;\u6157;\u615c5;\u6158\u01b6\u204c\0\u204e;\u615a;\u615d8;\u615el;\u6044wn;\u6322cr;\uc000\ud835\udcbb\u0880Eabcdefgijlnorstv\u2082\u2089\u209f\u20a5\u20b0\u20b4\u20f0\u20f5\u20fa\u20ff\u2103\u2112\u2138\u0317\u213e\u2152\u219e\u0100;l\u064d\u2087;\u6a8c\u0180cmp\u2090\u2095\u209dute;\u41f5ma\u0100;d\u209c\u1cda\u43b3;\u6a86reve;\u411f\u0100iy\u20aa\u20aerc;\u411d;\u4433ot;\u4121\u0200;lqs\u063e\u0642\u20bd\u20c9\u0180;qs\u063e\u064c\u20c4lan\xf4\u0665\u0200;cdl\u0665\u20d2\u20d5\u20e5c;\u6aa9ot\u0100;o\u20dc\u20dd\u6a80\u0100;l\u20e2\u20e3\u6a82;\u6a84\u0100;e\u20ea\u20ed\uc000\u22db\ufe00s;\u6a94r;\uc000\ud835\udd24\u0100;g\u0673\u061bmel;\u6137cy;\u4453\u0200;Eaj\u065a\u210c\u210e\u2110;\u6a92;\u6aa5;\u6aa4\u0200Eaes\u211b\u211d\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6a8arox\xbb\u2124\u0100;q\u212e\u212f\u6a88\u0100;q\u212e\u211bim;\u62e7pf;\uc000\ud835\udd58\u0100ci\u2143\u2146r;\u610am\u0180;el\u066b\u214e\u2150;\u6a8e;\u6a90\u8300>;cdlqr\u05ee\u2160\u216a\u216e\u2173\u2179\u0100ci\u2165\u2167;\u6aa7r;\u6a7aot;\u62d7Par;\u6995uest;\u6a7c\u0280adels\u2184\u216a\u2190\u0656\u219b\u01f0\u2189\0\u218epro\xf8\u209er;\u6978q\u0100lq\u063f\u2196les\xf3\u2088i\xed\u066b\u0100en\u21a3\u21adrtneqq;\uc000\u2269\ufe00\xc5\u21aa\u0500Aabcefkosy\u21c4\u21c7\u21f1\u21f5\u21fa\u2218\u221d\u222f\u2268\u227dr\xf2\u03a0\u0200ilmr\u21d0\u21d4\u21d7\u21dbrs\xf0\u1484f\xbb\u2024il\xf4\u06a9\u0100dr\u21e0\u21e4cy;\u444a\u0180;cw\u08f4\u21eb\u21efir;\u6948;\u61adar;\u610firc;\u4125\u0180alr\u2201\u220e\u2213rts\u0100;u\u2209\u220a\u6665it\xbb\u220alip;\u6026con;\u62b9r;\uc000\ud835\udd25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223a\u223e\u2243\u225e\u2263rr;\u61fftht;\u623bk\u0100lr\u2249\u2253eftarrow;\u61a9ightarrow;\u61aaf;\uc000\ud835\udd59bar;\u6015\u0180clt\u226f\u2274\u2278r;\uc000\ud835\udcbdas\xe8\u21f4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xbb\u1c5b\u0ae1\u22a3\0\u22aa\0\u22b8\u22c5\u22ce\0\u22d5\u22f3\0\0\u22f8\u2322\u2367\u2362\u237f\0\u2386\u23aa\u23b4cute\u803b\xed\u40ed\u0180;iy\u0771\u22b0\u22b5rc\u803b\xee\u40ee;\u4438\u0100cx\u22bc\u22bfy;\u4435cl\u803b\xa1\u40a1\u0100fr\u039f\u22c9;\uc000\ud835\udd26rave\u803b\xec\u40ec\u0200;ino\u073e\u22dd\u22e9\u22ee\u0100in\u22e2\u22e6nt;\u6a0ct;\u622dfin;\u69dcta;\u6129lig;\u4133\u0180aop\u22fe\u231a\u231d\u0180cgt\u2305\u2308\u2317r;\u412b\u0180elp\u071f\u230f\u2313in\xe5\u078ear\xf4\u0720h;\u4131f;\u62b7ed;\u41b5\u0280;cfot\u04f4\u232c\u2331\u233d\u2341are;\u6105in\u0100;t\u2338\u2339\u621eie;\u69dddo\xf4\u2319\u0280;celp\u0757\u234c\u2350\u235b\u2361al;\u62ba\u0100gr\u2355\u2359er\xf3\u1563\xe3\u234darhk;\u6a17rod;\u6a3c\u0200cgpt\u236f\u2372\u2376\u237by;\u4451on;\u412ff;\uc000\ud835\udd5aa;\u43b9uest\u803b\xbf\u40bf\u0100ci\u238a\u238fr;\uc000\ud835\udcben\u0280;Edsv\u04f4\u239b\u239d\u23a1\u04f3;\u62f9ot;\u62f5\u0100;v\u23a6\u23a7\u62f4;\u62f3\u0100;i\u0777\u23aelde;\u4129\u01eb\u23b8\0\u23bccy;\u4456l\u803b\xef\u40ef\u0300cfmosu\u23cc\u23d7\u23dc\u23e1\u23e7\u23f5\u0100iy\u23d1\u23d5rc;\u4135;\u4439r;\uc000\ud835\udd27ath;\u4237pf;\uc000\ud835\udd5b\u01e3\u23ec\0\u23f1r;\uc000\ud835\udcbfrcy;\u4458kcy;\u4454\u0400acfghjos\u240b\u2416\u2422\u2427\u242d\u2431\u2435\u243bppa\u0100;v\u2413\u2414\u43ba;\u43f0\u0100ey\u241b\u2420dil;\u4137;\u443ar;\uc000\ud835\udd28reen;\u4138cy;\u4445cy;\u445cpf;\uc000\ud835\udd5ccr;\uc000\ud835\udcc0\u0b80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248d\u2491\u250e\u253d\u255a\u2580\u264e\u265e\u2665\u2679\u267d\u269a\u26b2\u26d8\u275d\u2768\u278b\u27c0\u2801\u2812\u0180art\u2477\u247a\u247cr\xf2\u09c6\xf2\u0395ail;\u691barr;\u690e\u0100;g\u0994\u248b;\u6a8bar;\u6962\u0963\u24a5\0\u24aa\0\u24b1\0\0\0\0\0\u24b5\u24ba\0\u24c6\u24c8\u24cd\0\u24f9ute;\u413amptyv;\u69b4ra\xee\u084cbda;\u43bbg\u0180;dl\u088e\u24c1\u24c3;\u6991\xe5\u088e;\u6a85uo\u803b\xab\u40abr\u0400;bfhlpst\u0899\u24de\u24e6\u24e9\u24eb\u24ee\u24f1\u24f5\u0100;f\u089d\u24e3s;\u691fs;\u691d\xeb\u2252p;\u61abl;\u6939im;\u6973l;\u61a2\u0180;ae\u24ff\u2500\u2504\u6aabil;\u6919\u0100;s\u2509\u250a\u6aad;\uc000\u2aad\ufe00\u0180abr\u2515\u2519\u251drr;\u690crk;\u6772\u0100ak\u2522\u252cc\u0100ek\u2528\u252a;\u407b;\u405b\u0100es\u2531\u2533;\u698bl\u0100du\u2539\u253b;\u698f;\u698d\u0200aeuy\u2546\u254b\u2556\u2558ron;\u413e\u0100di\u2550\u2554il;\u413c\xec\u08b0\xe2\u2529;\u443b\u0200cqrs\u2563\u2566\u256d\u257da;\u6936uo\u0100;r\u0e19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694bh;\u61b2\u0280;fgqs\u258b\u258c\u0989\u25f3\u25ff\u6264t\u0280ahlrt\u2598\u25a4\u25b7\u25c2\u25e8rrow\u0100;t\u0899\u25a1a\xe9\u24f6arpoon\u0100du\u25af\u25b4own\xbb\u045ap\xbb\u0966eftarrows;\u61c7ight\u0180ahs\u25cd\u25d6\u25derrow\u0100;s\u08f4\u08a7arpoon\xf3\u0f98quigarro\xf7\u21f0hreetimes;\u62cb\u0180;qs\u258b\u0993\u25falan\xf4\u09ac\u0280;cdgs\u09ac\u260a\u260d\u261d\u2628c;\u6aa8ot\u0100;o\u2614\u2615\u6a7f\u0100;r\u261a\u261b\u6a81;\u6a83\u0100;e\u2622\u2625\uc000\u22da\ufe00s;\u6a93\u0280adegs\u2633\u2639\u263d\u2649\u264bppro\xf8\u24c6ot;\u62d6q\u0100gq\u2643\u2645\xf4\u0989gt\xf2\u248c\xf4\u099bi\xed\u09b2\u0180ilr\u2655\u08e1\u265asht;\u697c;\uc000\ud835\udd29\u0100;E\u099c\u2663;\u6a91\u0161\u2669\u2676r\u0100du\u25b2\u266e\u0100;l\u0965\u2673;\u696alk;\u6584cy;\u4459\u0280;acht\u0a48\u2688\u268b\u2691\u2696r\xf2\u25c1orne\xf2\u1d08ard;\u696bri;\u65fa\u0100io\u269f\u26a4dot;\u4140ust\u0100;a\u26ac\u26ad\u63b0che\xbb\u26ad\u0200Eaes\u26bb\u26bd\u26c9\u26d4;\u6268p\u0100;p\u26c3\u26c4\u6a89rox\xbb\u26c4\u0100;q\u26ce\u26cf\u6a87\u0100;q\u26ce\u26bbim;\u62e6\u0400abnoptwz\u26e9\u26f4\u26f7\u271a\u272f\u2741\u2747\u2750\u0100nr\u26ee\u26f1g;\u67ecr;\u61fdr\xeb\u08c1g\u0180lmr\u26ff\u270d\u2714eft\u0100ar\u09e6\u2707ight\xe1\u09f2apsto;\u67fcight\xe1\u09fdparrow\u0100lr\u2725\u2729ef\xf4\u24edight;\u61ac\u0180afl\u2736\u2739\u273dr;\u6985;\uc000\ud835\udd5dus;\u6a2dimes;\u6a34\u0161\u274b\u274fst;\u6217\xe1\u134e\u0180;ef\u2757\u2758\u1800\u65cange\xbb\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277c\u2785\u2787r\xf2\u08a8orne\xf2\u1d8car\u0100;d\u0f98\u2783;\u696d;\u600eri;\u62bf\u0300achiqt\u2798\u279d\u0a40\u27a2\u27ae\u27bbquo;\u6039r;\uc000\ud835\udcc1m\u0180;eg\u09b2\u27aa\u27ac;\u6a8d;\u6a8f\u0100bu\u252a\u27b3o\u0100;r\u0e1f\u27b9;\u601arok;\u4142\u8400<;cdhilqr\u082b\u27d2\u2639\u27dc\u27e0\u27e5\u27ea\u27f0\u0100ci\u27d7\u27d9;\u6aa6r;\u6a79re\xe5\u25f2mes;\u62c9arr;\u6976uest;\u6a7b\u0100Pi\u27f5\u27f9ar;\u6996\u0180;ef\u2800\u092d\u181b\u65c3r\u0100du\u2807\u280dshar;\u694ahar;\u6966\u0100en\u2817\u2821rtneqq;\uc000\u2268\ufe00\xc5\u281e\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288e\u2893\u28a0\u28a5\u28a8\u28da\u28e2\u28e4\u0a83\u28f3\u2902Dot;\u623a\u0200clpr\u284e\u2852\u2863\u287dr\u803b\xaf\u40af\u0100et\u2857\u2859;\u6642\u0100;e\u285e\u285f\u6720se\xbb\u285f\u0100;s\u103b\u2868to\u0200;dlu\u103b\u2873\u2877\u287bow\xee\u048cef\xf4\u090f\xf0\u13d1ker;\u65ae\u0100oy\u2887\u288cmma;\u6a29;\u443cash;\u6014asuredangle\xbb\u1626r;\uc000\ud835\udd2ao;\u6127\u0180cdn\u28af\u28b4\u28c9ro\u803b\xb5\u40b5\u0200;acd\u1464\u28bd\u28c0\u28c4s\xf4\u16a7ir;\u6af0ot\u80bb\xb7\u01b5us\u0180;bd\u28d2\u1903\u28d3\u6212\u0100;u\u1d3c\u28d8;\u6a2a\u0163\u28de\u28e1p;\u6adb\xf2\u2212\xf0\u0a81\u0100dp\u28e9\u28eeels;\u62a7f;\uc000\ud835\udd5e\u0100ct\u28f8\u28fdr;\uc000\ud835\udcc2pos\xbb\u159d\u0180;lm\u2909\u290a\u290d\u43bctimap;\u62b8\u0c00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297e\u2989\u2998\u29da\u29e9\u2a15\u2a1a\u2a58\u2a5d\u2a83\u2a95\u2aa4\u2aa8\u2b04\u2b07\u2b44\u2b7f\u2bae\u2c34\u2c67\u2c7c\u2ce9\u0100gt\u2947\u294b;\uc000\u22d9\u0338\u0100;v\u2950\u0bcf\uc000\u226b\u20d2\u0180elt\u295a\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61cdightarrow;\u61ce;\uc000\u22d8\u0338\u0100;v\u297b\u0c47\uc000\u226a\u20d2ightarrow;\u61cf\u0100Dd\u298e\u2993ash;\u62afash;\u62ae\u0280bcnpt\u29a3\u29a7\u29ac\u29b1\u29ccla\xbb\u02deute;\u4144g;\uc000\u2220\u20d2\u0280;Eiop\u0d84\u29bc\u29c0\u29c5\u29c8;\uc000\u2a70\u0338d;\uc000\u224b\u0338s;\u4149ro\xf8\u0d84ur\u0100;a\u29d3\u29d4\u666el\u0100;s\u29d3\u0b38\u01f3\u29df\0\u29e3p\u80bb\xa0\u0b37mp\u0100;e\u0bf9\u0c00\u0280aeouy\u29f4\u29fe\u2a03\u2a10\u2a13\u01f0\u29f9\0\u29fb;\u6a43on;\u4148dil;\u4146ng\u0100;d\u0d7e\u2a0aot;\uc000\u2a6d\u0338p;\u6a42;\u443dash;\u6013\u0380;Aadqsx\u0b92\u2a29\u2a2d\u2a3b\u2a41\u2a45\u2a50rr;\u61d7r\u0100hr\u2a33\u2a36k;\u6924\u0100;o\u13f2\u13f0ot;\uc000\u2250\u0338ui\xf6\u0b63\u0100ei\u2a4a\u2a4ear;\u6928\xed\u0b98ist\u0100;s\u0ba0\u0b9fr;\uc000\ud835\udd2b\u0200Eest\u0bc5\u2a66\u2a79\u2a7c\u0180;qs\u0bbc\u2a6d\u0be1\u0180;qs\u0bbc\u0bc5\u2a74lan\xf4\u0be2i\xed\u0bea\u0100;r\u0bb6\u2a81\xbb\u0bb7\u0180Aap\u2a8a\u2a8d\u2a91r\xf2\u2971rr;\u61aear;\u6af2\u0180;sv\u0f8d\u2a9c\u0f8c\u0100;d\u2aa1\u2aa2\u62fc;\u62facy;\u445a\u0380AEadest\u2ab7\u2aba\u2abe\u2ac2\u2ac5\u2af6\u2af9r\xf2\u2966;\uc000\u2266\u0338rr;\u619ar;\u6025\u0200;fqs\u0c3b\u2ace\u2ae3\u2aeft\u0100ar\u2ad4\u2ad9rro\xf7\u2ac1ightarro\xf7\u2a90\u0180;qs\u0c3b\u2aba\u2aealan\xf4\u0c55\u0100;s\u0c55\u2af4\xbb\u0c36i\xed\u0c5d\u0100;r\u0c35\u2afei\u0100;e\u0c1a\u0c25i\xe4\u0d90\u0100pt\u2b0c\u2b11f;\uc000\ud835\udd5f\u8180\xac;in\u2b19\u2b1a\u2b36\u40acn\u0200;Edv\u0b89\u2b24\u2b28\u2b2e;\uc000\u22f9\u0338ot;\uc000\u22f5\u0338\u01e1\u0b89\u2b33\u2b35;\u62f7;\u62f6i\u0100;v\u0cb8\u2b3c\u01e1\u0cb8\u2b41\u2b43;\u62fe;\u62fd\u0180aor\u2b4b\u2b63\u2b69r\u0200;ast\u0b7b\u2b55\u2b5a\u2b5flle\xec\u0b7bl;\uc000\u2afd\u20e5;\uc000\u2202\u0338lint;\u6a14\u0180;ce\u0c92\u2b70\u2b73u\xe5\u0ca5\u0100;c\u0c98\u2b78\u0100;e\u0c92\u2b7d\xf1\u0c98\u0200Aait\u2b88\u2b8b\u2b9d\u2ba7r\xf2\u2988rr\u0180;cw\u2b94\u2b95\u2b99\u619b;\uc000\u2933\u0338;\uc000\u219d\u0338ghtarrow\xbb\u2b95ri\u0100;e\u0ccb\u0cd6\u0380chimpqu\u2bbd\u2bcd\u2bd9\u2b04\u0b78\u2be4\u2bef\u0200;cer\u0d32\u2bc6\u0d37\u2bc9u\xe5\u0d45;\uc000\ud835\udcc3ort\u026d\u2b05\0\0\u2bd6ar\xe1\u2b56m\u0100;e\u0d6e\u2bdf\u0100;q\u0d74\u0d73su\u0100bp\u2beb\u2bed\xe5\u0cf8\xe5\u0d0b\u0180bcp\u2bf6\u2c11\u2c19\u0200;Ees\u2bff\u2c00\u0d22\u2c04\u6284;\uc000\u2ac5\u0338et\u0100;e\u0d1b\u2c0bq\u0100;q\u0d23\u2c00c\u0100;e\u0d32\u2c17\xf1\u0d38\u0200;Ees\u2c22\u2c23\u0d5f\u2c27\u6285;\uc000\u2ac6\u0338et\u0100;e\u0d58\u2c2eq\u0100;q\u0d60\u2c23\u0200gilr\u2c3d\u2c3f\u2c45\u2c47\xec\u0bd7lde\u803b\xf1\u40f1\xe7\u0c43iangle\u0100lr\u2c52\u2c5ceft\u0100;e\u0c1a\u2c5a\xf1\u0c26ight\u0100;e\u0ccb\u2c65\xf1\u0cd7\u0100;m\u2c6c\u2c6d\u43bd\u0180;es\u2c74\u2c75\u2c79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2c8f\u2c94\u2c99\u2c9e\u2ca3\u2cb0\u2cb6\u2cd3\u2ce3ash;\u62adarr;\u6904p;\uc000\u224d\u20d2ash;\u62ac\u0100et\u2ca8\u2cac;\uc000\u2265\u20d2;\uc000>\u20d2nfin;\u69de\u0180Aet\u2cbd\u2cc1\u2cc5rr;\u6902;\uc000\u2264\u20d2\u0100;r\u2cca\u2ccd\uc000<\u20d2ie;\uc000\u22b4\u20d2\u0100At\u2cd8\u2cdcrr;\u6903rie;\uc000\u22b5\u20d2im;\uc000\u223c\u20d2\u0180Aan\u2cf0\u2cf4\u2d02rr;\u61d6r\u0100hr\u2cfa\u2cfdk;\u6923\u0100;o\u13e7\u13e5ear;\u6927\u1253\u1a95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2d2d\0\u2d38\u2d48\u2d60\u2d65\u2d72\u2d84\u1b07\0\0\u2d8d\u2dab\0\u2dc8\u2dce\0\u2ddc\u2e19\u2e2b\u2e3e\u2e43\u0100cs\u2d31\u1a97ute\u803b\xf3\u40f3\u0100iy\u2d3c\u2d45r\u0100;c\u1a9e\u2d42\u803b\xf4\u40f4;\u443e\u0280abios\u1aa0\u2d52\u2d57\u01c8\u2d5alac;\u4151v;\u6a38old;\u69bclig;\u4153\u0100cr\u2d69\u2d6dir;\u69bf;\uc000\ud835\udd2c\u036f\u2d79\0\0\u2d7c\0\u2d82n;\u42dbave\u803b\xf2\u40f2;\u69c1\u0100bm\u2d88\u0df4ar;\u69b5\u0200acit\u2d95\u2d98\u2da5\u2da8r\xf2\u1a80\u0100ir\u2d9d\u2da0r;\u69beoss;\u69bbn\xe5\u0e52;\u69c0\u0180aei\u2db1\u2db5\u2db9cr;\u414dga;\u43c9\u0180cdn\u2dc0\u2dc5\u01cdron;\u43bf;\u69b6pf;\uc000\ud835\udd60\u0180ael\u2dd4\u2dd7\u01d2r;\u69b7rp;\u69b9\u0380;adiosv\u2dea\u2deb\u2dee\u2e08\u2e0d\u2e10\u2e16\u6228r\xf2\u1a86\u0200;efm\u2df7\u2df8\u2e02\u2e05\u6a5dr\u0100;o\u2dfe\u2dff\u6134f\xbb\u2dff\u803b\xaa\u40aa\u803b\xba\u40bagof;\u62b6r;\u6a56lope;\u6a57;\u6a5b\u0180clo\u2e1f\u2e21\u2e27\xf2\u2e01ash\u803b\xf8\u40f8l;\u6298i\u016c\u2e2f\u2e34de\u803b\xf5\u40f5es\u0100;a\u01db\u2e3as;\u6a36ml\u803b\xf6\u40f6bar;\u633d\u0ae1\u2e5e\0\u2e7d\0\u2e80\u2e9d\0\u2ea2\u2eb9\0\0\u2ecb\u0e9c\0\u2f13\0\0\u2f2b\u2fbc\0\u2fc8r\u0200;ast\u0403\u2e67\u2e72\u0e85\u8100\xb6;l\u2e6d\u2e6e\u40b6le\xec\u0403\u0269\u2e78\0\0\u2e7bm;\u6af3;\u6afdy;\u443fr\u0280cimpt\u2e8b\u2e8f\u2e93\u1865\u2e97nt;\u4025od;\u402eil;\u6030enk;\u6031r;\uc000\ud835\udd2d\u0180imo\u2ea8\u2eb0\u2eb4\u0100;v\u2ead\u2eae\u43c6;\u43d5ma\xf4\u0a76ne;\u660e\u0180;tv\u2ebf\u2ec0\u2ec8\u43c0chfork\xbb\u1ffd;\u43d6\u0100au\u2ecf\u2edfn\u0100ck\u2ed5\u2eddk\u0100;h\u21f4\u2edb;\u610e\xf6\u21f4s\u0480;abcdemst\u2ef3\u2ef4\u1908\u2ef9\u2efd\u2f04\u2f06\u2f0a\u2f0e\u402bcir;\u6a23ir;\u6a22\u0100ou\u1d40\u2f02;\u6a25;\u6a72n\u80bb\xb1\u0e9dim;\u6a26wo;\u6a27\u0180ipu\u2f19\u2f20\u2f25ntint;\u6a15f;\uc000\ud835\udd61nd\u803b\xa3\u40a3\u0500;Eaceinosu\u0ec8\u2f3f\u2f41\u2f44\u2f47\u2f81\u2f89\u2f92\u2f7e\u2fb6;\u6ab3p;\u6ab7u\xe5\u0ed9\u0100;c\u0ece\u2f4c\u0300;acens\u0ec8\u2f59\u2f5f\u2f66\u2f68\u2f7eppro\xf8\u2f43urlye\xf1\u0ed9\xf1\u0ece\u0180aes\u2f6f\u2f76\u2f7approx;\u6ab9qq;\u6ab5im;\u62e8i\xed\u0edfme\u0100;s\u2f88\u0eae\u6032\u0180Eas\u2f78\u2f90\u2f7a\xf0\u2f75\u0180dfp\u0eec\u2f99\u2faf\u0180als\u2fa0\u2fa5\u2faalar;\u632eine;\u6312urf;\u6313\u0100;t\u0efb\u2fb4\xef\u0efbrel;\u62b0\u0100ci\u2fc0\u2fc5r;\uc000\ud835\udcc5;\u43c8ncsp;\u6008\u0300fiopsu\u2fda\u22e2\u2fdf\u2fe5\u2feb\u2ff1r;\uc000\ud835\udd2epf;\uc000\ud835\udd62rime;\u6057cr;\uc000\ud835\udcc6\u0180aeo\u2ff8\u3009\u3013t\u0100ei\u2ffe\u3005rnion\xf3\u06b0nt;\u6a16st\u0100;e\u3010\u3011\u403f\xf1\u1f19\xf4\u0f14\u0a80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30e0\u310e\u312b\u3147\u3162\u3172\u318e\u3206\u3215\u3224\u3229\u3258\u326e\u3272\u3290\u32b0\u32b7\u0180art\u3047\u304a\u304cr\xf2\u10b3\xf2\u03ddail;\u691car\xf2\u1c65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307f\u308f\u3094\u30cc\u0100eu\u306d\u3071;\uc000\u223d\u0331te;\u4155i\xe3\u116emptyv;\u69b3g\u0200;del\u0fd1\u3089\u308b\u308d;\u6992;\u69a5\xe5\u0fd1uo\u803b\xbb\u40bbr\u0580;abcfhlpstw\u0fdc\u30ac\u30af\u30b7\u30b9\u30bc\u30be\u30c0\u30c3\u30c7\u30cap;\u6975\u0100;f\u0fe0\u30b4s;\u6920;\u6933s;\u691e\xeb\u225d\xf0\u272el;\u6945im;\u6974l;\u61a3;\u619d\u0100ai\u30d1\u30d5il;\u691ao\u0100;n\u30db\u30dc\u6236al\xf3\u0f1e\u0180abr\u30e7\u30ea\u30eer\xf2\u17e5rk;\u6773\u0100ak\u30f3\u30fdc\u0100ek\u30f9\u30fb;\u407d;\u405d\u0100es\u3102\u3104;\u698cl\u0100du\u310a\u310c;\u698e;\u6990\u0200aeuy\u3117\u311c\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xec\u0ff2\xe2\u30fa;\u4440\u0200clqs\u3134\u3137\u313d\u3144a;\u6937dhar;\u6969uo\u0100;r\u020e\u020dh;\u61b3\u0180acg\u314e\u315f\u0f44l\u0200;ips\u0f78\u3158\u315b\u109cn\xe5\u10bbar\xf4\u0fa9t;\u65ad\u0180ilr\u3169\u1023\u316esht;\u697d;\uc000\ud835\udd2f\u0100ao\u3177\u3186r\u0100du\u317d\u317f\xbb\u047b\u0100;l\u1091\u3184;\u696c\u0100;v\u318b\u318c\u43c1;\u43f1\u0180gns\u3195\u31f9\u31fcht\u0300ahlrst\u31a4\u31b0\u31c2\u31d8\u31e4\u31eerrow\u0100;t\u0fdc\u31ada\xe9\u30c8arpoon\u0100du\u31bb\u31bfow\xee\u317ep\xbb\u1092eft\u0100ah\u31ca\u31d0rrow\xf3\u0feaarpoon\xf3\u0551ightarrows;\u61c9quigarro\xf7\u30cbhreetimes;\u62ccg;\u42daingdotse\xf1\u1f32\u0180ahm\u320d\u3210\u3213r\xf2\u0feaa\xf2\u0551;\u600foust\u0100;a\u321e\u321f\u63b1che\xbb\u321fmid;\u6aee\u0200abpt\u3232\u323d\u3240\u3252\u0100nr\u3237\u323ag;\u67edr;\u61fer\xeb\u1003\u0180afl\u3247\u324a\u324er;\u6986;\uc000\ud835\udd63us;\u6a2eimes;\u6a35\u0100ap\u325d\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6a12ar\xf2\u31e3\u0200achq\u327b\u3280\u10bc\u3285quo;\u603ar;\uc000\ud835\udcc7\u0100bu\u30fb\u328ao\u0100;r\u0214\u0213\u0180hir\u3297\u329b\u32a0re\xe5\u31f8mes;\u62cai\u0200;efl\u32aa\u1059\u1821\u32ab\u65b9tri;\u69celuhar;\u6968;\u611e\u0d61\u32d5\u32db\u32df\u332c\u3338\u3371\0\u337a\u33a4\0\0\u33ec\u33f0\0\u3428\u3448\u345a\u34ad\u34b1\u34ca\u34f1\0\u3616\0\0\u3633cute;\u415bqu\xef\u27ba\u0500;Eaceinpsy\u11ed\u32f3\u32f5\u32ff\u3302\u330b\u330f\u331f\u3326\u3329;\u6ab4\u01f0\u32fa\0\u32fc;\u6ab8on;\u4161u\xe5\u11fe\u0100;d\u11f3\u3307il;\u415frc;\u415d\u0180Eas\u3316\u3318\u331b;\u6ab6p;\u6abaim;\u62e9olint;\u6a13i\xed\u1204;\u4441ot\u0180;be\u3334\u1d47\u3335\u62c5;\u6a66\u0380Aacmstx\u3346\u334a\u3357\u335b\u335e\u3363\u336drr;\u61d8r\u0100hr\u3350\u3352\xeb\u2228\u0100;o\u0a36\u0a34t\u803b\xa7\u40a7i;\u403bwar;\u6929m\u0100in\u3369\xf0nu\xf3\xf1t;\u6736r\u0100;o\u3376\u2055\uc000\ud835\udd30\u0200acoy\u3382\u3386\u3391\u33a0rp;\u666f\u0100hy\u338b\u338fcy;\u4449;\u4448rt\u026d\u3399\0\0\u339ci\xe4\u1464ara\xec\u2e6f\u803b\xad\u40ad\u0100gm\u33a8\u33b4ma\u0180;fv\u33b1\u33b2\u33b2\u43c3;\u43c2\u0400;deglnpr\u12ab\u33c5\u33c9\u33ce\u33d6\u33de\u33e1\u33e6ot;\u6a6a\u0100;q\u12b1\u12b0\u0100;E\u33d3\u33d4\u6a9e;\u6aa0\u0100;E\u33db\u33dc\u6a9d;\u6a9fe;\u6246lus;\u6a24arr;\u6972ar\xf2\u113d\u0200aeit\u33f8\u3408\u340f\u3417\u0100ls\u33fd\u3404lsetm\xe9\u336ahp;\u6a33parsl;\u69e4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341c\u341d\u6aaa\u0100;s\u3422\u3423\u6aac;\uc000\u2aac\ufe00\u0180flp\u342e\u3433\u3442tcy;\u444c\u0100;b\u3438\u3439\u402f\u0100;a\u343e\u343f\u69c4r;\u633ff;\uc000\ud835\udd64a\u0100dr\u344d\u0402es\u0100;u\u3454\u3455\u6660it\xbb\u3455\u0180csu\u3460\u3479\u349f\u0100au\u3465\u346fp\u0100;s\u1188\u346b;\uc000\u2293\ufe00p\u0100;s\u11b4\u3475;\uc000\u2294\ufe00u\u0100bp\u347f\u348f\u0180;es\u1197\u119c\u3486et\u0100;e\u1197\u348d\xf1\u119d\u0180;es\u11a8\u11ad\u3496et\u0100;e\u11a8\u349d\xf1\u11ae\u0180;af\u117b\u34a6\u05b0r\u0165\u34ab\u05b1\xbb\u117car\xf2\u1148\u0200cemt\u34b9\u34be\u34c2\u34c5r;\uc000\ud835\udcc8tm\xee\xf1i\xec\u3415ar\xe6\u11be\u0100ar\u34ce\u34d5r\u0100;f\u34d4\u17bf\u6606\u0100an\u34da\u34edight\u0100ep\u34e3\u34eapsilo\xee\u1ee0h\xe9\u2eafs\xbb\u2852\u0280bcmnp\u34fb\u355e\u1209\u358b\u358e\u0480;Edemnprs\u350e\u350f\u3511\u3515\u351e\u3523\u352c\u3531\u3536\u6282;\u6ac5ot;\u6abd\u0100;d\u11da\u351aot;\u6ac3ult;\u6ac1\u0100Ee\u3528\u352a;\u6acb;\u628alus;\u6abfarr;\u6979\u0180eiu\u353d\u3552\u3555t\u0180;en\u350e\u3545\u354bq\u0100;q\u11da\u350feq\u0100;q\u352b\u3528m;\u6ac7\u0100bp\u355a\u355c;\u6ad5;\u6ad3c\u0300;acens\u11ed\u356c\u3572\u3579\u357b\u3326ppro\xf8\u32faurlye\xf1\u11fe\xf1\u11f3\u0180aes\u3582\u3588\u331bppro\xf8\u331aq\xf1\u3317g;\u666a\u0680123;Edehlmnps\u35a9\u35ac\u35af\u121c\u35b2\u35b4\u35c0\u35c9\u35d5\u35da\u35df\u35e8\u35ed\u803b\xb9\u40b9\u803b\xb2\u40b2\u803b\xb3\u40b3;\u6ac6\u0100os\u35b9\u35bct;\u6abeub;\u6ad8\u0100;d\u1222\u35c5ot;\u6ac4s\u0100ou\u35cf\u35d2l;\u67c9b;\u6ad7arr;\u697bult;\u6ac2\u0100Ee\u35e4\u35e6;\u6acc;\u628blus;\u6ac0\u0180eiu\u35f4\u3609\u360ct\u0180;en\u121c\u35fc\u3602q\u0100;q\u1222\u35b2eq\u0100;q\u35e7\u35e4m;\u6ac8\u0100bp\u3611\u3613;\u6ad4;\u6ad6\u0180Aan\u361c\u3620\u362drr;\u61d9r\u0100hr\u3626\u3628\xeb\u222e\u0100;o\u0a2b\u0a29war;\u692alig\u803b\xdf\u40df\u0be1\u3651\u365d\u3660\u12ce\u3673\u3679\0\u367e\u36c2\0\0\0\0\0\u36db\u3703\0\u3709\u376c\0\0\0\u3787\u0272\u3656\0\0\u365bget;\u6316;\u43c4r\xeb\u0e5f\u0180aey\u3666\u366b\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uc000\ud835\udd31\u0200eiko\u3686\u369d\u36b5\u36bc\u01f2\u368b\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369b\u43b8ym;\u43d1\u0100cn\u36a2\u36b2k\u0100as\u36a8\u36aeppro\xf8\u12c1im\xbb\u12acs\xf0\u129e\u0100as\u36ba\u36ae\xf0\u12c1rn\u803b\xfe\u40fe\u01ec\u031f\u36c6\u22e7es\u8180\xd7;bd\u36cf\u36d0\u36d8\u40d7\u0100;a\u190f\u36d5r;\u6a31;\u6a30\u0180eps\u36e1\u36e3\u3700\xe1\u2a4d\u0200;bcf\u0486\u36ec\u36f0\u36f4ot;\u6336ir;\u6af1\u0100;o\u36f9\u36fc\uc000\ud835\udd65rk;\u6ada\xe1\u3362rime;\u6034\u0180aip\u370f\u3712\u3764d\xe5\u1248\u0380adempst\u3721\u374d\u3740\u3751\u3757\u375c\u375fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65b5own\xbb\u1dbbeft\u0100;e\u2800\u373e\xf1\u092e;\u625cight\u0100;e\u32aa\u374b\xf1\u105aot;\u65ecinus;\u6a3alus;\u6a39b;\u69cdime;\u6a3bezium;\u63e2\u0180cht\u3772\u377d\u3781\u0100ry\u3777\u377b;\uc000\ud835\udcc9;\u4446cy;\u445brok;\u4167\u0100io\u378b\u378ex\xf4\u1777head\u0100lr\u3797\u37a0eftarro\xf7\u084fightarrow\xbb\u0f5d\u0900AHabcdfghlmoprstuw\u37d0\u37d3\u37d7\u37e4\u37f0\u37fc\u380e\u381c\u3823\u3834\u3851\u385d\u386b\u38a9\u38cc\u38d2\u38ea\u38f6r\xf2\u03edar;\u6963\u0100cr\u37dc\u37e2ute\u803b\xfa\u40fa\xf2\u1150r\u01e3\u37ea\0\u37edy;\u445eve;\u416d\u0100iy\u37f5\u37farc\u803b\xfb\u40fb;\u4443\u0180abh\u3803\u3806\u380br\xf2\u13adlac;\u4171a\xf2\u13c3\u0100ir\u3813\u3818sht;\u697e;\uc000\ud835\udd32rave\u803b\xf9\u40f9\u0161\u3827\u3831r\u0100lr\u382c\u382e\xbb\u0957\xbb\u1083lk;\u6580\u0100ct\u3839\u384d\u026f\u383f\0\0\u384arn\u0100;e\u3845\u3846\u631cr\xbb\u3846op;\u630fri;\u65f8\u0100al\u3856\u385acr;\u416b\u80bb\xa8\u0349\u0100gp\u3862\u3866on;\u4173f;\uc000\ud835\udd66\u0300adhlsu\u114b\u3878\u387d\u1372\u3891\u38a0own\xe1\u13b3arpoon\u0100lr\u3888\u388cef\xf4\u382digh\xf4\u382fi\u0180;hl\u3899\u389a\u389c\u43c5\xbb\u13faon\xbb\u389aparrows;\u61c8\u0180cit\u38b0\u38c4\u38c8\u026f\u38b6\0\0\u38c1rn\u0100;e\u38bc\u38bd\u631dr\xbb\u38bdop;\u630eng;\u416fri;\u65f9cr;\uc000\ud835\udcca\u0180dir\u38d9\u38dd\u38e2ot;\u62f0lde;\u4169i\u0100;f\u3730\u38e8\xbb\u1813\u0100am\u38ef\u38f2r\xf2\u38a8l\u803b\xfc\u40fcangle;\u69a7\u0780ABDacdeflnoprsz\u391c\u391f\u3929\u392d\u39b5\u39b8\u39bd\u39df\u39e4\u39e8\u39f3\u39f9\u39fd\u3a01\u3a20r\xf2\u03f7ar\u0100;v\u3926\u3927\u6ae8;\u6ae9as\xe8\u03e1\u0100nr\u3932\u3937grt;\u699c\u0380eknprst\u34e3\u3946\u394b\u3952\u395d\u3964\u3996app\xe1\u2415othin\xe7\u1e96\u0180hir\u34eb\u2ec8\u3959op\xf4\u2fb5\u0100;h\u13b7\u3962\xef\u318d\u0100iu\u3969\u396dgm\xe1\u33b3\u0100bp\u3972\u3984setneq\u0100;q\u397d\u3980\uc000\u228a\ufe00;\uc000\u2acb\ufe00setneq\u0100;q\u398f\u3992\uc000\u228b\ufe00;\uc000\u2acc\ufe00\u0100hr\u399b\u399fet\xe1\u369ciangle\u0100lr\u39aa\u39afeft\xbb\u0925ight\xbb\u1051y;\u4432ash\xbb\u1036\u0180elr\u39c4\u39d2\u39d7\u0180;be\u2dea\u39cb\u39cfar;\u62bbq;\u625alip;\u62ee\u0100bt\u39dc\u1468a\xf2\u1469r;\uc000\ud835\udd33tr\xe9\u39aesu\u0100bp\u39ef\u39f1\xbb\u0d1c\xbb\u0d59pf;\uc000\ud835\udd67ro\xf0\u0efbtr\xe9\u39b4\u0100cu\u3a06\u3a0br;\uc000\ud835\udccb\u0100bp\u3a10\u3a18n\u0100Ee\u3980\u3a16\xbb\u397en\u0100Ee\u3992\u3a1e\xbb\u3990igzag;\u699a\u0380cefoprs\u3a36\u3a3b\u3a56\u3a5b\u3a54\u3a61\u3a6airc;\u4175\u0100di\u3a40\u3a51\u0100bg\u3a45\u3a49ar;\u6a5fe\u0100;q\u15fa\u3a4f;\u6259erp;\u6118r;\uc000\ud835\udd34pf;\uc000\ud835\udd68\u0100;e\u1479\u3a66at\xe8\u1479cr;\uc000\ud835\udccc\u0ae3\u178e\u3a87\0\u3a8b\0\u3a90\u3a9b\0\0\u3a9d\u3aa8\u3aab\u3aaf\0\0\u3ac3\u3ace\0\u3ad8\u17dc\u17dftr\xe9\u17d1r;\uc000\ud835\udd35\u0100Aa\u3a94\u3a97r\xf2\u03c3r\xf2\u09f6;\u43be\u0100Aa\u3aa1\u3aa4r\xf2\u03b8r\xf2\u09eba\xf0\u2713is;\u62fb\u0180dpt\u17a4\u3ab5\u3abe\u0100fl\u3aba\u17a9;\uc000\ud835\udd69im\xe5\u17b2\u0100Aa\u3ac7\u3acar\xf2\u03cer\xf2\u0a01\u0100cq\u3ad2\u17b8r;\uc000\ud835\udccd\u0100pt\u17d6\u3adcr\xe9\u17d4\u0400acefiosu\u3af0\u3afd\u3b08\u3b0c\u3b11\u3b15\u3b1b\u3b21c\u0100uy\u3af6\u3afbte\u803b\xfd\u40fd;\u444f\u0100iy\u3b02\u3b06rc;\u4177;\u444bn\u803b\xa5\u40a5r;\uc000\ud835\udd36cy;\u4457pf;\uc000\ud835\udd6acr;\uc000\ud835\udcce\u0100cm\u3b26\u3b29y;\u444el\u803b\xff\u40ff\u0500acdefhiosw\u3b42\u3b48\u3b54\u3b58\u3b64\u3b69\u3b6d\u3b74\u3b7a\u3b80cute;\u417a\u0100ay\u3b4d\u3b52ron;\u417e;\u4437ot;\u417c\u0100et\u3b5d\u3b61tr\xe6\u155fa;\u43b6r;\uc000\ud835\udd37cy;\u4436grarr;\u61ddpf;\uc000\ud835\udd6bcr;\uc000\ud835\udccf\u0100jn\u3b85\u3b87;\u600dj;\u600c"
    .split("")
    .map(function (c) { return c.charCodeAt(0); }));
//# sourceMappingURL=decode-data-html.js.map

/***/ }),

/***/ 7359:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Generated using scripts/write-decode-map.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = new Uint16Array(
// prettier-ignore
"\u0200aglq\t\x15\x18\x1b\u026d\x0f\0\0\x12p;\u4026os;\u4027t;\u403et;\u403cuot;\u4022"
    .split("")
    .map(function (c) { return c.charCodeAt(0); }));
//# sourceMappingURL=decode-data-xml.js.map

/***/ }),

/***/ 8180:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Generated using scripts/write-encode-map.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
function restoreDiff(arr) {
    for (var i = 1; i < arr.length; i++) {
        arr[i][0] += arr[i - 1][0] + 1;
    }
    return arr;
}
// prettier-ignore
exports["default"] = new Map(/* #__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* #__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* #__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* #__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
//# sourceMappingURL=encode-html.js.map

/***/ }),

/***/ 3000:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = exports.EncodingMode = exports.DecodingMode = exports.EntityLevel = void 0;
var decode_js_1 = __nccwpck_require__(5107);
var encode_js_1 = __nccwpck_require__(2006);
var escape_js_1 = __nccwpck_require__(7654);
/** The level of entities to support. */
var EntityLevel;
(function (EntityLevel) {
    /** Support only XML entities. */
    EntityLevel[EntityLevel["XML"] = 0] = "XML";
    /** Support HTML entities, which are a superset of XML entities. */
    EntityLevel[EntityLevel["HTML"] = 1] = "HTML";
})(EntityLevel = exports.EntityLevel || (exports.EntityLevel = {}));
/** Determines whether some entities are allowed to be written without a trailing `;`. */
var DecodingMode;
(function (DecodingMode) {
    /** Support legacy HTML entities. */
    DecodingMode[DecodingMode["Legacy"] = 0] = "Legacy";
    /** Do not support legacy HTML entities. */
    DecodingMode[DecodingMode["Strict"] = 1] = "Strict";
})(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));
var EncodingMode;
(function (EncodingMode) {
    /**
     * The output is UTF-8 encoded. Only characters that need escaping within
     * XML will be escaped.
     */
    EncodingMode[EncodingMode["UTF8"] = 0] = "UTF8";
    /**
     * The output consists only of ASCII characters. Characters that need
     * escaping within HTML, and characters that aren't ASCII characters will
     * be escaped.
     */
    EncodingMode[EncodingMode["ASCII"] = 1] = "ASCII";
    /**
     * Encode all characters that have an equivalent entity, as well as all
     * characters that are not ASCII characters.
     */
    EncodingMode[EncodingMode["Extensive"] = 2] = "Extensive";
    /**
     * Encode all characters that have to be escaped in HTML attributes,
     * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
     */
    EncodingMode[EncodingMode["Attribute"] = 3] = "Attribute";
    /**
     * Encode all characters that have to be escaped in HTML text,
     * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
     */
    EncodingMode[EncodingMode["Text"] = 4] = "Text";
})(EncodingMode = exports.EncodingMode || (exports.EncodingMode = {}));
/**
 * Decodes a string with entities.
 *
 * @param data String to decode.
 * @param options Decoding options.
 */
function decode(data, options) {
    if (options === void 0) { options = EntityLevel.XML; }
    var opts = typeof options === "number" ? { level: options } : options;
    if (opts.level === EntityLevel.HTML) {
        if (opts.mode === DecodingMode.Strict) {
            return (0, decode_js_1.decodeHTMLStrict)(data);
        }
        return (0, decode_js_1.decodeHTML)(data);
    }
    return (0, decode_js_1.decodeXML)(data);
}
exports.decode = decode;
/**
 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
 *
 * @param data String to decode.
 * @param options Decoding options.
 * @deprecated Use `decode` with the `mode` set to `Strict`.
 */
function decodeStrict(data, options) {
    if (options === void 0) { options = EntityLevel.XML; }
    var opts = typeof options === "number" ? { level: options } : options;
    if (opts.level === EntityLevel.HTML) {
        if (opts.mode === DecodingMode.Legacy) {
            return (0, decode_js_1.decodeHTML)(data);
        }
        return (0, decode_js_1.decodeHTMLStrict)(data);
    }
    return (0, decode_js_1.decodeXML)(data);
}
exports.decodeStrict = decodeStrict;
/**
 * Encodes a string with entities.
 *
 * @param data String to encode.
 * @param options Encoding options.
 */
function encode(data, options) {
    if (options === void 0) { options = EntityLevel.XML; }
    var opts = typeof options === "number" ? { level: options } : options;
    // Mode `UTF8` just escapes XML entities
    if (opts.mode === EncodingMode.UTF8)
        return (0, escape_js_1.escapeUTF8)(data);
    if (opts.mode === EncodingMode.Attribute)
        return (0, escape_js_1.escapeAttribute)(data);
    if (opts.mode === EncodingMode.Text)
        return (0, escape_js_1.escapeText)(data);
    if (opts.level === EntityLevel.HTML) {
        if (opts.mode === EncodingMode.ASCII) {
            return (0, encode_js_1.encodeNonAsciiHTML)(data);
        }
        return (0, encode_js_1.encodeHTML)(data);
    }
    // ASCII and Extensive are equivalent
    return (0, escape_js_1.encodeXML)(data);
}
exports.encode = encode;
var escape_js_2 = __nccwpck_require__(7654);
Object.defineProperty(exports, "encodeXML", ({ enumerable: true, get: function () { return escape_js_2.encodeXML; } }));
Object.defineProperty(exports, "escape", ({ enumerable: true, get: function () { return escape_js_2.escape; } }));
Object.defineProperty(exports, "escapeUTF8", ({ enumerable: true, get: function () { return escape_js_2.escapeUTF8; } }));
Object.defineProperty(exports, "escapeAttribute", ({ enumerable: true, get: function () { return escape_js_2.escapeAttribute; } }));
Object.defineProperty(exports, "escapeText", ({ enumerable: true, get: function () { return escape_js_2.escapeText; } }));
var encode_js_2 = __nccwpck_require__(2006);
Object.defineProperty(exports, "encodeHTML", ({ enumerable: true, get: function () { return encode_js_2.encodeHTML; } }));
Object.defineProperty(exports, "encodeNonAsciiHTML", ({ enumerable: true, get: function () { return encode_js_2.encodeNonAsciiHTML; } }));
// Legacy aliases (deprecated)
Object.defineProperty(exports, "encodeHTML4", ({ enumerable: true, get: function () { return encode_js_2.encodeHTML; } }));
Object.defineProperty(exports, "encodeHTML5", ({ enumerable: true, get: function () { return encode_js_2.encodeHTML; } }));
var decode_js_2 = __nccwpck_require__(5107);
Object.defineProperty(exports, "decodeXML", ({ enumerable: true, get: function () { return decode_js_2.decodeXML; } }));
Object.defineProperty(exports, "decodeHTML", ({ enumerable: true, get: function () { return decode_js_2.decodeHTML; } }));
Object.defineProperty(exports, "decodeHTMLStrict", ({ enumerable: true, get: function () { return decode_js_2.decodeHTMLStrict; } }));
// Legacy aliases (deprecated)
Object.defineProperty(exports, "decodeHTML4", ({ enumerable: true, get: function () { return decode_js_2.decodeHTML; } }));
Object.defineProperty(exports, "decodeHTML5", ({ enumerable: true, get: function () { return decode_js_2.decodeHTML; } }));
Object.defineProperty(exports, "decodeHTML4Strict", ({ enumerable: true, get: function () { return decode_js_2.decodeHTMLStrict; } }));
Object.defineProperty(exports, "decodeHTML5Strict", ({ enumerable: true, get: function () { return decode_js_2.decodeHTMLStrict; } }));
Object.defineProperty(exports, "decodeXMLStrict", ({ enumerable: true, get: function () { return decode_js_2.decodeXML; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 6863:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = realpath
realpath.realpath = realpath
realpath.sync = realpathSync
realpath.realpathSync = realpathSync
realpath.monkeypatch = monkeypatch
realpath.unmonkeypatch = unmonkeypatch

var fs = __nccwpck_require__(7147)
var origRealpath = fs.realpath
var origRealpathSync = fs.realpathSync

var version = process.version
var ok = /^v[0-5]\./.test(version)
var old = __nccwpck_require__(1734)

function newError (er) {
  return er && er.syscall === 'realpath' && (
    er.code === 'ELOOP' ||
    er.code === 'ENOMEM' ||
    er.code === 'ENAMETOOLONG'
  )
}

function realpath (p, cache, cb) {
  if (ok) {
    return origRealpath(p, cache, cb)
  }

  if (typeof cache === 'function') {
    cb = cache
    cache = null
  }
  origRealpath(p, cache, function (er, result) {
    if (newError(er)) {
      old.realpath(p, cache, cb)
    } else {
      cb(er, result)
    }
  })
}

function realpathSync (p, cache) {
  if (ok) {
    return origRealpathSync(p, cache)
  }

  try {
    return origRealpathSync(p, cache)
  } catch (er) {
    if (newError(er)) {
      return old.realpathSync(p, cache)
    } else {
      throw er
    }
  }
}

function monkeypatch () {
  fs.realpath = realpath
  fs.realpathSync = realpathSync
}

function unmonkeypatch () {
  fs.realpath = origRealpath
  fs.realpathSync = origRealpathSync
}


/***/ }),

/***/ 1734:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var pathModule = __nccwpck_require__(1017);
var isWindows = process.platform === 'win32';
var fs = __nccwpck_require__(7147);

// JavaScript implementation of realpath, ported from node pre-v6

var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);

function rethrow() {
  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
  // is fairly slow to generate.
  var callback;
  if (DEBUG) {
    var backtrace = new Error;
    callback = debugCallback;
  } else
    callback = missingCallback;

  return callback;

  function debugCallback(err) {
    if (err) {
      backtrace.message = err.message;
      err = backtrace;
      missingCallback(err);
    }
  }

  function missingCallback(err) {
    if (err) {
      if (process.throwDeprecation)
        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs
      else if (!process.noDeprecation) {
        var msg = 'fs: missing callback ' + (err.stack || err.message);
        if (process.traceDeprecation)
          console.trace(msg);
        else
          console.error(msg);
      }
    }
  }
}

function maybeCallback(cb) {
  return typeof cb === 'function' ? cb : rethrow();
}

var normalize = pathModule.normalize;

// Regexp that finds the next partion of a (partial) path
// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
if (isWindows) {
  var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
  var nextPartRe = /(.*?)(?:[\/]+|$)/g;
}

// Regex to find the device root, including trailing slash. E.g. 'c:\\'.
if (isWindows) {
  var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
  var splitRootRe = /^[\/]*/;
}

exports.realpathSync = function realpathSync(p, cache) {
  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return cache[p];
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstatSync(base);
      knownHard[base] = true;
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.
  while (pos < p.length) {
    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      continue;
    }

    var resolvedLink;
    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // some known symbolic link.  no need to stat again.
      resolvedLink = cache[base];
    } else {
      var stat = fs.lstatSync(base);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        continue;
      }

      // read the link if it wasn't read before
      // dev/ino always return 0 on windows, so skip the check.
      var linkTarget = null;
      if (!isWindows) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        fs.statSync(base);
        linkTarget = fs.readlinkSync(base);
      }
      resolvedLink = pathModule.resolve(previous, linkTarget);
      // track this, if given a cache.
      if (cache) cache[base] = resolvedLink;
      if (!isWindows) seenLinks[id] = linkTarget;
    }

    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache[original] = p;

  return p;
};


exports.realpath = function realpath(p, cache, cb) {
  if (typeof cb !== 'function') {
    cb = maybeCallback(cache);
    cache = null;
  }

  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return process.nextTick(cb.bind(null, null, cache[p]));
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstat(base, function(err) {
        if (err) return cb(err);
        knownHard[base] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  function LOOP() {
    // stop if scanned past end of path
    if (pos >= p.length) {
      if (cache) cache[original] = p;
      return cb(null, p);
    }

    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      return process.nextTick(LOOP);
    }

    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // known symbolic link.  no need to stat again.
      return gotResolvedLink(cache[base]);
    }

    return fs.lstat(base, gotStat);
  }

  function gotStat(err, stat) {
    if (err) return cb(err);

    // if not a symlink, skip to the next path part
    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      if (cache) cache[base] = base;
      return process.nextTick(LOOP);
    }

    // stat & read the link if not read before
    // call gotTarget as soon as the link target is known
    // dev/ino always return 0 on windows, so skip the check.
    if (!isWindows) {
      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }
    fs.stat(base, function(err) {
      if (err) return cb(err);

      fs.readlink(base, function(err, target) {
        if (!isWindows) seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  }

  function gotTarget(err, target, base) {
    if (err) return cb(err);

    var resolvedLink = pathModule.resolve(previous, target);
    if (cache) cache[base] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }

  function gotResolvedLink(resolvedLink) {
    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
};


/***/ }),

/***/ 7625:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

exports.alphasort = alphasort
exports.alphasorti = alphasorti
exports.setopts = setopts
exports.ownProp = ownProp
exports.makeAbs = makeAbs
exports.finish = finish
exports.mark = mark
exports.isIgnored = isIgnored
exports.childrenIgnored = childrenIgnored

function ownProp (obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field)
}

var path = __nccwpck_require__(1017)
var minimatch = __nccwpck_require__(3973)
var isAbsolute = __nccwpck_require__(8714)
var Minimatch = minimatch.Minimatch

function alphasorti (a, b) {
  return a.toLowerCase().localeCompare(b.toLowerCase())
}

function alphasort (a, b) {
  return a.localeCompare(b)
}

function setupIgnores (self, options) {
  self.ignore = options.ignore || []

  if (!Array.isArray(self.ignore))
    self.ignore = [self.ignore]

  if (self.ignore.length) {
    self.ignore = self.ignore.map(ignoreMap)
  }
}

// ignore patterns are always in dot:true mode.
function ignoreMap (pattern) {
  var gmatcher = null
  if (pattern.slice(-3) === '/**') {
    var gpattern = pattern.replace(/(\/\*\*)+$/, '')
    gmatcher = new Minimatch(gpattern, { dot: true })
  }

  return {
    matcher: new Minimatch(pattern, { dot: true }),
    gmatcher: gmatcher
  }
}

function setopts (self, pattern, options) {
  if (!options)
    options = {}

  // base-matching: just use globstar for that.
  if (options.matchBase && -1 === pattern.indexOf("/")) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar")
    }
    pattern = "**/" + pattern
  }

  self.silent = !!options.silent
  self.pattern = pattern
  self.strict = options.strict !== false
  self.realpath = !!options.realpath
  self.realpathCache = options.realpathCache || Object.create(null)
  self.follow = !!options.follow
  self.dot = !!options.dot
  self.mark = !!options.mark
  self.nodir = !!options.nodir
  if (self.nodir)
    self.mark = true
  self.sync = !!options.sync
  self.nounique = !!options.nounique
  self.nonull = !!options.nonull
  self.nosort = !!options.nosort
  self.nocase = !!options.nocase
  self.stat = !!options.stat
  self.noprocess = !!options.noprocess
  self.absolute = !!options.absolute

  self.maxLength = options.maxLength || Infinity
  self.cache = options.cache || Object.create(null)
  self.statCache = options.statCache || Object.create(null)
  self.symlinks = options.symlinks || Object.create(null)

  setupIgnores(self, options)

  self.changedCwd = false
  var cwd = process.cwd()
  if (!ownProp(options, "cwd"))
    self.cwd = cwd
  else {
    self.cwd = path.resolve(options.cwd)
    self.changedCwd = self.cwd !== cwd
  }

  self.root = options.root || path.resolve(self.cwd, "/")
  self.root = path.resolve(self.root)
  if (process.platform === "win32")
    self.root = self.root.replace(/\\/g, "/")

  // TODO: is an absolute `cwd` supposed to be resolved against `root`?
  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')
  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)
  if (process.platform === "win32")
    self.cwdAbs = self.cwdAbs.replace(/\\/g, "/")
  self.nomount = !!options.nomount

  // disable comments and negation in Minimatch.
  // Note that they are not supported in Glob itself anyway.
  options.nonegate = true
  options.nocomment = true

  self.minimatch = new Minimatch(pattern, options)
  self.options = self.minimatch.options
}

function finish (self) {
  var nou = self.nounique
  var all = nou ? [] : Object.create(null)

  for (var i = 0, l = self.matches.length; i < l; i ++) {
    var matches = self.matches[i]
    if (!matches || Object.keys(matches).length === 0) {
      if (self.nonull) {
        // do like the shell, and spit out the literal glob
        var literal = self.minimatch.globSet[i]
        if (nou)
          all.push(literal)
        else
          all[literal] = true
      }
    } else {
      // had matches
      var m = Object.keys(matches)
      if (nou)
        all.push.apply(all, m)
      else
        m.forEach(function (m) {
          all[m] = true
        })
    }
  }

  if (!nou)
    all = Object.keys(all)

  if (!self.nosort)
    all = all.sort(self.nocase ? alphasorti : alphasort)

  // at *some* point we statted all of these
  if (self.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self._mark(all[i])
    }
    if (self.nodir) {
      all = all.filter(function (e) {
        var notDir = !(/\/$/.test(e))
        var c = self.cache[e] || self.cache[makeAbs(self, e)]
        if (notDir && c)
          notDir = c !== 'DIR' && !Array.isArray(c)
        return notDir
      })
    }
  }

  if (self.ignore.length)
    all = all.filter(function(m) {
      return !isIgnored(self, m)
    })

  self.found = all
}

function mark (self, p) {
  var abs = makeAbs(self, p)
  var c = self.cache[abs]
  var m = p
  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c)
    var slash = p.slice(-1) === '/'

    if (isDir && !slash)
      m += '/'
    else if (!isDir && slash)
      m = m.slice(0, -1)

    if (m !== p) {
      var mabs = makeAbs(self, m)
      self.statCache[mabs] = self.statCache[abs]
      self.cache[mabs] = self.cache[abs]
    }
  }

  return m
}

// lotta situps...
function makeAbs (self, f) {
  var abs = f
  if (f.charAt(0) === '/') {
    abs = path.join(self.root, f)
  } else if (isAbsolute(f) || f === '') {
    abs = f
  } else if (self.changedCwd) {
    abs = path.resolve(self.cwd, f)
  } else {
    abs = path.resolve(f)
  }

  if (process.platform === 'win32')
    abs = abs.replace(/\\/g, '/')

  return abs
}


// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
function isIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
  })
}

function childrenIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path))
  })
}


/***/ }),

/***/ 1957:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

module.exports = glob

var fs = __nccwpck_require__(7147)
var rp = __nccwpck_require__(6863)
var minimatch = __nccwpck_require__(3973)
var Minimatch = minimatch.Minimatch
var inherits = __nccwpck_require__(4124)
var EE = (__nccwpck_require__(2361).EventEmitter)
var path = __nccwpck_require__(1017)
var assert = __nccwpck_require__(9491)
var isAbsolute = __nccwpck_require__(8714)
var globSync = __nccwpck_require__(9010)
var common = __nccwpck_require__(7625)
var alphasort = common.alphasort
var alphasorti = common.alphasorti
var setopts = common.setopts
var ownProp = common.ownProp
var inflight = __nccwpck_require__(2492)
var util = __nccwpck_require__(3837)
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

var once = __nccwpck_require__(1223)

function glob (pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {}
  if (!options) options = {}

  if (options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return globSync(pattern, options)
  }

  return new Glob(pattern, options, cb)
}

glob.sync = globSync
var GlobSync = glob.GlobSync = globSync.GlobSync

// old api surface
glob.glob = glob

function extend (origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin
  }

  var keys = Object.keys(add)
  var i = keys.length
  while (i--) {
    origin[keys[i]] = add[keys[i]]
  }
  return origin
}

glob.hasMagic = function (pattern, options_) {
  var options = extend({}, options_)
  options.noprocess = true

  var g = new Glob(pattern, options)
  var set = g.minimatch.set

  if (!pattern)
    return false

  if (set.length > 1)
    return true

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string')
      return true
  }

  return false
}

glob.Glob = Glob
inherits(Glob, EE)
function Glob (pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = null
  }

  if (options && options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return new GlobSync(pattern, options)
  }

  if (!(this instanceof Glob))
    return new Glob(pattern, options, cb)

  setopts(this, pattern, options)
  this._didRealPath = false

  // process each pattern in the minimatch set
  var n = this.minimatch.set.length

  // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.
  this.matches = new Array(n)

  if (typeof cb === 'function') {
    cb = once(cb)
    this.on('error', cb)
    this.on('end', function (matches) {
      cb(null, matches)
    })
  }

  var self = this
  this._processing = 0

  this._emitQueue = []
  this._processQueue = []
  this.paused = false

  if (this.noprocess)
    return this

  if (n === 0)
    return done()

  var sync = true
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false, done)
  }
  sync = false

  function done () {
    --self._processing
    if (self._processing <= 0) {
      if (sync) {
        process.nextTick(function () {
          self._finish()
        })
      } else {
        self._finish()
      }
    }
  }
}

Glob.prototype._finish = function () {
  assert(this instanceof Glob)
  if (this.aborted)
    return

  if (this.realpath && !this._didRealpath)
    return this._realpath()

  common.finish(this)
  this.emit('end', this.found)
}

Glob.prototype._realpath = function () {
  if (this._didRealpath)
    return

  this._didRealpath = true

  var n = this.matches.length
  if (n === 0)
    return this._finish()

  var self = this
  for (var i = 0; i < this.matches.length; i++)
    this._realpathSet(i, next)

  function next () {
    if (--n === 0)
      self._finish()
  }
}

Glob.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index]
  if (!matchset)
    return cb()

  var found = Object.keys(matchset)
  var self = this
  var n = found.length

  if (n === 0)
    return cb()

  var set = this.matches[index] = Object.create(null)
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p)
    rp.realpath(p, self.realpathCache, function (er, real) {
      if (!er)
        set[real] = true
      else if (er.syscall === 'stat')
        set[p] = true
      else
        self.emit('error', er) // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set
        cb()
      }
    })
  })
}

Glob.prototype._mark = function (p) {
  return common.mark(this, p)
}

Glob.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}

Glob.prototype.abort = function () {
  this.aborted = true
  this.emit('abort')
}

Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true
    this.emit('pause')
  }
}

Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume')
    this.paused = false
    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0)
      this._emitQueue.length = 0
      for (var i = 0; i < eq.length; i ++) {
        var e = eq[i]
        this._emitMatch(e[0], e[1])
      }
    }
    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0)
      this._processQueue.length = 0
      for (var i = 0; i < pq.length; i ++) {
        var p = pq[i]
        this._processing--
        this._process(p[0], p[1], p[2], p[3])
      }
    }
  }
}

Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  assert(this instanceof Glob)
  assert(typeof cb === 'function')

  if (this.aborted)
    return

  this._processing++
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb])
    return
  }

  //console.error('PROCESS %d', this._processing, pattern)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // see if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip _processing
  if (childrenIgnored(this, read))
    return cb()

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
}

Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}

Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return cb()

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return cb()

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return cb()
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix) {
      if (prefix !== '/')
        e = prefix + '/' + e
      else
        e = prefix + e
    }
    this._process([e].concat(remain), index, inGlobStar, cb)
  }
  cb()
}

Glob.prototype._emitMatch = function (index, e) {
  if (this.aborted)
    return

  if (isIgnored(this, e))
    return

  if (this.paused) {
    this._emitQueue.push([index, e])
    return
  }

  var abs = isAbsolute(e) ? e : this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute)
    e = abs

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  var st = this.statCache[abs]
  if (st)
    this.emit('stat', e, st)

  this.emit('match', e)
}

Glob.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted)
    return

  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false, cb)

  var lstatkey = 'lstat\0' + abs
  var self = this
  var lstatcb = inflight(lstatkey, lstatcb_)

  if (lstatcb)
    fs.lstat(abs, lstatcb)

  function lstatcb_ (er, lstat) {
    if (er && er.code === 'ENOENT')
      return cb()

    var isSym = lstat && lstat.isSymbolicLink()
    self.symlinks[abs] = isSym

    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && lstat && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE'
      cb()
    } else
      self._readdir(abs, false, cb)
  }
}

Glob.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted)
    return

  cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
  if (!cb)
    return

  //console.error('RD %j %j', +inGlobStar, abs)
  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs, cb)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return cb()

    if (Array.isArray(c))
      return cb(null, c)
  }

  var self = this
  fs.readdir(abs, readdirCb(this, abs, cb))
}

function readdirCb (self, abs, cb) {
  return function (er, entries) {
    if (er)
      self._readdirError(abs, er, cb)
    else
      self._readdirEntries(abs, entries, cb)
  }
}

Glob.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted)
    return

  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries
  return cb(null, entries)
}

Glob.prototype._readdirError = function (f, er, cb) {
  if (this.aborted)
    return

  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        this.emit('error', error)
        this.abort()
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict) {
        this.emit('error', er)
        // If the error is handled, then we abort
        // if not, we threw out of here
        this.abort()
      }
      if (!this.silent)
        console.error('glob error', er)
      break
  }

  return cb()
}

Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}


Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error('pgs2', prefix, remain[0], entries)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return cb()

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false, cb)

  var isSym = this.symlinks[abs]
  var len = entries.length

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return cb()

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true, cb)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true, cb)
  }

  cb()
}

Glob.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this
  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb)
  })
}
Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

  //console.error('ps2', prefix, exists)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return cb()

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
  cb()
}

// Returns either 'DIR', 'FILE', or false
Glob.prototype._stat = function (f, cb) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return cb()

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return cb(null, c)

    if (needDir && c === 'FILE')
      return cb()

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (stat !== undefined) {
    if (stat === false)
      return cb(null, stat)
    else {
      var type = stat.isDirectory() ? 'DIR' : 'FILE'
      if (needDir && type === 'FILE')
        return cb()
      else
        return cb(null, type, stat)
    }
  }

  var self = this
  var statcb = inflight('stat\0' + abs, lstatcb_)
  if (statcb)
    fs.lstat(abs, statcb)

  function lstatcb_ (er, lstat) {
    if (lstat && lstat.isSymbolicLink()) {
      // If it's a symlink, then treat it as the target, unless
      // the target does not exist, then treat it as a file.
      return fs.stat(abs, function (er, stat) {
        if (er)
          self._stat2(f, abs, null, lstat, cb)
        else
          self._stat2(f, abs, er, stat, cb)
      })
    } else {
      self._stat2(f, abs, er, lstat, cb)
    }
  }
}

Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
    this.statCache[abs] = false
    return cb()
  }

  var needDir = f.slice(-1) === '/'
  this.statCache[abs] = stat

  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())
    return cb(null, false, stat)

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'
  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return cb()

  return cb(null, c, stat)
}


/***/ }),

/***/ 9010:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = globSync
globSync.GlobSync = GlobSync

var fs = __nccwpck_require__(7147)
var rp = __nccwpck_require__(6863)
var minimatch = __nccwpck_require__(3973)
var Minimatch = minimatch.Minimatch
var Glob = (__nccwpck_require__(1957).Glob)
var util = __nccwpck_require__(3837)
var path = __nccwpck_require__(1017)
var assert = __nccwpck_require__(9491)
var isAbsolute = __nccwpck_require__(8714)
var common = __nccwpck_require__(7625)
var alphasort = common.alphasort
var alphasorti = common.alphasorti
var setopts = common.setopts
var ownProp = common.ownProp
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

function globSync (pattern, options) {
  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  return new GlobSync(pattern, options).found
}

function GlobSync (pattern, options) {
  if (!pattern)
    throw new Error('must provide pattern')

  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  if (!(this instanceof GlobSync))
    return new GlobSync(pattern, options)

  setopts(this, pattern, options)

  if (this.noprocess)
    return this

  var n = this.minimatch.set.length
  this.matches = new Array(n)
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false)
  }
  this._finish()
}

GlobSync.prototype._finish = function () {
  assert(this instanceof GlobSync)
  if (this.realpath) {
    var self = this
    this.matches.forEach(function (matchset, index) {
      var set = self.matches[index] = Object.create(null)
      for (var p in matchset) {
        try {
          p = self._makeAbs(p)
          var real = rp.realpathSync(p, self.realpathCache)
          set[real] = true
        } catch (er) {
          if (er.syscall === 'stat')
            set[self._makeAbs(p)] = true
          else
            throw er
        }
      }
    })
  }
  common.finish(this)
}


GlobSync.prototype._process = function (pattern, index, inGlobStar) {
  assert(this instanceof GlobSync)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // See if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip processing
  if (childrenIgnored(this, read))
    return

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
}


GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar)

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix.slice(-1) !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix)
      newPattern = [prefix, e]
    else
      newPattern = [e]
    this._process(newPattern.concat(remain), index, inGlobStar)
  }
}


GlobSync.prototype._emitMatch = function (index, e) {
  if (isIgnored(this, e))
    return

  var abs = this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute) {
    e = abs
  }

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  if (this.stat)
    this._stat(e)
}


GlobSync.prototype._readdirInGlobStar = function (abs) {
  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false)

  var entries
  var lstat
  var stat
  try {
    lstat = fs.lstatSync(abs)
  } catch (er) {
    if (er.code === 'ENOENT') {
      // lstat failed, doesn't exist
      return null
    }
  }

  var isSym = lstat && lstat.isSymbolicLink()
  this.symlinks[abs] = isSym

  // If it's not a symlink or a dir, then it's definitely a regular file.
  // don't bother doing a readdir in that case.
  if (!isSym && lstat && !lstat.isDirectory())
    this.cache[abs] = 'FILE'
  else
    entries = this._readdir(abs, false)

  return entries
}

GlobSync.prototype._readdir = function (abs, inGlobStar) {
  var entries

  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return null

    if (Array.isArray(c))
      return c
  }

  try {
    return this._readdirEntries(abs, fs.readdirSync(abs))
  } catch (er) {
    this._readdirError(abs, er)
    return null
  }
}

GlobSync.prototype._readdirEntries = function (abs, entries) {
  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries

  // mark and cache dir-ness
  return entries
}

GlobSync.prototype._readdirError = function (f, er) {
  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        throw error
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict)
        throw er
      if (!this.silent)
        console.error('glob error', er)
      break
  }
}

GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

  var entries = this._readdir(abs, inGlobStar)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false)

  var len = entries.length
  var isSym = this.symlinks[abs]

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true)
  }
}

GlobSync.prototype._processSimple = function (prefix, index) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var exists = this._stat(prefix)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
}

// Returns either 'DIR', 'FILE', or false
GlobSync.prototype._stat = function (f) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return false

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return c

    if (needDir && c === 'FILE')
      return false

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (!stat) {
    var lstat
    try {
      lstat = fs.lstatSync(abs)
    } catch (er) {
      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
        this.statCache[abs] = false
        return false
      }
    }

    if (lstat && lstat.isSymbolicLink()) {
      try {
        stat = fs.statSync(abs)
      } catch (er) {
        stat = lstat
      }
    } else {
      stat = lstat
    }
  }

  this.statCache[abs] = stat

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'

  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return false

  return c
}

GlobSync.prototype._mark = function (p) {
  return common.mark(this, p)
}

GlobSync.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}


/***/ }),

/***/ 8460:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Parser = void 0;
var Tokenizer_js_1 = __importStar(__nccwpck_require__(2689));
var decode_js_1 = __nccwpck_require__(5107);
var formTags = new Set([
    "input",
    "option",
    "optgroup",
    "select",
    "button",
    "datalist",
    "textarea",
]);
var pTag = new Set(["p"]);
var tableSectionTags = new Set(["thead", "tbody"]);
var ddtTags = new Set(["dd", "dt"]);
var rtpTags = new Set(["rt", "rp"]);
var openImpliesClose = new Map([
    ["tr", new Set(["tr", "th", "td"])],
    ["th", new Set(["th"])],
    ["td", new Set(["thead", "th", "td"])],
    ["body", new Set(["head", "link", "script"])],
    ["li", new Set(["li"])],
    ["p", pTag],
    ["h1", pTag],
    ["h2", pTag],
    ["h3", pTag],
    ["h4", pTag],
    ["h5", pTag],
    ["h6", pTag],
    ["select", formTags],
    ["input", formTags],
    ["output", formTags],
    ["button", formTags],
    ["datalist", formTags],
    ["textarea", formTags],
    ["option", new Set(["option"])],
    ["optgroup", new Set(["optgroup", "option"])],
    ["dd", ddtTags],
    ["dt", ddtTags],
    ["address", pTag],
    ["article", pTag],
    ["aside", pTag],
    ["blockquote", pTag],
    ["details", pTag],
    ["div", pTag],
    ["dl", pTag],
    ["fieldset", pTag],
    ["figcaption", pTag],
    ["figure", pTag],
    ["footer", pTag],
    ["form", pTag],
    ["header", pTag],
    ["hr", pTag],
    ["main", pTag],
    ["nav", pTag],
    ["ol", pTag],
    ["pre", pTag],
    ["section", pTag],
    ["table", pTag],
    ["ul", pTag],
    ["rt", rtpTags],
    ["rp", rtpTags],
    ["tbody", tableSectionTags],
    ["tfoot", tableSectionTags],
]);
var voidElements = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr",
]);
var foreignContextElements = new Set(["math", "svg"]);
var htmlIntegrationElements = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignobject",
    "desc",
    "title",
]);
var reNameEnd = /\s|\//;
var Parser = /** @class */ (function () {
    function Parser(cbs, options) {
        if (options === void 0) { options = {}; }
        var _a, _b, _c, _d, _e;
        this.options = options;
        /** The start index of the last event. */
        this.startIndex = 0;
        /** The end index of the last event. */
        this.endIndex = 0;
        /**
         * Store the start index of the current open tag,
         * so we can update the start index for attributes.
         */
        this.openTagStart = 0;
        this.tagname = "";
        this.attribname = "";
        this.attribvalue = "";
        this.attribs = null;
        this.stack = [];
        this.foreignContext = [];
        this.buffers = [];
        this.bufferOffset = 0;
        /** The index of the last written buffer. Used when resuming after a `pause()`. */
        this.writeIndex = 0;
        /** Indicates whether the parser has finished running / `.end` has been called. */
        this.ended = false;
        this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
        this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
        this.lowerCaseAttributeNames =
            (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
        this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_js_1.default)(this.options, this);
        (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
    }
    // Tokenizer event handlers
    /** @internal */
    Parser.prototype.ontext = function (start, endIndex) {
        var _a, _b;
        var data = this.getSlice(start, endIndex);
        this.endIndex = endIndex - 1;
        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
        this.startIndex = endIndex;
    };
    /** @internal */
    Parser.prototype.ontextentity = function (cp) {
        var _a, _b;
        /*
         * Entities can be emitted on the character, or directly after.
         * We use the section start here to get accurate indices.
         */
        var idx = this.tokenizer.getSectionStart();
        this.endIndex = idx - 1;
        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, (0, decode_js_1.fromCodePoint)(cp));
        this.startIndex = idx;
    };
    Parser.prototype.isVoidElement = function (name) {
        return !this.options.xmlMode && voidElements.has(name);
    };
    /** @internal */
    Parser.prototype.onopentagname = function (start, endIndex) {
        this.endIndex = endIndex;
        var name = this.getSlice(start, endIndex);
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        this.emitOpenTag(name);
    };
    Parser.prototype.emitOpenTag = function (name) {
        var _a, _b, _c, _d;
        this.openTagStart = this.startIndex;
        this.tagname = name;
        var impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
        if (impliesClose) {
            while (this.stack.length > 0 &&
                impliesClose.has(this.stack[this.stack.length - 1])) {
                var el = this.stack.pop();
                (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, el, true);
            }
        }
        if (!this.isVoidElement(name)) {
            this.stack.push(name);
            if (foreignContextElements.has(name)) {
                this.foreignContext.push(true);
            }
            else if (htmlIntegrationElements.has(name)) {
                this.foreignContext.push(false);
            }
        }
        (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
        if (this.cbs.onopentag)
            this.attribs = {};
    };
    Parser.prototype.endOpenTag = function (isImplied) {
        var _a, _b;
        this.startIndex = this.openTagStart;
        if (this.attribs) {
            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
            this.attribs = null;
        }
        if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
            this.cbs.onclosetag(this.tagname, true);
        }
        this.tagname = "";
    };
    /** @internal */
    Parser.prototype.onopentagend = function (endIndex) {
        this.endIndex = endIndex;
        this.endOpenTag(false);
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */
    Parser.prototype.onclosetag = function (start, endIndex) {
        var _a, _b, _c, _d, _e, _f;
        this.endIndex = endIndex;
        var name = this.getSlice(start, endIndex);
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        if (foreignContextElements.has(name) ||
            htmlIntegrationElements.has(name)) {
            this.foreignContext.pop();
        }
        if (!this.isVoidElement(name)) {
            var pos = this.stack.lastIndexOf(name);
            if (pos !== -1) {
                if (this.cbs.onclosetag) {
                    var count = this.stack.length - pos;
                    while (count--) {
                        // We know the stack has sufficient elements.
                        this.cbs.onclosetag(this.stack.pop(), count !== 0);
                    }
                }
                else
                    this.stack.length = pos;
            }
            else if (!this.options.xmlMode && name === "p") {
                // Implicit open before close
                this.emitOpenTag("p");
                this.closeCurrentTag(true);
            }
        }
        else if (!this.options.xmlMode && name === "br") {
            // We can't use `emitOpenTag` for implicit open, as `br` would be implicitly closed.
            (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, "br");
            (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
            (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
        }
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */
    Parser.prototype.onselfclosingtag = function (endIndex) {
        this.endIndex = endIndex;
        if (this.options.xmlMode ||
            this.options.recognizeSelfClosing ||
            this.foreignContext[this.foreignContext.length - 1]) {
            this.closeCurrentTag(false);
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        }
        else {
            // Ignore the fact that the tag is self-closing.
            this.onopentagend(endIndex);
        }
    };
    Parser.prototype.closeCurrentTag = function (isOpenImplied) {
        var _a, _b;
        var name = this.tagname;
        this.endOpenTag(isOpenImplied);
        // Self-closing tags will be on the top of the stack
        if (this.stack[this.stack.length - 1] === name) {
            // If the opening tag isn't implied, the closing tag has to be implied.
            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);
            this.stack.pop();
        }
    };
    /** @internal */
    Parser.prototype.onattribname = function (start, endIndex) {
        this.startIndex = start;
        var name = this.getSlice(start, endIndex);
        this.attribname = this.lowerCaseAttributeNames
            ? name.toLowerCase()
            : name;
    };
    /** @internal */
    Parser.prototype.onattribdata = function (start, endIndex) {
        this.attribvalue += this.getSlice(start, endIndex);
    };
    /** @internal */
    Parser.prototype.onattribentity = function (cp) {
        this.attribvalue += (0, decode_js_1.fromCodePoint)(cp);
    };
    /** @internal */
    Parser.prototype.onattribend = function (quote, endIndex) {
        var _a, _b;
        this.endIndex = endIndex;
        (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === Tokenizer_js_1.QuoteType.Double
            ? '"'
            : quote === Tokenizer_js_1.QuoteType.Single
                ? "'"
                : quote === Tokenizer_js_1.QuoteType.NoValue
                    ? undefined
                    : null);
        if (this.attribs &&
            !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
            this.attribs[this.attribname] = this.attribvalue;
        }
        this.attribvalue = "";
    };
    Parser.prototype.getInstructionName = function (value) {
        var idx = value.search(reNameEnd);
        var name = idx < 0 ? value : value.substr(0, idx);
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        return name;
    };
    /** @internal */
    Parser.prototype.ondeclaration = function (start, endIndex) {
        this.endIndex = endIndex;
        var value = this.getSlice(start, endIndex);
        if (this.cbs.onprocessinginstruction) {
            var name = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("!".concat(name), "!".concat(value));
        }
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */
    Parser.prototype.onprocessinginstruction = function (start, endIndex) {
        this.endIndex = endIndex;
        var value = this.getSlice(start, endIndex);
        if (this.cbs.onprocessinginstruction) {
            var name = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("?".concat(name), "?".concat(value));
        }
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */
    Parser.prototype.oncomment = function (start, endIndex, offset) {
        var _a, _b, _c, _d;
        this.endIndex = endIndex;
        (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));
        (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */
    Parser.prototype.oncdata = function (start, endIndex, offset) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        this.endIndex = endIndex;
        var value = this.getSlice(start, endIndex - offset);
        if (this.options.xmlMode || this.options.recognizeCDATA) {
            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
        }
        else {
            (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, "[CDATA[".concat(value, "]]"));
            (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
        }
        // Set `startIndex` for next node
        this.startIndex = endIndex + 1;
    };
    /** @internal */
    Parser.prototype.onend = function () {
        var _a, _b;
        if (this.cbs.onclosetag) {
            // Set the end index for all remaining tags
            this.endIndex = this.startIndex;
            for (var i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i], true))
                ;
        }
        (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    /**
     * Resets the parser to a blank state, ready to parse a new HTML document
     */
    Parser.prototype.reset = function () {
        var _a, _b, _c, _d;
        (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.tokenizer.reset();
        this.tagname = "";
        this.attribname = "";
        this.attribs = null;
        this.stack.length = 0;
        this.startIndex = 0;
        this.endIndex = 0;
        (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
        this.buffers.length = 0;
        this.bufferOffset = 0;
        this.writeIndex = 0;
        this.ended = false;
    };
    /**
     * Resets the parser, then parses a complete document and
     * pushes it to the handler.
     *
     * @param data Document to parse.
     */
    Parser.prototype.parseComplete = function (data) {
        this.reset();
        this.end(data);
    };
    Parser.prototype.getSlice = function (start, end) {
        while (start - this.bufferOffset >= this.buffers[0].length) {
            this.shiftBuffer();
        }
        var str = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
        while (end - this.bufferOffset > this.buffers[0].length) {
            this.shiftBuffer();
            str += this.buffers[0].slice(0, end - this.bufferOffset);
        }
        return str;
    };
    Parser.prototype.shiftBuffer = function () {
        this.bufferOffset += this.buffers[0].length;
        this.writeIndex--;
        this.buffers.shift();
    };
    /**
     * Parses a chunk of data and calls the corresponding callbacks.
     *
     * @param chunk Chunk to parse.
     */
    Parser.prototype.write = function (chunk) {
        var _a, _b;
        if (this.ended) {
            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".write() after done!"));
            return;
        }
        this.buffers.push(chunk);
        if (this.tokenizer.running) {
            this.tokenizer.write(chunk);
            this.writeIndex++;
        }
    };
    /**
     * Parses the end of the buffer and clears the stack, calls onend.
     *
     * @param chunk Optional final chunk to parse.
     */
    Parser.prototype.end = function (chunk) {
        var _a, _b;
        if (this.ended) {
            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, Error(".end() after done!"));
            return;
        }
        if (chunk)
            this.write(chunk);
        this.ended = true;
        this.tokenizer.end();
    };
    /**
     * Pauses parsing. The parser won't emit events until `resume` is called.
     */
    Parser.prototype.pause = function () {
        this.tokenizer.pause();
    };
    /**
     * Resumes parsing after `pause` was called.
     */
    Parser.prototype.resume = function () {
        this.tokenizer.resume();
        while (this.tokenizer.running &&
            this.writeIndex < this.buffers.length) {
            this.tokenizer.write(this.buffers[this.writeIndex++]);
        }
        if (this.ended)
            this.tokenizer.end();
    };
    /**
     * Alias of `write`, for backwards compatibility.
     *
     * @param chunk Chunk to parse.
     * @deprecated
     */
    Parser.prototype.parseChunk = function (chunk) {
        this.write(chunk);
    };
    /**
     * Alias of `end`, for backwards compatibility.
     *
     * @param chunk Optional final chunk to parse.
     * @deprecated
     */
    Parser.prototype.done = function (chunk) {
        this.end(chunk);
    };
    return Parser;
}());
exports.Parser = Parser;
//# sourceMappingURL=Parser.js.map

/***/ }),

/***/ 2689:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QuoteType = void 0;
var decode_js_1 = __nccwpck_require__(5107);
var CharCodes;
(function (CharCodes) {
    CharCodes[CharCodes["Tab"] = 9] = "Tab";
    CharCodes[CharCodes["NewLine"] = 10] = "NewLine";
    CharCodes[CharCodes["FormFeed"] = 12] = "FormFeed";
    CharCodes[CharCodes["CarriageReturn"] = 13] = "CarriageReturn";
    CharCodes[CharCodes["Space"] = 32] = "Space";
    CharCodes[CharCodes["ExclamationMark"] = 33] = "ExclamationMark";
    CharCodes[CharCodes["Num"] = 35] = "Num";
    CharCodes[CharCodes["Amp"] = 38] = "Amp";
    CharCodes[CharCodes["SingleQuote"] = 39] = "SingleQuote";
    CharCodes[CharCodes["DoubleQuote"] = 34] = "DoubleQuote";
    CharCodes[CharCodes["Dash"] = 45] = "Dash";
    CharCodes[CharCodes["Slash"] = 47] = "Slash";
    CharCodes[CharCodes["Zero"] = 48] = "Zero";
    CharCodes[CharCodes["Nine"] = 57] = "Nine";
    CharCodes[CharCodes["Semi"] = 59] = "Semi";
    CharCodes[CharCodes["Lt"] = 60] = "Lt";
    CharCodes[CharCodes["Eq"] = 61] = "Eq";
    CharCodes[CharCodes["Gt"] = 62] = "Gt";
    CharCodes[CharCodes["Questionmark"] = 63] = "Questionmark";
    CharCodes[CharCodes["UpperA"] = 65] = "UpperA";
    CharCodes[CharCodes["LowerA"] = 97] = "LowerA";
    CharCodes[CharCodes["UpperF"] = 70] = "UpperF";
    CharCodes[CharCodes["LowerF"] = 102] = "LowerF";
    CharCodes[CharCodes["UpperZ"] = 90] = "UpperZ";
    CharCodes[CharCodes["LowerZ"] = 122] = "LowerZ";
    CharCodes[CharCodes["LowerX"] = 120] = "LowerX";
    CharCodes[CharCodes["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes || (CharCodes = {}));
/** All the states the tokenizer can be in. */
var State;
(function (State) {
    State[State["Text"] = 1] = "Text";
    State[State["BeforeTagName"] = 2] = "BeforeTagName";
    State[State["InTagName"] = 3] = "InTagName";
    State[State["InSelfClosingTag"] = 4] = "InSelfClosingTag";
    State[State["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
    State[State["InClosingTagName"] = 6] = "InClosingTagName";
    State[State["AfterClosingTagName"] = 7] = "AfterClosingTagName";
    // Attributes
    State[State["BeforeAttributeName"] = 8] = "BeforeAttributeName";
    State[State["InAttributeName"] = 9] = "InAttributeName";
    State[State["AfterAttributeName"] = 10] = "AfterAttributeName";
    State[State["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
    State[State["InAttributeValueDq"] = 12] = "InAttributeValueDq";
    State[State["InAttributeValueSq"] = 13] = "InAttributeValueSq";
    State[State["InAttributeValueNq"] = 14] = "InAttributeValueNq";
    // Declarations
    State[State["BeforeDeclaration"] = 15] = "BeforeDeclaration";
    State[State["InDeclaration"] = 16] = "InDeclaration";
    // Processing instructions
    State[State["InProcessingInstruction"] = 17] = "InProcessingInstruction";
    // Comments & CDATA
    State[State["BeforeComment"] = 18] = "BeforeComment";
    State[State["CDATASequence"] = 19] = "CDATASequence";
    State[State["InSpecialComment"] = 20] = "InSpecialComment";
    State[State["InCommentLike"] = 21] = "InCommentLike";
    // Special tags
    State[State["BeforeSpecialS"] = 22] = "BeforeSpecialS";
    State[State["SpecialStartSequence"] = 23] = "SpecialStartSequence";
    State[State["InSpecialTag"] = 24] = "InSpecialTag";
    State[State["BeforeEntity"] = 25] = "BeforeEntity";
    State[State["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
    State[State["InNamedEntity"] = 27] = "InNamedEntity";
    State[State["InNumericEntity"] = 28] = "InNumericEntity";
    State[State["InHexEntity"] = 29] = "InHexEntity";
})(State || (State = {}));
function isWhitespace(c) {
    return (c === CharCodes.Space ||
        c === CharCodes.NewLine ||
        c === CharCodes.Tab ||
        c === CharCodes.FormFeed ||
        c === CharCodes.CarriageReturn);
}
function isEndOfTagSection(c) {
    return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);
}
function isNumber(c) {
    return c >= CharCodes.Zero && c <= CharCodes.Nine;
}
function isASCIIAlpha(c) {
    return ((c >= CharCodes.LowerA && c <= CharCodes.LowerZ) ||
        (c >= CharCodes.UpperA && c <= CharCodes.UpperZ));
}
function isHexDigit(c) {
    return ((c >= CharCodes.UpperA && c <= CharCodes.UpperF) ||
        (c >= CharCodes.LowerA && c <= CharCodes.LowerF));
}
var QuoteType;
(function (QuoteType) {
    QuoteType[QuoteType["NoValue"] = 0] = "NoValue";
    QuoteType[QuoteType["Unquoted"] = 1] = "Unquoted";
    QuoteType[QuoteType["Single"] = 2] = "Single";
    QuoteType[QuoteType["Double"] = 3] = "Double";
})(QuoteType = exports.QuoteType || (exports.QuoteType = {}));
/**
 * Sequences used to match longer strings.
 *
 * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End
 * sequences with an increased offset.
 */
var Sequences = {
    Cdata: new Uint8Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]),
    CdataEnd: new Uint8Array([0x5d, 0x5d, 0x3e]),
    CommentEnd: new Uint8Array([0x2d, 0x2d, 0x3e]),
    ScriptEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]),
    StyleEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]),
    TitleEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]), // `</title`
};
var Tokenizer = /** @class */ (function () {
    function Tokenizer(_a, cbs) {
        var _b = _a.xmlMode, xmlMode = _b === void 0 ? false : _b, _c = _a.decodeEntities, decodeEntities = _c === void 0 ? true : _c;
        this.cbs = cbs;
        /** The current state the tokenizer is in. */
        this.state = State.Text;
        /** The read buffer. */
        this.buffer = "";
        /** The beginning of the section that is currently being read. */
        this.sectionStart = 0;
        /** The index within the buffer that we are currently looking at. */
        this.index = 0;
        /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
        this.baseState = State.Text;
        /** For special parsing behavior inside of script and style tags. */
        this.isSpecial = false;
        /** Indicates whether the tokenizer has been paused. */
        this.running = true;
        /** The offset of the current buffer. */
        this.offset = 0;
        this.sequenceIndex = 0;
        this.trieIndex = 0;
        this.trieCurrent = 0;
        /** For named entities, the index of the value. For numeric entities, the code point. */
        this.entityResult = 0;
        this.entityExcess = 0;
        this.xmlMode = xmlMode;
        this.decodeEntities = decodeEntities;
        this.entityTrie = xmlMode ? decode_js_1.xmlDecodeTree : decode_js_1.htmlDecodeTree;
    }
    Tokenizer.prototype.reset = function () {
        this.state = State.Text;
        this.buffer = "";
        this.sectionStart = 0;
        this.index = 0;
        this.baseState = State.Text;
        this.currentSequence = undefined;
        this.running = true;
        this.offset = 0;
    };
    Tokenizer.prototype.write = function (chunk) {
        this.offset += this.buffer.length;
        this.buffer = chunk;
        this.parse();
    };
    Tokenizer.prototype.end = function () {
        if (this.running)
            this.finish();
    };
    Tokenizer.prototype.pause = function () {
        this.running = false;
    };
    Tokenizer.prototype.resume = function () {
        this.running = true;
        if (this.index < this.buffer.length + this.offset) {
            this.parse();
        }
    };
    /**
     * The current index within all of the written data.
     */
    Tokenizer.prototype.getIndex = function () {
        return this.index;
    };
    /**
     * The start of the current section.
     */
    Tokenizer.prototype.getSectionStart = function () {
        return this.sectionStart;
    };
    Tokenizer.prototype.stateText = function (c) {
        if (c === CharCodes.Lt ||
            (!this.decodeEntities && this.fastForwardTo(CharCodes.Lt))) {
            if (this.index > this.sectionStart) {
                this.cbs.ontext(this.sectionStart, this.index);
            }
            this.state = State.BeforeTagName;
            this.sectionStart = this.index;
        }
        else if (this.decodeEntities && c === CharCodes.Amp) {
            this.state = State.BeforeEntity;
        }
    };
    Tokenizer.prototype.stateSpecialStartSequence = function (c) {
        var isEnd = this.sequenceIndex === this.currentSequence.length;
        var isMatch = isEnd
            ? // If we are at the end of the sequence, make sure the tag name has ended
                isEndOfTagSection(c)
            : // Otherwise, do a case-insensitive comparison
                (c | 0x20) === this.currentSequence[this.sequenceIndex];
        if (!isMatch) {
            this.isSpecial = false;
        }
        else if (!isEnd) {
            this.sequenceIndex++;
            return;
        }
        this.sequenceIndex = 0;
        this.state = State.InTagName;
        this.stateInTagName(c);
    };
    /** Look for an end tag. For <title> tags, also decode entities. */
    Tokenizer.prototype.stateInSpecialTag = function (c) {
        if (this.sequenceIndex === this.currentSequence.length) {
            if (c === CharCodes.Gt || isWhitespace(c)) {
                var endOfText = this.index - this.currentSequence.length;
                if (this.sectionStart < endOfText) {
                    // Spoof the index so that reported locations match up.
                    var actualIndex = this.index;
                    this.index = endOfText;
                    this.cbs.ontext(this.sectionStart, endOfText);
                    this.index = actualIndex;
                }
                this.isSpecial = false;
                this.sectionStart = endOfText + 2; // Skip over the `</`
                this.stateInClosingTagName(c);
                return; // We are done; skip the rest of the function.
            }
            this.sequenceIndex = 0;
        }
        if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {
            this.sequenceIndex += 1;
        }
        else if (this.sequenceIndex === 0) {
            if (this.currentSequence === Sequences.TitleEnd) {
                // We have to parse entities in <title> tags.
                if (this.decodeEntities && c === CharCodes.Amp) {
                    this.state = State.BeforeEntity;
                }
            }
            else if (this.fastForwardTo(CharCodes.Lt)) {
                // Outside of <title> tags, we can fast-forward.
                this.sequenceIndex = 1;
            }
        }
        else {
            // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.
            this.sequenceIndex = Number(c === CharCodes.Lt);
        }
    };
    Tokenizer.prototype.stateCDATASequence = function (c) {
        if (c === Sequences.Cdata[this.sequenceIndex]) {
            if (++this.sequenceIndex === Sequences.Cdata.length) {
                this.state = State.InCommentLike;
                this.currentSequence = Sequences.CdataEnd;
                this.sequenceIndex = 0;
                this.sectionStart = this.index + 1;
            }
        }
        else {
            this.sequenceIndex = 0;
            this.state = State.InDeclaration;
            this.stateInDeclaration(c); // Reconsume the character
        }
    };
    /**
     * When we wait for one specific character, we can speed things up
     * by skipping through the buffer until we find it.
     *
     * @returns Whether the character was found.
     */
    Tokenizer.prototype.fastForwardTo = function (c) {
        while (++this.index < this.buffer.length + this.offset) {
            if (this.buffer.charCodeAt(this.index - this.offset) === c) {
                return true;
            }
        }
        /*
         * We increment the index at the end of the `parse` loop,
         * so set it to `buffer.length - 1` here.
         *
         * TODO: Refactor `parse` to increment index before calling states.
         */
        this.index = this.buffer.length + this.offset - 1;
        return false;
    };
    /**
     * Comments and CDATA end with `-->` and `]]>`.
     *
     * Their common qualities are:
     * - Their end sequences have a distinct character they start with.
     * - That character is then repeated, so we have to check multiple repeats.
     * - All characters but the start character of the sequence can be skipped.
     */
    Tokenizer.prototype.stateInCommentLike = function (c) {
        if (c === this.currentSequence[this.sequenceIndex]) {
            if (++this.sequenceIndex === this.currentSequence.length) {
                if (this.currentSequence === Sequences.CdataEnd) {
                    this.cbs.oncdata(this.sectionStart, this.index, 2);
                }
                else {
                    this.cbs.oncomment(this.sectionStart, this.index, 2);
                }
                this.sequenceIndex = 0;
                this.sectionStart = this.index + 1;
                this.state = State.Text;
            }
        }
        else if (this.sequenceIndex === 0) {
            // Fast-forward to the first character of the sequence
            if (this.fastForwardTo(this.currentSequence[0])) {
                this.sequenceIndex = 1;
            }
        }
        else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
            // Allow long sequences, eg. --->, ]]]>
            this.sequenceIndex = 0;
        }
    };
    /**
     * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
     *
     * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
     * We allow anything that wouldn't end the tag.
     */
    Tokenizer.prototype.isTagStartChar = function (c) {
        return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
    };
    Tokenizer.prototype.startSpecial = function (sequence, offset) {
        this.isSpecial = true;
        this.currentSequence = sequence;
        this.sequenceIndex = offset;
        this.state = State.SpecialStartSequence;
    };
    Tokenizer.prototype.stateBeforeTagName = function (c) {
        if (c === CharCodes.ExclamationMark) {
            this.state = State.BeforeDeclaration;
            this.sectionStart = this.index + 1;
        }
        else if (c === CharCodes.Questionmark) {
            this.state = State.InProcessingInstruction;
            this.sectionStart = this.index + 1;
        }
        else if (this.isTagStartChar(c)) {
            var lower = c | 0x20;
            this.sectionStart = this.index;
            if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
                this.startSpecial(Sequences.TitleEnd, 3);
            }
            else {
                this.state =
                    !this.xmlMode && lower === Sequences.ScriptEnd[2]
                        ? State.BeforeSpecialS
                        : State.InTagName;
            }
        }
        else if (c === CharCodes.Slash) {
            this.state = State.BeforeClosingTagName;
        }
        else {
            this.state = State.Text;
            this.stateText(c);
        }
    };
    Tokenizer.prototype.stateInTagName = function (c) {
        if (isEndOfTagSection(c)) {
            this.cbs.onopentagname(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
        }
    };
    Tokenizer.prototype.stateBeforeClosingTagName = function (c) {
        if (isWhitespace(c)) {
            // Ignore
        }
        else if (c === CharCodes.Gt) {
            this.state = State.Text;
        }
        else {
            this.state = this.isTagStartChar(c)
                ? State.InClosingTagName
                : State.InSpecialComment;
            this.sectionStart = this.index;
        }
    };
    Tokenizer.prototype.stateInClosingTagName = function (c) {
        if (c === CharCodes.Gt || isWhitespace(c)) {
            this.cbs.onclosetag(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State.AfterClosingTagName;
            this.stateAfterClosingTagName(c);
        }
    };
    Tokenizer.prototype.stateAfterClosingTagName = function (c) {
        // Skip everything until ">"
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.state = State.Text;
            this.sectionStart = this.index + 1;
        }
    };
    Tokenizer.prototype.stateBeforeAttributeName = function (c) {
        if (c === CharCodes.Gt) {
            this.cbs.onopentagend(this.index);
            if (this.isSpecial) {
                this.state = State.InSpecialTag;
                this.sequenceIndex = 0;
            }
            else {
                this.state = State.Text;
            }
            this.baseState = this.state;
            this.sectionStart = this.index + 1;
        }
        else if (c === CharCodes.Slash) {
            this.state = State.InSelfClosingTag;
        }
        else if (!isWhitespace(c)) {
            this.state = State.InAttributeName;
            this.sectionStart = this.index;
        }
    };
    Tokenizer.prototype.stateInSelfClosingTag = function (c) {
        if (c === CharCodes.Gt) {
            this.cbs.onselfclosingtag(this.index);
            this.state = State.Text;
            this.baseState = State.Text;
            this.sectionStart = this.index + 1;
            this.isSpecial = false; // Reset special state, in case of self-closing special tags
        }
        else if (!isWhitespace(c)) {
            this.state = State.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
        }
    };
    Tokenizer.prototype.stateInAttributeName = function (c) {
        if (c === CharCodes.Eq || isEndOfTagSection(c)) {
            this.cbs.onattribname(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State.AfterAttributeName;
            this.stateAfterAttributeName(c);
        }
    };
    Tokenizer.prototype.stateAfterAttributeName = function (c) {
        if (c === CharCodes.Eq) {
            this.state = State.BeforeAttributeValue;
        }
        else if (c === CharCodes.Slash || c === CharCodes.Gt) {
            this.cbs.onattribend(QuoteType.NoValue, this.index);
            this.state = State.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
        }
        else if (!isWhitespace(c)) {
            this.cbs.onattribend(QuoteType.NoValue, this.index);
            this.state = State.InAttributeName;
            this.sectionStart = this.index;
        }
    };
    Tokenizer.prototype.stateBeforeAttributeValue = function (c) {
        if (c === CharCodes.DoubleQuote) {
            this.state = State.InAttributeValueDq;
            this.sectionStart = this.index + 1;
        }
        else if (c === CharCodes.SingleQuote) {
            this.state = State.InAttributeValueSq;
            this.sectionStart = this.index + 1;
        }
        else if (!isWhitespace(c)) {
            this.sectionStart = this.index;
            this.state = State.InAttributeValueNq;
            this.stateInAttributeValueNoQuotes(c); // Reconsume token
        }
    };
    Tokenizer.prototype.handleInAttributeValue = function (c, quote) {
        if (c === quote ||
            (!this.decodeEntities && this.fastForwardTo(quote))) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.cbs.onattribend(quote === CharCodes.DoubleQuote
                ? QuoteType.Double
                : QuoteType.Single, this.index);
            this.state = State.BeforeAttributeName;
        }
        else if (this.decodeEntities && c === CharCodes.Amp) {
            this.baseState = this.state;
            this.state = State.BeforeEntity;
        }
    };
    Tokenizer.prototype.stateInAttributeValueDoubleQuotes = function (c) {
        this.handleInAttributeValue(c, CharCodes.DoubleQuote);
    };
    Tokenizer.prototype.stateInAttributeValueSingleQuotes = function (c) {
        this.handleInAttributeValue(c, CharCodes.SingleQuote);
    };
    Tokenizer.prototype.stateInAttributeValueNoQuotes = function (c) {
        if (isWhitespace(c) || c === CharCodes.Gt) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.cbs.onattribend(QuoteType.Unquoted, this.index);
            this.state = State.BeforeAttributeName;
            this.stateBeforeAttributeName(c);
        }
        else if (this.decodeEntities && c === CharCodes.Amp) {
            this.baseState = this.state;
            this.state = State.BeforeEntity;
        }
    };
    Tokenizer.prototype.stateBeforeDeclaration = function (c) {
        if (c === CharCodes.OpeningSquareBracket) {
            this.state = State.CDATASequence;
            this.sequenceIndex = 0;
        }
        else {
            this.state =
                c === CharCodes.Dash
                    ? State.BeforeComment
                    : State.InDeclaration;
        }
    };
    Tokenizer.prototype.stateInDeclaration = function (c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.ondeclaration(this.sectionStart, this.index);
            this.state = State.Text;
            this.sectionStart = this.index + 1;
        }
    };
    Tokenizer.prototype.stateInProcessingInstruction = function (c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.onprocessinginstruction(this.sectionStart, this.index);
            this.state = State.Text;
            this.sectionStart = this.index + 1;
        }
    };
    Tokenizer.prototype.stateBeforeComment = function (c) {
        if (c === CharCodes.Dash) {
            this.state = State.InCommentLike;
            this.currentSequence = Sequences.CommentEnd;
            // Allow short comments (eg. <!-->)
            this.sequenceIndex = 2;
            this.sectionStart = this.index + 1;
        }
        else {
            this.state = State.InDeclaration;
        }
    };
    Tokenizer.prototype.stateInSpecialComment = function (c) {
        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.oncomment(this.sectionStart, this.index, 0);
            this.state = State.Text;
            this.sectionStart = this.index + 1;
        }
    };
    Tokenizer.prototype.stateBeforeSpecialS = function (c) {
        var lower = c | 0x20;
        if (lower === Sequences.ScriptEnd[3]) {
            this.startSpecial(Sequences.ScriptEnd, 4);
        }
        else if (lower === Sequences.StyleEnd[3]) {
            this.startSpecial(Sequences.StyleEnd, 4);
        }
        else {
            this.state = State.InTagName;
            this.stateInTagName(c); // Consume the token again
        }
    };
    Tokenizer.prototype.stateBeforeEntity = function (c) {
        // Start excess with 1 to include the '&'
        this.entityExcess = 1;
        this.entityResult = 0;
        if (c === CharCodes.Num) {
            this.state = State.BeforeNumericEntity;
        }
        else if (c === CharCodes.Amp) {
            // We have two `&` characters in a row. Stay in the current state.
        }
        else {
            this.trieIndex = 0;
            this.trieCurrent = this.entityTrie[0];
            this.state = State.InNamedEntity;
            this.stateInNamedEntity(c);
        }
    };
    Tokenizer.prototype.stateInNamedEntity = function (c) {
        this.entityExcess += 1;
        this.trieIndex = (0, decode_js_1.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
        if (this.trieIndex < 0) {
            this.emitNamedEntity();
            this.index--;
            return;
        }
        this.trieCurrent = this.entityTrie[this.trieIndex];
        var masked = this.trieCurrent & decode_js_1.BinTrieFlags.VALUE_LENGTH;
        // If the branch is a value, store it and continue
        if (masked) {
            // The mask is the number of bytes of the value, including the current byte.
            var valueLength = (masked >> 14) - 1;
            // If we have a legacy entity while parsing strictly, just skip the number of bytes
            if (!this.allowLegacyEntity() && c !== CharCodes.Semi) {
                this.trieIndex += valueLength;
            }
            else {
                // Add 1 as we have already incremented the excess
                var entityStart = this.index - this.entityExcess + 1;
                if (entityStart > this.sectionStart) {
                    this.emitPartial(this.sectionStart, entityStart);
                }
                // If this is a surrogate pair, consume the next two bytes
                this.entityResult = this.trieIndex;
                this.trieIndex += valueLength;
                this.entityExcess = 0;
                this.sectionStart = this.index + 1;
                if (valueLength === 0) {
                    this.emitNamedEntity();
                }
            }
        }
    };
    Tokenizer.prototype.emitNamedEntity = function () {
        this.state = this.baseState;
        if (this.entityResult === 0) {
            return;
        }
        var valueLength = (this.entityTrie[this.entityResult] & decode_js_1.BinTrieFlags.VALUE_LENGTH) >>
            14;
        switch (valueLength) {
            case 1:
                this.emitCodePoint(this.entityTrie[this.entityResult] &
                    ~decode_js_1.BinTrieFlags.VALUE_LENGTH);
                break;
            case 2:
                this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                break;
            case 3: {
                this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
            }
        }
    };
    Tokenizer.prototype.stateBeforeNumericEntity = function (c) {
        if ((c | 0x20) === CharCodes.LowerX) {
            this.entityExcess++;
            this.state = State.InHexEntity;
        }
        else {
            this.state = State.InNumericEntity;
            this.stateInNumericEntity(c);
        }
    };
    Tokenizer.prototype.emitNumericEntity = function (strict) {
        var entityStart = this.index - this.entityExcess - 1;
        var numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
        if (numberStart !== this.index) {
            // Emit leading data if any
            if (entityStart > this.sectionStart) {
                this.emitPartial(this.sectionStart, entityStart);
            }
            this.sectionStart = this.index + Number(strict);
            this.emitCodePoint((0, decode_js_1.replaceCodePoint)(this.entityResult));
        }
        this.state = this.baseState;
    };
    Tokenizer.prototype.stateInNumericEntity = function (c) {
        if (c === CharCodes.Semi) {
            this.emitNumericEntity(true);
        }
        else if (isNumber(c)) {
            this.entityResult = this.entityResult * 10 + (c - CharCodes.Zero);
            this.entityExcess++;
        }
        else {
            if (this.allowLegacyEntity()) {
                this.emitNumericEntity(false);
            }
            else {
                this.state = this.baseState;
            }
            this.index--;
        }
    };
    Tokenizer.prototype.stateInHexEntity = function (c) {
        if (c === CharCodes.Semi) {
            this.emitNumericEntity(true);
        }
        else if (isNumber(c)) {
            this.entityResult = this.entityResult * 16 + (c - CharCodes.Zero);
            this.entityExcess++;
        }
        else if (isHexDigit(c)) {
            this.entityResult =
                this.entityResult * 16 + ((c | 0x20) - CharCodes.LowerA + 10);
            this.entityExcess++;
        }
        else {
            if (this.allowLegacyEntity()) {
                this.emitNumericEntity(false);
            }
            else {
                this.state = this.baseState;
            }
            this.index--;
        }
    };
    Tokenizer.prototype.allowLegacyEntity = function () {
        return (!this.xmlMode &&
            (this.baseState === State.Text ||
                this.baseState === State.InSpecialTag));
    };
    /**
     * Remove data that has already been consumed from the buffer.
     */
    Tokenizer.prototype.cleanup = function () {
        // If we are inside of text or attributes, emit what we already have.
        if (this.running && this.sectionStart !== this.index) {
            if (this.state === State.Text ||
                (this.state === State.InSpecialTag && this.sequenceIndex === 0)) {
                this.cbs.ontext(this.sectionStart, this.index);
                this.sectionStart = this.index;
            }
            else if (this.state === State.InAttributeValueDq ||
                this.state === State.InAttributeValueSq ||
                this.state === State.InAttributeValueNq) {
                this.cbs.onattribdata(this.sectionStart, this.index);
                this.sectionStart = this.index;
            }
        }
    };
    Tokenizer.prototype.shouldContinue = function () {
        return this.index < this.buffer.length + this.offset && this.running;
    };
    /**
     * Iterates through the buffer, calling the function corresponding to the current state.
     *
     * States that are more likely to be hit are higher up, as a performance improvement.
     */
    Tokenizer.prototype.parse = function () {
        while (this.shouldContinue()) {
            var c = this.buffer.charCodeAt(this.index - this.offset);
            if (this.state === State.Text) {
                this.stateText(c);
            }
            else if (this.state === State.SpecialStartSequence) {
                this.stateSpecialStartSequence(c);
            }
            else if (this.state === State.InSpecialTag) {
                this.stateInSpecialTag(c);
            }
            else if (this.state === State.CDATASequence) {
                this.stateCDATASequence(c);
            }
            else if (this.state === State.InAttributeValueDq) {
                this.stateInAttributeValueDoubleQuotes(c);
            }
            else if (this.state === State.InAttributeName) {
                this.stateInAttributeName(c);
            }
            else if (this.state === State.InCommentLike) {
                this.stateInCommentLike(c);
            }
            else if (this.state === State.InSpecialComment) {
                this.stateInSpecialComment(c);
            }
            else if (this.state === State.BeforeAttributeName) {
                this.stateBeforeAttributeName(c);
            }
            else if (this.state === State.InTagName) {
                this.stateInTagName(c);
            }
            else if (this.state === State.InClosingTagName) {
                this.stateInClosingTagName(c);
            }
            else if (this.state === State.BeforeTagName) {
                this.stateBeforeTagName(c);
            }
            else if (this.state === State.AfterAttributeName) {
                this.stateAfterAttributeName(c);
            }
            else if (this.state === State.InAttributeValueSq) {
                this.stateInAttributeValueSingleQuotes(c);
            }
            else if (this.state === State.BeforeAttributeValue) {
                this.stateBeforeAttributeValue(c);
            }
            else if (this.state === State.BeforeClosingTagName) {
                this.stateBeforeClosingTagName(c);
            }
            else if (this.state === State.AfterClosingTagName) {
                this.stateAfterClosingTagName(c);
            }
            else if (this.state === State.BeforeSpecialS) {
                this.stateBeforeSpecialS(c);
            }
            else if (this.state === State.InAttributeValueNq) {
                this.stateInAttributeValueNoQuotes(c);
            }
            else if (this.state === State.InSelfClosingTag) {
                this.stateInSelfClosingTag(c);
            }
            else if (this.state === State.InDeclaration) {
                this.stateInDeclaration(c);
            }
            else if (this.state === State.BeforeDeclaration) {
                this.stateBeforeDeclaration(c);
            }
            else if (this.state === State.BeforeComment) {
                this.stateBeforeComment(c);
            }
            else if (this.state === State.InProcessingInstruction) {
                this.stateInProcessingInstruction(c);
            }
            else if (this.state === State.InNamedEntity) {
                this.stateInNamedEntity(c);
            }
            else if (this.state === State.BeforeEntity) {
                this.stateBeforeEntity(c);
            }
            else if (this.state === State.InHexEntity) {
                this.stateInHexEntity(c);
            }
            else if (this.state === State.InNumericEntity) {
                this.stateInNumericEntity(c);
            }
            else {
                // `this._state === State.BeforeNumericEntity`
                this.stateBeforeNumericEntity(c);
            }
            this.index++;
        }
        this.cleanup();
    };
    Tokenizer.prototype.finish = function () {
        if (this.state === State.InNamedEntity) {
            this.emitNamedEntity();
        }
        // If there is remaining data, emit it in a reasonable way
        if (this.sectionStart < this.index) {
            this.handleTrailingData();
        }
        this.cbs.onend();
    };
    /** Handle any trailing data. */
    Tokenizer.prototype.handleTrailingData = function () {
        var endIndex = this.buffer.length + this.offset;
        if (this.state === State.InCommentLike) {
            if (this.currentSequence === Sequences.CdataEnd) {
                this.cbs.oncdata(this.sectionStart, endIndex, 0);
            }
            else {
                this.cbs.oncomment(this.sectionStart, endIndex, 0);
            }
        }
        else if (this.state === State.InNumericEntity &&
            this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
            // All trailing data will have been consumed
        }
        else if (this.state === State.InHexEntity &&
            this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
            // All trailing data will have been consumed
        }
        else if (this.state === State.InTagName ||
            this.state === State.BeforeAttributeName ||
            this.state === State.BeforeAttributeValue ||
            this.state === State.AfterAttributeName ||
            this.state === State.InAttributeName ||
            this.state === State.InAttributeValueSq ||
            this.state === State.InAttributeValueDq ||
            this.state === State.InAttributeValueNq ||
            this.state === State.InClosingTagName) {
            /*
             * If we are currently in an opening or closing tag, us not calling the
             * respective callback signals that the tag should be ignored.
             */
        }
        else {
            this.cbs.ontext(this.sectionStart, endIndex);
        }
    };
    Tokenizer.prototype.emitPartial = function (start, endIndex) {
        if (this.baseState !== State.Text &&
            this.baseState !== State.InSpecialTag) {
            this.cbs.onattribdata(start, endIndex);
        }
        else {
            this.cbs.ontext(start, endIndex);
        }
    };
    Tokenizer.prototype.emitCodePoint = function (cp) {
        if (this.baseState !== State.Text &&
            this.baseState !== State.InSpecialTag) {
            this.cbs.onattribentity(cp);
        }
        else {
            this.cbs.ontextentity(cp);
        }
    };
    return Tokenizer;
}());
exports["default"] = Tokenizer;
//# sourceMappingURL=Tokenizer.js.map

/***/ }),

/***/ 2928:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultHandler = exports.DomUtils = exports.parseFeed = exports.getFeed = exports.ElementType = exports.Tokenizer = exports.createDomStream = exports.parseDOM = exports.parseDocument = exports.DomHandler = exports.Parser = void 0;
var Parser_js_1 = __nccwpck_require__(8460);
Object.defineProperty(exports, "Parser", ({ enumerable: true, get: function () { return Parser_js_1.Parser; } }));
var domhandler_1 = __nccwpck_require__(4038);
Object.defineProperty(exports, "DomHandler", ({ enumerable: true, get: function () { return domhandler_1.DomHandler; } }));
Object.defineProperty(exports, "DefaultHandler", ({ enumerable: true, get: function () { return domhandler_1.DomHandler; } }));
// Helper methods
/**
 * Parses the data, returns the resulting document.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM builder.
 */
function parseDocument(data, options) {
    var handler = new domhandler_1.DomHandler(undefined, options);
    new Parser_js_1.Parser(handler, options).end(data);
    return handler.root;
}
exports.parseDocument = parseDocument;
/**
 * Parses data, returns an array of the root nodes.
 *
 * Note that the root nodes still have a `Document` node as their parent.
 * Use `parseDocument` to get the `Document` node instead.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM builder.
 * @deprecated Use `parseDocument` instead.
 */
function parseDOM(data, options) {
    return parseDocument(data, options).children;
}
exports.parseDOM = parseDOM;
/**
 * Creates a parser instance, with an attached DOM handler.
 *
 * @param cb A callback that will be called once parsing has been completed.
 * @param options Optional options for the parser and DOM builder.
 * @param elementCb An optional callback that will be called every time a tag has been completed inside of the DOM.
 */
function createDomStream(cb, options, elementCb) {
    var handler = new domhandler_1.DomHandler(cb, options, elementCb);
    return new Parser_js_1.Parser(handler, options);
}
exports.createDomStream = createDomStream;
var Tokenizer_js_1 = __nccwpck_require__(2689);
Object.defineProperty(exports, "Tokenizer", ({ enumerable: true, get: function () { return __importDefault(Tokenizer_js_1).default; } }));
/*
 * All of the following exports exist for backwards-compatibility.
 * They should probably be removed eventually.
 */
var ElementType = __importStar(__nccwpck_require__(3944));
exports.ElementType = ElementType;
var domutils_1 = __nccwpck_require__(1754);
Object.defineProperty(exports, "getFeed", ({ enumerable: true, get: function () { return domutils_1.getFeed; } }));
/**
 * Parse a feed.
 *
 * @param feed The feed that should be parsed, as a string.
 * @param options Optionally, options for parsing. When using this, you should set `xmlMode` to `true`.
 */
function parseFeed(feed, options) {
    if (options === void 0) { options = { xmlMode: true }; }
    return (0, domutils_1.getFeed)(parseDOM(feed, options));
}
exports.parseFeed = parseFeed;
exports.DomUtils = __importStar(__nccwpck_require__(1754));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 2492:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var wrappy = __nccwpck_require__(2940)
var reqs = Object.create(null)
var once = __nccwpck_require__(1223)

module.exports = wrappy(inflight)

function inflight (key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb)
    return null
  } else {
    reqs[key] = [cb]
    return makeres(key)
  }
}

function makeres (key) {
  return once(function RES () {
    var cbs = reqs[key]
    var len = cbs.length
    var args = slice(arguments)

    // XXX It's somewhat ambiguous whether a new callback added in this
    // pass should be queued for later execution if something in the
    // list of callbacks throws, or if it should just be discarded.
    // However, it's such an edge case that it hardly matters, and either
    // choice is likely as surprising as the other.
    // As it happens, we do go ahead and schedule it for later execution.
    try {
      for (var i = 0; i < len; i++) {
        cbs[i].apply(null, args)
      }
    } finally {
      if (cbs.length > len) {
        // added more in the interim.
        // de-zalgo, just in case, but don't call again.
        cbs.splice(0, len)
        process.nextTick(function () {
          RES.apply(null, args)
        })
      } else {
        delete reqs[key]
      }
    }
  })
}

function slice (args) {
  var length = args.length
  var array = []

  for (var i = 0; i < length; i++) array[i] = args[i]
  return array
}


/***/ }),

/***/ 4124:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

try {
  var util = __nccwpck_require__(3837);
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __nccwpck_require__(8544);
}


/***/ }),

/***/ 8544:
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ 3973:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = (function () { try { return __nccwpck_require__(1017) } catch (e) {}}()) || {
  sep: '/'
}
minimatch.sep = path.sep

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = __nccwpck_require__(3717)

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  b = b || {}
  var t = {}
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || typeof def !== 'object' || !Object.keys(def).length) {
    return minimatch
  }

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }
  m.Minimatch.defaults = function defaults (options) {
    return orig.defaults(ext(def, options)).Minimatch
  }

  m.filter = function filter (pattern, options) {
    return orig.filter(pattern, ext(def, options))
  }

  m.defaults = function defaults (options) {
    return orig.defaults(ext(def, options))
  }

  m.makeRe = function makeRe (pattern, options) {
    return orig.makeRe(pattern, ext(def, options))
  }

  m.braceExpand = function braceExpand (pattern, options) {
    return orig.braceExpand(pattern, ext(def, options))
  }

  m.match = function (list, pattern, options) {
    return orig.match(list, pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  assertValidPattern(pattern)

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  assertValidPattern(pattern)

  if (!options) options = {}

  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (!options.allowWindowsEscape && path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false
  this.partial = !!options.partial

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = function debug() { console.error.apply(console, arguments) }

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  assertValidPattern(pattern)

  // Thanks to Yeting Li <https://github.com/yetingli> for
  // improving this regexp to avoid a ReDOS vulnerability.
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

var MAX_PATTERN_LENGTH = 1024 * 64
var assertValidPattern = function (pattern) {
  if (typeof pattern !== 'string') {
    throw new TypeError('invalid pattern')
  }

  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError('pattern is too long')
  }
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  assertValidPattern(pattern)

  var options = this.options

  // shortcuts
  if (pattern === '**') {
    if (!options.noglobstar)
      return GLOBSTAR
    else
      pattern = '*'
  }
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      /* istanbul ignore next */
      case '/': {
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false
      }

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        // split where the last [ was, make sure we don't have
        // an invalid re. if so, re-walk the contents of the
        // would-be class to re-translate any characters that
        // were passed through as-is
        // TODO: It would probably be faster to determine this
        // without a try/catch and a new RegExp, but it's tricky
        // to do safely.  For now, this is safe and works.
        var cs = pattern.substring(classStart + 1, i)
        try {
          RegExp('[' + cs + ']')
        } catch (er) {
          // not a valid class!
          var sp = this.parse(cs, SUBPARSE)
          re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
          hasMagic = hasMagic || sp[1]
          inClass = false
          continue
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '[': case '.': case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) /* istanbul ignore next - should be impossible */ {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) /* istanbul ignore next - should be impossible */ {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = function match (f, partial) {
  if (typeof partial === 'undefined') partial = this.partial
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    /* istanbul ignore if */
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      /* istanbul ignore if */
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      hit = f === p
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else /* istanbul ignore else */ if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    return (fi === fl - 1) && (file[fi] === '')
  }

  // should be unreachable.
  /* istanbul ignore next */
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}


/***/ }),

/***/ 1223:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var wrappy = __nccwpck_require__(2940)
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),

/***/ 8714:
/***/ ((module) => {

"use strict";


function posix(path) {
	return path.charAt(0) === '/';
}

function win32(path) {
	// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	var result = splitDeviceRe.exec(path);
	var device = result[1] || '';
	var isUnc = Boolean(device && device.charAt(1) !== ':');

	// UNC paths are always absolute
	return Boolean(result[2] || isUnc);
}

module.exports = process.platform === 'win32' ? win32 : posix;
module.exports.posix = posix;
module.exports.win32 = win32;


/***/ }),

/***/ 4315:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

/**
 * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.
 *
 * This can be used with JS designed for browsers to improve reuse of code and
 * allow the use of existing libraries.
 *
 * Usage: include("XMLHttpRequest.js") and use XMLHttpRequest per W3C specs.
 *
 * @author Dan DeFelippi <dan@driverdan.com>
 * @contributor David Ellis <d.f.ellis@ieee.org>
 * @contributor Guillaume Grossetie <ggrossetie@yuzutech.fr>
 * @license MIT
 */
const Url = __nccwpck_require__(7310)
const fs = __nccwpck_require__(7147)
const path = __nccwpck_require__(1017)

exports.XMLHttpRequest = function () {
  'use strict'

  /**
   * Private variables
   */
  const self = this
  const http = __nccwpck_require__(3685)
  const https = __nccwpck_require__(5687)

  // Holds http.js objects
  let request
  let response

  // Request settings
  let settings = {}

  // Disable header blacklist.
  // Not part of XHR specs.
  let disableHeaderCheck = false

  // Set some default headers
  const defaultHeaders = {
    'User-Agent': 'node-XMLHttpRequest',
    'Accept': '*/*'
  }

  let headers = {}
  const headersCase = {}

  // These headers are not user setable.
  // The following are allowed but banned in the spec:
  // * user-agent
  const forbiddenRequestHeaders = [
    'accept-charset',
    'accept-encoding',
    'access-control-request-headers',
    'access-control-request-method',
    'connection',
    'content-length',
    'content-transfer-encoding',
    'cookie',
    'cookie2',
    'date',
    'expect',
    'host',
    'keep-alive',
    'origin',
    'referer',
    'te',
    'trailer',
    'transfer-encoding',
    'upgrade',
    'via'
  ]

  // These request methods are not allowed
  const forbiddenRequestMethods = [
    'TRACE',
    'TRACK',
    'CONNECT'
  ]

  // Send flag
  let sendFlag = false
  // Error flag, used when errors occur or abort is called
  let errorFlag = false

  // Event listeners
  const listeners = {}

  /**
   * Constants
   */

  this.UNSENT = 0
  this.OPENED = 1
  this.HEADERS_RECEIVED = 2
  this.LOADING = 3
  this.DONE = 4

  /**
   * Public vars
   */

  // Current state
  this.readyState = this.UNSENT

  // default ready state change handler in case one is not set or is set late
  this.onreadystatechange = null

  // Result & response
  this.responseText = ''
  this.responseXML = ''
  this.status = null
  this.statusText = null

  // Whether cross-site Access-Control requests should be made using
  // credentials such as cookies or authorization headers
  this.withCredentials = false
  // "text", "arraybuffer", "blob", or "document", depending on your data needs.
  // Note, setting xhr.responseType = '' (or omitting) will default the response to "text".
  this.responseType = ''

  /**
   * Private methods
   */

  /**
   * Check if the specified header is allowed.
   *
   * @param header - {string} Header to validate
   * @return {boolean} - False if not allowed, otherwise true
   */
  const isAllowedHttpHeader = function (header) {
    return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1)
  }

  /**
   * Check if the specified method is allowed.
   *
   * @param method - {string}  Request method to validate
   * @return {boolean} - False if not allowed, otherwise true
   */
  const isAllowedHttpMethod = function (method) {
    return (method && forbiddenRequestMethods.indexOf(method) === -1)
  }

  /**
   * Public methods
   */

  /**
   * Open the connection. Currently supports local server requests.
   *
   * @param method - {string} Connection method (eg GET, POST)
   * @param url - {string} URL for the connection.
   * @param async - {boolean} Asynchronous connection. Default is true.
   * @param user - {string} Username for basic authentication (optional)
   * @param password - {string} Password for basic authentication (optional)
   */
  this.open = function (method, url, async, user, password) {
    this.abort()
    errorFlag = false

    // Check for valid request method
    if (!isAllowedHttpMethod(method)) {
      throw new Error('SecurityError: Request method not allowed')
    }

    settings = {
      'method': method,
      'url': url.toString(),
      'async': (typeof async !== 'boolean' ? true : async),
      'user': user || null,
      'password': password || null
    }

    setState(this.OPENED)
  }

  /**
   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.
   * This does not conform to the W3C spec.
   *
   * @param state - {boolean} Enable or disable header checking.
   */
  this.setDisableHeaderCheck = function (state) {
    disableHeaderCheck = state
  }

  /**
   * Sets a header for the request or appends the value if one is already set.
   *
   * @param header - {string} Header name
   * @param value - {string} Header value
   */
  this.setRequestHeader = function (header, value) {
    if (this.readyState !== this.OPENED) {
      throw new Error('INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN')
    }
    if (!isAllowedHttpHeader(header)) {
      console.warn('Refused to set unsafe header "' + header + '"')
      return
    }
    if (sendFlag) {
      throw new Error('INVALID_STATE_ERR: send flag is true')
    }
    header = headersCase[header.toLowerCase()] || header
    headersCase[header.toLowerCase()] = header
    headers[header] = headers[header] ? headers[header] + ', ' + value : value
  }

  /**
   * Gets a header from the server response.
   *
   * @param header - {string} Name of header to get.
   * @return {Object} - Text of the header or null if it doesn't exist.
   */
  this.getResponseHeader = function (header) {
    if (typeof header === 'string' &&
      this.readyState > this.OPENED &&
      response &&
      response.headers &&
      response.headers[header.toLowerCase()] &&
      !errorFlag
    ) {
      return response.headers[header.toLowerCase()]
    }

    return null
  }

  /**
   * Gets all the response headers.
   *
   * @return string A string with all response headers separated by CR+LF
   */
  this.getAllResponseHeaders = function () {
    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {
      return ''
    }
    let result = ''

    for (let i in response.headers) {
      // Cookie headers are excluded
      if (i !== 'set-cookie' && i !== 'set-cookie2') {
        result += i + ': ' + response.headers[i] + '\r\n'
      }
    }
    return result.substr(0, result.length - 2)
  }

  /**
   * Gets a request header
   *
   * @param name - {string} Name of header to get
   * @return {string} Returns the request header or empty string if not set
   */
  this.getRequestHeader = function (name) {
    if (typeof name === 'string' && headersCase[name.toLowerCase()]) {
      return headers[headersCase[name.toLowerCase()]]
    }

    return ''
  }

  /**
   * Sends the request to the server.
   *
   * @param data - {string} Optional data to send as request body.
   */
  this.send = function (data) {
    if (this.readyState !== this.OPENED) {
      throw new Error('INVALID_STATE_ERR: connection must be opened before send() is called')
    }

    if (sendFlag) {
      throw new Error('INVALID_STATE_ERR: send has already been called')
    }
    let ssl = false
    let local = false
    const url = Url.parse(settings.url)
    let host
    // Determine the server
    switch (url.protocol) {
      case 'https:':
        ssl = true
        host = url.hostname
        break
      case 'http:':
        host = url.hostname
        break
      case 'file:':
        local = true
        break
      case undefined:
      case null:
      case '':
        host = 'localhost'
        break
      default:
        throw new Error('Protocol not supported.')
    }

    // Load files off the local filesystem (file://)
    if (local) {
      if (settings.method !== 'GET') {
        throw new Error('XMLHttpRequest: Only GET method is supported')
      }

      if (settings.async) {
        fs.readFile(url.pathname, 'utf8', function (error, data) {
          if (error) {
            self.handleError(error)
          } else {
            self.status = 200
            self.responseText = data
            setState(self.DONE)
          }
        })
      } else {
        try {
          this.responseText = fs.readFileSync(url.pathname, 'utf8')
          this.status = 200
          setState(self.DONE)
        } catch (e) {
          this.handleError(e)
        }
      }

      return
    }

    // Default to port 80. If accessing localhost on another port be sure
    // to use http://localhost:port/path
    const port = url.port || (ssl ? 443 : 80)
    // Add query string if one is used
    const uri = url.pathname + (url.search ? url.search : '')

    // Set the defaults if they haven't been set
    for (let name in defaultHeaders) {
      if (!headersCase[name.toLowerCase()]) {
        headers[name] = defaultHeaders[name]
      }
    }

    // Set the Host header or the server may reject the request
    headers.Host = host
    // IPv6 addresses must be escaped with brackets
    if (url.host[0] === '[') {
      headers.Host = '[' + headers.Host + ']'
    }
    if (!((ssl && port === 443) || port === 80)) {
      headers.Host += ':' + url.port
    }

    // Set Basic Auth if necessary
    if (settings.user) {
      if (typeof settings.password === 'undefined') {
        settings.password = ''
      }
      const authBuf = Buffer.from(settings.user + ':' + settings.password)
      headers.Authorization = 'Basic ' + authBuf.toString('base64')
    }

    // Set content length header
    if (settings.method === 'GET' || settings.method === 'HEAD') {
      data = null
    } else if (data) {
      headers['Content-Length'] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data)

      if (!this.getRequestHeader('Content-Type')) {
        headers['Content-Type'] = 'text/plain;charset=UTF-8'
      }
    } else if (settings.method === 'POST') {
      // For a post with no data set Content-Length: 0.
      // This is required by buggy servers that don't meet the specs.
      headers['Content-Length'] = 0
    }

    const options = {
      host: host,
      port: port,
      path: uri,
      method: settings.method,
      headers: headers,
      agent: false,
      withCredentials: self.withCredentials
    }

    const responseType = this.responseType || 'text'

    // Reset error flag
    errorFlag = false

    // Handle async requests
    if (settings.async) {
      // Use the proper protocol
      var doRequest = ssl ? https.request : http.request

      // Request is being sent, set send flag
      sendFlag = true

      // As per spec, this is called here for historical reasons.
      self.dispatchEvent('readystatechange')

      // Handler for the response
      const responseHandler = function responseHandler (resp) {
        // Set response var to the response we got back
        // This is so it remains accessable outside this scope
        response = resp
        // Check for redirect
        // @TODO Prevent looped redirects
        if (response.statusCode === 301 || response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {
          // Change URL to the redirect location
          settings.url = response.headers.location
          const url = Url.parse(settings.url)
          // Set host var in case it's used later
          host = url.hostname
          // Options for the new request
          const newOptions = {
            hostname: url.hostname,
            port: url.port,
            path: url.path,
            method: response.statusCode === 303 ? 'GET' : settings.method,
            headers: headers,
            withCredentials: self.withCredentials
          }

          // Issue the new request
          request = doRequest(newOptions, responseHandler).on('error', errorHandler)
          request.end()
          // @TODO Check if an XHR event needs to be fired here
          return
        }

        response.setEncoding('utf8')

        setState(self.HEADERS_RECEIVED)
        self.status = response.statusCode

        response.on('data', function (chunk) {
          // Make sure there's some data
          if (chunk) {
            self.responseText += chunk
          }
          // Don't emit state changes if the connection has been aborted.
          if (sendFlag) {
            setState(self.LOADING)
          }
        })

        response.on('end', function () {
          if (sendFlag) {
            // Discard the end event if the connection has been aborted
            setState(self.DONE)
            sendFlag = false
          }
        })

        response.on('error', function (error) {
          self.handleError(error)
        })
      }

      // Error handler for the request
      const errorHandler = function errorHandler (error) {
        self.handleError(error)
      }

      // Create the request
      request = doRequest(options, responseHandler).on('error', errorHandler)

      // Node 0.4 and later won't accept empty data. Make sure it's needed.
      if (data) {
        request.write(data)
      }

      request.end()

      self.dispatchEvent('loadstart')
    } else { // Synchronous
      const encoding = responseType === 'text' ? 'utf8' : 'binary'
      const output = (__nccwpck_require__(2081).execSync)(`"${process.argv[0]}" "${__dirname}/request.js" \
--ssl="${ssl}" \
--encoding="${encoding}" \
--request-options=${JSON.stringify(JSON.stringify(options))}`, { stdio: 'pipe' })
      const result = JSON.parse(output.toString('utf8'))
      if (result.error) {
        self.handleError(result.error)
      } else {
        response = result.data
        self.status = result.data.statusCode
        if (encoding === 'binary') {
          self.response = Uint8Array.from(result.data.binary.data).buffer
        } else {
          self.responseText = result.data.text
        }
        setState(self.DONE)
      }
    }
  }

  /**
   * Called when an error is encountered to deal with it.
   */
  this.handleError = function (error) {
    this.status = 0
    this.statusText = error
    this.responseText = error.stack
    errorFlag = true
    setState(this.DONE)
    this.dispatchEvent('error')
  }

  /**
   * Aborts a request.
   */
  this.abort = function () {
    if (request) {
      request.abort()
      request = null
    }

    headers = defaultHeaders
    this.status = 0
    this.responseText = ''
    this.responseXML = ''

    errorFlag = true

    if (this.readyState !== this.UNSENT &&
      (this.readyState !== this.OPENED || sendFlag) &&
      this.readyState !== this.DONE) {
      sendFlag = false
      setState(this.DONE)
    }
    this.readyState = this.UNSENT
    this.dispatchEvent('abort')
  }

  /**
   * Adds an event listener. Preferred method of binding to events.
   */
  this.addEventListener = function (event, callback) {
    if (!(event in listeners)) {
      listeners[event] = []
    }
    // Currently allows duplicate callbacks. Should it?
    listeners[event].push(callback)
  }

  /**
   * Remove an event callback that has already been bound.
   * Only works on the matching funciton, cannot be a copy.
   */
  this.removeEventListener = function (event, callback) {
    if (event in listeners) {
      // Filter will return a new array with the callback removed
      listeners[event] = listeners[event].filter(function (ev) {
        return ev !== callback
      })
    }
  }

  /**
   * Dispatch any events, including both "on" methods and events attached using addEventListener.
   */
  this.dispatchEvent = function (event) {
    if (typeof self['on' + event] === 'function') {
      self['on' + event]()
    }
    if (event in listeners) {
      for (let i = 0, len = listeners[event].length; i < len; i++) {
        listeners[event][i].call(self)
      }
    }
  }

  /**
   * Changes readyState and calls onreadystatechange.
   *
   * @param state - {Number} New state
   */
  const setState = function (state) {
    if (state === self.LOADING || self.readyState !== state) {
      self.readyState = state

      if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {
        self.dispatchEvent('readystatechange')
      }

      if (self.readyState === self.DONE && !errorFlag) {
        self.dispatchEvent('load')
        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)
        self.dispatchEvent('loadend')
      }
    }
  }
}


/***/ }),

/***/ 2940:
/***/ ((module) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),

/***/ 9491:
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ 2081:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ 2361:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 7147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 3685:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 5687:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 2037:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 1017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 7310:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 3837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 8656:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var domhandler = __nccwpck_require__(4038);
var selderee = __nccwpck_require__(5178);

function hp2Builder(nodes) {
    return new selderee.Picker(handleArray(nodes));
}
function handleArray(nodes) {
    const matchers = nodes.map(handleNode);
    return (el, ...tail) => matchers.flatMap(m => m(el, ...tail));
}
function handleNode(node) {
    switch (node.type) {
        case 'terminal': {
            const result = [node.valueContainer];
            return (el, ...tail) => result;
        }
        case 'tagName':
            return handleTagName(node);
        case 'attrValue':
            return handleAttrValueName(node);
        case 'attrPresence':
            return handleAttrPresenceName(node);
        case 'pushElement':
            return handlePushElementNode(node);
        case 'popElement':
            return handlePopElementNode(node);
    }
}
function handleTagName(node) {
    const variants = {};
    for (const variant of node.variants) {
        variants[variant.value] = handleArray(variant.cont);
    }
    return (el, ...tail) => {
        const continuation = variants[el.name];
        return (continuation) ? continuation(el, ...tail) : [];
    };
}
function handleAttrPresenceName(node) {
    const attrName = node.name;
    const continuation = handleArray(node.cont);
    return (el, ...tail) => (Object.prototype.hasOwnProperty.call(el.attribs, attrName))
        ? continuation(el, ...tail)
        : [];
}
function handleAttrValueName(node) {
    const callbacks = [];
    for (const matcher of node.matchers) {
        const predicate = matcher.predicate;
        const continuation = handleArray(matcher.cont);
        callbacks.push((attr, el, ...tail) => (predicate(attr) ? continuation(el, ...tail) : []));
    }
    const attrName = node.name;
    return (el, ...tail) => {
        const attr = el.attribs[attrName];
        return (attr || attr === '')
            ? callbacks.flatMap(cb => cb(attr, el, ...tail))
            : [];
    };
}
function handlePushElementNode(node) {
    const continuation = handleArray(node.cont);
    const leftElementGetter = (node.combinator === '+')
        ? getPrecedingElement
        : getParentElement;
    return (el, ...tail) => {
        const next = leftElementGetter(el);
        if (next === null) {
            return [];
        }
        return continuation(next, el, ...tail);
    };
}
const getPrecedingElement = (el) => {
    const prev = el.prev;
    if (prev === null) {
        return null;
    }
    return (domhandler.isTag(prev)) ? prev : getPrecedingElement(prev);
};
const getParentElement = (el) => {
    const parent = el.parent;
    return (parent && domhandler.isTag(parent)) ? parent : null;
};
function handlePopElementNode(node) {
    const continuation = handleArray(node.cont);
    return (el, next, ...tail) => continuation(next, ...tail);
}

exports.hp2Builder = hp2Builder;


/***/ }),

/***/ 3012:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({ value: true });

var pluginHtmlparser2 = __nccwpck_require__(8656);
var htmlparser2 = __nccwpck_require__(2928);
var selderee = __nccwpck_require__(5178);
var merge = __nccwpck_require__(6323);
var domSerializer = __nccwpck_require__(8621);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var merge__default = /*#__PURE__*/_interopDefaultLegacy(merge);

/**
 * Make a recursive function that will only run to a given depth
 * and switches to an alternative function at that depth. \
 * No limitation if `n` is `undefined` (Just wraps `f` in that case).
 *
 * @param   { number | undefined } n   Allowed depth of recursion. `undefined` for no limitation.
 * @param   { Function }           f   Function that accepts recursive callback as the first argument.
 * @param   { Function }           [g] Function to run instead, when maximum depth was reached. Do nothing by default.
 * @returns { Function }
 */
function limitedDepthRecursive (n, f, g = () => undefined) {
  if (n === undefined) {
    const f1 = function (...args) { return f(f1, ...args); };
    return f1;
  }
  if (n >= 0) {
    return function (...args) { return f(limitedDepthRecursive(n - 1, f, g), ...args); };
  }
  return g;
}

/**
 * Return the same string or a substring with
 * the given character occurrences removed from each side.
 *
 * @param   { string } str  A string to trim.
 * @param   { string } char A character to be trimmed.
 * @returns { string }
 */
function trimCharacter (str, char) {
  let start = 0;
  let end = str.length;
  while (start < end && str[start] === char) { ++start; }
  while (end > start && str[end - 1] === char) { --end; }
  return (start > 0 || end < str.length)
    ? str.substring(start, end)
    : str;
}

/**
 * Return the same string or a substring with
 * the given character occurrences removed from the end only.
 *
 * @param   { string } str  A string to trim.
 * @param   { string } char A character to be trimmed.
 * @returns { string }
 */
function trimCharacterEnd (str, char) {
  let end = str.length;
  while (end > 0 && str[end - 1] === char) { --end; }
  return (end < str.length)
    ? str.substring(0, end)
    : str;
}

/**
 * Return a new string will all characters replaced with unicode escape sequences.
 * This extreme kind of escaping can used to be safely compose regular expressions.
 *
 * @param { string } str A string to escape.
 * @returns { string } A string of unicode escape sequences.
 */
function unicodeEscape (str) {
  return str.replace(/[\s\S]/g, c => '\\u' + c.charCodeAt().toString(16).padStart(4, '0'));
}

/**
 * Deduplicate an array by a given key callback.
 * Item properties are merged recursively and with the preference for last defined values.
 * Of items with the same key, merged item takes the place of the last item,
 * others are omitted.
 *
 * @param { any[] } items An array to deduplicate.
 * @param { (x: any) => string } getKey Callback to get a value that distinguishes unique items.
 * @returns { any[] }
 */
function mergeDuplicatesPreferLast (items, getKey) {
  const map = new Map();
  for (let i = items.length; i-- > 0;) {
    const item = items[i];
    const key = getKey(item);
    map.set(
      key,
      (map.has(key))
        ? merge__default["default"](item, map.get(key), { arrayMerge: overwriteMerge$1 })
        : item
    );
  }
  return [...map.values()].reverse();
}

const overwriteMerge$1 = (acc, src, options) => [...src];

/**
 * Get a nested property from an object.
 *
 * @param   { object }   obj  The object to query for the value.
 * @param   { string[] } path The path to the property.
 * @returns { any }
 */
function get (obj, path) {
  for (const key of path) {
    if (!obj) { return undefined; }
    obj = obj[key];
  }
  return obj;
}

/**
 * Convert a number into alphabetic sequence representation (Sequence without zeroes).
 *
 * For example: `a, ..., z, aa, ..., zz, aaa, ...`.
 *
 * @param   { number } num              Number to convert. Must be >= 1.
 * @param   { string } [baseChar = 'a'] Character for 1 in the sequence.
 * @param   { number } [base = 26]      Number of characters in the sequence.
 * @returns { string }
 */
function numberToLetterSequence (num, baseChar = 'a', base = 26) {
  const digits = [];
  do {
    num -= 1;
    digits.push(num % base);
    num = (num / base) >> 0; // quick `floor`
  } while (num > 0);
  const baseCode = baseChar.charCodeAt(0);
  return digits
    .reverse()
    .map(n => String.fromCharCode(baseCode + n))
    .join('');
}

const I = ['I', 'X', 'C', 'M'];
const V = ['V', 'L', 'D'];

/**
 * Convert a number to it's Roman representation. No large numbers extension.
 *
 * @param   { number } num Number to convert. `0 < num <= 3999`.
 * @returns { string }
 */
function numberToRoman (num) {
  return [...(num) + '']
    .map(n => +n)
    .reverse()
    .map((v, i) => ((v % 5 < 4)
      ? (v < 5 ? '' : V[i]) + I[i].repeat(v % 5)
      : I[i] + (v < 5 ? V[i] : I[i + 1])))
    .reverse()
    .join('');
}

/**
 * Helps to build text from words.
 */
class InlineTextBuilder {
  /**
   * Creates an instance of InlineTextBuilder.
   *
   * If `maxLineLength` is not provided then it is either `options.wordwrap` or unlimited.
   *
   * @param { Options } options           HtmlToText options.
   * @param { number }  [ maxLineLength ] This builder will try to wrap text to fit this line length.
   */
  constructor (options, maxLineLength = undefined) {
    /** @type { string[][] } */
    this.lines = [];
    /** @type { string[] }   */
    this.nextLineWords = [];
    this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;
    this.nextLineAvailableChars = this.maxLineLength;
    this.wrapCharacters = get(options, ['longWordSplit', 'wrapCharacters']) || [];
    this.forceWrapOnLimit = get(options, ['longWordSplit', 'forceWrapOnLimit']) || false;

    this.stashedSpace = false;
    this.wordBreakOpportunity = false;
  }

  /**
   * Add a new word.
   *
   * @param { string } word A word to add.
   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.
   */
  pushWord (word, noWrap = false) {
    if (this.nextLineAvailableChars <= 0 && !noWrap) {
      this.startNewLine();
    }
    const isLineStart = this.nextLineWords.length === 0;
    const cost = word.length + (isLineStart ? 0 : 1);
    if ((cost <= this.nextLineAvailableChars) || noWrap) { // Fits into available budget

      this.nextLineWords.push(word);
      this.nextLineAvailableChars -= cost;

    } else { // Does not fit - try to split the word

      // The word is moved to a new line - prefer to wrap between words.
      const [first, ...rest] = this.splitLongWord(word);
      if (!isLineStart) { this.startNewLine(); }
      this.nextLineWords.push(first);
      this.nextLineAvailableChars -= first.length;
      for (const part of rest) {
        this.startNewLine();
        this.nextLineWords.push(part);
        this.nextLineAvailableChars -= part.length;
      }

    }
  }

  /**
   * Pop a word from the currently built line.
   * This doesn't affect completed lines.
   *
   * @returns { string }
   */
  popWord () {
    const lastWord = this.nextLineWords.pop();
    if (lastWord !== undefined) {
      const isLineStart = this.nextLineWords.length === 0;
      const cost = lastWord.length + (isLineStart ? 0 : 1);
      this.nextLineAvailableChars += cost;
    }
    return lastWord;
  }

  /**
   * Concat a word to the last word already in the builder.
   * Adds a new word in case there are no words yet in the last line.
   *
   * @param { string } word A word to be concatenated.
   * @param { boolean } [noWrap] Don't wrap text even if the line is too long.
   */
  concatWord (word, noWrap = false) {
    if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {
      this.pushWord(word, noWrap);
      this.wordBreakOpportunity = false;
    } else {
      const lastWord = this.popWord();
      this.pushWord((lastWord) ? lastWord.concat(word) : word, noWrap);
    }
  }

  /**
   * Add current line (and more empty lines if provided argument > 1) to the list of complete lines and start a new one.
   *
   * @param { number } n Number of line breaks that will be added to the resulting string.
   */
  startNewLine (n = 1) {
    this.lines.push(this.nextLineWords);
    if (n > 1) {
      this.lines.push(...Array.from({ length: n - 1 }, () => []));
    }
    this.nextLineWords = [];
    this.nextLineAvailableChars = this.maxLineLength;
  }

  /**
   * No words in this builder.
   *
   * @returns { boolean }
   */
  isEmpty () {
    return this.lines.length === 0
        && this.nextLineWords.length === 0;
  }

  clear () {
    this.lines.length = 0;
    this.nextLineWords.length = 0;
    this.nextLineAvailableChars = this.maxLineLength;
  }

  /**
   * Join all lines of words inside the InlineTextBuilder into a complete string.
   *
   * @returns { string }
   */
  toString () {
    return [...this.lines, this.nextLineWords]
      .map(words => words.join(' '))
      .join('\n');
  }

  /**
   * Split a long word up to fit within the word wrap limit.
   * Use either a character to split looking back from the word wrap limit,
   * or truncate to the word wrap limit.
   *
   * @param   { string }   word Input word.
   * @returns { string[] }      Parts of the word.
   */
  splitLongWord (word) {
    const parts = [];
    let idx = 0;
    while (word.length > this.maxLineLength) {

      const firstLine = word.substring(0, this.maxLineLength);
      const remainingChars = word.substring(this.maxLineLength);

      const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);

      if (splitIndex > -1) { // Found a character to split on

        word = firstLine.substring(splitIndex + 1) + remainingChars;
        parts.push(firstLine.substring(0, splitIndex + 1));

      } else { // Not found a character to split on

        idx++;
        if (idx < this.wrapCharacters.length) { // There is next character to try

          word = firstLine + remainingChars;

        } else { // No more characters to try

          if (this.forceWrapOnLimit) {
            parts.push(firstLine);
            word = remainingChars;
            if (word.length > this.maxLineLength) {
              continue;
            }
          } else {
            word = firstLine + remainingChars;
          }
          break;

        }

      }

    }
    parts.push(word); // Add remaining part to array
    return parts;
  }
}

/* eslint-disable max-classes-per-file */


class StackItem {
  constructor (next = null) { this.next = next; }

  getRoot () { return (this.next) ? this.next : this; }
}

class BlockStackItem extends StackItem {
  constructor (options, next = null, leadingLineBreaks = 1, maxLineLength = undefined) {
    super(next);
    this.leadingLineBreaks = leadingLineBreaks;
    this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);
    this.rawText = '';
    this.stashedLineBreaks = 0;
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class ListStackItem extends BlockStackItem {
  constructor (
    options,
    next = null,
    {
      interRowLineBreaks = 1,
      leadingLineBreaks = 2,
      maxLineLength = undefined,
      maxPrefixLength = 0,
      prefixAlign = 'left',
    } = {}
  ) {
    super(options, next, leadingLineBreaks, maxLineLength);
    this.maxPrefixLength = maxPrefixLength;
    this.prefixAlign = prefixAlign;
    this.interRowLineBreaks = interRowLineBreaks;
  }
}

class ListItemStackItem extends BlockStackItem {
  constructor (
    options,
    next = null,
    {
      leadingLineBreaks = 1,
      maxLineLength = undefined,
      prefix = '',
    } = {}
  ) {
    super(options, next, leadingLineBreaks, maxLineLength);
    this.prefix = prefix;
  }
}

class TableStackItem extends StackItem {
  constructor (next = null) {
    super(next);
    this.rows = [];
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class TableRowStackItem extends StackItem {
  constructor (next = null) {
    super(next);
    this.cells = [];
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class TableCellStackItem extends StackItem {
  constructor (options, next = null, maxColumnWidth = undefined) {
    super(next);
    this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);
    this.rawText = '';
    this.stashedLineBreaks = 0;
    this.isPre = next && next.isPre;
    this.isNoWrap = next && next.isNoWrap;
  }
}

class TransformerStackItem extends StackItem {
  constructor (next = null, transform) {
    super(next);
    this.transform = transform;
  }
}

function charactersToCodes (str) {
  return [...str]
    .map(c => '\\u' + c.charCodeAt(0).toString(16).padStart(4, '0'))
    .join('');
}

/**
 * Helps to handle HTML whitespaces.
 *
 * @class WhitespaceProcessor
 */
class WhitespaceProcessor {

  /**
   * Creates an instance of WhitespaceProcessor.
   *
   * @param { Options } options    HtmlToText options.
   * @memberof WhitespaceProcessor
   */
  constructor (options) {
    this.whitespaceChars = (options.preserveNewlines)
      ? options.whitespaceCharacters.replace(/\n/g, '')
      : options.whitespaceCharacters;
    const whitespaceCodes = charactersToCodes(this.whitespaceChars);
    this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);
    this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);
    this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);
    this.newlineOrNonWhitespaceRe = new RegExp(`(\\n|[^\\n${whitespaceCodes}])`, 'g');
    this.newlineOrNonNewlineStringRe = new RegExp(`(\\n|[^\\n]+)`, 'g');

    if (options.preserveNewlines) {

      const wordOrNewlineRe = new RegExp(`\\n|[^\\n${whitespaceCodes}]+`, 'gm');

      /**
       * Shrink whitespaces and wrap text, add to the builder.
       *
       * @param { string }                  text              Input text.
       * @param { InlineTextBuilder }       inlineTextBuilder A builder to receive processed text.
       * @param { (str: string) => string } [ transform ]     A transform to be applied to words.
       * @param { boolean }                 [noWrap] Don't wrap text even if the line is too long.
       */
      this.shrinkWrapAdd = function (text, inlineTextBuilder, transform = (str => str), noWrap = false) {
        if (!text) { return; }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = wordOrNewlineRe.exec(text);
        if (m) {
          anyMatch = true;
          if (m[0] === '\n') {
            inlineTextBuilder.startNewLine();
          } else if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
            inlineTextBuilder.pushWord(transform(m[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform(m[0]), noWrap);
          }
          while ((m = wordOrNewlineRe.exec(text)) !== null) {
            if (m[0] === '\n') {
              inlineTextBuilder.startNewLine();
            } else {
              inlineTextBuilder.pushWord(transform(m[0]), noWrap);
            }
          }
        }
        inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch) || (this.testTrailingWhitespace(text));
        // No need to stash a space in case last added item was a new line,
        // but that won't affect anything later anyway.
      };

    } else {

      const wordRe = new RegExp(`[^${whitespaceCodes}]+`, 'g');

      this.shrinkWrapAdd = function (text, inlineTextBuilder, transform = (str => str), noWrap = false) {
        if (!text) { return; }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = wordRe.exec(text);
        if (m) {
          anyMatch = true;
          if (previouslyStashedSpace || this.testLeadingWhitespace(text)) {
            inlineTextBuilder.pushWord(transform(m[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform(m[0]), noWrap);
          }
          while ((m = wordRe.exec(text)) !== null) {
            inlineTextBuilder.pushWord(transform(m[0]), noWrap);
          }
        }
        inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch) || this.testTrailingWhitespace(text);
      };

    }
  }

  /**
   * Add text with only minimal processing.
   * Everything between newlines considered a single word.
   * No whitespace is trimmed.
   * Not affected by preserveNewlines option - `\n` always starts a new line.
   *
   * `noWrap` argument is `true` by default - this won't start a new line
   * even if there is not enough space left in the current line.
   *
   * @param { string }            text              Input text.
   * @param { InlineTextBuilder } inlineTextBuilder A builder to receive processed text.
   * @param { boolean }           [noWrap] Don't wrap text even if the line is too long.
   */
  addLiteral (text, inlineTextBuilder, noWrap = true) {
    if (!text) { return; }
    const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
    let anyMatch = false;
    let m = this.newlineOrNonNewlineStringRe.exec(text);
    if (m) {
      anyMatch = true;
      if (m[0] === '\n') {
        inlineTextBuilder.startNewLine();
      } else if (previouslyStashedSpace) {
        inlineTextBuilder.pushWord(m[0], noWrap);
      } else {
        inlineTextBuilder.concatWord(m[0], noWrap);
      }
      while ((m = this.newlineOrNonNewlineStringRe.exec(text)) !== null) {
        if (m[0] === '\n') {
          inlineTextBuilder.startNewLine();
        } else {
          inlineTextBuilder.pushWord(m[0], noWrap);
        }
      }
    }
    inlineTextBuilder.stashedSpace = (previouslyStashedSpace && !anyMatch);
  }

  /**
   * Test whether the given text starts with HTML whitespace character.
   *
   * @param   { string }  text  The string to test.
   * @returns { boolean }
   */
  testLeadingWhitespace (text) {
    return this.leadingWhitespaceRe.test(text);
  }

  /**
   * Test whether the given text ends with HTML whitespace character.
   *
   * @param   { string }  text  The string to test.
   * @returns { boolean }
   */
  testTrailingWhitespace (text) {
    return this.trailingWhitespaceRe.test(text);
  }

  /**
   * Test whether the given text contains any non-whitespace characters.
   *
   * @param   { string }  text  The string to test.
   * @returns { boolean }
   */
  testContainsWords (text) {
    return !this.allWhitespaceOrEmptyRe.test(text);
  }

  /**
   * Return the number of newlines if there are no words.
   *
   * If any word is found then return zero regardless of the actual number of newlines.
   *
   * @param   { string }  text  Input string.
   * @returns { number }
   */
  countNewlinesNoWords (text) {
    this.newlineOrNonWhitespaceRe.lastIndex = 0;
    let counter = 0;
    let match;
    while ((match = this.newlineOrNonWhitespaceRe.exec(text)) !== null) {
      if (match[0] === '\n') {
        counter++;
      } else {
        return 0;
      }
    }
    return counter;
  }

}

/**
 * Helps to build text from inline and block elements.
 *
 * @class BlockTextBuilder
 */
class BlockTextBuilder {

  /**
   * Creates an instance of BlockTextBuilder.
   *
   * @param { Options } options HtmlToText options.
   * @param { import('selderee').Picker<DomNode, TagDefinition> } picker Selectors decision tree picker.
   * @param { any} [metadata] Optional metadata for HTML document, for use in formatters.
   */
  constructor (options, picker, metadata = undefined) {
    this.options = options;
    this.picker = picker;
    this.metadata = metadata;
    this.whitespaceProcessor = new WhitespaceProcessor(options);
    /** @type { StackItem } */
    this._stackItem = new BlockStackItem(options);
    /** @type { TransformerStackItem } */
    this._wordTransformer = undefined;
  }

  /**
   * Put a word-by-word transform function onto the transformations stack.
   *
   * Mainly used for uppercasing. Can be bypassed to add unformatted text such as URLs.
   *
   * Word transformations applied before wrapping.
   *
   * @param { (str: string) => string } wordTransform Word transformation function.
   */
  pushWordTransform (wordTransform) {
    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);
  }

  /**
   * Remove a function from the word transformations stack.
   *
   * @returns { (str: string) => string } A function that was removed.
   */
  popWordTransform () {
    if (!this._wordTransformer) { return undefined; }
    const transform = this._wordTransformer.transform;
    this._wordTransformer = this._wordTransformer.next;
    return transform;
  }

  /**
   * Ignore wordwrap option in followup inline additions and disable automatic wrapping.
   */
  startNoWrap () {
    this._stackItem.isNoWrap = true;
  }

  /**
   * Return automatic wrapping to behavior defined by options.
   */
  stopNoWrap () {
    this._stackItem.isNoWrap = false;
  }

  /** @returns { (str: string) => string } */
  _getCombinedWordTransformer () {
    const wt = (this._wordTransformer)
      ? ((str) => applyTransformer(str, this._wordTransformer))
      : undefined;
    const ce = this.options.encodeCharacters;
    return (wt)
      ? ((ce) ? (str) => ce(wt(str)) : wt)
      : ce;
  }

  _popStackItem () {
    const item = this._stackItem;
    this._stackItem = item.next;
    return item;
  }

  /**
   * Add a line break into currently built block.
   */
  addLineBreak () {
    if (!(
      this._stackItem instanceof BlockStackItem
      || this._stackItem instanceof ListItemStackItem
      || this._stackItem instanceof TableCellStackItem
    )) { return; }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += '\n';
    } else {
      this._stackItem.inlineTextBuilder.startNewLine();
    }
  }

  /**
   * Allow to break line in case directly following text will not fit.
   */
  addWordBreakOpportunity () {
    if (
      this._stackItem instanceof BlockStackItem
      || this._stackItem instanceof ListItemStackItem
      || this._stackItem instanceof TableCellStackItem
    ) {
      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;
    }
  }

  /**
   * Add a node inline into the currently built block.
   *
   * @param { string } str
   * Text content of a node to add.
   *
   * @param { object } [param1]
   * Object holding the parameters of the operation.
   *
   * @param { boolean } [param1.noWordTransform]
   * Ignore word transformers if there are any.
   * Don't encode characters as well.
   * (Use this for things like URL addresses).
   */
  addInline (str, { noWordTransform = false } = {}) {
    if (!(
      this._stackItem instanceof BlockStackItem
      || this._stackItem instanceof ListItemStackItem
      || this._stackItem instanceof TableCellStackItem
    )) { return; }

    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }

    if (
      str.length === 0 || // empty string
      (
        this._stackItem.stashedLineBreaks && // stashed linebreaks make whitespace irrelevant
        !this.whitespaceProcessor.testContainsWords(str) // no words to add
      )
    ) { return; }

    if (this.options.preserveNewlines) {
      const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);
      if (newlinesNumber > 0) {
        this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);
        // keep stashedLineBreaks unchanged
        return;
      }
    }

    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.shrinkWrapAdd(
      str,
      this._stackItem.inlineTextBuilder,
      (noWordTransform) ? undefined : this._getCombinedWordTransformer(),
      this._stackItem.isNoWrap
    );
    this._stackItem.stashedLineBreaks = 0; // inline text doesn't introduce line breaks
  }

  /**
   * Add a string inline into the currently built block.
   *
   * Use this for markup elements that don't have to adhere
   * to text layout rules.
   *
   * @param { string } str Text to add.
   */
  addLiteral (str) {
    if (!(
      this._stackItem instanceof BlockStackItem
      || this._stackItem instanceof ListItemStackItem
      || this._stackItem instanceof TableCellStackItem
    )) { return; }

    if (str.length === 0) { return; }

    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }

    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.addLiteral(
      str,
      this._stackItem.inlineTextBuilder,
      this._stackItem.isNoWrap
    );
    this._stackItem.stashedLineBreaks = 0;
  }

  /**
   * Start building a new block.
   *
   * @param { object } [param0]
   * Object holding the parameters of the block.
   *
   * @param { number } [param0.leadingLineBreaks]
   * This block should have at least this number of line breaks to separate it from any preceding block.
   *
   * @param { number }  [param0.reservedLineLength]
   * Reserve this number of characters on each line for block markup.
   *
   * @param { boolean } [param0.isPre]
   * Should HTML whitespace be preserved inside this block.
   */
  openBlock ({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {
    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);
    this._stackItem = new BlockStackItem(
      this.options,
      this._stackItem,
      leadingLineBreaks,
      maxLineLength
    );
    if (isPre) { this._stackItem.isPre = true; }
  }

  /**
   * Finalize currently built block, add it's content to the parent block.
   *
   * @param { object } [param0]
   * Object holding the parameters of the block.
   *
   * @param { number } [param0.trailingLineBreaks]
   * This block should have at least this number of line breaks to separate it from any following block.
   *
   * @param { (str: string) => string } [param0.blockTransform]
   * A function to transform the block text before adding to the parent block.
   * This happens after word wrap and should be used in combination with reserved line length
   * in order to keep line lengths correct.
   * Used for whole block markup.
   */
  closeBlock ({ trailingLineBreaks = 1, blockTransform = undefined } = {}) {
    const block = this._popStackItem();
    const blockText = (blockTransform) ? blockTransform(getText(block)) : getText(block);
    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));
  }

  /**
   * Start building a new list.
   *
   * @param { object } [param0]
   * Object holding the parameters of the list.
   *
   * @param { number } [param0.maxPrefixLength]
   * Length of the longest list item prefix.
   * If not supplied or too small then list items won't be aligned properly.
   *
   * @param { 'left' | 'right' } [param0.prefixAlign]
   * Specify how prefixes of different lengths have to be aligned
   * within a column.
   *
   * @param { number } [param0.interRowLineBreaks]
   * Minimum number of line breaks between list items.
   *
   * @param { number } [param0.leadingLineBreaks]
   * This list should have at least this number of line breaks to separate it from any preceding block.
   */
  openList ({ maxPrefixLength = 0, prefixAlign = 'left', interRowLineBreaks = 1, leadingLineBreaks = 2 } = {}) {
    this._stackItem = new ListStackItem(this.options, this._stackItem, {
      interRowLineBreaks: interRowLineBreaks,
      leadingLineBreaks: leadingLineBreaks,
      maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,
      maxPrefixLength: maxPrefixLength,
      prefixAlign: prefixAlign
    });
  }

  /**
   * Start building a new list item.
   *
   * @param {object} param0
   * Object holding the parameters of the list item.
   *
   * @param { string } [param0.prefix]
   * Prefix for this list item (item number, bullet point, etc).
   */
  openListItem ({ prefix = '' } = {}) {
    if (!(this._stackItem instanceof ListStackItem)) {
      throw new Error('Can\'t add a list item to something that is not a list! Check the formatter.');
    }
    const list = this._stackItem;
    const prefixLength = Math.max(prefix.length, list.maxPrefixLength);
    const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);
    this._stackItem = new ListItemStackItem(this.options, list, {
      prefix: prefix,
      maxLineLength: maxLineLength,
      leadingLineBreaks: list.interRowLineBreaks
    });
  }

  /**
   * Finalize currently built list item, add it's content to the parent list.
   */
  closeListItem () {
    const listItem = this._popStackItem();
    const list = listItem.next;

    const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);
    const spacing = '\n' + ' '.repeat(prefixLength);
    const prefix = (list.prefixAlign === 'right')
      ? listItem.prefix.padStart(prefixLength)
      : listItem.prefix.padEnd(prefixLength);
    const text = prefix + getText(listItem).replace(/\n/g, spacing);

    addText(
      list,
      text,
      listItem.leadingLineBreaks,
      Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks)
    );
  }

  /**
   * Finalize currently built list, add it's content to the parent block.
   *
   * @param { object } param0
   * Object holding the parameters of the list.
   *
   * @param { number } [param0.trailingLineBreaks]
   * This list should have at least this number of line breaks to separate it from any following block.
   */
  closeList ({ trailingLineBreaks = 2 } = {}) {
    const list = this._popStackItem();
    const text = getText(list);
    if (text) {
      addText(this._stackItem, text, list.leadingLineBreaks, trailingLineBreaks);
    }
  }

  /**
   * Start building a table.
   */
  openTable () {
    this._stackItem = new TableStackItem(this._stackItem);
  }

  /**
   * Start building a table row.
   */
  openTableRow () {
    if (!(this._stackItem instanceof TableStackItem)) {
      throw new Error('Can\'t add a table row to something that is not a table! Check the formatter.');
    }
    this._stackItem = new TableRowStackItem(this._stackItem);
  }

  /**
   * Start building a table cell.
   *
   * @param { object } [param0]
   * Object holding the parameters of the cell.
   *
   * @param { number } [param0.maxColumnWidth]
   * Wrap cell content to this width. Fall back to global wordwrap value if undefined.
   */
  openTableCell ({ maxColumnWidth = undefined } = {}) {
    if (!(this._stackItem instanceof TableRowStackItem)) {
      throw new Error('Can\'t add a table cell to something that is not a table row! Check the formatter.');
    }
    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);
  }

  /**
   * Finalize currently built table cell and add it to parent table row's cells.
   *
   * @param { object } [param0]
   * Object holding the parameters of the cell.
   *
   * @param { number } [param0.colspan] How many columns this cell should occupy.
   * @param { number } [param0.rowspan] How many rows this cell should occupy.
   */
  closeTableCell ({ colspan = 1, rowspan = 1 } = {}) {
    const cell = this._popStackItem();
    const text = trimCharacter(getText(cell), '\n');
    cell.next.cells.push({ colspan: colspan, rowspan: rowspan, text: text });
  }

  /**
   * Finalize currently built table row and add it to parent table's rows.
   */
  closeTableRow () {
    const row = this._popStackItem();
    row.next.rows.push(row.cells);
  }

  /**
   * Finalize currently built table and add the rendered text to the parent block.
   *
   * @param { object } param0
   * Object holding the parameters of the table.
   *
   * @param { TablePrinter } param0.tableToString
   * A function to convert a table of stringified cells into a complete table.
   *
   * @param { number } [param0.leadingLineBreaks]
   * This table should have at least this number of line breaks to separate if from any preceding block.
   *
   * @param { number } [param0.trailingLineBreaks]
   * This table should have at least this number of line breaks to separate it from any following block.
   */
  closeTable ({ tableToString, leadingLineBreaks = 2, trailingLineBreaks = 2 }) {
    const table = this._popStackItem();
    const output = tableToString(table.rows);
    if (output) {
      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);
    }
  }

  /**
   * Return the rendered text content of this builder.
   *
   * @returns { string }
   */
  toString () {
    return getText(this._stackItem.getRoot());
    // There should only be the root item if everything is closed properly.
  }

}

function getText (stackItem) {
  if (!(
    stackItem instanceof BlockStackItem
    || stackItem instanceof ListItemStackItem
    || stackItem instanceof TableCellStackItem
  )) {
    throw new Error('Only blocks, list items and table cells can be requested for text contents.');
  }
  return (stackItem.inlineTextBuilder.isEmpty())
    ? stackItem.rawText
    : stackItem.rawText + stackItem.inlineTextBuilder.toString();
}

function addText (stackItem, text, leadingLineBreaks, trailingLineBreaks) {
  if (!(
    stackItem instanceof BlockStackItem
    || stackItem instanceof ListItemStackItem
    || stackItem instanceof TableCellStackItem
  )) {
    throw new Error('Only blocks, list items and table cells can contain text.');
  }
  const parentText = getText(stackItem);
  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);
  stackItem.inlineTextBuilder.clear();
  if (parentText) {
    stackItem.rawText = parentText + '\n'.repeat(lineBreaks) + text;
  } else {
    stackItem.rawText = text;
    stackItem.leadingLineBreaks = lineBreaks;
  }
  stackItem.stashedLineBreaks = trailingLineBreaks;
}

/**
 * @param { string } str A string to transform.
 * @param { TransformerStackItem } transformer A transformer item (with possible continuation).
 * @returns { string }
 */
function applyTransformer (str, transformer) {
  return ((transformer) ? applyTransformer(transformer.transform(str), transformer.next) : str);
}

/**
 * Compile selectors into a decision tree,
 * return a function intended for batch processing.
 *
 * @param   { Options } [options = {}]   HtmlToText options (defaults, formatters, user options merged, deduplicated).
 * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.
 * @static
 */
function compile$1 (options = {}) {
  const selectorsWithoutFormat = options.selectors.filter(s => !s.format);
  if (selectorsWithoutFormat.length) {
    throw new Error(
      'Following selectors have no specified format: ' +
      selectorsWithoutFormat.map(s => `\`${s.selector}\``).join(', ')
    );
  }
  const picker = new selderee.DecisionTree(
    options.selectors.map(s => [s.selector, s])
  ).build(pluginHtmlparser2.hp2Builder);

  if (typeof options.encodeCharacters !== 'function') {
    options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);
  }

  const baseSelectorsPicker = new selderee.DecisionTree(
    options.baseElements.selectors.map((s, i) => [s, i + 1])
  ).build(pluginHtmlparser2.hp2Builder);
  function findBaseElements (dom) {
    return findBases(dom, options, baseSelectorsPicker);
  }

  const limitedWalk = limitedDepthRecursive(
    options.limits.maxDepth,
    recursiveWalk,
    function (dom, builder) {
      builder.addInline(options.limits.ellipsis || '');
    }
  );

  return function (html, metadata = undefined) {
    return process(html, metadata, options, picker, findBaseElements, limitedWalk);
  };
}


/**
 * Convert given HTML according to preprocessed options.
 *
 * @param { string } html HTML content to convert.
 * @param { any } metadata Optional metadata for HTML document, for use in formatters.
 * @param { Options } options HtmlToText options (preprocessed).
 * @param { import('selderee').Picker<DomNode, TagDefinition> } picker
 * Tag definition picker for DOM nodes processing.
 * @param { (dom: DomNode[]) => DomNode[] } findBaseElements
 * Function to extract elements from HTML DOM
 * that will only be present in the output text.
 * @param { RecursiveCallback } walk Recursive callback.
 * @returns { string }
 */
function process (html, metadata, options, picker, findBaseElements, walk) {
  const maxInputLength = options.limits.maxInputLength;
  if (maxInputLength && html && html.length > maxInputLength) {
    console.warn(
      `Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`
    );
    html = html.substring(0, maxInputLength);
  }

  const document = htmlparser2.parseDocument(html, { decodeEntities: options.decodeEntities });
  const bases = findBaseElements(document.children);
  const builder = new BlockTextBuilder(options, picker, metadata);
  walk(bases, builder);
  return builder.toString();
}


function findBases (dom, options, baseSelectorsPicker) {
  const results = [];

  function recursiveWalk (walk, /** @type { DomNode[] } */ dom) {
    dom = dom.slice(0, options.limits.maxChildNodes);
    for (const elem of dom) {
      if (elem.type !== 'tag') {
        continue;
      }
      const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);
      if (pickedSelectorIndex > 0) {
        results.push({ selectorIndex: pickedSelectorIndex, element: elem });
      } else if (elem.children) {
        walk(elem.children);
      }
      if (results.length >= options.limits.maxBaseElements) {
        return;
      }
    }
  }

  const limitedWalk = limitedDepthRecursive(
    options.limits.maxDepth,
    recursiveWalk
  );
  limitedWalk(dom);

  if (options.baseElements.orderBy !== 'occurrence') { // 'selectors'
    results.sort((a, b) => a.selectorIndex - b.selectorIndex);
  }
  return (options.baseElements.returnDomByDefault && results.length === 0)
    ? dom
    : results.map(x => x.element);
}

/**
 * Function to walk through DOM nodes and accumulate their string representations.
 *
 * @param   { RecursiveCallback } walk    Recursive callback.
 * @param   { DomNode[] }         [dom]   Nodes array to process.
 * @param   { BlockTextBuilder }  builder Passed around to accumulate output text.
 * @private
 */
function recursiveWalk (walk, dom, builder) {
  if (!dom) { return; }

  const options = builder.options;

  const tooManyChildNodes = dom.length > options.limits.maxChildNodes;
  if (tooManyChildNodes) {
    dom = dom.slice(0, options.limits.maxChildNodes);
    dom.push({
      data: options.limits.ellipsis,
      type: 'text'
    });
  }

  for (const elem of dom) {
    switch (elem.type) {
      case 'text': {
        builder.addInline(elem.data);
        break;
      }
      case 'tag': {
        const tagDefinition = builder.picker.pick1(elem);
        const format = options.formatters[tagDefinition.format];
        format(elem, walk, builder, tagDefinition.options || {});
        break;
      }
    }
  }

  return;
}

/**
 * @param { Object<string,string | false> } dict
 * A dictionary where keys are characters to replace
 * and values are replacement strings.
 *
 * First code point from dict keys is used.
 * Compound emojis with ZWJ are not supported (not until Node 16).
 *
 * @returns { ((str: string) => string) | undefined }
 */
function makeReplacerFromDict (dict) {
  if (!dict || Object.keys(dict).length === 0) {
    return undefined;
  }
  /** @type { [string, string][] } */
  const entries = Object.entries(dict).filter(([, v]) => v !== false);
  const regex = new RegExp(
    entries
      .map(([c]) => `(${unicodeEscape([...c][0])})`)
      .join('|'),
    'g'
  );
  const values = entries.map(([, v]) => v);
  const replacer = (m, ...cgs) => values[cgs.findIndex(cg => cg)];
  return (str) => str.replace(regex, replacer);
}

/**
 * Dummy formatter that discards the input and does nothing.
 *
 * @type { FormatCallback }
 */
function formatSkip (elem, walk, builder, formatOptions) {
  /* do nothing */
}

/**
 * Insert the given string literal inline instead of a tag.
 *
 * @type { FormatCallback }
 */
function formatInlineString (elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.string || '');
}

/**
 * Insert a block with the given string literal instead of a tag.
 *
 * @type { FormatCallback }
 */
function formatBlockString (elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addLiteral(formatOptions.string || '');
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}

/**
 * Process an inline-level element.
 *
 * @type { FormatCallback }
 */
function formatInline (elem, walk, builder, formatOptions) {
  walk(elem.children, builder);
}

/**
 * Process a block-level container.
 *
 * @type { FormatCallback }
 */
function formatBlock$1 (elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}

function renderOpenTag (elem) {
  const attrs = (elem.attribs && elem.attribs.length)
    ? ' ' + Object.entries(elem.attribs)
      .map(([k, v]) => ((v === '') ? k : `${k}=${v.replace(/"/g, '&quot;')}`))
      .join(' ')
    : '';
  return `<${elem.name}${attrs}>`;
}

function renderCloseTag (elem) {
  return `</${elem.name}>`;
}

/**
 * Render an element as inline HTML tag, walk through it's children.
 *
 * @type { FormatCallback }
 */
function formatInlineTag (elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
}

/**
 * Render an element as HTML block bag, walk through it's children.
 *
 * @type { FormatCallback }
 */
function formatBlockTag (elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}

/**
 * Render an element with all it's children as inline HTML.
 *
 * @type { FormatCallback }
 */
function formatInlineHtml (elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(
    domSerializer.render(elem, { decodeEntities: builder.options.decodeEntities })
  );
  builder.stopNoWrap();
}

/**
 * Render an element with all it's children as HTML block.
 *
 * @type { FormatCallback }
 */
function formatBlockHtml (elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(
    domSerializer.render(elem, { decodeEntities: builder.options.decodeEntities })
  );
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}

/**
 * Render inline element wrapped with given strings.
 *
 * @type { FormatCallback }
 */
function formatInlineSurround (elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.prefix || '');
  walk(elem.children, builder);
  builder.addLiteral(formatOptions.suffix || '');
}

var genericFormatters = /*#__PURE__*/Object.freeze({
  __proto__: null,
  block: formatBlock$1,
  blockHtml: formatBlockHtml,
  blockString: formatBlockString,
  blockTag: formatBlockTag,
  inline: formatInline,
  inlineHtml: formatInlineHtml,
  inlineString: formatInlineString,
  inlineSurround: formatInlineSurround,
  inlineTag: formatInlineTag,
  skip: formatSkip
});

function getRow (matrix, j) {
  if (!matrix[j]) { matrix[j] = []; }
  return matrix[j];
}

function findFirstVacantIndex (row, x = 0) {
  while (row[x]) { x++; }
  return x;
}

function transposeInPlace (matrix, maxSize) {
  for (let i = 0; i < maxSize; i++) {
    const rowI = getRow(matrix, i);
    for (let j = 0; j < i; j++) {
      const rowJ = getRow(matrix, j);
      const temp = rowI[j];
      rowI[j] = rowJ[i];
      rowJ[i] = temp;
    }
  }
}

function putCellIntoLayout (cell, layout, baseRow, baseCol) {
  for (let r = 0; r < cell.rowspan; r++) {
    const layoutRow = getRow(layout, baseRow + r);
    for (let c = 0; c < cell.colspan; c++) {
      layoutRow[baseCol + c] = cell;
    }
  }
}

function updateOffset (offsets, base, span, value) {
  offsets[base + span] = Math.max(
    offsets[base + span] || 0,
    offsets[base] + value
  );
}

/**
 * Render a table into a string.
 * Cells can contain multiline text and span across multiple rows and columns.
 *
 * Modifies cells to add lines array.
 *
 * @param { TablePrinterCell[][] } tableRows Table to render.
 * @param { number } rowSpacing Number of spaces between columns.
 * @param { number } colSpacing Number of empty lines between rows.
 * @returns { string }
 */
function tableToString (tableRows, rowSpacing, colSpacing) {
  const layout = [];
  let colNumber = 0;
  const rowNumber = tableRows.length;
  const rowOffsets = [0];
  // Fill the layout table and row offsets row-by-row.
  for (let j = 0; j < rowNumber; j++) {
    const layoutRow = getRow(layout, j);
    const cells = tableRows[j];
    let x = 0;
    for (let i = 0; i < cells.length; i++) {
      const cell = cells[i];
      x = findFirstVacantIndex(layoutRow, x);
      putCellIntoLayout(cell, layout, j, x);
      x += cell.colspan;
      cell.lines = cell.text.split('\n');
      const cellHeight = cell.lines.length;
      updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);
    }
    colNumber = (layoutRow.length > colNumber) ? layoutRow.length : colNumber;
  }

  transposeInPlace(layout, (rowNumber > colNumber) ? rowNumber : colNumber);

  const outputLines = [];
  const colOffsets = [0];
  // Fill column offsets and output lines column-by-column.
  for (let x = 0; x < colNumber; x++) {
    let y = 0;
    let cell;
    while (y < rowNumber && (cell = layout[x][y])) {
      if (!cell.rendered) {
        let cellWidth = 0;
        for (let j = 0; j < cell.lines.length; j++) {
          const line = cell.lines[j];
          const lineOffset = rowOffsets[y] + j;
          outputLines[lineOffset] = (outputLines[lineOffset] || '').padEnd(colOffsets[x]) + line;
          cellWidth = (line.length > cellWidth) ? line.length : cellWidth;
        }
        updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);
        cell.rendered = true;
      }
      y += cell.rowspan;
    }
  }

  return outputLines.join('\n');
}

/**
 * Process a line-break.
 *
 * @type { FormatCallback }
 */
function formatLineBreak (elem, walk, builder, formatOptions) {
  builder.addLineBreak();
}

/**
 * Process a `wbr` tag (word break opportunity).
 *
 * @type { FormatCallback }
 */
function formatWbr (elem, walk, builder, formatOptions) {
  builder.addWordBreakOpportunity();
}

/**
 * Process a horizontal line.
 *
 * @type { FormatCallback }
 */
function formatHorizontalLine (elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addInline('-'.repeat(formatOptions.length || builder.options.wordwrap || 40));
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}

/**
 * Process a paragraph.
 *
 * @type { FormatCallback }
 */
function formatParagraph (elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}

/**
 * Process a preformatted content.
 *
 * @type { FormatCallback }
 */
function formatPre (elem, walk, builder, formatOptions) {
  builder.openBlock({
    isPre: true,
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2
  });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}

/**
 * Process a heading.
 *
 * @type { FormatCallback }
 */
function formatHeading (elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  if (formatOptions.uppercase !== false) {
    builder.pushWordTransform(str => str.toUpperCase());
    walk(elem.children, builder);
    builder.popWordTransform();
  } else {
    walk(elem.children, builder);
  }
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}

/**
 * Process a blockquote.
 *
 * @type { FormatCallback }
 */
function formatBlockquote (elem, walk, builder, formatOptions) {
  builder.openBlock({
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,
    reservedLineLength: 2
  });
  walk(elem.children, builder);
  builder.closeBlock({
    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,
    blockTransform: str => ((formatOptions.trimEmptyLines !== false) ? trimCharacter(str, '\n') : str)
      .split('\n')
      .map(line => '> ' + line)
      .join('\n')
  });
}

function withBrackets (str, brackets) {
  if (!brackets) { return str; }

  const lbr = (typeof brackets[0] === 'string')
    ? brackets[0]
    : '[';
  const rbr = (typeof brackets[1] === 'string')
    ? brackets[1]
    : ']';
  return lbr + str + rbr;
}

function pathRewrite (path, rewriter, baseUrl, metadata, elem) {
  const modifiedPath = (typeof rewriter === 'function')
    ? rewriter(path, metadata, elem)
    : path;
  return (modifiedPath[0] === '/' && baseUrl)
    ? trimCharacterEnd(baseUrl, '/') + modifiedPath
    : modifiedPath;
}

/**
 * Process an image.
 *
 * @type { FormatCallback }
 */
function formatImage (elem, walk, builder, formatOptions) {
  const attribs = elem.attribs || {};
  const alt = (attribs.alt)
    ? attribs.alt
    : '';
  const src = (!attribs.src)
    ? ''
    : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
  const text = (!src)
    ? alt
    : (!alt)
      ? withBrackets(src, formatOptions.linkBrackets)
      : alt + ' ' + withBrackets(src, formatOptions.linkBrackets);

  builder.addInline(text, { noWordTransform: true });
}

/**
 * Process an anchor.
 *
 * @type { FormatCallback }
 */
function formatAnchor (elem, walk, builder, formatOptions) {
  function getHref () {
    if (formatOptions.ignoreHref) { return ''; }
    if (!elem.attribs || !elem.attribs.href) { return ''; }
    let href = elem.attribs.href.replace(/^mailto:/, '');
    if (formatOptions.noAnchorUrl && href[0] === '#') { return ''; }
    href = pathRewrite(href, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
    return href;
  }
  const href = getHref();
  if (!href) {
    walk(elem.children, builder);
  } else {
    let text = '';
    builder.pushWordTransform(
      str => {
        if (str) { text += str; }
        return str;
      }
    );
    walk(elem.children, builder);
    builder.popWordTransform();

    const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text;
    if (!hideSameLink) {
      builder.addInline(
        (!text)
          ? href
          : ' ' + withBrackets(href, formatOptions.linkBrackets),
        { noWordTransform: true }
      );
    }
  }
}

/**
 * @param { DomNode }           elem               List items with their prefixes.
 * @param { RecursiveCallback } walk               Recursive callback to process child nodes.
 * @param { BlockTextBuilder }  builder            Passed around to accumulate output text.
 * @param { FormatOptions }     formatOptions      Options specific to a formatter.
 * @param { () => string }      nextPrefixCallback Function that returns increasing index each time it is called.
 */
function formatList (elem, walk, builder, formatOptions, nextPrefixCallback) {
  const isNestedList = get(elem, ['parent', 'name']) === 'li';

  // With Roman numbers, index length is not as straightforward as with Arabic numbers or letters,
  // so the dumb length comparison is the most robust way to get the correct value.
  let maxPrefixLength = 0;
  const listItems = (elem.children || [])
    // it might be more accurate to check only for html spaces here, but no significant benefit
    .filter(child => child.type !== 'text' || !/^\s*$/.test(child.data))
    .map(function (child) {
      if (child.name !== 'li') {
        return { node: child, prefix: '' };
      }
      const prefix = (isNestedList)
        ? nextPrefixCallback().trimStart()
        : nextPrefixCallback();
      if (prefix.length > maxPrefixLength) { maxPrefixLength = prefix.length; }
      return { node: child, prefix: prefix };
    });
  if (!listItems.length) { return; }

  builder.openList({
    interRowLineBreaks: 1,
    leadingLineBreaks: isNestedList ? 1 : (formatOptions.leadingLineBreaks || 2),
    maxPrefixLength: maxPrefixLength,
    prefixAlign: 'left'
  });

  for (const { node, prefix } of listItems) {
    builder.openListItem({ prefix: prefix });
    walk([node], builder);
    builder.closeListItem();
  }

  builder.closeList({ trailingLineBreaks: isNestedList ? 1 : (formatOptions.trailingLineBreaks || 2) });
}

/**
 * Process an unordered list.
 *
 * @type { FormatCallback }
 */
function formatUnorderedList (elem, walk, builder, formatOptions) {
  const prefix = formatOptions.itemPrefix || ' * ';
  return formatList(elem, walk, builder, formatOptions, () => prefix);
}

/**
 * Process an ordered list.
 *
 * @type { FormatCallback }
 */
function formatOrderedList (elem, walk, builder, formatOptions) {
  let nextIndex = Number(elem.attribs.start || '1');
  const indexFunction = getOrderedListIndexFunction(elem.attribs.type);
  const nextPrefixCallback = () => ' ' + indexFunction(nextIndex++) + '. ';
  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);
}

/**
 * Return a function that can be used to generate index markers of a specified format.
 *
 * @param   { string } [olType='1'] Marker type.
 * @returns { (i: number) => string }
 */
function getOrderedListIndexFunction (olType = '1') {
  switch (olType) {
    case 'a': return (i) => numberToLetterSequence(i, 'a');
    case 'A': return (i) => numberToLetterSequence(i, 'A');
    case 'i': return (i) => numberToRoman(i).toLowerCase();
    case 'I': return (i) => numberToRoman(i);
    case '1':
    default: return (i) => (i).toString();
  }
}

/**
 * Given a list of class and ID selectors (prefixed with '.' and '#'),
 * return them as separate lists of names without prefixes.
 *
 * @param { string[] } selectors Class and ID selectors (`[".class", "#id"]` etc).
 * @returns { { classes: string[], ids: string[] } }
 */
function splitClassesAndIds (selectors) {
  const classes = [];
  const ids = [];
  for (const selector of selectors) {
    if (selector.startsWith('.')) {
      classes.push(selector.substring(1));
    } else if (selector.startsWith('#')) {
      ids.push(selector.substring(1));
    }
  }
  return { classes: classes, ids: ids };
}

function isDataTable (attr, tables) {
  if (tables === true) { return true; }
  if (!attr) { return false; }

  const { classes, ids } = splitClassesAndIds(tables);
  const attrClasses = (attr['class'] || '').split(' ');
  const attrIds = (attr['id'] || '').split(' ');

  return attrClasses.some(x => classes.includes(x)) || attrIds.some(x => ids.includes(x));
}

/**
 * Process a table (either as a container or as a data table, depending on options).
 *
 * @type { FormatCallback }
 */
function formatTable (elem, walk, builder, formatOptions) {
  return isDataTable(elem.attribs, builder.options.tables)
    ? formatDataTable(elem, walk, builder, formatOptions)
    : formatBlock(elem, walk, builder, formatOptions);
}

function formatBlock (elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks });
}

/**
 * Process a data table.
 *
 * @type { FormatCallback }
 */
function formatDataTable (elem, walk, builder, formatOptions) {
  builder.openTable();
  elem.children.forEach(walkTable);
  builder.closeTable({
    tableToString: (rows) => tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),
    leadingLineBreaks: formatOptions.leadingLineBreaks,
    trailingLineBreaks: formatOptions.trailingLineBreaks
  });

  function formatCell (cellNode) {
    const colspan = +get(cellNode, ['attribs', 'colspan']) || 1;
    const rowspan = +get(cellNode, ['attribs', 'rowspan']) || 1;
    builder.openTableCell({ maxColumnWidth: formatOptions.maxColumnWidth });
    walk(cellNode.children, builder);
    builder.closeTableCell({ colspan: colspan, rowspan: rowspan });
  }

  function walkTable (elem) {
    if (elem.type !== 'tag') { return; }

    const formatHeaderCell = (formatOptions.uppercaseHeaderCells !== false)
      ? (cellNode) => {
        builder.pushWordTransform(str => str.toUpperCase());
        formatCell(cellNode);
        builder.popWordTransform();
      }
      : formatCell;

    switch (elem.name) {
      case 'thead':
      case 'tbody':
      case 'tfoot':
      case 'center':
        elem.children.forEach(walkTable);
        return;

      case 'tr': {
        builder.openTableRow();
        for (const childOfTr of elem.children) {
          if (childOfTr.type !== 'tag') { continue; }
          switch (childOfTr.name) {
            case 'th': {
              formatHeaderCell(childOfTr);
              break;
            }
            case 'td': {
              formatCell(childOfTr);
              break;
            }
              // do nothing
          }
        }
        builder.closeTableRow();
        break;
      }
        // do nothing
    }
  }
}

var textFormatters = /*#__PURE__*/Object.freeze({
  __proto__: null,
  anchor: formatAnchor,
  blockquote: formatBlockquote,
  dataTable: formatDataTable,
  heading: formatHeading,
  horizontalLine: formatHorizontalLine,
  image: formatImage,
  lineBreak: formatLineBreak,
  orderedList: formatOrderedList,
  paragraph: formatParagraph,
  pre: formatPre,
  table: formatTable,
  unorderedList: formatUnorderedList,
  wbr: formatWbr
});

/**
 * Default options.
 *
 * @constant
 * @type { Options }
 * @default
 * @private
 */
const DEFAULT_OPTIONS = {
  baseElements: {
    selectors: [ 'body' ],
    orderBy: 'selectors', // 'selectors' | 'occurrence'
    returnDomByDefault: true
  },
  decodeEntities: true,
  encodeCharacters: {},
  formatters: {},
  limits: {
    ellipsis: '...',
    maxBaseElements: undefined,
    maxChildNodes: undefined,
    maxDepth: undefined,
    maxInputLength: (1 << 24) // 16_777_216
  },
  longWordSplit: {
    forceWrapOnLimit: false,
    wrapCharacters: []
  },
  preserveNewlines: false,
  selectors: [
    { selector: '*', format: 'inline' },
    {
      selector: 'a',
      format: 'anchor',
      options: {
        baseUrl: null,
        hideLinkHrefIfSameAsText: false,
        ignoreHref: false,
        linkBrackets: ['[', ']'],
        noAnchorUrl: true
      }
    },
    { selector: 'article', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: 'aside', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: 'blockquote',
      format: 'blockquote',
      options: { leadingLineBreaks: 2, trailingLineBreaks: 2, trimEmptyLines: true }
    },
    { selector: 'br', format: 'lineBreak' },
    { selector: 'div', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: 'footer', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: 'form', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: 'h1', format: 'heading', options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: 'h2', format: 'heading', options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: 'h3', format: 'heading', options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
    { selector: 'h4', format: 'heading', options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: 'h5', format: 'heading', options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: 'h6', format: 'heading', options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
    { selector: 'header', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: 'hr',
      format: 'horizontalLine',
      options: { leadingLineBreaks: 2, length: undefined, trailingLineBreaks: 2 }
    },
    {
      selector: 'img',
      format: 'image',
      options: { baseUrl: null, linkBrackets: ['[', ']'] }
    },
    { selector: 'main', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    { selector: 'nav', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: 'ol',
      format: 'orderedList',
      options: { leadingLineBreaks: 2, trailingLineBreaks: 2 }
    },
    { selector: 'p', format: 'paragraph', options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
    { selector: 'pre', format: 'pre', options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
    { selector: 'section', format: 'block', options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
    {
      selector: 'table',
      format: 'table',
      options: {
        colSpacing: 3,
        leadingLineBreaks: 2,
        maxColumnWidth: 60,
        rowSpacing: 0,
        trailingLineBreaks: 2,
        uppercaseHeaderCells: true
      }
    },
    {
      selector: 'ul',
      format: 'unorderedList',
      options: { itemPrefix: ' * ', leadingLineBreaks: 2, trailingLineBreaks: 2 }
    },
    { selector: 'wbr', format: 'wbr' },
  ],
  tables: [], // deprecated
  whitespaceCharacters: ' \t\r\n\f\u200b',
  wordwrap: 80
};

const concatMerge = (acc, src, options) => [...acc, ...src];
const overwriteMerge = (acc, src, options) => [...src];
const selectorsMerge = (acc, src, options) => (
  (acc.some(s => typeof s === 'object'))
    ? concatMerge(acc, src) // selectors
    : overwriteMerge(acc, src) // baseElements.selectors
);

/**
 * Preprocess options, compile selectors into a decision tree,
 * return a function intended for batch processing.
 *
 * @param   { Options } [options = {}]   HtmlToText options.
 * @returns { (html: string, metadata?: any) => string } Pre-configured converter function.
 * @static
 */
function compile (options = {}) {
  options = merge__default["default"](
    DEFAULT_OPTIONS,
    options,
    {
      arrayMerge: overwriteMerge,
      customMerge: (key) => ((key === 'selectors') ? selectorsMerge : undefined)
    }
  );
  options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);
  options.selectors = mergeDuplicatesPreferLast(options.selectors, (s => s.selector));

  handleDeprecatedOptions(options);

  return compile$1(options);
}

/**
 * Convert given HTML content to plain text string.
 *
 * @param   { string }  html           HTML content to convert.
 * @param   { Options } [options = {}] HtmlToText options.
 * @param   { any }     [metadata]     Optional metadata for HTML document, for use in formatters.
 * @returns { string }                 Plain text string.
 * @static
 *
 * @example
 * const { convert } = require('html-to-text');
 * const text = convert('<h1>Hello World</h1>', {
 *   wordwrap: 130
 * });
 * console.log(text); // HELLO WORLD
 */
function convert (html, options = {}, metadata = undefined) {
  return compile(options)(html, metadata);
}

/**
 * Map previously existing and now deprecated options to the new options layout.
 * This is a subject for cleanup in major releases.
 *
 * @param { Options } options HtmlToText options.
 */
function handleDeprecatedOptions (options) {
  if (options.tags) {
    const tagDefinitions = Object.entries(options.tags).map(
      ([selector, definition]) => ({ ...definition, selector: selector || '*' })
    );
    options.selectors.push(...tagDefinitions);
    options.selectors = mergeDuplicatesPreferLast(options.selectors, (s => s.selector));
  }

  function set (obj, path, value) {
    const valueKey = path.pop();
    for (const key of path) {
      let nested = obj[key];
      if (!nested) {
        nested = {};
        obj[key] = nested;
      }
      obj = nested;
    }
    obj[valueKey] = value;
  }

  if (options['baseElement']) {
    const baseElement = options['baseElement'];
    set(
      options,
      ['baseElements', 'selectors'],
      (Array.isArray(baseElement) ? baseElement : [baseElement])
    );
  }
  if (options['returnDomByDefault'] !== undefined) {
    set(options, ['baseElements', 'returnDomByDefault'], options['returnDomByDefault']);
  }

  for (const definition of options.selectors) {
    if (definition.format === 'anchor' && get(definition, ['options', 'noLinkBrackets'])) {
      set(definition, ['options', 'linkBrackets'], false);
    }
  }
}

__webpack_unused_export__ = compile;
exports.OQ = convert;
__webpack_unused_export__ = convert;


/***/ }),

/***/ 6549:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value:!0}));const e=/\n/g;function t(t){const o=[...t.matchAll(e)].map((e=>e.index||0));o.unshift(-1);const s=n(o,0,o.length);return e=>r(s,e)}function n(e,t,r){if(r-t==1)return{offset:e[t],index:t+1};const o=Math.ceil((t+r)/2),s=n(e,t,o),l=n(e,o,r);return{offset:s.offset,low:s,high:l}}function r(e,t){return function(e){return Object.prototype.hasOwnProperty.call(e,"index")}(e)?{line:e.index,column:t-e.offset}:r(e.high.offset<t?e.high:e.low,t)}function o(e,t){return{...e,regex:s(e,t)}}function s(e,t){if(0===e.name.length)throw new Error(`Rule #${t} has empty name, which is not allowed.`);if(function(e){return Object.prototype.hasOwnProperty.call(e,"regex")}(e))return function(e){if(e.global)throw new Error(`Regular expression /${e.source}/${e.flags} contains the global flag, which is not allowed.`);return e.sticky?e:new RegExp(e.source,e.flags+"y")}(e.regex);if(function(e){return Object.prototype.hasOwnProperty.call(e,"str")}(e)){if(0===e.str.length)throw new Error(`Rule #${t} ("${e.name}") has empty "str" property, which is not allowed.`);return new RegExp(l(e.str),"y")}return new RegExp(l(e.name),"y")}function l(e){return e.replace(/[-[\]{}()*+!<=:?./\\^$|#\s,]/g,"\\$&")}exports.createLexer=function(e,n="",r={}){const s="string"!=typeof n?n:r,l="string"==typeof n?n:"",c=e.map(o),i=!!s.lineNumbers;return function(e,n=0){const r=i?t(e):()=>({line:0,column:0});let o=n;const s=[];e:for(;o<e.length;){let t=!1;for(const n of c){n.regex.lastIndex=o;const c=n.regex.exec(e);if(c&&c[0].length>0){if(!n.discard){const e=r(o),t="string"==typeof n.replace?c[0].replace(new RegExp(n.regex.source,n.regex.flags),n.replace):c[0];s.push({state:l,name:n.name,text:t,offset:o,len:c[0].length,line:e.line,column:e.column})}if(o=n.regex.lastIndex,t=!0,n.push){const t=n.push(e,o);s.push(...t.tokens),o=t.offset}if(n.pop)break e;break}}if(!t)break}return{tokens:s,offset:o,complete:e.length<=o}}};


/***/ }),

/***/ 2425:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var leac = __nccwpck_require__(6549);
var p = __nccwpck_require__(6986);

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var p__namespace = /*#__PURE__*/_interopNamespace(p);

var ast = /*#__PURE__*/Object.freeze({
    __proto__: null
});

const lex = leac.createLexer([
    { name: 'ws', regex: /[ \t\r\n\f]+/ },
    { name: 'idn', regex: /[a-zA-Z_-][a-zA-Z0-9_-]*/ },
    { name: '#id', regex: /#[a-zA-Z0-9_-]+/ },
    { name: 'str1', regex: /'(?:\\['\\]|[^\n'\\])*'/ },
    { name: 'str2', regex: /"(?:\\["\\]|[^\n"\\])*"/ },
    { name: '*' },
    { name: '.' },
    { name: ',' },
    { name: '[' },
    { name: ']' },
    { name: '=' },
    { name: '>' },
    { name: '|' },
    { name: '+' },
    { name: '~' },
    { name: '^' },
    { name: '$' },
]);
function sumSpec([a0, a1, a2], [b0, b1, b2]) {
    return [a0 + b0, a1 + b1, a2 + b2];
}
function sumAllSpec(ss) {
    return ss.reduce(sumSpec, [0, 0, 0]);
}
function literal(name) {
    return p__namespace.token((t) => t.name === name ? true : undefined);
}
const whitespace_ = p__namespace.token((t) => t.name === 'ws' ? null : undefined);
const optionalWhitespace_ = p__namespace.option(whitespace_, null);
function optionallySpaced(parser) {
    return p__namespace.middle(optionalWhitespace_, parser, optionalWhitespace_);
}
const identifier_ = p__namespace.token((t) => t.name === 'idn' ? t.text : undefined);
const hashId_ = p__namespace.token((t) => t.name === '#id' ? t.text.slice(1) : undefined);
const string_ = p__namespace.token((t) => t.name.startsWith('str') ? t.text.slice(1, -1) : undefined);
const namespace_ = p__namespace.left(p__namespace.option(identifier_, ''), literal('|'));
const qualifiedName_ = p__namespace.eitherOr(p__namespace.ab(namespace_, identifier_, (ns, name) => ({ name: name, namespace: ns })), p__namespace.map(identifier_, (name) => ({ name: name, namespace: null })));
const uniSelector_ = p__namespace.eitherOr(p__namespace.ab(namespace_, literal('*'), (ns) => ({ type: 'universal', namespace: ns, specificity: [0, 0, 0] })), p__namespace.map(literal('*'), () => ({ type: 'universal', namespace: null, specificity: [0, 0, 0] })));
const tagSelector_ = p__namespace.map(qualifiedName_, ({ name, namespace }) => ({
    type: 'tag',
    name: name,
    namespace: namespace,
    specificity: [0, 0, 1]
}));
const classSelector_ = p__namespace.ab(literal('.'), identifier_, (fullstop, name) => ({
    type: 'class',
    name: name,
    specificity: [0, 1, 0]
}));
const idSelector_ = p__namespace.map(hashId_, (name) => ({
    type: 'id',
    name: name,
    specificity: [1, 0, 0]
}));
const attrModifier_ = p__namespace.token((t) => {
    if (t.name === 'idn') {
        if (t.text === 'i' || t.text === 'I') {
            return 'i';
        }
        if (t.text === 's' || t.text === 'S') {
            return 's';
        }
    }
    return undefined;
});
const attrValue_ = p__namespace.eitherOr(p__namespace.ab(string_, p__namespace.option(p__namespace.right(optionalWhitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })), p__namespace.ab(identifier_, p__namespace.option(p__namespace.right(whitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })));
const attrMatcher_ = p__namespace.choice(p__namespace.map(literal('='), () => '='), p__namespace.ab(literal('~'), literal('='), () => '~='), p__namespace.ab(literal('|'), literal('='), () => '|='), p__namespace.ab(literal('^'), literal('='), () => '^='), p__namespace.ab(literal('$'), literal('='), () => '$='), p__namespace.ab(literal('*'), literal('='), () => '*='));
const attrPresenceSelector_ = p__namespace.abc(literal('['), optionallySpaced(qualifiedName_), literal(']'), (lbr, { name, namespace }) => ({
    type: 'attrPresence',
    name: name,
    namespace: namespace,
    specificity: [0, 1, 0]
}));
const attrValueSelector_ = p__namespace.middle(literal('['), p__namespace.abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({ name, namespace }, matcher, { value, modifier }) => ({
    type: 'attrValue',
    name: name,
    namespace: namespace,
    matcher: matcher,
    value: value,
    modifier: modifier,
    specificity: [0, 1, 0]
})), literal(']'));
const attrSelector_ = p__namespace.eitherOr(attrPresenceSelector_, attrValueSelector_);
const typeSelector_ = p__namespace.eitherOr(uniSelector_, tagSelector_);
const subclassSelector_ = p__namespace.choice(idSelector_, classSelector_, attrSelector_);
const compoundSelector_ = p__namespace.map(p__namespace.eitherOr(p__namespace.flatten(typeSelector_, p__namespace.many(subclassSelector_)), p__namespace.many1(subclassSelector_)), (ss) => {
    return {
        type: 'compound',
        list: ss,
        specificity: sumAllSpec(ss.map(s => s.specificity))
    };
});
const combinator_ = p__namespace.choice(p__namespace.map(literal('>'), () => '>'), p__namespace.map(literal('+'), () => '+'), p__namespace.map(literal('~'), () => '~'), p__namespace.ab(literal('|'), literal('|'), () => '||'));
const combinatorSeparator_ = p__namespace.eitherOr(optionallySpaced(combinator_), p__namespace.map(whitespace_, () => ' '));
const complexSelector_ = p__namespace.leftAssoc2(compoundSelector_, p__namespace.map(combinatorSeparator_, (c) => (left, right) => ({
    type: 'compound',
    list: [...right.list, { type: 'combinator', combinator: c, left: left, specificity: left.specificity }],
    specificity: sumSpec(left.specificity, right.specificity)
})), compoundSelector_);
const listSelector_ = p__namespace.leftAssoc2(p__namespace.map(complexSelector_, (s) => ({ type: 'list', list: [s] })), p__namespace.map(optionallySpaced(literal(',')), () => (acc, next) => ({ type: 'list', list: [...acc.list, next] })), complexSelector_);
function parse_(parser, str) {
    const lexerResult = lex(str);
    if (!lexerResult.complete) {
        throw new Error(`The input "${str}" was only partially tokenized, stopped at offset ${lexerResult.offset}!\n` +
            prettyPrintPosition(str, lexerResult.offset));
    }
    const result = optionallySpaced(parser)({ tokens: lexerResult.tokens, options: undefined }, 0);
    if (!result.matched) {
        throw new Error(`No match for "${str}" input!`);
    }
    if (result.position < lexerResult.tokens.length) {
        const token = lexerResult.tokens[result.position];
        throw new Error(`The input "${str}" was only partially parsed, stopped at offset ${token.offset}!\n` +
            prettyPrintPosition(str, token.offset, token.len));
    }
    return result.value;
}
function prettyPrintPosition(str, offset, len = 1) {
    return `${str.replace(/(\t)|(\r)|(\n)/g, (m, t, r) => t ? '\u2409' : r ? '\u240d' : '\u240a')}\n${''.padEnd(offset)}${'^'.repeat(len)}`;
}
function parse(str) {
    return parse_(listSelector_, str);
}
function parse1(str) {
    return parse_(complexSelector_, str);
}

function serialize(selector) {
    if (!selector.type) {
        throw new Error('This is not an AST node.');
    }
    switch (selector.type) {
        case 'universal':
            return _serNs(selector.namespace) + '*';
        case 'tag':
            return _serNs(selector.namespace) + selector.name;
        case 'class':
            return '.' + selector.name;
        case 'id':
            return '#' + selector.name;
        case 'attrPresence':
            return `[${_serNs(selector.namespace)}${selector.name}]`;
        case 'attrValue':
            return `[${_serNs(selector.namespace)}${selector.name}${selector.matcher}${_serStr(selector.value)}${(selector.modifier ? selector.modifier : '')}]`;
        case 'combinator':
            return serialize(selector.left) + selector.combinator;
        case 'compound':
            return selector.list.reduce((acc, node) => {
                if (node.type === 'combinator') {
                    return serialize(node) + acc;
                }
                else {
                    return acc + serialize(node);
                }
            }, '');
        case 'list':
            return selector.list.map(serialize).join(',');
    }
}
function _serNs(ns) {
    return (ns || ns === '')
        ? ns + '|'
        : '';
}
function _serStr(str) {
    if (str.indexOf('"') === -1) {
        return `"${str}"`;
    }
    else if (str.indexOf("'") === -1) {
        return `'${str}'`;
    }
    else {
        return `"${str.replace('"', '\\"')}"`;
    }
}
function normalize(selector) {
    if (!selector.type) {
        throw new Error('This is not an AST node.');
    }
    switch (selector.type) {
        case 'compound': {
            selector.list.forEach(normalize);
            selector.list.sort((a, b) => _compareArrays(_getSelectorPriority(a), _getSelectorPriority(b)));
            break;
        }
        case 'combinator': {
            normalize(selector.left);
            break;
        }
        case 'list': {
            selector.list.forEach(normalize);
            selector.list.sort((a, b) => (serialize(a) < serialize(b)) ? -1 : 1);
            break;
        }
    }
    return selector;
}
function _getSelectorPriority(selector) {
    switch (selector.type) {
        case 'universal':
            return [1];
        case 'tag':
            return [1];
        case 'id':
            return [2];
        case 'class':
            return [3, selector.name];
        case 'attrPresence':
            return [4, serialize(selector)];
        case 'attrValue':
            return [5, serialize(selector)];
        case 'combinator':
            return [15, serialize(selector)];
    }
}
function compareSelectors(a, b) {
    return _compareArrays(a.specificity, b.specificity);
}
function compareSpecificity(a, b) {
    return _compareArrays(a, b);
}
function _compareArrays(a, b) {
    if (!Array.isArray(a) || !Array.isArray(b)) {
        throw new Error('Arguments must be arrays.');
    }
    const shorter = (a.length < b.length) ? a.length : b.length;
    for (let i = 0; i < shorter; i++) {
        if (a[i] === b[i]) {
            continue;
        }
        return (a[i] < b[i]) ? -1 : 1;
    }
    return a.length - b.length;
}

exports.Ast = ast;
exports.compareSelectors = compareSelectors;
exports.compareSpecificity = compareSpecificity;
exports.normalize = normalize;
exports.parse = parse;
exports.parse1 = parse1;
exports.serialize = serialize;


/***/ }),

/***/ 6986:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var util = __nccwpck_require__(124);

function emit(value) {
    return (data, i) => ({
        matched: true,
        position: i,
        value: value
    });
}
function make(
f) {
    return (data, i) => ({
        matched: true,
        position: i,
        value: f(data, i)
    });
}
function action(
f) {
    return (data, i) => {
        f(data, i);
        return {
            matched: true,
            position: i,
            value: null
        };
    };
}
function fail(
data, i) {
    return { matched: false };
}
function error(message) {
    return (data, i) => {
        throw new Error((message instanceof Function) ? message(data, i) : message);
    };
}
function token(
onToken,
onEnd) {
    return (data, i) => {
        let position = i;
        let value = undefined;
        if (i < data.tokens.length) {
            value = onToken(data.tokens[i], data, i);
            if (value !== undefined) {
                position++;
            }
        }
        else {
            onEnd?.(data, i);
        }
        return (value === undefined)
            ? { matched: false }
            : {
                matched: true,
                position: position,
                value: value
            };
    };
}
function any(data, i) {
    return (i < data.tokens.length)
        ? {
            matched: true,
            position: i + 1,
            value: data.tokens[i]
        }
        : { matched: false };
}
function satisfy(
test) {
    return (data, i) => (i < data.tokens.length && test(data.tokens[i], data, i))
        ? {
            matched: true,
            position: i + 1,
            value: data.tokens[i]
        }
        : { matched: false };
}
function mapInner(r, f) {
    return (r.matched) ? ({
        matched: true,
        position: r.position,
        value: f(r.value, r.position)
    }) : r;
}
function mapOuter(r, f) {
    return (r.matched) ? f(r) : r;
}
function map(p, mapper) {
    return (data, i) => mapInner(p(data, i), (v, j) => mapper(v, data, i, j));
}
function map1(p,
mapper) {
    return (data, i) => mapOuter(p(data, i), (m) => mapper(m, data, i));
}
function peek(p, f) {
    return (data, i) => {
        const r = p(data, i);
        f(r, data, i);
        return r;
    };
}
function option(p, def) {
    return (data, i) => {
        const r = p(data, i);
        return (r.matched)
            ? r
            : {
                matched: true,
                position: i,
                value: def
            };
    };
}
function not(p) {
    return (data, i) => {
        const r = p(data, i);
        return (r.matched)
            ? { matched: false }
            : {
                matched: true,
                position: i,
                value: true
            };
    };
}
function choice(...ps) {
    return (data, i) => {
        for (const p of ps) {
            const result = p(data, i);
            if (result.matched) {
                return result;
            }
        }
        return { matched: false };
    };
}
function otherwise(pa, pb) {
    return (data, i) => {
        const r1 = pa(data, i);
        return (r1.matched)
            ? r1
            : pb(data, i);
    };
}
function longest(...ps) {
    return (data, i) => {
        let match = undefined;
        for (const p of ps) {
            const result = p(data, i);
            if (result.matched && (!match || match.position < result.position)) {
                match = result;
            }
        }
        return match || { matched: false };
    };
}
function takeWhile(p,
test) {
    return (data, i) => {
        const values = [];
        let success = true;
        do {
            const r = p(data, i);
            if (r.matched && test(r.value, values.length + 1, data, i, r.position)) {
                values.push(r.value);
                i = r.position;
            }
            else {
                success = false;
            }
        } while (success);
        return {
            matched: true,
            position: i,
            value: values
        };
    };
}
function takeUntil(p,
test) {
    return takeWhile(p, (value, n, data, i, j) => !test(value, n, data, i, j));
}
function takeWhileP(pValue, pTest) {
    return takeWhile(pValue, (value, n, data, i) => pTest(data, i).matched);
}
function takeUntilP(pValue, pTest) {
    return takeWhile(pValue, (value, n, data, i) => !pTest(data, i).matched);
}
function many(p) {
    return takeWhile(p, () => true);
}
function many1(p) {
    return ab(p, many(p), (head, tail) => [head, ...tail]);
}
function ab(pa, pb,
join) {
    return (data, i) => mapOuter(pa(data, i), (ma) => mapInner(pb(data, ma.position), (vb, j) => join(ma.value, vb, data, i, j)));
}
function left(pa, pb) {
    return ab(pa, pb, (va) => va);
}
function right(pa, pb) {
    return ab(pa, pb, (va, vb) => vb);
}
function abc(pa, pb, pc,
join) {
    return (data, i) => mapOuter(pa(data, i), (ma) => mapOuter(pb(data, ma.position), (mb) => mapInner(pc(data, mb.position), (vc, j) => join(ma.value, mb.value, vc, data, i, j))));
}
function middle(pa, pb, pc) {
    return abc(pa, pb, pc, (ra, rb) => rb);
}
function all(...ps) {
    return (data, i) => {
        const result = [];
        let position = i;
        for (const p of ps) {
            const r1 = p(data, position);
            if (r1.matched) {
                result.push(r1.value);
                position = r1.position;
            }
            else {
                return { matched: false };
            }
        }
        return {
            matched: true,
            position: position,
            value: result
        };
    };
}
function skip(...ps) {
    return map(all(...ps), () => null);
}
function flatten(...ps) {
    return flatten1(all(...ps));
}
function flatten1(p) {
    return map(p, (vs) => vs.flatMap((v) => v));
}
function sepBy1(pValue, pSep) {
    return ab(pValue, many(right(pSep, pValue)), (head, tail) => [head, ...tail]);
}
function sepBy(pValue, pSep) {
    return otherwise(sepBy1(pValue, pSep), emit([]));
}
function chainReduce(acc,
f) {
    return (data, i) => {
        let loop = true;
        let acc1 = acc;
        let pos = i;
        do {
            const r = f(acc1, data, pos)(data, pos);
            if (r.matched) {
                acc1 = r.value;
                pos = r.position;
            }
            else {
                loop = false;
            }
        } while (loop);
        return {
            matched: true,
            position: pos,
            value: acc1
        };
    };
}
function reduceLeft(acc, p,
reducer) {
    return chainReduce(acc, (acc) => map(p, (v, data, i, j) => reducer(acc, v, data, i, j)));
}
function reduceRight(p, acc,
reducer) {
    return map(many(p), (vs, data, i, j) => vs.reduceRight((acc, v) => reducer(v, acc, data, i, j), acc));
}
function leftAssoc1(pLeft, pOper) {
    return chain(pLeft, (v0) => reduceLeft(v0, pOper, (acc, f) => f(acc)));
}
function rightAssoc1(pOper, pRight) {
    return ab(reduceRight(pOper, (y) => y, (f, acc) => (y) => f(acc(y))), pRight, (f, v) => f(v));
}
function leftAssoc2(pLeft, pOper, pRight) {
    return chain(pLeft, (v0) => reduceLeft(v0, ab(pOper, pRight, (f, y) => [f, y]), (acc, [f, y]) => f(acc, y)));
}
function rightAssoc2(pLeft, pOper, pRight) {
    return ab(reduceRight(ab(pLeft, pOper, (x, f) => [x, f]), (y) => y, ([x, f], acc) => (y) => f(x, acc(y))), pRight, (f, v) => f(v));
}
function condition(
cond, pTrue, pFalse) {
    return (data, i) => (cond(data, i))
        ? pTrue(data, i)
        : pFalse(data, i);
}
function decide(p) {
    return (data, i) => mapOuter(p(data, i), (m1) => m1.value(data, m1.position));
}
function chain(p,
f) {
    return (data, i) => mapOuter(p(data, i), (m1) => f(m1.value, data, i, m1.position)(data, m1.position));
}
function ahead(p) {
    return (data, i) => mapOuter(p(data, i), (m1) => ({
        matched: true,
        position: i,
        value: m1.value
    }));
}
function recursive(f) {
    return function (data, i) {
        return f()(data, i);
    };
}
function start(data, i) {
    return (i !== 0)
        ? { matched: false }
        : {
            matched: true,
            position: i,
            value: true
        };
}
function end(data, i) {
    return (i < data.tokens.length)
        ? { matched: false }
        : {
            matched: true,
            position: i,
            value: true
        };
}
function remainingTokensNumber(data, i) {
    return data.tokens.length - i;
}
function parserPosition(data, i, formatToken, contextTokens = 3) {
    const len = data.tokens.length;
    const lowIndex = util.clamp(0, i - contextTokens, len - contextTokens);
    const highIndex = util.clamp(contextTokens, i + 1 + contextTokens, len);
    const tokensSlice = data.tokens.slice(lowIndex, highIndex);
    const lines = [];
    const indexWidth = String(highIndex - 1).length + 1;
    if (i < 0) {
        lines.push(`${String(i).padStart(indexWidth)} >>`);
    }
    if (0 < lowIndex) {
        lines.push('...'.padStart(indexWidth + 6));
    }
    for (let j = 0; j < tokensSlice.length; j++) {
        const index = lowIndex + j;
        lines.push(`${String(index).padStart(indexWidth)} ${(index === i ? '>' : ' ')} ${util.escapeWhitespace(formatToken(tokensSlice[j]))}`);
    }
    if (highIndex < len) {
        lines.push('...'.padStart(indexWidth + 6));
    }
    if (len <= i) {
        lines.push(`${String(i).padStart(indexWidth)} >>`);
    }
    return lines.join('\n');
}
function parse(parser, tokens, options, formatToken = JSON.stringify) {
    const data = { tokens: tokens, options: options };
    const result = parser(data, 0);
    if (!result.matched) {
        throw new Error('No match');
    }
    if (result.position < data.tokens.length) {
        throw new Error(`Partial match. Parsing stopped at:\n${parserPosition(data, result.position, formatToken)}`);
    }
    return result.value;
}
function tryParse(parser, tokens, options) {
    const result = parser({ tokens: tokens, options: options }, 0);
    return (result.matched)
        ? result.value
        : undefined;
}
function match(matcher, tokens, options) {
    const result = matcher({ tokens: tokens, options: options }, 0);
    return result.value;
}

exports.ab = ab;
exports.abc = abc;
exports.action = action;
exports.ahead = ahead;
exports.all = all;
exports.and = all;
exports.any = any;
exports.chain = chain;
exports.chainReduce = chainReduce;
exports.choice = choice;
exports.condition = condition;
exports.decide = decide;
exports.discard = skip;
exports.eitherOr = otherwise;
exports.emit = emit;
exports.end = end;
exports.eof = end;
exports.error = error;
exports.fail = fail;
exports.flatten = flatten;
exports.flatten1 = flatten1;
exports.left = left;
exports.leftAssoc1 = leftAssoc1;
exports.leftAssoc2 = leftAssoc2;
exports.longest = longest;
exports.lookAhead = ahead;
exports.make = make;
exports.many = many;
exports.many1 = many1;
exports.map = map;
exports.map1 = map1;
exports.match = match;
exports.middle = middle;
exports.not = not;
exports.of = emit;
exports.option = option;
exports.or = choice;
exports.otherwise = otherwise;
exports.parse = parse;
exports.parserPosition = parserPosition;
exports.peek = peek;
exports.recursive = recursive;
exports.reduceLeft = reduceLeft;
exports.reduceRight = reduceRight;
exports.remainingTokensNumber = remainingTokensNumber;
exports.right = right;
exports.rightAssoc1 = rightAssoc1;
exports.rightAssoc2 = rightAssoc2;
exports.satisfy = satisfy;
exports.sepBy = sepBy;
exports.sepBy1 = sepBy1;
exports.skip = skip;
exports.some = many1;
exports.start = start;
exports.takeUntil = takeUntil;
exports.takeUntilP = takeUntilP;
exports.takeWhile = takeWhile;
exports.takeWhileP = takeWhileP;
exports.token = token;
exports.tryParse = tryParse;


/***/ }),

/***/ 124:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

function clamp(left, x, right) {
    return Math.max(left, Math.min(x, right));
}
function escapeWhitespace(str) {
    return str.replace(/(\t)|(\r)|(\n)/g, (m, t, r) => t ? '\\t' : r ? '\\r' : '\\n');
}

exports.clamp = clamp;
exports.escapeWhitespace = escapeWhitespace;


/***/ }),

/***/ 5178:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var parseley = __nccwpck_require__(2425);

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var parseley__namespace = /*#__PURE__*/_interopNamespace(parseley);

var Ast = /*#__PURE__*/Object.freeze({
    __proto__: null
});

var Types = /*#__PURE__*/Object.freeze({
    __proto__: null
});

const treeify = (nodes) => '▽\n' + treeifyArray(nodes, thinLines);
const thinLines = [['├─', '│ '], ['└─', '  ']];
const heavyLines = [['┠─', '┃ '], ['┖─', '  ']];
const doubleLines = [['╟─', '║ '], ['╙─', '  ']];
function treeifyArray(nodes, tpl = heavyLines) {
    return prefixItems(tpl, nodes.map(n => treeifyNode(n)));
}
function treeifyNode(node) {
    switch (node.type) {
        case 'terminal': {
            const vctr = node.valueContainer;
            return `◁ #${vctr.index} ${JSON.stringify(vctr.specificity)} ${vctr.value}`;
        }
        case 'tagName':
            return `◻ Tag name\n${treeifyArray(node.variants, doubleLines)}`;
        case 'attrValue':
            return `▣ Attr value: ${node.name}\n${treeifyArray(node.matchers, doubleLines)}`;
        case 'attrPresence':
            return `◨ Attr presence: ${node.name}\n${treeifyArray(node.cont)}`;
        case 'pushElement':
            return `◉ Push element: ${node.combinator}\n${treeifyArray(node.cont, thinLines)}`;
        case 'popElement':
            return `◌ Pop element\n${treeifyArray(node.cont, thinLines)}`;
        case 'variant':
            return `◇ = ${node.value}\n${treeifyArray(node.cont)}`;
        case 'matcher':
            return `◈ ${node.matcher} "${node.value}"${node.modifier || ''}\n${treeifyArray(node.cont)}`;
    }
}
function prefixItems(tpl, items) {
    return items
        .map((item, i, { length }) => prefixItem(tpl, item, i === length - 1))
        .join('\n');
}
function prefixItem(tpl, item, tail = true) {
    const tpl1 = tpl[tail ? 1 : 0];
    return tpl1[0] + item.split('\n').join('\n' + tpl1[1]);
}

var TreeifyBuilder = /*#__PURE__*/Object.freeze({
    __proto__: null,
    treeify: treeify
});

class DecisionTree {
    constructor(input) {
        this.branches = weave(toAstTerminalPairs(input));
    }
    build(builder) {
        return builder(this.branches);
    }
}
function toAstTerminalPairs(array) {
    const len = array.length;
    const results = new Array(len);
    for (let i = 0; i < len; i++) {
        const [selectorString, val] = array[i];
        const ast = preprocess(parseley__namespace.parse1(selectorString));
        results[i] = {
            ast: ast,
            terminal: {
                type: 'terminal',
                valueContainer: { index: i, value: val, specificity: ast.specificity }
            }
        };
    }
    return results;
}
function preprocess(ast) {
    reduceSelectorVariants(ast);
    parseley__namespace.normalize(ast);
    return ast;
}
function reduceSelectorVariants(ast) {
    const newList = [];
    ast.list.forEach(sel => {
        switch (sel.type) {
            case 'class':
                newList.push({
                    matcher: '~=',
                    modifier: null,
                    name: 'class',
                    namespace: null,
                    specificity: sel.specificity,
                    type: 'attrValue',
                    value: sel.name,
                });
                break;
            case 'id':
                newList.push({
                    matcher: '=',
                    modifier: null,
                    name: 'id',
                    namespace: null,
                    specificity: sel.specificity,
                    type: 'attrValue',
                    value: sel.name,
                });
                break;
            case 'combinator':
                reduceSelectorVariants(sel.left);
                newList.push(sel);
                break;
            case 'universal':
                break;
            default:
                newList.push(sel);
                break;
        }
    });
    ast.list = newList;
}
function weave(items) {
    const branches = [];
    while (items.length) {
        const topKind = findTopKey(items, (sel) => true, getSelectorKind);
        const { matches, nonmatches, empty } = breakByKind(items, topKind);
        items = nonmatches;
        if (matches.length) {
            branches.push(branchOfKind(topKind, matches));
        }
        if (empty.length) {
            branches.push(...terminate(empty));
        }
    }
    return branches;
}
function terminate(items) {
    const results = [];
    for (const item of items) {
        const terminal = item.terminal;
        if (terminal.type === 'terminal') {
            results.push(terminal);
        }
        else {
            const { matches, rest } = partition(terminal.cont, (node) => node.type === 'terminal');
            matches.forEach((node) => results.push(node));
            if (rest.length) {
                terminal.cont = rest;
                results.push(terminal);
            }
        }
    }
    return results;
}
function breakByKind(items, selectedKind) {
    const matches = [];
    const nonmatches = [];
    const empty = [];
    for (const item of items) {
        const simpsels = item.ast.list;
        if (simpsels.length) {
            const isMatch = simpsels.some(node => getSelectorKind(node) === selectedKind);
            (isMatch ? matches : nonmatches).push(item);
        }
        else {
            empty.push(item);
        }
    }
    return { matches, nonmatches, empty };
}
function getSelectorKind(sel) {
    switch (sel.type) {
        case 'attrPresence':
            return `attrPresence ${sel.name}`;
        case 'attrValue':
            return `attrValue ${sel.name}`;
        case 'combinator':
            return `combinator ${sel.combinator}`;
        default:
            return sel.type;
    }
}
function branchOfKind(kind, items) {
    if (kind === 'tag') {
        return tagNameBranch(items);
    }
    if (kind.startsWith('attrValue ')) {
        return attrValueBranch(kind.substring(10), items);
    }
    if (kind.startsWith('attrPresence ')) {
        return attrPresenceBranch(kind.substring(13), items);
    }
    if (kind === 'combinator >') {
        return combinatorBranch('>', items);
    }
    if (kind === 'combinator +') {
        return combinatorBranch('+', items);
    }
    throw new Error(`Unsupported selector kind: ${kind}`);
}
function tagNameBranch(items) {
    const groups = spliceAndGroup(items, (x) => x.type === 'tag', (x) => x.name);
    const variants = Object.entries(groups).map(([name, group]) => ({
        type: 'variant',
        value: name,
        cont: weave(group.items)
    }));
    return {
        type: 'tagName',
        variants: variants
    };
}
function attrPresenceBranch(name, items) {
    for (const item of items) {
        spliceSimpleSelector(item, (x) => (x.type === 'attrPresence') && (x.name === name));
    }
    return {
        type: 'attrPresence',
        name: name,
        cont: weave(items)
    };
}
function attrValueBranch(name, items) {
    const groups = spliceAndGroup(items, (x) => (x.type === 'attrValue') && (x.name === name), (x) => `${x.matcher} ${x.modifier || ''} ${x.value}`);
    const matchers = [];
    for (const group of Object.values(groups)) {
        const sel = group.oneSimpleSelector;
        const predicate = getAttrPredicate(sel);
        const continuation = weave(group.items);
        matchers.push({
            type: 'matcher',
            matcher: sel.matcher,
            modifier: sel.modifier,
            value: sel.value,
            predicate: predicate,
            cont: continuation
        });
    }
    return {
        type: 'attrValue',
        name: name,
        matchers: matchers
    };
}
function getAttrPredicate(sel) {
    if (sel.modifier === 'i') {
        const expected = sel.value.toLowerCase();
        switch (sel.matcher) {
            case '=':
                return (actual) => expected === actual.toLowerCase();
            case '~=':
                return (actual) => actual.toLowerCase().split(/[ \t]+/).includes(expected);
            case '^=':
                return (actual) => actual.toLowerCase().startsWith(expected);
            case '$=':
                return (actual) => actual.toLowerCase().endsWith(expected);
            case '*=':
                return (actual) => actual.toLowerCase().includes(expected);
            case '|=':
                return (actual) => {
                    const lower = actual.toLowerCase();
                    return (expected === lower) || (lower.startsWith(expected) && lower[expected.length] === '-');
                };
        }
    }
    else {
        const expected = sel.value;
        switch (sel.matcher) {
            case '=':
                return (actual) => expected === actual;
            case '~=':
                return (actual) => actual.split(/[ \t]+/).includes(expected);
            case '^=':
                return (actual) => actual.startsWith(expected);
            case '$=':
                return (actual) => actual.endsWith(expected);
            case '*=':
                return (actual) => actual.includes(expected);
            case '|=':
                return (actual) => (expected === actual) || (actual.startsWith(expected) && actual[expected.length] === '-');
        }
    }
}
function combinatorBranch(combinator, items) {
    const groups = spliceAndGroup(items, (x) => (x.type === 'combinator') && (x.combinator === combinator), (x) => parseley__namespace.serialize(x.left));
    const leftItems = [];
    for (const group of Object.values(groups)) {
        const rightCont = weave(group.items);
        const leftAst = group.oneSimpleSelector.left;
        leftItems.push({
            ast: leftAst,
            terminal: { type: 'popElement', cont: rightCont }
        });
    }
    return {
        type: 'pushElement',
        combinator: combinator,
        cont: weave(leftItems)
    };
}
function spliceAndGroup(items, predicate, keyCallback) {
    const groups = {};
    while (items.length) {
        const bestKey = findTopKey(items, predicate, keyCallback);
        const bestKeyPredicate = (sel) => predicate(sel) && keyCallback(sel) === bestKey;
        const hasBestKeyPredicate = (item) => item.ast.list.some(bestKeyPredicate);
        const { matches, rest } = partition1(items, hasBestKeyPredicate);
        let oneSimpleSelector = null;
        for (const item of matches) {
            const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);
            if (!oneSimpleSelector) {
                oneSimpleSelector = splicedNode;
            }
        }
        if (oneSimpleSelector == null) {
            throw new Error('No simple selector is found.');
        }
        groups[bestKey] = { oneSimpleSelector: oneSimpleSelector, items: matches };
        items = rest;
    }
    return groups;
}
function spliceSimpleSelector(item, predicate) {
    const simpsels = item.ast.list;
    const matches = new Array(simpsels.length);
    let firstIndex = -1;
    for (let i = simpsels.length; i-- > 0;) {
        if (predicate(simpsels[i])) {
            matches[i] = true;
            firstIndex = i;
        }
    }
    if (firstIndex == -1) {
        throw new Error(`Couldn't find the required simple selector.`);
    }
    const result = simpsels[firstIndex];
    item.ast.list = simpsels.filter((sel, i) => !matches[i]);
    return result;
}
function findTopKey(items, predicate, keyCallback) {
    const candidates = {};
    for (const item of items) {
        const candidates1 = {};
        for (const node of item.ast.list.filter(predicate)) {
            candidates1[keyCallback(node)] = true;
        }
        for (const key of Object.keys(candidates1)) {
            if (candidates[key]) {
                candidates[key]++;
            }
            else {
                candidates[key] = 1;
            }
        }
    }
    let topKind = '';
    let topCounter = 0;
    for (const entry of Object.entries(candidates)) {
        if (entry[1] > topCounter) {
            topKind = entry[0];
            topCounter = entry[1];
        }
    }
    return topKind;
}
function partition(src, predicate) {
    const matches = [];
    const rest = [];
    for (const x of src) {
        if (predicate(x)) {
            matches.push(x);
        }
        else {
            rest.push(x);
        }
    }
    return { matches, rest };
}
function partition1(src, predicate) {
    const matches = [];
    const rest = [];
    for (const x of src) {
        if (predicate(x)) {
            matches.push(x);
        }
        else {
            rest.push(x);
        }
    }
    return { matches, rest };
}

class Picker {
    constructor(f) {
        this.f = f;
    }
    pickAll(el) {
        return this.f(el);
    }
    pick1(el, preferFirst = false) {
        const results = this.f(el);
        const len = results.length;
        if (len === 0) {
            return null;
        }
        if (len === 1) {
            return results[0].value;
        }
        const comparator = (preferFirst)
            ? comparatorPreferFirst
            : comparatorPreferLast;
        let result = results[0];
        for (let i = 1; i < len; i++) {
            const next = results[i];
            if (comparator(result, next)) {
                result = next;
            }
        }
        return result.value;
    }
}
function comparatorPreferFirst(acc, next) {
    const diff = parseley.compareSpecificity(next.specificity, acc.specificity);
    return diff > 0 || (diff === 0 && next.index < acc.index);
}
function comparatorPreferLast(acc, next) {
    const diff = parseley.compareSpecificity(next.specificity, acc.specificity);
    return diff > 0 || (diff === 0 && next.index > acc.index);
}

exports.Ast = Ast;
exports.DecisionTree = DecisionTree;
exports.Picker = Picker;
exports.Treeify = TreeifyBuilder;
exports.Types = Types;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + "/";
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
let Asciidoctor = __nccwpck_require__(853);
let convert = (__nccwpck_require__(3012)/* .convert */ .OQ);

const asciidoc = Asciidoctor();

const parse = (content) => {
  const doc = asciidoc.load(content);

  const sections = doc
    .getSections()
    .map((section) => formatSection(section, content))
    .reduce((acc, prev) => [...acc, ...prev], []);

  return {
    title: doc
      .getTitle()
      .replace("RFD", "")
      .replace("# ", "")
      .replace("= ", "")
      .trim()
      .split(' ')
      .slice(1)
      .join(' '),
    sections
  };
};

const formatSection = (section, content) => {
  const formattedSections = [];
  for (const s of section.getSections()) {
    formattedSections.push(...formatSection(s, content));
  }
  const parentSections = [];
  let level = section.getLevel() - 1;
  let currSection = section.getParent();

  while (level-- && currSection) {
    parentSections.push(currSection.getName());
    currSection = currSection.getParent();
  }

  return [
    {
      section_id: section.getId(),
      name: section.getName(),
      content: convert(
        section
          .getBlocks()
          .filter((block) => block.context !== "section")
          .map((block) => block.convert())
          .join("")
      ),
      parents: parentSections
    },
    ...formattedSections,
  ];
};

let content = (__nccwpck_require__(7147).readFileSync)(0, 'utf-8');
console.log(JSON.stringify(parse(content)))
})();

module.exports = __webpack_exports__;
/******/ })()
;