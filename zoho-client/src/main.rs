use std::{collections::HashMap, fs, io::Write};

use anyhow::Result;

pub mod client;
pub mod modules;

#[tokio::main]
async fn main() -> Result<()> {
    // This map contains known necessary field overrides where the field type returned
    // from the settings API does not match up against the type of actual values
    let mut overrides: HashMap<(&str, &str), &str> = HashMap::new();
    overrides.insert(("Accounts", "layout"), "serde_json::Value");

    let client = crate::client::Zoho::new_from_env();
    client
        .refresh_access_token()
        .await
        .expect("Failed to refresh access token");

    let mut out = r#"
///
/// Do not edit this file manually. It is generated from the Zoho metadata APIs
/// 

use serde::{Deserialize, Serialize};
use crate::client::RecordsModule;
"#
    .to_string();

    let mut module_struct_names = vec![];

    for module in client.modules().await?.modules.iter() {
        if module.api_supported {
            println!("Generate struct for {}", module.api_name);
            if let Ok(fields) = client.fields(&module.api_name).await {
                let struct_name = module.api_name.replace('_', "");

                module_struct_names.push(struct_name.clone());

                let mut struct_fields = String::new();
                let mut input_struct_fields = String::new();

                // All modules start with an id field
                struct_fields.push_str(&format!("    pub {}: {},\n", "id", "String"));

                let mut seen_fields = HashMap::new();

                for field in fields.fields {
                    let mut field_name = field.api_name.to_lowercase();

                    // Special case any field named "type" as it is a reserved word in Rust
                    if field_name == "type" {
                        field_name = "_type".to_string();
                    }

                    let field_type = if let Some(o) = overrides.get(&(struct_name.as_str(), field_name.as_str())) {
                        o
                    } else {
                        field.json_type()
                    };

                    if let Some(previous_field_type) = seen_fields.get(&field_name) {
                        if previous_field_type != field_type {
                            panic!(
                                "Module {} reports to have a field {} with multiple types {} and {}",
                                module.api_name, field.api_name, previous_field_type, field_type
                            );
                        }
                    } else {
                        struct_fields.push_str(&format!("    #[serde(alias = \"{}\")]\n", field.api_name));
                        struct_fields.push_str(&format!("    pub {}: Option<{}>,\n", &field_name, field_type));

                        if field.system_mandatory {
                            input_struct_fields.push_str(&format!("    #[serde(rename = \"{}\")]\n", field.api_name));
                            input_struct_fields.push_str(&format!("    pub {}: {},\n", &field_name, field_type));
                        } else {
                            input_struct_fields.push_str(&format!(
                                "    #[serde(rename = \"{}\", skip_serializing_if = \"Option::is_none\")]\n",
                                field.api_name
                            ));
                            input_struct_fields
                                .push_str(&format!("    pub {}: Option<{}>,\n", &field_name, field_type));
                        }

                        seen_fields.insert(field_name, field_type.to_string());
                    }
                }

                out.push_str(&format!(
                    r#"
#[derive(Debug, Clone, Deserialize)]
pub struct {} {{
{}
}}

impl RecordsModule for {} {{
    type Input = {}Input;
    fn api_path() -> &'static str {{
        "{}"
    }}
}}

#[derive(Debug, Clone, Default, Serialize)]
pub struct {}Input {{
{}
}}
"#,
                    struct_name,
                    struct_fields.trim_end(),
                    struct_name,
                    struct_name,
                    module.api_name,
                    struct_name,
                    input_struct_fields
                ));
            } else {
                println!("Failed to create struct for {}", module.api_name);
            }
        } else {
            println!("Skipping {}. API is not supported", module.api_name);
        }
    }

    let mut modules = fs::File::create("src/modules.rs")?;
    modules.write_all(out.as_bytes())?;

    Ok(())
}
